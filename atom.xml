<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Howie&#39;s Notes</title>
  
  <subtitle>Machine Learning and Cyber Security</subtitle>
  <link href="https://howiezhao.github.io/atom.xml" rel="self"/>
  
  <link href="https://howiezhao.github.io/"/>
  <updated>2021-03-07T08:31:12.000Z</updated>
  <id>https://howiezhao.github.io/</id>
  
  <author>
    <name>Howie Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ICMP 运行机制</title>
    <link href="https://howiezhao.github.io/2021/03/06/icmp/"/>
    <id>https://howiezhao.github.io/2021/03/06/icmp/</id>
    <published>2021-03-06T10:30:51.000Z</published>
    <updated>2021-03-07T08:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ICMP</strong>（Internet Control Message Protocol，因特网控制报文协议）被主机和路由器用来彼此沟通网络层的信息。ICMP 最典型的用途是差错报告。</p><p>ICMP 报文有一个类型字段和一个编码字段，并且包含引起该 ICMP 首次生成的 IP 数据报的首部和前 8 个字节（以便发送方能确定引发该差错的数据报）。下表是相关的 ICMP 报文类型：</p><a id="more"></a><table><thead><tr><th>ICMP 类型</th><th>编码</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>回显回答（对 <code>ping</code> 的回答）</td></tr><tr><td>3</td><td>0</td><td>目的网络不可达</td></tr><tr><td>3</td><td>1</td><td>目的主机不可达</td></tr><tr><td>3</td><td>2</td><td>目的协议不可达</td></tr><tr><td>3</td><td>3</td><td>目的端口不可达</td></tr><tr><td>3</td><td>6</td><td>目的网络未知</td></tr><tr><td>3</td><td>7</td><td>目的主机未知</td></tr><tr><td>4</td><td>0</td><td>源抑制（拥塞控制）</td></tr><tr><td>8</td><td>0</td><td>回显请求</td></tr><tr><td>9</td><td>0</td><td>路由器通告</td></tr><tr><td>10</td><td>0</td><td>路由器发现</td></tr><tr><td>11</td><td>0</td><td>TTL 过期</td></tr><tr><td>12</td><td>0</td><td>IP 首部损坏</td></tr></tbody></table><p>注意到 ICMP 报文并不仅是用于通知差错情况。</p><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a><code>ping</code></h2><p><code>ping</code> 程序发送一个 ICMP 类型 8 编码 0 的报文到指定主机。看到回显（echo）请求，目的主机发回一个类型 0 编码 0 的 ICMP 回显回答。</p><p>当 <code>ping</code> 一个不存在的 IP 时，会收到目的主机不可达（类型 3 编码 1）的响应。</p><h2 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h2><p>Traceroute 在 Linux 中一般为 <code>tracepath</code>，在 Windows 中一般为 <code>tracert</code>。该程序允许我们跟踪从一台主机到世界上任意一台主机之间的路由。其用 ICMP 报文来实现。</p><p>为了判断源和目的地之间所有路由器的名字和地址，源主机中的 Traceroute 向目的地主机发送一系列普通的 IP 数据报。这些数据报的每个携带了一个具有不可达 UDP 端口号的 UDP 报文段。第一个数据报的 TTL 为 1，第二个的 TTL 为 2，第三个的 TTL 为 3，依此类推。该源主机也为每个数据报启动定时器。当第 n 个数据报到达第 n 台路由器时，第 n 台路由器观察到这个数据报的 TTL 正好过期。根据 IP 协议规则，路由器丢弃该数据报并发送一个 ICMP 告警报文给源主机（类型 11 编码 0）。该告警报文包含了路由器的名字和它的 IP 地址。当该 ICMP 报文返回源主机时，源主机从定时器得到往返时延，从 ICMP 报文中得到第 n 台路由器的名字与 IP 地址。</p><p>这些数据报之一将最终沿着这条路到达目的主机。因为该数据报包含了一个具有不可达端口号的 UDP 报文段，该目的主机将向源发送一个端口不可达的 ICMP 报文（类型 3 编码 3）。当源主机收到这个特别的 ICMP 报文时，知道它不需要再发送另外的探测分组。</p><p>标准的 Traceroute 程序实际上用相同的 TTL 发送 3 个一组的分组，因此 Traceroute 输出对每个 TTL 提供了 3 个结果。</p><p>一个 Traceroute 运行示例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tracert 185.199.109.153</span><br><span class="line"></span><br><span class="line">通过最多 30 个跃点跟踪</span><br><span class="line">到 cdn-185-199-109-153.github.com [185.199.109.153] 的路由:</span><br><span class="line"></span><br><span class="line">  1    26 ms     5 ms    51 ms  Hiwifi.lan [192.168.199.1]</span><br><span class="line">  2     *        *        *     请求超时。</span><br><span class="line">  3     9 ms    16 ms     6 ms  1.240.35.58.broad.xw.sh.dynamic.163data.com.cn [58.35.240.1]</span><br><span class="line">  4    11 ms    11 ms    10 ms  124.74.22.29</span><br><span class="line">  5     9 ms     6 ms    14 ms  61.152.24.42</span><br><span class="line">  6    27 ms    41 ms     *     202.97.50.154</span><br><span class="line">  7    21 ms    23 ms    30 ms  202.97.74.1</span><br><span class="line">  8    93 ms   102 ms   102 ms  202.97.94.10</span><br><span class="line">  9    85 ms     *        *     ae-3.r30.tokyjp05.jp.bb.gin.ntt.net [129.250.3.23]</span><br><span class="line"> 10     *       83 ms    78 ms  ae-2.r00.tokyjp08.jp.bb.gin.ntt.net [129.250.6.127]</span><br><span class="line"> 11    85 ms     *       81 ms  ae-2.fastly.tokyjp08.jp.bb.gin.ntt.net [117.103.177.66]</span><br><span class="line"> 12    72 ms    70 ms    80 ms  cdn-185-199-109-153.github.com [185.199.109.153]</span><br><span class="line"></span><br><span class="line">跟踪完成。</span><br></pre></td></tr></table></figure><p>可以看到输出有 6 列：</p><ul><li>第一列：前面描述的 n 值，即路径上的路由器编号</li><li>第二、三、四列：3 次实验的往返时延</li><li>第五列：路由器的名字</li><li>第六列：路由器地址</li></ul><p>如果源从任何给定路由器接收到的报文少于 3 条（由于网络中的丢包），Traceroute 在该路由器号码后面放一个星号，并向那台路由器报告少于 3 次往返时间。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>ICMP 通常被认为是 IP 的一部分，但从体系结构上讲它位于 IP 之上，因为 ICMP 报文是承载在 IP 分组中的。这就是说，ICMP 报文是作为 IP 有效载荷承载的，就像 TCP 与 UDP 报文段作为 IP 有效载荷被承载那样。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;ICMP&lt;/strong&gt;（Internet Control Message Protocol，因特网控制报文协议）被主机和路由器用来彼此沟通网络层的信息。ICMP 最典型的用途是差错报告。&lt;/p&gt;
&lt;p&gt;ICMP 报文有一个类型字段和一个编码字段，并且包含引起该 ICMP 首次生成的 IP 数据报的首部和前 8 个字节（以便发送方能确定引发该差错的数据报）。下表是相关的 ICMP 报文类型：&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ARP 运行机制</title>
    <link href="https://howiezhao.github.io/2021/03/06/arp/"/>
    <id>https://howiezhao.github.io/2021/03/06/arp/</id>
    <published>2021-03-06T09:03:40.000Z</published>
    <updated>2021-03-06T10:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>与 DNS 类似，<strong>ARP</strong>（Address Resolution Protocol，地址解析协议）提供了将 <strong>IP 地址</strong>转换为<strong>链路层地址</strong>的机制。这两种解析器之间的一个重要区别是，DNS 为在因特网中任何地方的主机解析主机名，而 ARP 只为在同一个子网上的主机和路由器接口解析 IP 地址。</p><a id="more"></a><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>事实上，并不是主机或路由器具有链路层地址，而是它们的适配器（即网络接口）具有链路层地址。因此，具有多个网络接口的主机或路由器将具有与之相关联的多个链路层地址，就像它也具有与之相关联的多个 IP 地址一样。</p><p>链路层地址有各种不同的称呼：<strong>LAN 地址</strong>（LAN address）、<strong>物理地址</strong>（physical address）或 <strong>MAC 地址</strong>（MAC address）。我们一般将链路层地址称为 MAC 地址。</p><p>对于大多数局域网（包括以太网和 802.11 无线局域网）而言，MAC 地址长度为 6 字节，共有 2^48 个可能的 MAC 地址。这些 6 个字节地址通常用十六进制表示法，地址的每个字节被表示为一对十六进制数。如 <code>1A-23-F9-CD-06-9B</code>。尽管 MAC 地址被设计为永久的，但用软件改变一块适配器的 MAC 地址现在是可能的。</p><p>没有两块适配器具有相同的 MAC 地址。IEEE 在管理着 MAC 地址空间。特别是，当一个公司要生产适配器时，它支付象征性的费用购买组成 2^24 个地址的一块地址空间。IEEE 分配这块 2^24 个地址的方式是：固定一个 MAC 地址的前 24 比特，让公司自己为每个适配器生成后 24 比特的唯一组合。具体的分配列表可参考<a href="http://standards-oui.ieee.org/oui/oui.txt">其官网</a>。</p><p>适配器的 MAC 地址具有扁平结构（这与层次结构相反），而且不论适配器到哪里用都不会变化。与之形成对照的是，IP 地址具有层次结构（即一个网络部分和一个主机部分），而且当主机移动时，主机的 IP 地址需要改变，即改变它所连接到的网络。可以将适配器的 MAC 地址比喻成一个人的身份证号，而将 IP 地址比喻成一个人的住址。</p><p>当某适配器要向某些目的适配器发送一个帧时，发送适配器将目的适配器的 MAC 地址插入到该帧中，并将该帧发送到局域网上。对于使用 6 字节地址的局域网（例如以太网和 802.11）来说，<strong>MAC 广播地址</strong>（broadcast address）是 48 个连续的 1 组成的字符串（即以十六进制表示法表示的 <code>FF-FF-FF-FF-FF-FF</code>）。</p><h2 id="ARP-工作过程"><a href="#ARP-工作过程" class="headerlink" title="ARP 工作过程"></a>ARP 工作过程</h2><p>每台主机或路由器在其内存中具有一个 <strong>ARP 表</strong>（ARP table），这张表包含 IP 地址到 MAC 地址的映射关系。例如：</p><table><thead><tr><th>IP 地址</th><th>MAC 地址</th><th>TTL</th></tr></thead><tbody><tr><td>222.222.222.221</td><td>88-B2-2F-54-1A-0F</td><td>13:45:00</td></tr><tr><td>222.222.222.223</td><td>5C-66-AB-90-75-B1</td><td>13:52:00</td></tr></tbody></table><p>该 ARP 表也包含一个寿命（TTL）值，它指示了从表中删除每个映射的时间。注意到这张表不必为该子网中的每台主机和路由器都包含一个表项；某些可能从来没有进入到该表中，某些可能已经过期。从一个表项放置到某 ARP 表中开始，一个表项通常的过期时间是 20 分钟。</p><p>如果 ARP 表中当前没有目的主机的表项，在这种情况下，发送方用 ARP 协议来解析这个地址。首先，发送方构造一个称为 <strong>ARP 分组</strong>（ARP packet）的特殊分组。一个 ARP 分组有几个字段，包括发送和接收 IP 地址及 MAC 地址。ARP 查询分组和响应分组都具有相同的格式。ARP 查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的 IP 地址的那个 MAC 地址。</p><p>查询 ARP 报文是在广播帧中发送的，而响应 ARP 报文在一个标准帧中发送。</p><p>ARP 表是即插即用的，这就是说，一个 ARP 表是自动建立的，即它不需要系统管理员来配置。并且如果某主机与子网断开连接，它的表项最终会从留在子网中的节点的表中删除。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>ARP 是一个链路层协议还是一个网络层协议？一个 ARP 分组封装在链路层帧中，因而在体系结构上位于链路层之上。然而，一个 ARP 分组具有包含链路层地址的字段，因而可认为是链路层协议，但它也包含网络层地址，因而也可认为是为网络层协议。所以，可能最好把 ARP 看成是跨越链路层和网络层边界两边的协议，即不完全符合简单的分层协议栈。现实世界协议就是这样复杂！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;与 DNS 类似，&lt;strong&gt;ARP&lt;/strong&gt;（Address Resolution Protocol，地址解析协议）提供了将 &lt;strong&gt;IP 地址&lt;/strong&gt;转换为&lt;strong&gt;链路层地址&lt;/strong&gt;的机制。这两种解析器之间的一个重要区别是，DNS 为在因特网中任何地方的主机解析主机名，而 ARP 只为在同一个子网上的主机和路由器接口解析 IP 地址。&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>vCard 是什么</title>
    <link href="https://howiezhao.github.io/2021/02/04/what-is-vcard/"/>
    <id>https://howiezhao.github.io/2021/02/04/what-is-vcard/</id>
    <published>2021-02-04T09:00:58.000Z</published>
    <updated>2021-02-05T09:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>vCard 是广为使用的电子名片的文件格式标准，常用于手机通讯录文件中，其后缀名常为 <code>.vcf</code>。</p><p>一个典型的 vCard 文件内容如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BEGIN:VCARD</span><br><span class="line">VERSION:2.1</span><br><span class="line">N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:testa</span><br><span class="line">FN;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:testa</span><br><span class="line">TEL;CELL:12345678910</span><br><span class="line">END:VCARD</span><br><span class="line">BEGIN:VCARD</span><br><span class="line">VERSION:2.1</span><br><span class="line">N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:testb</span><br><span class="line">FN;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:testb</span><br><span class="line">TEL;CELL:12345678910</span><br><span class="line">END:VCARD</span><br></pre></td></tr></table></figure><p>每个 vCard 条目通过 <code>BEGIN:VCARD</code> 与 <code>END:VCARD</code> 包裹，其中 <code>VERSION</code> 字段表示 vCard 版本号，<code>N</code> 和 <code>FN</code> 字段分别表示 <em>姓名</em> 和 <em>名</em>，<code>TEL</code> 字段表示电话号码。</p><p>GitHub 上的 <a href="https://github.com/metowolf/vCards">vCards</a> 项目提供了类似中国黄页的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vCard 是广为使用的电子名片的文件格式标准，常用于手机通讯录文件中，其后缀名常为 &lt;code&gt;.vcf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一个典型的 vCard 文件内容如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>CDN</title>
    <link href="https://howiezhao.github.io/2021/01/21/cdn/"/>
    <id>https://howiezhao.github.io/2021/01/21/cdn/</id>
    <published>2021-01-21T04:26:07.000Z</published>
    <updated>2021-02-05T09:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CDN</strong> 全称 Content Distribution Network，即<strong>内容分发网络</strong>。CDN 管理分布在多个地理位置上的服务器，在它的服务器中存储各种类型的 Web 内容（包括文档、图片、音频和视频等）的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的 CDN 位置。</p><p>CDN 可以是<strong>专用 CDN</strong>（private CDN），即它由内容提供商自己所拥有；例如，谷歌的 CDN 分发 YouTube 视频和其他类型的内容。也可以是<strong>第三方 CDN</strong>（third-party CDN），它代表多个内容提供商分发内容；<a href="https://www.akamai.com/cn/zh/">Akamai</a>、<a href="https://www.limelight.com/">Limelight</a> 和 <a href="https://www.cloudflare.com/zh-cn/cdn">Cloudflare CDN</a> 都运行第三方 CDN。</p><a id="more"></a><p>相比于使用 CDN，建立单一的大规模数据中心存在以下三个问题：</p><ul><li>如果客户远离数据中心，服务器到客户的分组将跨越许多通信链路并很可能通过许多 ISP，其中某些 ISP 可能位于不同的大洲。如果这些链路之一提供的吞吐量小于内容消耗速率，端到端吞吐量也将小于该消耗速率，给用户带来恼人的停滞时延。出现这种事件的可能性随着端到端的路径中链路数量的增加而增加。</li><li>流行的内容很可能经过相同的通信链路发送许多次。这不仅浪费了网络带宽，内容提供商自己也将为向因特网反复发送 <em>相同</em> 的字节而向其 ISP 运营商（连接到数据中心）支付费用。</li><li>单个数据中心代表一个单点故障，如果数据中心或其通向因特网的链路崩溃，它将不能够分发 <em>任何</em> 内容了。</li></ul><p>CDN 通常采用两种不同的服务器安置原则：</p><ul><li><strong>深入</strong>：该原则是通过在遍及全球的接入 ISP 中部署服务器集群来深入到 ISP 的接入网中。由 Akamai 首创。其目标是靠近端用户，通过减少端用户和 CDN 集群之间（内容从这里收到）链路和路由器的数量，从而改善了用户感受的时延和吞吐量。因为这种高度分布式设计，维护和管理集群的任务成为挑战。</li><li><strong>邀请做客</strong>：该原则是通过在少量（例如 10 个）关键位置建造大集群来 <em>邀请到 ISP 做客</em>。该原则由 Limelight 和许多其他 CDN 公司所采用。不是将集群放在接入 ISP 中，这些 CDN 通常将它们的集群放置在因特网交换点（IXP）。与深入设计原则相比，邀请做客设计通常产生较低的维护和管理开销，可能以对端用户的较高时延和较低吞吐量为代价。</li></ul><p>一旦 CDN 的集群准备就绪，它就可以跨集群复制内容。CDN 可能不希望将每个内容的副本放置在每个集群中，因为某些内容很少访问或仅在某些国家中流行。事实上，许多 CDN 没有将内容推入它们的集群，而是使用一种简单的拉策略：如果客户向一个未存储该内容的集群请求某内容，则该集群检索该内容（从某中心仓库或者从另一个集群），向客户传输内容时的同时在本地存储一个副本。类似于 Web 缓存器，当某集群存储器变满时，它删除不经常请求的内容。</p><p>当用户主机中的一个浏览器指令检索一个特定的视频（由 URL 标识）时，CDN 必须截获该请求，以便能够：</p><ol><li>确定此时适合用于该客户的 CDN 服务器集群；</li><li>将客户的请求重定向到该集群的某台服务器。</li></ol><p>大多数 CDN 利用 DNS 来截获和重定向请求，其步骤如下：</p><ol><li>用户访问目标网页；</li><li>当用户点击链接时，该用户主机发送了一个对于目标 URL 的 DNS 请求；</li><li>用户的本地 DNS 服务器（LDNS）将该 DNS 请求中继到 <em>目标服务器的权威 DNS 服务器</em>，<em>目标服务器的权威 DNS 服务器</em> 并不返回一个 IP 地址，而是向 LDNS 返回一个 <em>第三方 CDN 的主机名</em>；</li><li>从这时起，DNS 请求进入了 <em>第三方 CDN 的专用 DNS 基础设施</em>。用户的 LDNS 则发送第二个请求，此时是对 <em>第三方 CDN 的主机名</em> 的 DNS 请求，<em>第三方 CDN 的 DNS 系统</em> 最终向 LDNS 返回 <em>第三方 CDN 服务器</em> 的 IP 地址。所以正是在这里，在 <em>第三方 CDN 的 DNS 系统</em> 中，指定了 CDN 服务器，客户将能够从这台服务器接收到它的内容；</li><li>LDNS 向用户主机转发 <em>第三方 CDN 节点</em> 的 IP 地址；</li><li>一旦客户收到 <em>第三方 CDN 节点</em> 的 IP 地址，它与具有该 IP 地址的服务器创建了一条直接的 TCP 连接，并且发出对该网页的 HTTP GET 请求。</li></ol><p>任何 CDN 部署，其核心是<strong>集群选择策略</strong>（cluster selection strategy），即动态地将客户定向到 CDN 中的某个服务器集群或数据中心的机制。如上所述，经过客户的 DNS 查找，CDN 得知了该客户的 LDNS 服务器的 IP 地址。在得知该 IP 地址之后，CDN 需要基于该 IP 地址选择一个适当的集群。CDN 一般采用专用的集群选择策略。</p><p>一种简单的策略是指派客户到<strong>地理上最为临近</strong>（geographically closest）的集群。使用商用地理位置数据库，每个 LDNS IP 地址都映射到一个地理位置。当从一个特殊的 LDNS 接收到一个 DNS 请求时，CDN 选择地理上最为接近的集群，即离 LDNS 最少几千米远的集群。这样的解决方案对于众多用户来说能够工作得相当好。但对于某些客户，该解决方案可能执行的效果差，因为就网络路径的长度或跳数而言，地理最临近的集群可能并不是最近的集群。此外，一种所有基于 DNS 的方法都内在具有的问题是，某些端用户配置使用位于远地的 LDNS，在这种情况下，LDNS 位置可能远离客户的位置。此外，这种简单的策略忽略了时延和可用带宽随因特网路径时间而变化，总是为特定的客户指派相同的集群。</p><p>为了基于 <em>当前</em> 流量条件为客户决定最好的集群，CDN 能够对其集群和客户之间的时延和丢包性能执行周期性的<strong>实时测量</strong>（real-time measurement）。例如，CDN 能够让它的每个集群周期性地向位于全世界的所有 LDNS 发送探测分组（例如，ping 报文或 DNS 请求）。这种方法的一个缺点是许多 LDNS 被配置为不会响应这些探测。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;CDN&lt;/strong&gt; 全称 Content Distribution Network，即&lt;strong&gt;内容分发网络&lt;/strong&gt;。CDN 管理分布在多个地理位置上的服务器，在它的服务器中存储各种类型的 Web 内容（包括文档、图片、音频和视频等）的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的 CDN 位置。&lt;/p&gt;
&lt;p&gt;CDN 可以是&lt;strong&gt;专用 CDN&lt;/strong&gt;（private CDN），即它由内容提供商自己所拥有；例如，谷歌的 CDN 分发 YouTube 视频和其他类型的内容。也可以是&lt;strong&gt;第三方 CDN&lt;/strong&gt;（third-party CDN），它代表多个内容提供商分发内容；&lt;a href=&quot;https://www.akamai.com/cn/zh/&quot;&gt;Akamai&lt;/a&gt;、&lt;a href=&quot;https://www.limelight.com/&quot;&gt;Limelight&lt;/a&gt; 和 &lt;a href=&quot;https://www.cloudflare.com/zh-cn/cdn&quot;&gt;Cloudflare CDN&lt;/a&gt; 都运行第三方 CDN。&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>UDP 协议分析</title>
    <link href="https://howiezhao.github.io/2021/01/12/udp/"/>
    <id>https://howiezhao.github.io/2021/01/12/udp/</id>
    <published>2021-01-12T07:25:26.000Z</published>
    <updated>2021-01-21T15:21:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>UDP 全称 User Datagram Protocol，即<strong>用户数据报协议</strong>，它为调用它的应用程序提供了一种不可靠、无连接的服务。</p><p>UDP 无非就是对网络层协议增加了一点（多路）复用/（多路）分解服务而已。</p><p>使用 UDP 的上层协议有：</p><ul><li><a href="/2020/12/29/dns/" title="DNS">DNS</a></li><li>SNMP</li></ul><p>选择使用 UDP 的原因：</p><ul><li>关于发送什么数据以及何时发送的应用层控制更为精细。</li><li>无须连接建立。</li><li>无连接状态。</li><li>分组首部开销小。每个 TCP 报文段都有 20 字节的首部开销，而 UDP 仅有 8 字节的开销。</li></ul><p>使用 UDP 的应用是可能实现可靠数据传输的，这可通过在应用程序自身中建立可靠性机制来完成。<br>可参考 <a href="https://github.com/skywind3000/kcp">KCP</a>、<a href="https://www.chromium.org/quic">QUIC</a>。</p><a id="more"></a><h2 id="UDP-报文段结构"><a href="#UDP-报文段结构" class="headerlink" title="UDP 报文段结构"></a>UDP 报文段结构</h2><p>UDP 报文段结构如图所示：</p><p><img src="/images/udp-segment-structure.jpg" alt="UDP 报文段结构"></p><p>通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程（即执行分解功能）。<br>长度字段指示了在 UDP 报文段中的字节数（首部加数据）。<br>接收方使用检验和来检查在该报文段中是否出现了差错。</p><h2 id="UDP-检验和"><a href="#UDP-检验和" class="headerlink" title="UDP 检验和"></a>UDP 检验和</h2><p>发送方的 UDP 对报文段中的所有 16 比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在 UDP 报文段中的检验和字段。</p><p>在接收方，全部的 16 比特字（包括检验和）加在一起。如果和为 <code>1111111111111111</code>，则未引入差错，反之，则已经出现了差错。</p><p>在既无法确保逐链路的可靠性，又无法确保内存中的差错检测的情况下，如果端到端数据传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测。这是一个在系统设计中被称颂的<strong>端到端原则</strong>（end-end principle）的例子，该原则表述为因为某种功能（在此时为差错检测）必须基于端到端实现：“在与较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的。”</p><p>虽然 UDP 提供差错检测，但它对差错恢复无能为力。UDP 的某种实现只是丢弃受损的报文段；其他实现是将受损的报文段交给应用程序并给出警告。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;UDP 全称 User Datagram Protocol，即&lt;strong&gt;用户数据报协议&lt;/strong&gt;，它为调用它的应用程序提供了一种不可靠、无连接的服务。&lt;/p&gt;
&lt;p&gt;UDP 无非就是对网络层协议增加了一点（多路）复用/（多路）分解服务而已。&lt;/p&gt;
&lt;p&gt;使用 UDP 的上层协议有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2020/12/29/dns/&quot; title=&quot;DNS&quot;&gt;DNS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SNMP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择使用 UDP 的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于发送什么数据以及何时发送的应用层控制更为精细。&lt;/li&gt;
&lt;li&gt;无须连接建立。&lt;/li&gt;
&lt;li&gt;无连接状态。&lt;/li&gt;
&lt;li&gt;分组首部开销小。每个 TCP 报文段都有 20 字节的首部开销，而 UDP 仅有 8 字节的开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 UDP 的应用是可能实现可靠数据传输的，这可通过在应用程序自身中建立可靠性机制来完成。&lt;br&gt;可参考 &lt;a href=&quot;https://github.com/skywind3000/kcp&quot;&gt;KCP&lt;/a&gt;、&lt;a href=&quot;https://www.chromium.org/quic&quot;&gt;QUIC&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>DNS 运行机制</title>
    <link href="https://howiezhao.github.io/2020/12/29/dns/"/>
    <id>https://howiezhao.github.io/2020/12/29/dns/</id>
    <published>2020-12-29T11:25:33.000Z</published>
    <updated>2021-02-05T09:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>DNS</strong>（Domain Name System，域名系统）的主要任务是进行<strong>主机名</strong>（hostname，也称域名）到 <strong>IP 地址</strong>转换的目录服务，它由两部分组成：</p><ul><li>一个由<strong>分层</strong>的 <strong>DNS 服务器</strong>（DNS server）实现的<strong>分布式数据库</strong></li><li>一个使得主机能够查询分布式数据库的<strong>应用层协议</strong></li></ul><p>DNS 服务器通常是运行 <a href="https://www.isc.org/bind/">BIND</a>（Berkeley Internet Name Domain）软件的 UNIX 机器。DNS 协议运行在 UDP 之上，使用 <strong>53</strong> 号端口。</p><a id="more"></a><p>除了进行主机名到 IP 地址的转换外，DNS 还提供了一些重要的服务：</p><ul><li>主机别名（host aliasing）：有着复杂主机名的主机能拥有一个或着多个别名</li><li>邮件服务器别名（mail server aliasing）</li><li>负载分配（load distribution）：DNS 也用于在冗余的服务器（如冗余的 Web 服务器等）之间进行负载分配。这种负载均衡的缺点为由于 DNS 缓存（如 LDNS 中缓存）的存在，其实际作用很有限。</li></ul><h2 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h2><p>DNS 服务器大致分为 3 种：</p><ul><li><strong>根 DNS 服务器</strong>：根 DNS 服务器提供 TLD 服务器的 IP 地址。有 400 多个根 DNS 服务器遍及全世界。这些根 DNS 服务器由 13 个不同的组织管理。根 DNS 服务器的全部清单连同管理它们的组织及其 IP 地址可以在<a href="https://root-servers.org/">这里</a>找到。</li><li><strong>顶级域（Top-Level Domain，TLD）DNS 服务器</strong>：TLD 服务器提供了权威 DNS 服务器的 IP 地址。对于每个顶级域（如 <code>com</code>、<code>org</code>、<code>net</code>、<code>edu</code> 和 <code>gov</code>）和所有国家的顶级域（如 <code>uk</code>、<code>fr</code>、<code>ca</code> 和 <code>jp</code>），都有 TLD 服务器（或服务器集群）。所有顶级域的列表可参见<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%88%97%E8%A1%A8">维基百科</a>。</li><li><strong>权威 DNS 服务器</strong>：在因特网上具有公共可访问主机（如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织机构的权威 DNS 服务器收藏了这些 DNS 记录。一个组织机构能够选择实现它自己的权威 DNS 服务器以保存这些记录；另一种方法是，该组织能够支付费用，让这些记录存储在某个服务提供商的一个权威 DNS 服务器中。</li></ul><p>还有另一类重要的 DNS 服务器，称为<strong>本地 DNS 服务器</strong>（Local DNS server，LDNS）。严格来说，一个本地 DNS 服务器并不属于该服务器的层次结构，但它对 DNS 层次结构是至关重要的。每个 ISP（如一个居民区的 ISP 或一个机构的 ISP）都有一台本地 DNS 服务器（也叫默认名字服务器）。当主机与某个 ISP 连接时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址（通常通过 DHCP）。主机的本地 DNS 服务器通常“临近”本主机。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次结构中，大致过程如下所述：</p><ol><li>客户端向它的本地 DNS 服务器发送一个关于 <code>tieba.baidu.com</code> 的 DNS 查询报文</li><li>本地 DNS 服务器将该报文转发到根 DNS 服务器</li><li>根 DNS 服务器注意到其 <code>com</code> 前缀并向本地 DNS 服务器返回负责 <code>com</code> 的 TLD 的 IP 地址列表</li><li>本地 DNS 服务器则再次向这些 TLD 服务器之一发送查询报文</li><li>TLD 服务器注意到 <code>baidu.com</code> 前缀，并用权威 DNS 服务器的 IP 地址进行响应，该权威 DNS 服务器是 <code>dns.baidu.com</code></li><li>本地 DNS 服务器直接向 <code>dns.baidu.com</code> 重发查询报文，<code>dns.baidu.com</code> 用 <code>tieba.baidu.com</code> 的 IP 地址进行响应</li></ol><p>注意到在本例中，为了获得一台主机名的映射，共发送了 8 份 DNS 报文：4 份查询报文和 4 份回答报文！下文将介绍利用 <strong>DNS 缓存</strong>（DNS caching）减少这种查询流量的方法。</p><p>上述例子利用了<strong>递归查询</strong>（recursive query）和<strong>迭代查询</strong>（iterative query）。从请求主机到本地 DNS 服务器的查询是递归的，其余的查询是迭代的。从理论上讲，任何 DNS 查询既可以是迭代的也能是递归的。</p><h2 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h2><p>共同实现 DNS 分布式数据库的所有 DNS 服务器存储了<strong>资源记录</strong>（Resource Record，RR），RR 提供了主机名到 IP 地址的映射。每个 DNS 回答报文包含了一条或多条资源记录。</p><p>资源记录是一个包含了下列字段的 4 元组：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Name, Value, Type, TTL)</span><br></pre></td></tr></table></figure><p>TTL（Time To Live）是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。Name 和 Value 的值取决于 Type：</p><ul><li>若 Type = A，则 Name 是主机名，Value 是该主机名对应的 IP 地址。因此，一条类型为 A 的资源记录提供了标准的主机名到 IP 地址的映射。例如 <code>(relay1.bar.foo.com, 145.37.93.126, A)</code> 就是一条类型 A 记录。</li><li>若 Type = NS，则 Name 是个域（如 <code>foo.com</code>），而 Value 是个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名。这个记录用于沿着查询链来路要 DNS 查询。例如 <code>(foo.com, dns.foo.com, NS)</code> 就是一条类型为 NS 的记录。</li><li>若 Type = CNAME，则 Value 是别名为 Name 的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名，例如 <code>(foo.com, relay1.bar.foo.com, CNAME)</code> 就是一条 CNAME 类型的记录。</li><li>若 Type = MX，则 Value 是个别名为 Name 的邮件服务器的规范主机名。举例来说，<code>(foo.com, mail.bar.foo.com, MX)</code> 就是一条 MX 记录。MX 记录允许邮件服务器主机名具有简单的别名。值得注意的是，通过使用 MX 记录，一个公司的邮件服务器和其他服务器（如它的 Web 服务器）可以使用相同的别名。为了获得邮件服务器的规范主机名，DNS 客户应当请求一条 MX 记录；而为了获得其他服务器的规范主机名，DNS 客户应当请求 CNAME 记录。</li></ul><p>如果一台 DNS 服务器是用于某特定主机名的权威 DNS 服务器，那么该 DNS 服务器会有一条包含用于该主机名的类型 A 记录（即使该 DNS 服务器不是其权威 DNS 服务器，它也可能在缓存中包含有一条类型 A 记录）。如果服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型 NS 记录，该记录对应于包含主机名的域；它还将包括一条类型 A 记录，该记录提供了在 NS 记录的 Value 字段中的 DNS 服务器的 IP 地址。</p><p>DNS 只有查询和回答这两种报文，并且，查询和回答报文有着相同的格式，如下图所示：</p><p><img src="/images/dns-message.jpg" alt="dns message"></p><p>前 12 个字节是<strong>首部区域</strong>，其中有如下几个字段：</p><ul><li>标识符：是一个 16 比特的数，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。</li><li>标志：含有若干标志。1 比特的“<strong>查询/回答</strong>”标志位指出报文是查询报文（0）还是回答报文（1）。当某 DNS 服务器是所请求名字的权威 DNS 服务器时，1 比特的“<strong>权威的</strong>”标志位被置在回答报文中。如果客户在该 DNS 服务器没有某记录时希望它执行递归查询，将设置 1 比特的“<strong>希望递归</strong>”标志位。如果该 DNS 服务器支持递归查询，在它的回答报文中会对 1 比特的“<strong>递归可用</strong>”标志位置位。</li><li>剩余 4 个有关数量的字段，这些字段指出了在首部后的 4 类数据区域出现的数量。</li></ul><p><strong>问题区域</strong>包含着正在进行的查询信息。该区域包括：</p><ol><li>名字字段，包含正在被查询的主机名字；</li><li>类型字段，指出有关该名字的正被询问的问题类型，例如主机地址是与一个名字相关联（类型 A）还是与某个名字的邮件服务器相关联（类型 MX）。</li></ol><p>在来自 DNS 服务器的回答中，<strong>回答区域</strong>包含了对最初请求的名字的资源记录。在回答报文的回答区域中可以包含多条 RR，因此一个主机名能够有多个 IP 地址。</p><p><strong>权威区域</strong>包含了其他权威服务器的记录。</p><p><strong>附加区域</strong>包含了其他有帮助的记录。例如，对于一个 MX 请求的回答报文的回答区域包含了一条资源记录，该记录提供了邮件服务器的规范主机名。该附加区域包含一个类型 A 记录，该记录提供了用于该邮件服务器的规范主机名的 IP 地址。</p><p>上面的讨论只是关注如何从 DNS 数据库中取数据，这些数据最初是怎么进入数据库中的呢？<strong>注册登记机构</strong>（registrar）是一个商业实体，它验证域名的唯一性，并将域名输入 DNS 数据库，对提供的服务收取少量费用。<strong>因特网名字和地址分配机构</strong>（Internet Corporation for Assigned Names and Numbers，<strong>ICANN</strong>）向各种注册登记机构授权。</p><h2 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h2><p>实际上，为了改善时延性能并减少在因特网上到处传输的 DNS 报文数量，DNS 广泛使用了缓存技术。</p><p>DNS 缓存的原理非常简单。在一个请求链中，当某 DNS 服务器接收一个 DNS 回答（例如，包含某主机名到 IP 地址的映射）时，它能将映射缓存到本地存储器中。如果在 DNS 服务器中缓存了一台主机名/IP 地址对，另一个对相同主机名的查询到达该 DNS 服务器时，该 DNS 服务器就能够提供所要求的 IP 地址，即使它不是该主机名的权威服务器。由于主机和主机名与 IP 地址间的映射并不是永久的，DNS 服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。</p><p>本地 DNS 服务器也能够缓存 TLD 服务器的 IP 地址，因而允许本地 DNS 绕过查询链中的根 DNS 服务器。事实上，因为缓存，除了少数 DNS 查询以外，根服务器被绕过了。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>第一种针对 DNS 服务的攻击是分布式拒绝服务（DDoS）带宽洪泛攻击，对 DNS 的潜在更为有效的 DDoS 攻击将是向顶级域名服务器（例如向所有处理 <code>.com</code> 域的顶级域名服务器）发送大量的 DNS 请求，以上两种 DDoS 攻击的严重性都可以通过本地 DNS 服务器中的缓存技术可将部分地被缓解。</p><p>DNS 能够潜在地以其他方式被攻击。在中间人攻击中，攻击者截获来自主机的请求并返回伪造的回答，这被称为 <strong>DNS 劫持</strong>。在 <strong>DNS 毒害</strong>（DNS 投毒、DNS 污染）攻击中，攻击者向一台 DNS 服务器发送伪造的回答，诱使服务器在它的缓存中接收伪造的记录。这些攻击中的任一种，都能够将毫无疑虑的 Web 用户重定向到攻击者的 Web 站点。然而，这些攻击难以实现，因为它们要求截获分组或扼制住服务器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;DNS&lt;/strong&gt;（Domain Name System，域名系统）的主要任务是进行&lt;strong&gt;主机名&lt;/strong&gt;（hostname，也称域名）到 &lt;strong&gt;IP 地址&lt;/strong&gt;转换的目录服务，它由两部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个由&lt;strong&gt;分层&lt;/strong&gt;的 &lt;strong&gt;DNS 服务器&lt;/strong&gt;（DNS server）实现的&lt;strong&gt;分布式数据库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个使得主机能够查询分布式数据库的&lt;strong&gt;应用层协议&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DNS 服务器通常是运行 &lt;a href=&quot;https://www.isc.org/bind/&quot;&gt;BIND&lt;/a&gt;（Berkeley Internet Name Domain）软件的 UNIX 机器。DNS 协议运行在 UDP 之上，使用 &lt;strong&gt;53&lt;/strong&gt; 号端口。&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>POP3、IMAP 和 SMTP</title>
    <link href="https://howiezhao.github.io/2020/12/29/pop3-imap-smtp/"/>
    <id>https://howiezhao.github.io/2020/12/29/pop3-imap-smtp/</id>
    <published>2020-12-29T06:52:46.000Z</published>
    <updated>2020-12-30T04:46:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>因特网电子邮件系统由 3 个主要部分组成：</p><ul><li>用户代理（user agent）：允许用户阅读、回复、转发、保存和撰写报文，如微软的 Outlook 和 Apple Mail 等</li><li>邮件服务器（mail server）：每个接收方在其中的某个邮件服务器上有一个邮箱（mailbox）</li><li>SMTP</li></ul><p>一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器（通过 SMTP 或 HTTP），再传输到接收方的邮件服务器（通过 SMTP），然后在这里被分发到接收方的邮箱中。如果发送方的邮件服务器不能将邮件交付给接收方的邮件服务器，发送方的邮件服务器在一个<strong>报文队列</strong>（message queue）中保持该报文并在以后尝试再次发送。</p><a id="more"></a><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><p><strong>SMTP</strong>（Simple Mail Transfer Protocol，简单邮件传输协议）是因特网电子邮件中主要的应用层协议。它使用 TCP 可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。每台邮件服务器既运行 SMTP 的客户端也运行 SMTP 的服务器端。</p><p>SMTP 一般不使用中间邮件服务器发送邮件。</p><p>SMTP 是如何将一个报文从发送邮件服务器传送到接收邮件服务器的呢？首先，客户 SMTP（运行在发送邮件服务器主机上）在 <strong>25</strong> 号端口建立一个到服务器 SMTP（运行在接收邮件服务器主机上）的 TCP 连接。如果服务器没有开机，客户会在稍后继续尝试连接。一旦连接建立，服务器和客户执行某些应用层的握手。在 SMTP 握手的阶段，SMTP 客户指示发送方的邮件地址（产生报文的那个人）和接收方的邮件地址。一旦握手完成，客户发送该报文。该客户如果有另外的报文要发送到该服务器，就在该相同的 TCP 连接上重复这种处理；否则，它指示 TCP 关闭连接。以下是一个例子（S 代表 SMTP 服务器，C 代表 SMTP 客户）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">S: 220 hamburger.edu</span><br><span class="line">C: HELO crepes.fr</span><br><span class="line">S: 250 Hello crepes.fr, pleased to meet you</span><br><span class="line">C: MAIL FROM: &lt;alice@crepes.fr&gt;</span><br><span class="line">S: 250 alice@crepes.fr ... Sender ok</span><br><span class="line">C: RCPT TO: &lt;bob@hamburger.edu&gt;</span><br><span class="line">S: 250 bob@hamburger.edu ... Recipient ok</span><br><span class="line">C: DATA</span><br><span class="line">S: 354 Enter mail, end with &quot;.&quot; on a line by itself</span><br><span class="line">C: Do you like ketchup?</span><br><span class="line">C: How about pickles?</span><br><span class="line">C: .</span><br><span class="line">S: 250 Message accepted for delivery</span><br><span class="line">C: QUIT</span><br><span class="line">S: 221 hamburger.edu closing connection</span><br></pre></td></tr></table></figure><p>在上例中，该客户发送了 5 条命令：<code>HELO</code>（是 HELLO 的缩写）、<code>MAIL FROM</code>、<code>RCPT TO</code>、<code>DATA</code> 以及 <code>QUIT</code>。</p><p>当然，你也可以使用 Telnet 直接与一个 SMTP 服务器对话，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet smtp.office365.com 25</span><br></pre></td></tr></table></figure><h3 id="与-HTTP-的对比"><a href="#与-HTTP-的对比" class="headerlink" title="与 HTTP 的对比"></a>与 HTTP 的对比</h3><p>SMTP 与 HTTP 有一些共同的特征：</p><ul><li>这两个协议都用于从一台主机向另一台主机传送文件</li><li>当进行文件传送时，持续的 HTTP 和 SMTP 都使用持续连接</li></ul><p>然而，两者之间也有一些重要的区别：</p><p>首先，HTTP 主要是一个<strong>拉协议</strong>（pull protocol），即在方便的时候，某些人在 Web 服务器上装载信息，用户使用 HTTP 从该服务器拉取这些信息。特别是 TCP 连接是由想接收文件的机器发起的。另一方面，SMTP 基本上是一个<strong>推协议</strong>（push protocol），即发送邮件服务器把文件推向接收邮件服务器。特别是，这个 TCP 连接是由发送该文件的机器发起的。</p><p>第二个区别是由于问世较早， SMTP 要求每个报文（包括它们的体）采用 7 比特 ASCII 码格式。如果某报文包含了非 7 比特 ASCII 字符（如具有重音的法文字符）或二进制数据（如图形文件），则该报文必须按照 7 比特 ASCII 码进行编码。HTTP 数据则不受这种限制。</p><p>第三个重要区别是如何处理一个既包含文本又包含图形（也可能是其他媒体类型）的文档。HTTP 把每个对象封装到它自己的 HTTP 响应报文中，而 SMTP 则把所有报文对象放在一个报文之中。</p><h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>如同 HTTP 协议，邮件报文也有相应的邮件首部行，每个首部行包含了可读的文本，是由关键词后跟冒号及其值组成的。某些关键词是必须的，另一些则是可选的。每个首部 <em>必须</em> 含有一个 <code>From:</code> 首部行和一个 <code>To:</code> 首部行；一个首部 <em>也许</em> 包含一个 <code>Subject:</code> 首部行以及其他可选的首部行。</p><p>一个典型的报文首部看看起来如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">From: alice@crepes.fr</span><br><span class="line">To: bob@hamburger.edu</span><br><span class="line">Subject: Searching for the meaning of life.</span><br></pre></td></tr></table></figure><h2 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h2><p><strong>POP3</strong>（Post Office Protocol——Version 3，第三版的邮局协议）是一个极为简单的邮件访问协议。</p><p>当用户代理（客户）打开了一个到邮件服务器（服务器）端口 <strong>110</strong> 上的 TCP 连接后，POP3 就开始工作了。随着建立 TCP 连接，POP3 按照 3 个阶段进行工作：</p><ol><li>特许（authorization）：用户代理发送（以明文形式）用户名和口令以鉴别用户</li><li>事务处理：用户代理取回报文；同时在这个阶段用户代理还能进行如下操作，对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息</li><li>更新：它出现在客户发出了 quit 命令之后，目的是结束该 POP3 会话；这时，该邮件服务器删除那些被标记为删除的报文</li></ol><p>在 POP3 的事务处理过程中，用户代理发出一些命令，服务器对每个命令做出回答。回答可能有两种：</p><ul><li><code>+OK</code>：（有时后面还跟有服务器到客户的数据），被服务器用来指示前面的命令是正常的</li><li><code>-ERR</code>：被服务器用来指示前面的命令出现了某些差错</li></ul><p>特许阶段有两个主要的命令：<code>user &lt;user name&gt;</code> 和 <code>pass &lt;password&gt;</code>。你可以使用 Telnet 进行测试，如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">telnet outlook.office365.com 110</span><br><span class="line">+OK The Microsoft Exchange POP3 service is ready.</span><br><span class="line">user bob</span><br><span class="line">+OK</span><br><span class="line">pass hungry</span><br><span class="line">+OK user successfully logged on</span><br></pre></td></tr></table></figure><p>在特许阶段以后，用户代理仅使用 4 个命令 <code>list</code>、<code>retr</code>、<code>dele</code> 和 <code>quit</code>。</p><p>使用 POP3 的用户代理通常被用户配置为“<strong>下载并删除</strong>”或者“<strong>下载并保留</strong>”方式。POP3 用户代理发出的命令序列取决于用户代理程序被配置为这两种工作方式的哪一种。使用下载并删除方式，用户代理发出 <code>list</code> —— <code>retr</code> —— <code>dele</code> 命令，如下（C 代表客户，S 代表服务器）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C: list</span><br><span class="line">S: 1 498</span><br><span class="line">S: 2 912</span><br><span class="line">S: .</span><br><span class="line">C: retr 1</span><br><span class="line">S: (blah blah ...</span><br><span class="line">S: .................</span><br><span class="line">S: ..........blah)</span><br><span class="line">S: .</span><br><span class="line">C: dele 1</span><br><span class="line">C: retr 2</span><br><span class="line">S: (blah blah ...</span><br><span class="line">S: .................</span><br><span class="line">S: ..........blah)</span><br><span class="line">S: .</span><br><span class="line">C: dele 2</span><br><span class="line">C: quit</span><br><span class="line">S: +OK POP3 server signing off</span><br></pre></td></tr></table></figure><p>使用下载并保留方式，用户代理下载某邮件后，该邮件仍保留在邮件服务器上。</p><h2 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h2><p><strong>IMAP</strong>（Internet Mail Access Protocol，因特网邮件访问协议）是一个相比 POP3 更强大的邮件访问协议。</p><p>相比 POP3，IMAP 协议为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令；还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件；它还提供了允许用户代理获取报文某些部分的命令。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>相比于 SMTP，POP3 和 IMAP 等邮件访问协议本质上属于拉协议，在基于 Web 的电子邮件中，则可以通过 HTTP 进行邮件的收发，此时，用户代理就是普通的浏览器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因特网电子邮件系统由 3 个主要部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户代理（user agent）：允许用户阅读、回复、转发、保存和撰写报文，如微软的 Outlook 和 Apple Mail 等&lt;/li&gt;
&lt;li&gt;邮件服务器（mail server）：每个接收方在其中的某个邮件服务器上有一个邮箱（mailbox）&lt;/li&gt;
&lt;li&gt;SMTP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器（通过 SMTP 或 HTTP），再传输到接收方的邮件服务器（通过 SMTP），然后在这里被分发到接收方的邮箱中。如果发送方的邮件服务器不能将邮件交付给接收方的邮件服务器，发送方的邮件服务器在一个&lt;strong&gt;报文队列&lt;/strong&gt;（message queue）中保持该报文并在以后尝试再次发送。&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>P2P 与 BitTorrent</title>
    <link href="https://howiezhao.github.io/2020/12/15/p2p-bittorrent/"/>
    <id>https://howiezhao.github.io/2020/12/15/p2p-bittorrent/</id>
    <published>2020-12-15T08:18:58.000Z</published>
    <updated>2020-12-26T13:46:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>P2P 是一种<strong>体系结构</strong>，就好像 C/S 体系结构一样，但不同的是，P2P 对总是打开的基础设施服务器有最小的（或者没有）依赖，成对间歇连接的主机（称为<strong>对等方</strong>）彼此直接通信。</p><p>基于 P2P 这种体系结构产生了许多应用，譬如<strong>文件分发应用</strong>和<strong>分布式散列表</strong>（DHT），而文件分发应用中一个典型的例子就是 BitTorrent 协议。</p><p>如果要类比 P2P 与 BitTorrent 之间的关系，就好像 C/S 体系结构与 FTP 协议之间的关系。</p><a id="more"></a><h2 id="P2P-与-C-S"><a href="#P2P-与-C-S" class="headerlink" title="P2P 与 C/S"></a>P2P 与 C/S</h2><p>以文件分发应用为例，在 C/S 文件分发中，该服务器必须向每个对等方发送该文件的一个副本，即服务器承受了极大的负担，并且消耗了大量的服务器带宽。在 P2P 文件分发中，每个对等方能够向任何其他对等方重新分发它已经收到的该文件的任何部分，从而在分发过程中协助该服务器。</p><p>对于 C/S 体系结构，随着对等方数量的增加，分发时间呈线性增长并且没有界。然而，对于 P2P 体系结构，最小分发时间不仅总是小于 C/S 体系结构的分发时间，并且对于任意的对等方数量，总是小于一对一的 C/S 体系结构的分发时间。因此，具有 P2P 体系结构的应用程序能够是自扩展的。这种扩展性的直接成因是：<strong>对等方除了是比特的消费者外还是它们的重新分发者</strong>。</p><h2 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h2><p>如前所述，BitTorrent 是最为流行的 P2P 文件分发协议，通常也简称为 BT，最初由 Bram Cohen 所研发。</p><p>用 BitTorrent 的术语来讲，参与一个特定文件分发的所有对等方的集合被称为一个<strong>洪流（torrent）</strong>。在一个洪流中的对等方彼此下载等长度的文件块（chunk），典型的块长度为 256 KB。当一个对等方首次加入一个洪流时，它没有块。随着时间的流逝，它累积了越来越多的块。当它下载块时，也为其他对等方上载了多个块。一旦某对等方获得了整个文件，它也许（自私地）离开洪流，或（大公无私地）留在该洪流中并继续向其他对等方上载块。同时，任何对等方可能在任何时候仅具有块的子集就离开该洪流，并在以后重新加入该洪流中。</p><p>每个洪流具有一个基础设施节点，称为 <strong>tracker</strong>（追踪器）。当一个对等方加入某洪流时，它向 tracker 注册自己，并周期性地通知 tracker 它仍在该洪流中。以这种方式，tracker 跟踪参与在洪流中的对等方。</p><p>当一个新的对等方 A 加入该洪流时，tracker 随机地从参与对等方的集合中选择对等方的一个子集，将这个子集中每个对等方的 IP 地址发送给 A。A 持有对等方的这张列表，试图与该列表上的所有对等方创建并行的 TCP 连接。我们称所有这样与 A 成功地创建一个 TCP 连接的对等方为<strong>邻近对等方</strong>。一个对等方的临近对等方将随时间而波动。</p><p>在任何给定的时刻，A 将具有块的子集并知道它的邻居具有哪些块。利用这些信息，A 将做出两个重要决定：</p><ul><li>它应当从它的邻居请求哪些块呢？</li><li>它应当向哪些向它请求块的邻居发送块？</li></ul><p>在决定请求哪些块的过程中，A 使用一种称为<strong>最稀缺优先</strong>（rarest first）的技术。这种技术的思路时，针对它没有的块在它的邻居中决定最稀缺的块（最稀缺的块就是那些在它的邻居中副本数量最少的块），并首先请求那些最稀缺的块。这样，最稀缺块得到更为迅速的重新发放，其目标是（大致地）均衡每个块在洪流中的副本数量。</p><p>为了决定它响应哪个请求，BitTorrent 使用了一种被称为<strong>一报还一报</strong>（tit-for-tat）的交换激励机制。其基本想法是，A 根据当前能够以 <em>最高速率</em> 向它提供数据的邻居，给出其优先权。特别是，A 对于它的每个邻居都持续地测量接收到比特的速率，并确定以最高速率流入的 4 个邻居。每过 10 秒，它重新计算该速率并可能修改这 4 个对等方的集合。用 BitTorrent 术语来说，这 4 个对等方被称为<strong>疏通</strong>（unchoked）。重要的是，每过 30 秒，它也要随机地选择另外一个邻居并向其发送块。我们将这个被随机选择的对等方称为 B。现在站在 B 的角度上看，因为 A 正在向 B 发送数据，它可能成为 B 前 4 位上载者之一，这样的话 B 将开始向 A 发送数据。如果 B 向 A 发送数据的速率足够高，B 接下来也能成为 A 的前 4 位上载者。换言之，每过 30 秒 A 将随机地选择一名新的对换伴侣并开始与那位伴侣进行对换。如果这两名对等方都满足此对换，它们将对方放入其前 4 位列表中并继续与对方进行对换，直到该对等方之一发现了一个更好的伴侣为止。这种效果是对等方能够以趋向于找到彼此的协调的速率上载。随机选择邻居也允许新的对等方得到块，因此它们能够具有对换的东西。除了这 5 个对等方（<em>前</em> 4 个对等方和一个试探的对等方）的所有其他相邻对等方均被 <em>阻塞</em>，即它们不能从 A 接收到任何块。</p><h2 id="BitTorrent-客户端"><a href="#BitTorrent-客户端" class="headerlink" title="BitTorrent 客户端"></a>BitTorrent 客户端</h2><p>就如同 FTP 协议有众多的 FTP 客户端一样，BitTorrent 协议也有众多的 BitTorrent 客户端。最早的 BitTorrent 客户端应该是由 BitTorrent 发明人 Bram Cohen 开发的，很巧，软件的名字也叫 <a href="https://www.bittorrent.com/zh-cn/">BitTorrent</a>，现在已经成长为一家公司，也收购了著名的开源 BitTorrent 客户端 <a href="https://www.utorrent.com/intl/zh_cn/">µTorrent</a>。</p><p>出于种种原因，现在并不推荐使用以上两款软件，BitTorrent 发明人 Bram Cohen 也已经离开了那家公司，更推荐使用开源跨平台的 <a href="https://www.qbittorrent.org/">qBittorrent</a>。</p><!--迅雷--><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如前所述，tracker 服务器是一个 BitTorrent 网络的重点，大部分客户端都支持自定义 tracker 列表，GitHub 上就有一些精选的 tracker 列表：</p><ul><li><a href="https://github.com/ngosang/trackerslist">https://github.com/ngosang/trackerslist</a></li><li><a href="https://github.com/XIU2/TrackersListCollection">https://github.com/XIU2/TrackersListCollection</a></li></ul><p>为了降低对 tracker 服务器的依赖，BitTorrent 中也使用到了前面提到的分布式散列表（DHT）。</p><!--[IKnowWhatYouDownload](https://iknowwhatyoudownload.com/en/peer/)-->]]></content>
    
    
    <summary type="html">&lt;p&gt;P2P 是一种&lt;strong&gt;体系结构&lt;/strong&gt;，就好像 C/S 体系结构一样，但不同的是，P2P 对总是打开的基础设施服务器有最小的（或者没有）依赖，成对间歇连接的主机（称为&lt;strong&gt;对等方&lt;/strong&gt;）彼此直接通信。&lt;/p&gt;
&lt;p&gt;基于 P2P 这种体系结构产生了许多应用，譬如&lt;strong&gt;文件分发应用&lt;/strong&gt;和&lt;strong&gt;分布式散列表&lt;/strong&gt;（DHT），而文件分发应用中一个典型的例子就是 BitTorrent 协议。&lt;/p&gt;
&lt;p&gt;如果要类比 P2P 与 BitTorrent 之间的关系，就好像 C/S 体系结构与 FTP 协议之间的关系。&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HackRF 初体验</title>
    <link href="https://howiezhao.github.io/2020/01/22/hackrf/"/>
    <id>https://howiezhao.github.io/2020/01/22/hackrf/</id>
    <published>2020-01-22T12:25:55.000Z</published>
    <updated>2020-02-05T12:51:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://greatscottgadgets.com/hackrf/">HackRF</a> 是由 Great Scott Gadgets 设计和制造的开源 SDR 硬件，其可以发送或接收 1 MHz 到 6 GHz 的无线电信号。目前 HackRF 的具体版本为 HackRF One。你可以通过其<a href="https://greatscottgadgets.com/wheretobuy/">官网上列出的购买网址</a>购买它，也可以在万能的淘宝上购买。<img src="https://greatscottgadgets.com/images/h1-preliminary1-445.jpeg" alt="HackRF One"></p><a id="more"></a><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>你需要安装如下软件以使用 HackRF One：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:bladerf/bladerf</span><br><span class="line">sudo add-apt-repository -y ppa:myriadrf/drivers</span><br><span class="line">sudo add-apt-repository -y ppa:myriadrf/gnuradio</span><br><span class="line">sudo add-apt-repository -y ppa:gqrx/gqrx-sdr</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install gqrx-sdr hackrf</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hackrf_info    # 查看 Hack RF 连接信息</span><br><span class="line"></span><br><span class="line">hackrf_transfer    # 基于文件进行发送和接收 SDR</span><br><span class="line">hackrf_transfer -h    # 查看 hackrf_transfer 帮助信息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 录制信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r：将数据存储到文件中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f：中心频率，单位 Hz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：采样率，单位 Hz（4/8/10/12.5/16/20 MHz，默认 10 MHz）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n：采样数量（默认值是无限的）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：设置功放（1 表示开启，0 表示关闭）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g：设置 Rx VGA 增益（0 到 62 dB 之间，每次增加 2 dB）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l：设置 Rx LNA 增益（0 到 40 dB 之间，每次增加 8 dB）</span></span><br><span class="line">hackrf_transfer -r capture.raw -f 315000000 -l 8/16/24 -g 20/40 [-s 2000000 -n 10000000 -a 1]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重放信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t：从文件中读取数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x：设置 Tx VGA 增益（0 到 47 dB 之间，每次增加 1 dB）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -R：重复发送模式（默认为关闭）</span></span><br><span class="line">hackrf_transfer -t capture.raw -f 315000000 -x 40 [-s 2000000 -a 1]</span><br></pre></td></tr></table></figure><p>一般无线钥匙工作频段都在 315 Mhz、433.92 Mhz。<br>Tx Mode：发射模式<br>Rx Mode：接收模式</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://greatscottgadgets.com/hackrf/&quot;&gt;HackRF&lt;/a&gt; 是由 Great Scott Gadgets 设计和制造的开源 SDR 硬件，其可以发送或接收 1 MHz 到 6 GHz 的无线电信号。目前 HackRF 的具体版本为 HackRF One。你可以通过其&lt;a href=&quot;https://greatscottgadgets.com/wheretobuy/&quot;&gt;官网上列出的购买网址&lt;/a&gt;购买它，也可以在万能的淘宝上购买。&lt;img src=&quot;https://greatscottgadgets.com/images/h1-preliminary1-445.jpeg&quot; alt=&quot;HackRF One&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 Sphinx 生成项目文档</title>
    <link href="https://howiezhao.github.io/2020/01/22/sphinx-document/"/>
    <id>https://howiezhao.github.io/2020/01/22/sphinx-document/</id>
    <published>2020-01-22T12:21:54.000Z</published>
    <updated>2021-01-29T12:14:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.sphinx-doc.org/en/master/">Sphinx</a> 是一个用 Python 编写的文档生成工具，其使用 <a href="/2018/09/17/restructuredtext/" title="reStructuredText">reStructuredText</a> 作为标记语言，目前广泛应用于 Python 相关项目的文档生成。比如 <a href="https://docs.python.org/zh-cn/3/">Python 官方文档</a>就是基于 Sphinx 生成的，此外 <a href="https://www.kernel.org/doc/html/latest/index.html">Linux 内核文档</a>的生成也于 2016 年从 <a href="http://www.doxygen.nl/">Doxygen</a> 转向 Sphinx，要了解更多使用 Sphinx 的项目可参考其<a href="https://www.sphinx-doc.org/en/master/examples.html">官方列表</a>。</p><a id="more"></a><p>使用 <code>pip install sphinx</code> 即可安装 Sphinx。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>按照最佳实践，项目文档一般是在项目的 <code>docs</code> 目录中，所以不妨先创建一个 <code>docs</code> 目录并进入，之后的一切有关 sphinx 的命令都在此目录中运行。</p><p>安装完 Sphinx 并进入 <code>docs</code> 目录后，输入 <code>sphinx-quickstart</code> 即可创建一个文档项目。该引导程序会询问你一些问题，并根据你给出的回答对生成的文档项目进行相关配置，当然，这些配置都可以在生成后的 <code>conf.py</code> 文件中进行重新设置。以下是它可能会问到的一些问题：</p><ul><li>分隔“source”和“build”目录（y/n）[n]：默认不分隔即可</li><li>项目名称：项目名称将显示在左侧导航栏顶部</li><li>作者姓名：作者姓名将显示在页面底部</li><li>项目版本：可不填</li><li>项目语言[en]：默认为英文，要切换为中文请输入 <code>zh_CN</code></li></ul><p>执行完成后，会在当前目录下生成如下文件/文件夹：</p><ul><li><code>_duild/</code>：存放构建之后的文件</li><li><code>_static/</code>：存放静态文件</li><li><code>_templates/</code>：存放模板文件</li><li><code>conf.py</code>：sphinx 的配置文件</li><li><code>index.rst</code>：文档主页</li><li><code>Makefile</code>：Linux 下 <code>make</code> 构建工具的配置文件</li><li><code>make.bat</code>：Windows 下的构建命令脚本</li></ul><p>编写完文档后，使用 <code>make html</code> 命令即可将其构建为 HTML 文件，其中，<code>html</code> 被称为构建器（builder），当然，你也可以使用别的构建器，比如 <code>latex</code>、<code>epub</code> 等。</p><p>输入 <code>make help</code> 可查看 make 支持的相关命令。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Sphinx 生成的 HTML 文件默认使用的主题为 <a href="https://github.com/bitprophet/alabaster">Alabaster</a>（个人觉得挺好看的，<a href="https://cn.python-requests.org/zh_CN/latest/">Requests</a> 和 <a href="https://flask.palletsprojects.com/en/1.1.x/">Flask</a> 项目文档的主题都是基于此主题修改的），除此之外，Sphinx 还内置了一些别的主题，具体可见其<a href="https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes">官方文档中列出的</a>（个人觉得其余的主题不如 Alabaster 好看），当然，你也可以使用第三方主题。</p><p>第三方主题中最常见的非 <a href="https://github.com/readthedocs/sphinx_rtd_theme">sphinx_rtd_theme</a> 莫属，<a href="https://docs.scrapy.org/en/latest/">Scrapy</a> 项目的文档就使用的它，要使用 sphinx_rtd_theme，需要先执行 <code>pip install sphinx_rtd_theme</code> 命令下载它，然后修改 <code>conf.py</code> 配置文件中的 <code>html_theme</code> 变量为 <code>&#39;sphinx_rtd_theme&#39;</code> 并在 <code>extensions</code> 列表中添加 <code>&#39;sphinx_rtd_theme&#39;</code>。</p><p>要探索更多的第三方主题，可参考 <a href="https://sphinx-themes.org/">Sphinx Themes</a> 网站上收录的。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Sphinx 支持扩展，安装完 Sphinx 后就已经内置了一些扩展，除此之外，你也可以下载第三方扩展。</p><h3 id="内置扩展"><a href="#内置扩展" class="headerlink" title="内置扩展"></a>内置扩展</h3><h4 id="sphinx-ext-autodoc"><a href="#sphinx-ext-autodoc" class="headerlink" title="sphinx.ext.autodoc"></a>sphinx.ext.autodoc</h4><h4 id="sphinx-ext-coverage"><a href="#sphinx-ext-coverage" class="headerlink" title="sphinx.ext.coverage"></a>sphinx.ext.coverage</h4><h4 id="sphinx-ext-viewcode"><a href="#sphinx-ext-viewcode" class="headerlink" title="sphinx.ext.viewcode"></a>sphinx.ext.viewcode</h4><h4 id="sphinx-ext-napoleon"><a href="#sphinx-ext-napoleon" class="headerlink" title="sphinx.ext.napoleon"></a>sphinx.ext.napoleon</h4><h4 id="sphinx-ext-graphviz"><a href="#sphinx-ext-graphviz" class="headerlink" title="sphinx.ext.graphviz"></a>sphinx.ext.graphviz</h4><h4 id="sphinx-ext-todo"><a href="#sphinx-ext-todo" class="headerlink" title="sphinx.ext.todo"></a>sphinx.ext.todo</h4><h3 id="第三方扩展"><a href="#第三方扩展" class="headerlink" title="第三方扩展"></a>第三方扩展</h3><h4 id="recommonmark"><a href="#recommonmark" class="headerlink" title="recommonmark"></a>recommonmark</h4><h4 id="nbsphinx"><a href="#nbsphinx" class="headerlink" title="nbsphinx"></a>nbsphinx</h4><h4 id="sphinx-autodoc-typehints"><a href="#sphinx-autodoc-typehints" class="headerlink" title="sphinx-autodoc-typehints"></a>sphinx-autodoc-typehints</h4><h4 id="sphinx-gallery"><a href="#sphinx-gallery" class="headerlink" title="sphinx-gallery"></a>sphinx-gallery</h4><h2 id="Read-the-Docs"><a href="#Read-the-Docs" class="headerlink" title="Read the Docs"></a>Read the Docs</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.sphinx-doc.org/en/master/&quot;&gt;Sphinx&lt;/a&gt; 是一个用 Python 编写的文档生成工具，其使用 &lt;a href=&quot;/2018/09/17/restructuredtext/&quot; title=&quot;reStructuredText&quot;&gt;reStructuredText&lt;/a&gt; 作为标记语言，目前广泛应用于 Python 相关项目的文档生成。比如 &lt;a href=&quot;https://docs.python.org/zh-cn/3/&quot;&gt;Python 官方文档&lt;/a&gt;就是基于 Sphinx 生成的，此外 &lt;a href=&quot;https://www.kernel.org/doc/html/latest/index.html&quot;&gt;Linux 内核文档&lt;/a&gt;的生成也于 2016 年从 &lt;a href=&quot;http://www.doxygen.nl/&quot;&gt;Doxygen&lt;/a&gt; 转向 Sphinx，要了解更多使用 Sphinx 的项目可参考其&lt;a href=&quot;https://www.sphinx-doc.org/en/master/examples.html&quot;&gt;官方列表&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>Proxmark 入坑指南</title>
    <link href="https://howiezhao.github.io/2019/12/01/proxmark/"/>
    <id>https://howiezhao.github.io/2019/12/01/proxmark/</id>
    <published>2019-12-01T05:37:30.000Z</published>
    <updated>2020-02-05T12:51:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>Proxmark 是 RFID 界的瑞士军刀，请注意，其官网为 <a href="http://www.proxmark.org/">proxmark.org</a>，其他的如 <a href="https://proxmark.com/">proxmark.com</a>、<a href="https://www.proxmark3.com/">proxmark3.com</a> 等，均为第三方商业网站，目前的最新硬件版本是 Proxmark 3。</p><a id="more"></a><h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><ul><li>Proxmark 3：这是 Proxmark 3 的原始版本，现已过时，不建议购买，产品图如下：</li></ul><p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/05.proxmark-3/PM3-Trans.png" alt="Proxmark 3"></p><ul><li>Proxmark 3 RDV 2：这是 Proxmark 3 的一次升级，又称为 Revision Two（修订第二版），产品图如下：</li></ul><p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/03.proxmark-3-rdv-2/PM3-RDV2-Trans.png" alt="Proxmark 3 RDV 2"></p><ul><li>Proxmark 3 Easy：这是 Proxmark 3 RDV 2 的廉价版本，专门通过淘宝在中国销售，也是目前淘宝上主要的 Proxmark 3 版本，产品图如下：</li></ul><p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/04.proxmark-3-easy/PM3-Easy-Trans.png" alt="Proxmark 3 Easy"></p><ul><li>Proxmark 3 EVO：这是 Proxmark 3 RDV 2 的一次进化，又称为 Evolution（进化），产品图如下：</li></ul><p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/02.proxmark-3-evo/PM3-Evo-Trans.png" alt="Proxmark 3 EVO"></p><ul><li>Proxmark 3 RDV 4：这是 Proxmark 3 的最新升级版本，产品图如下：</li></ul><p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/01.proxmark-3-rdv4/PM3-RDV4-Trans.png" alt="Proxmark 3 RDV 4"></p><h2 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h2><p>Proxmark 只有 2 个官方分销商：<a href="https://lab401.com/">Lab401</a> 和 <a href="https://hackerwarehouse.com/">Hacker Warehouse</a>，当然，你也可以从万能的淘宝上购买。</p><p>请注意，淘宝上的版本号并不规范，据我所知，淘宝上的大部分产品都是基于 Proxmark 3 Easy 的国内再次改造版，比如，它们所谓的<strong>“一体机”</strong>实际上是 Proxmark 3 Easy 和 <a href="https://github.com/iceman1001/ChameleonMini-rebooted">ChameleonMini（变色龙）</a>的合体版。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Proxmark 是 RFID 界的瑞士军刀，请注意，其官网为 &lt;a href=&quot;http://www.proxmark.org/&quot;&gt;proxmark.org&lt;/a&gt;，其他的如 &lt;a href=&quot;https://proxmark.com/&quot;&gt;proxmark.com&lt;/a&gt;、&lt;a href=&quot;https://www.proxmark3.com/&quot;&gt;proxmark3.com&lt;/a&gt; 等，均为第三方商业网站，目前的最新硬件版本是 Proxmark 3。&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="硬件" scheme="https://howiezhao.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Scheme的五法十诫</title>
    <link href="https://howiezhao.github.io/2019/08/07/scheme-commandments-and-laws/"/>
    <id>https://howiezhao.github.io/2019/08/07/scheme-commandments-and-laws/</id>
    <published>2019-08-07T13:42:23.000Z</published>
    <updated>2021-02-05T11:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>节选自《The Little Schemer》</p><h2 id="Scheme-五法"><a href="#Scheme-五法" class="headerlink" title="Scheme 五法"></a>Scheme 五法</h2><h3 id="Scheme-五法之第一法-——-car-之法则"><a href="#Scheme-五法之第一法-——-car-之法则" class="headerlink" title="Scheme 五法之第一法 —— car 之法则"></a>Scheme 五法之第一法 —— car 之法则</h3><p>基本元件 <em>car</em> 仅定义为针对非空列表。</p><h3 id="Scheme-五法之第二法-——-cdr-之法则"><a href="#Scheme-五法之第二法-——-cdr-之法则" class="headerlink" title="Scheme 五法之第二法 —— cdr 之法则"></a>Scheme 五法之第二法 —— cdr 之法则</h3><p>基本元件 <em>cdr</em> 仅定义为针对非空列表。任意非空列表的 <em>cdr</em> 总是另一个列表。</p><h3 id="Scheme-五法之第三法-——-cons-之法则"><a href="#Scheme-五法之第三法-——-cons-之法则" class="headerlink" title="Scheme 五法之第三法 —— cons 之法则"></a>Scheme 五法之第三法 —— cons 之法则</h3><p>基本元件 <em>cons</em> 需要两个参数。第二个参数必须是一个列表。结果是一个列表。</p><h3 id="Scheme-五法之第四法-——-Null-之法则"><a href="#Scheme-五法之第四法-——-Null-之法则" class="headerlink" title="Scheme 五法之第四法 —— Null? 之法则"></a>Scheme 五法之第四法 —— Null? 之法则</h3><p>基本元件 <em>null?</em> 仅定义为针对列表。</p><h3 id="Scheme-五法之第五法-——-eq-之法则"><a href="#Scheme-五法之第五法-——-eq-之法则" class="headerlink" title="Scheme 五法之第五法 —— eq? 之法则"></a>Scheme 五法之第五法 —— eq? 之法则</h3><p>基本元件 <em>eq?</em> 需要两个参数。每个参数都必须是一个非数字的原子。</p><a id="more"></a><h2 id="Scheme十诫"><a href="#Scheme十诫" class="headerlink" title="Scheme十诫"></a>Scheme十诫</h2><h3 id="第一诫"><a href="#第一诫" class="headerlink" title="第一诫"></a>第一诫</h3><p>当对一个原子列表 <em>lat</em> 进行递归调用时，询问两个有关 <em>lat</em> 的问题：*(null? lat)* 和 <strong>else</strong>。</p><p>当对一个数字 <em>n</em> 进行递归调用时，询问两个有关 <em>n</em> 的问题：*(zero? n)* 和 <strong>else</strong>。</p><p>当对一个S-表达式列表 <em>l</em> 进行递归调用时，询问三个有关 <em>l</em> 的问题：*(null? lat)<em>、</em>(atom? (car l))* 和 <strong>else</strong>。</p><h3 id="第二诫"><a href="#第二诫" class="headerlink" title="第二诫"></a>第二诫</h3><p>使用 <em>cons</em> 来构建列表。</p><h3 id="第三诫"><a href="#第三诫" class="headerlink" title="第三诫"></a>第三诫</h3><p>构建一个列表的时候，描述第一个典型元素，之后 <em>cons</em> 该元素到一般性递归（natural recursion）上。</p><h3 id="第四诫"><a href="#第四诫" class="headerlink" title="第四诫"></a>第四诫</h3><p>在递归时总是改变至少一个参数。当对一个原子列表 <em>lat</em> 进行递归调用时，使用 <em>(cdr lat)*。当对数字 *n</em> 进行递归调用时，使用 <em>(sub1 n)*。当对一个S-表达式 *l</em> 进行递归调用时，只要是 <em>(null? l)</em> 和 <em>(atom? (car l))</em> 都不为 true，那么就同时使用 <em>(car l)</em> 和 *(cdr l)*。</p><p>在递归时改变的参数，必须向着不断接近结束条件而改变。改变的参数必须在结束条件中得以测试：<br>    当使用 <em>cdr</em> 时，用 <em>null?</em> 测试是否结束；<br>    当使用 <em>sub1</em> 时,用 <em>zero?</em> 测试是否结束。</p><h3 id="第五诫"><a href="#第五诫" class="headerlink" title="第五诫"></a>第五诫</h3><p>当用 ➕ 构建一个值时，总是使用 0 作为结束代码行的值，因为加上 0 不会改变加法的值。</p><p>当用 ✖ 构建一个值时，总是使用 1 作为结柬代码行的值，因为乘以 1 不会改变乘法的值。</p><p>当用 <em>cons</em> 构建一个值时，总是考虑把 0 作为结束代码行的值。</p><h3 id="第六诫"><a href="#第六诫" class="headerlink" title="第六诫"></a>第六诫</h3><p>简化工作只在功能正确之后开展。</p><h3 id="第七诫"><a href="#第七诫" class="headerlink" title="第七诫"></a>第七诫</h3><p>对具有相同性质的 <em>subparts</em>（子部件）进行递归调用：</p><ul><li>列表的子列表。</li><li>算术表达式的子表达式。</li></ul><h3 id="第八诫"><a href="#第八诫" class="headerlink" title="第八诫"></a>第八诫</h3><p>使用辅助函数来抽象表示方式。</p><h3 id="第九诫"><a href="#第九诫" class="headerlink" title="第九诫"></a>第九诫</h3><p>用函数来抽象通用模式。</p><h3 id="第十诫"><a href="#第十诫" class="headerlink" title="第十诫"></a>第十诫</h3><p>构建函数,一次收集多个值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;节选自《The Little Schemer》&lt;/p&gt;
&lt;h2 id=&quot;Scheme-五法&quot;&gt;&lt;a href=&quot;#Scheme-五法&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法&quot;&gt;&lt;/a&gt;Scheme 五法&lt;/h2&gt;&lt;h3 id=&quot;Scheme-五法之第一法-——-car-之法则&quot;&gt;&lt;a href=&quot;#Scheme-五法之第一法-——-car-之法则&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法之第一法 —— car 之法则&quot;&gt;&lt;/a&gt;Scheme 五法之第一法 —— car 之法则&lt;/h3&gt;&lt;p&gt;基本元件 &lt;em&gt;car&lt;/em&gt; 仅定义为针对非空列表。&lt;/p&gt;
&lt;h3 id=&quot;Scheme-五法之第二法-——-cdr-之法则&quot;&gt;&lt;a href=&quot;#Scheme-五法之第二法-——-cdr-之法则&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法之第二法 —— cdr 之法则&quot;&gt;&lt;/a&gt;Scheme 五法之第二法 —— cdr 之法则&lt;/h3&gt;&lt;p&gt;基本元件 &lt;em&gt;cdr&lt;/em&gt; 仅定义为针对非空列表。任意非空列表的 &lt;em&gt;cdr&lt;/em&gt; 总是另一个列表。&lt;/p&gt;
&lt;h3 id=&quot;Scheme-五法之第三法-——-cons-之法则&quot;&gt;&lt;a href=&quot;#Scheme-五法之第三法-——-cons-之法则&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法之第三法 —— cons 之法则&quot;&gt;&lt;/a&gt;Scheme 五法之第三法 —— cons 之法则&lt;/h3&gt;&lt;p&gt;基本元件 &lt;em&gt;cons&lt;/em&gt; 需要两个参数。第二个参数必须是一个列表。结果是一个列表。&lt;/p&gt;
&lt;h3 id=&quot;Scheme-五法之第四法-——-Null-之法则&quot;&gt;&lt;a href=&quot;#Scheme-五法之第四法-——-Null-之法则&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法之第四法 —— Null? 之法则&quot;&gt;&lt;/a&gt;Scheme 五法之第四法 —— Null? 之法则&lt;/h3&gt;&lt;p&gt;基本元件 &lt;em&gt;null?&lt;/em&gt; 仅定义为针对列表。&lt;/p&gt;
&lt;h3 id=&quot;Scheme-五法之第五法-——-eq-之法则&quot;&gt;&lt;a href=&quot;#Scheme-五法之第五法-——-eq-之法则&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法之第五法 —— eq? 之法则&quot;&gt;&lt;/a&gt;Scheme 五法之第五法 —— eq? 之法则&lt;/h3&gt;&lt;p&gt;基本元件 &lt;em&gt;eq?&lt;/em&gt; 需要两个参数。每个参数都必须是一个非数字的原子。&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://howiezhao.github.io/categories/Notes/"/>
    
    
    <category term="函数式编程" scheme="https://howiezhao.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ADB小记</title>
    <link href="https://howiezhao.github.io/2019/07/29/adb/"/>
    <id>https://howiezhao.github.io/2019/07/29/adb/</id>
    <published>2019-07-29T04:56:04.000Z</published>
    <updated>2021-02-05T11:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="error-device-still-connecting"><a href="#error-device-still-connecting" class="headerlink" title="error: device still connecting"></a>error: device still connecting</h3><p>输入<code>adb shell</code>时显示<code>error: device still connecting</code>，一般可通过：关闭<strong>开发者模式</strong>然后重新打开<strong>开发者模式</strong>，接着开启<strong>USB调试</strong>并重新和电脑配对，即可解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关问题&quot;&gt;&lt;a href=&quot;#相关问题&quot; class=&quot;headerlink&quot; title=&quot;相关问题&quot;&gt;&lt;/a&gt;相关问题&lt;/h2&gt;&lt;h3 id=&quot;error-device-still-connecting&quot;&gt;&lt;a href=&quot;#error-device-sti</summary>
      
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="Android" scheme="https://howiezhao.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>关于 Windows 的代理设置</title>
    <link href="https://howiezhao.github.io/2019/07/29/about-the-proxy-settings-for-windows/"/>
    <id>https://howiezhao.github.io/2019/07/29/about-the-proxy-settings-for-windows/</id>
    <published>2019-07-29T04:21:18.000Z</published>
    <updated>2021-02-05T09:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Windows 的<strong>系统代理</strong>使用的其实是 <strong>IE 的代理设置</strong>，此外，对于<strong>绝大多数</strong>的应用程序而言，它们默认使用的也是 IE 的代理设置，比如，Chrome、Firefox、Microsoft Store 等。因此，如果想让绝大多数的应用程序使用代理，一个简单的方法是直接设置 IE 的代理（即系统代理）。不过，对于一小部分没有使用 IE 代理设置的应用程序，比如 Android Studio 等，你可能需要单独设置它们的代理（一般在软件的设置项中）。</p><p>值得注意的是，同为应用程序的 <strong>Shell</strong>（包括<strong>命令提示符</strong>和 <strong>PowerShell</strong>）就没有使用 IE 的代理设置，它们各自有自己的代理设置。具体而言，要为命令提示符设置代理，可使用如下两条命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> HTTP_PROXY=http://user:password@proxy.domain.com:port</span><br><span class="line"><span class="built_in">set</span> HTTPS_PROXY=https://user:password@proxy.domain.com:port</span><br></pre></td></tr></table></figure><p>而要为 PowerShell 设置代理则要使用<a href="todo">这个脚本</a>。</p><p>最后，对于 Shell 中运行的程序，有一部分使用的是 IE 的代理设置，比如 <code>pip</code>、<code>git</code>、<code>npm</code> 等，另一部分则使用的是 Shell 的代理设置，比如 <code>curl</code>、<code>gem</code> 等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Windows 的&lt;strong&gt;系统代理&lt;/strong&gt;使用的其实是 &lt;strong&gt;IE 的代理设置&lt;/strong&gt;，此外，对于&lt;strong&gt;绝大多数&lt;/strong&gt;的应用程序而言，它们默认使用的也是 IE 的代理设置，比如，Chrome、Firefox、Mic</summary>
      
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="Windows" scheme="https://howiezhao.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Nexus/Pixel 相关问题解决</title>
    <link href="https://howiezhao.github.io/2019/07/21/nexus-pixel-problem/"/>
    <id>https://howiezhao.github.io/2019/07/21/nexus-pixel-problem/</id>
    <published>2019-07-21T02:15:55.000Z</published>
    <updated>2020-12-04T10:01:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动网络-WiFi-出现叹号或叉号"><a href="#移动网络-WiFi-出现叹号或叉号" class="headerlink" title="移动网络/WiFi 出现叹号或叉号"></a>移动网络/WiFi 出现叹号或叉号</h2><p>Captive Portal 是从 Android 5 开始引入的一项新功能，其主要用于检测网络连接是否正常，当用户连接网络后，系统会通过 HTTP 访问一个 Google 的服务器，若返回 200 状态码，则表示用户可能处在一个需要登录认证的网络环境中；若返回 204 状态码，则表示网络连接正常；若连接超时，则表示网络连接不正常，此时网络图标会显示一个叹号或叉号。</p><p>显然，Google 的服务器是连接不上的，我们可以通过修改服务器地址来解决此问题。具体而言，连接 ADB，针对不同的系统版本，下方分别给出了相关命令：</p><p>Android 9.0/8.1/8.0/7.1.2/7.1.1：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204</span><br></pre></td></tr></table></figure><p>Android 7.1/7.0：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings delete global captive_portal_server  </span><br><span class="line">adb shell settings put global captive_portal_detection_enabled 0</span><br></pre></td></tr></table></figure><p>Android 5.0-6.x：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global captive_portal_server www.google.cn</span><br></pre></td></tr></table></figure><p>执行之后，开启飞行模式，接着关闭飞行模式即可。</p><a id="more"></a><h2 id="搜索不到-WiFi"><a href="#搜索不到-WiFi" class="headerlink" title="搜索不到 WiFi"></a>搜索不到 WiFi</h2><p>因为美国 2.4GHz 频段的 WiFi 信道为 1-11，而中国 2.4GHz 频段的 WiFi 信道为 1-13，所以当 2.4GHz 频段的 WiFi 信道位于 12 或 13 时，美版的 Nexus/Pixel 会搜索不到 WiFi，此时可通过重启路由器，使其自动更换信道，或进入路由器设置页面，将信道改为 11 以内任意信道即可。</p><h2 id="4G-信号问题"><a href="#4G-信号问题" class="headerlink" title="4G 信号问题"></a>4G 信号问题</h2><p>由于联通的网络制式一直采用的是国际通用的网络制式，所以 Nexus/Pixel 可以完美支持联通 2G/3G/4G。</p><p>移动的 3G 网络制式采用的是自主研发的技术，所以 Nexus/Pixel 并不支持移动 3G，然而移动 4G 网络制式采用的是自主研发和国际通用并行的方式，所以 Nexus/Pixel 只支持部分移动 4G 频段。</p><p>简单来说，Nexus/Pixel 完美支持联通 2G/3G/4G，支持移动 2G，不支持移动 3G，部分支持移动 4G（具体表现为在城市有 4G 网络，在农村没有 4G 网络），电信 2G/3G/4G 可通过破解（本文不讨论这点）实现支持。</p><h2 id="Google（即负一屏）无法使用"><a href="#Google（即负一屏）无法使用" class="headerlink" title="Google（即负一屏）无法使用"></a>Google（即负一屏）无法使用</h2><h2 id="接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）"><a href="#接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）" class="headerlink" title="接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）"></a>接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）</h2><p>严格来说，这不算是 Nexus/Pixel 特有的问题，究其原因是距离感应器坏了，可通过设置使用电源键挂断电话，具体方法为在<strong>设置</strong> —&gt; <strong>辅助功能/无障碍</strong>中开启<strong>按电源按钮结束通话</strong>。</p><h2 id="蓝牙传输失败，显示不支持此内容"><a href="#蓝牙传输失败，显示不支持此内容" class="headerlink" title="蓝牙传输失败，显示不支持此内容"></a>蓝牙传输失败，显示不支持此内容</h2><p>由于版权问题，原生 Android 不支持传输以 <code>.apk</code> 结尾的文件，可通过将其改为 <code>.jpg</code> 结尾传输。</p><h2 id="Google-Play-商店更新应用卡住"><a href="#Google-Play-商店更新应用卡住" class="headerlink" title="Google Play 商店更新应用卡住"></a>Google Play 商店更新应用卡住</h2><p>在 Android 9.0 之前，Play 商店是通过<strong>下载管理器</strong>下载应用的，出现这种情况可以直接将<strong>下载管理器</strong>强行停止，然后重新启动 Play 商店即可更新应用。在 Android 9.0 之后，可直接将 Play 商店强行停止再重新启动即可。</p><h2 id="系统无法更新"><a href="#系统无法更新" class="headerlink" title="系统无法更新"></a>系统无法更新</h2><p>具体表现为<strong>系统更新</strong>处永远显示<strong>正在安装系统更新</strong>，一般来说，这是由于网络原因引起的，目前并没有一个稳定的解决办法，建议直接下载新系统镜像并线刷。你可以在<a href="https://developers.google.cn/android/images">这个官方地址</a>找到有关 Nexus/Pixel 的所有出厂镜像，其中也附带有详细的安装方法。</p><p>具体而言，你需要先解锁 Bootloader，然后连接 ADB，紧接着执行 <code>adb reboot bootloader</code> 进入 fastboot 模式，最后执行相应系统的 <code>flash-all</code> 脚本即可。</p><h2 id="Pixel-Pixel-XL-Verizon-版解锁-Bootloader-教程"><a href="#Pixel-Pixel-XL-Verizon-版解锁-Bootloader-教程" class="headerlink" title="Pixel/Pixel XL Verizon 版解锁 Bootloader 教程"></a>Pixel/Pixel XL Verizon 版解锁 Bootloader 教程</h2><p>教程来源自 xda 上的一篇<a href="https://www.xda-developers.com/unlock-bootloader-verizon-google-pixel-xl/">文章</a>，具体步骤如下：</p><ol><li>从您的设备中删除 Google 帐户和任何类型的屏幕锁定（指纹，PIN，图案等）。</li><li>从您的设备中取出 SIM 卡。</li><li>重置您的设备。在设置向导中，跳过所有内容，不要连接到 WiFi，不要添加指纹或任何类型的屏幕锁定。</li><li>转到开发人员选项并启用 USB 调试。</li><li>将手机连接到 PC。</li><li>在 adb 目录中打开 CMD 并输入：<code>adb shell pm uninstall --user 0 com.android.phone</code></li><li>重启您的设备。</li><li>连接到 WiFi，打开 Chrome 并转到 google.com（或任何网站）。</li><li>转到开发人员选项并启用 OEM 解锁。</li><li>重启到 bootloader 并通过 CMD 运行：<code>fastboot oem unlock</code> 或 <code>fastboot flashing unlock</code>。</li><li>完成。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;移动网络-WiFi-出现叹号或叉号&quot;&gt;&lt;a href=&quot;#移动网络-WiFi-出现叹号或叉号&quot; class=&quot;headerlink&quot; title=&quot;移动网络/WiFi 出现叹号或叉号&quot;&gt;&lt;/a&gt;移动网络/WiFi 出现叹号或叉号&lt;/h2&gt;&lt;p&gt;Captive Portal 是从 Android 5 开始引入的一项新功能，其主要用于检测网络连接是否正常，当用户连接网络后，系统会通过 HTTP 访问一个 Google 的服务器，若返回 200 状态码，则表示用户可能处在一个需要登录认证的网络环境中；若返回 204 状态码，则表示网络连接正常；若连接超时，则表示网络连接不正常，此时网络图标会显示一个叹号或叉号。&lt;/p&gt;
&lt;p&gt;显然，Google 的服务器是连接不上的，我们可以通过修改服务器地址来解决此问题。具体而言，连接 ADB，针对不同的系统版本，下方分别给出了相关命令：&lt;/p&gt;
&lt;p&gt;Android 9.0/8.1/8.0/7.1.2/7.1.1：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Android 7.1/7.0：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adb shell settings delete global captive_portal_server  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;adb shell settings put global captive_portal_detection_enabled 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Android 5.0-6.x：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adb shell settings put global captive_portal_server www.google.cn&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;执行之后，开启飞行模式，接着关闭飞行模式即可。&lt;/p&gt;</summary>
    
    
    
    <category term="Bug" scheme="https://howiezhao.github.io/categories/Bug/"/>
    
    
    <category term="Android" scheme="https://howiezhao.github.io/tags/Android/"/>
    
    <category term="硬件" scheme="https://howiezhao.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>GCC 小记</title>
    <link href="https://howiezhao.github.io/2019/04/18/gcc/"/>
    <id>https://howiezhao.github.io/2019/04/18/gcc/</id>
    <published>2019-04-18T09:42:24.000Z</published>
    <updated>2021-02-05T09:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>GCC 一般有两层意思，广义是指 GNU Compiler Collection（即 GNU 编译器套装），狭义是指 GNU C Compiler（即 GNU C 语言编译器），在本文中，我默认大写的 GCC 指广义，小写的 gcc 指狭义。</p><p>使用 gcc 编译 C 语言源代码的一般格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>Linux下 <code>gcc</code> 命令常用的参数及其含义如下所示：</p><ul><li><code>--help</code>：显示帮助信息</li><li><code>-o</code>：指定生成的文件名，若不指定，则默认生成 <code>a.out</code></li><li><code>-E</code>：生成 <code>.i</code> 格式的预处理文件</li><li><code>-S</code>：生成 <code>.s</code> 格式的汇编文件</li><li><code>-c</code>：生成 <code>.o</code> 格式的二进制文件</li><li><code>-save-temps</code>：保留所有生成的中间文件</li><li><code>-g</code>：生成必要的符号信息，为调试而用</li><li><code>-ggdb</code>：生成可特供于 gdb 使用的调试信息</li><li><code>-gstabs</code>：生成 stabs 格式的调试信息</li><li><code>-Wall</code>：显示所有常用的警告信息，即 Warning all</li><li><code>-m32</code>：指定生成 32 位程序</li><li><code>-Os</code>：为减小代码大小而进行优化，即 Optimizers small</li><li><code>-nostdinc</code>：不使用标准库</li><li><code>-fno-stack-protector</code>：不生成用于检测缓冲区溢出的代码</li><li><code>-I&lt;dir&gt;</code>：添加搜索头文件的路径</li><li><code>-fno-builtin</code>：除非用 <code>__builtin_</code> 前缀，否则不进行 <code>builtin</code> 函数的优化</li></ul><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>为了在 Windows 中使用 GCC，诞生了 <a href="http://www.mingw.org/"><strong>MinGW</strong></a> 项目，即 Minimalist GNU for Windows（适用于 Windows 的极简 GNU），它是将 GCC 编译器和 GNU Binutils 移植到 Win32 平台下的产物，又被称为 <strong>mingw32</strong>。另有可用于产生 32 位及 64 位 Windows 可执行文件的 <a href="https://mingw-w64.org/doku.php/start"><strong>MinGW-w64</strong></a> 项目，是从原 MinGW 项目产生的分支。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GCC 一般有两层意思，广义是指 GNU Compiler Collection（即 GNU 编译器套装），狭义是指 GNU C Compiler（即 GNU C 语言编译器），在本文中，我默认大写的 GCC 指广义，小写的 gcc 指狭义。&lt;/p&gt;
&lt;p&gt;使用 gcc 编译 C 语言源代码的一般格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gcc test.c -o &lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>QEMU小记</title>
    <link href="https://howiezhao.github.io/2019/04/18/qemu/"/>
    <id>https://howiezhao.github.io/2019/04/18/qemu/</id>
    <published>2019-04-18T09:17:11.000Z</published>
    <updated>2021-02-05T11:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.qemu.org/">QEMU</a>是Linux中使用最广的虚拟机，其便于调试的特性也适合于系统开发者。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用<code>sudo apt install qemu</code>即可在Ubuntu中安装QEMU，安装完成后直接输入<code>qemu</code>来验证是否成功安装，如果出错，可再输入<code>qemu-system-i386</code>来验证其是否成功安装，若成功，可建立如下所示的软链接，以方便日后使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu</span><br></pre></td></tr></table></figure><p>值得注意的是，QEMU的启动需要有图形界面，若未安装图形界面，则会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not initialize SDL(No available video device) - exiting</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>使用QEMU运行一个虚拟机的命令格式为<code>qemu [options] [disk_image]</code>，其中disk_image即硬盘镜像文件。其常用的参数如下：</p><ul><li><code>-hda file</code>：使用file作为硬盘0的镜像文件。</li><li><code>-m megs</code>：设定虚拟内存为megs M字节，默认为128M字节。</li><li><code>-smp n</code>：设置为有n个CPU的SMP系统。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.qemu.org/&quot;&gt;QEMU&lt;/a&gt;是Linux中使用最广的虚拟机，其便于调试的特性也适合于系统开发者。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;sudo apt install qemu&lt;/code&gt;即可在Ubuntu中安装QEMU，安装完成后直接输入&lt;code&gt;qemu&lt;/code&gt;来验证是否成功安装，如果出错，可再输入&lt;code&gt;qemu-system-i386&lt;/code&gt;来验证其是否成功安装，若成功，可建立如下所示的软链接，以方便日后使用。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;值得注意的是，QEMU的启动需要有图形界面，若未安装图形界面，则会报错：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Could not initialize SDL(No available video device) - exiting&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Makefile小记</title>
    <link href="https://howiezhao.github.io/2019/04/18/makefile/"/>
    <id>https://howiezhao.github.io/2019/04/18/makefile/</id>
    <published>2019-04-18T04:40:39.000Z</published>
    <updated>2021-02-05T11:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中使用最广的构建工具是<strong>make</strong>，而make会读取<strong>Makefile</strong>文件中的配置信息来完成构建，一个简单的Makefile文件如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">editor : main.o text.o</span><br><span class="line">    gcc -o editor main.o text.o</span><br><span class="line">main.o : main.c def.h</span><br><span class="line">    gcc -c main.c  <span class="comment">#-c参数指定生成.o文件</span></span><br><span class="line">text.o : text.c com.h</span><br><span class="line">    gcc -c text.c</span><br><span class="line">install : editor</span><br><span class="line">    mv editor /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>具体而言，冒号前面为<strong>target</strong>，即要生成的文件；冒号后面为<strong>dependencies</strong>，即被依赖的文件；每一个<strong>target:dependencies对</strong>的下一行为要执行的<strong>命令</strong>（注意要以Tab键起首）。当make不带参数时，默认执行第一个target。target也可以是要求make要完成的动作，执行这种target后并不能得到和target同名的文件，因此，也称做<strong>phony target</strong>（即伪target），如第7行所示。dependencies也可以为空，如常用的target为<code>clean</code>时，就没有依赖，只有命令，一般用于清理工作。</p><p>当输入<code>make</code>或<code>make editor</code>，即可开始构建。若<code>editor</code>这个target文件不存在，或者<code>main.o</code>、<code>text.o</code>这两个依赖文件被修改，都会导致make调用其下的命令<code>gcc -o editor main.o text.o</code>；接下来，由于引用到<code>main.o</code>和<code>text.o</code>，make会检查<code>main.o</code>的依赖<code>main.c</code>、<code>def.h</code>有无更新，如果有，则执行其下的命令<code>gcc -c main.c</code>；同理，也适用于<code>text.o</code>。当输入<code>make install</code>，make会检查install的依赖<code>editor</code>是否是最新，如果是，则执行其下的命令<code>mv editor /usr/local</code>。</p><a id="more"></a><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Makefile中以<code>#</code>开头的均为注释。</p><h2 id="回声"><a href="#回声" class="headerlink" title="回声"></a>回声</h2><p>正常情况下，make会打印每条命令，然后再执行，这就叫做<strong>回声</strong>。在命令的前面加上<code>@</code>，就可以关闭回声。由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上<code>@</code>。</p><h2 id="内置目标名"><a href="#内置目标名" class="headerlink" title="内置目标名"></a>内置目标名</h2><p><strong>内置目标名</strong>指示了如果某些名称作为target（目标名）出现，则具有特殊含义，常用的如下所示：</p><ul><li><code>.PHONY</code>：明确声明伪目标</li><li><code>.SUFFIXES</code>：消除默认后缀规则</li><li><code>.DELETE_ON_ERROR</code>：如果遇到错误（或make中断）则删除目标文件</li></ul><p>更多的内置目标名可以参考<a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets">make官方手册</a>。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Makefile中也可以使用变量，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TXT = Hello World</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    <span class="built_in">echo</span> $(TXT)</span><br></pre></td></tr></table></figure><p>这类似于C语言中的宏，按照传统，变量名一般大写，使用变量时要放在<code>$()</code>之中。</p><p>有时，变量的值可能指向另一个变量，比如：<code>V1 = $(V2)</code>，这时会出现一个问题，V1的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果V2的值是动态变化的，这两种扩展方式的结果可能会差异很大。为了解决类似问题，Makefile一共提供了四个赋值运算符，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在运行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><p>Makefile提供了一系列的内置变量，常见的如下所示：</p><ul><li><code>$(CC)</code>：指向当前使用的编译器</li></ul><p>更多的内置变量可以参考<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">make官方手册</a>。</p><h2 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h2><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(CC),gcc)</span><br><span class="line">  libs=$(libs_for_gcc)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=$(normal_libs)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>上面代码判断当前编译器是否为gcc，然后指定不同的库文件。其中<code>ifeq</code>比较参数<code>arg1</code>和<code>arg2</code>是否相同，类似的，<code>ifneq</code>比较参数<code>arg1</code>和<code>arg2</code>是否不相同。</p><p>除此之外，还有<code>ifdef</code>判断变量是否被定义，<code>ifndef</code>判断变量是否没有被定义。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Makefile中还内置了许多函数，可供调用，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> arguments)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$&#123;function arguments&#125;</span></span><br></pre></td></tr></table></figure><p>常用的函数有：</p><ul><li><code>$(shell)</code>：用来执行shell命令</li><li><code>$(wildcard)</code>：用来在Makefile中，替换Bash的通配符。</li><li><code>$(patsubst)</code>：用于模式匹配的替换，语法为<code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></li><li><code>$(filter)</code>：</li><li><code>$(addsuffix)</code>：</li><li><code>$(addprefix)</code>：</li><li><code>$(if)</code>：</li><li><code>$(foreach)</code>：</li><li><code>$(call)</code>：唯一一个可以用来创建新的参数化的函数，语法为<code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</code>，值得注意的是，call函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而在向call函数提供参数时，最安全的做法是去除所有多余的空格，避免造成一些奇怪的效果。</li></ul><p>相关示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell函数用法</span></span><br><span class="line">contents := $(shell cat foo) <span class="comment"># 将foo文件中的内容赋值给contents</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call函数用法</span></span><br><span class="line">reverse =  $(2) $(1)</span><br><span class="line">foo = $(call reverse,a,b) <span class="comment"># 最终foo的值为b a</span></span><br></pre></td></tr></table></figure><p>更多的内置函数可以参考<a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">make官方手册</a></p><h2 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h2><p>在Makefile中可以使用<code>include</code>关键字把别的Makefile包含进来，这很像C语言的<code>#include</code>，被包含的文件会原模原样的放在当前文件的包含位置。<code>include</code>的语法是：<code>include &lt;filename&gt;</code>，其中被包含的Makefile文件通常以<code>.mk</code>结尾。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux中使用最广的构建工具是&lt;strong&gt;make&lt;/strong&gt;，而make会读取&lt;strong&gt;Makefile&lt;/strong&gt;文件中的配置信息来完成构建，一个简单的Makefile文件如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;editor : main.o text.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gcc -o editor main.o text.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;main.o : main.c def.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gcc -c main.c  &lt;span class=&quot;comment&quot;&gt;#-c参数指定生成.o文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;text.o : text.c com.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gcc -c text.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;install : editor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mv editor /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;具体而言，冒号前面为&lt;strong&gt;target&lt;/strong&gt;，即要生成的文件；冒号后面为&lt;strong&gt;dependencies&lt;/strong&gt;，即被依赖的文件；每一个&lt;strong&gt;target:dependencies对&lt;/strong&gt;的下一行为要执行的&lt;strong&gt;命令&lt;/strong&gt;（注意要以Tab键起首）。当make不带参数时，默认执行第一个target。target也可以是要求make要完成的动作，执行这种target后并不能得到和target同名的文件，因此，也称做&lt;strong&gt;phony target&lt;/strong&gt;（即伪target），如第7行所示。dependencies也可以为空，如常用的target为&lt;code&gt;clean&lt;/code&gt;时，就没有依赖，只有命令，一般用于清理工作。&lt;/p&gt;
&lt;p&gt;当输入&lt;code&gt;make&lt;/code&gt;或&lt;code&gt;make editor&lt;/code&gt;，即可开始构建。若&lt;code&gt;editor&lt;/code&gt;这个target文件不存在，或者&lt;code&gt;main.o&lt;/code&gt;、&lt;code&gt;text.o&lt;/code&gt;这两个依赖文件被修改，都会导致make调用其下的命令&lt;code&gt;gcc -o editor main.o text.o&lt;/code&gt;；接下来，由于引用到&lt;code&gt;main.o&lt;/code&gt;和&lt;code&gt;text.o&lt;/code&gt;，make会检查&lt;code&gt;main.o&lt;/code&gt;的依赖&lt;code&gt;main.c&lt;/code&gt;、&lt;code&gt;def.h&lt;/code&gt;有无更新，如果有，则执行其下的命令&lt;code&gt;gcc -c main.c&lt;/code&gt;；同理，也适用于&lt;code&gt;text.o&lt;/code&gt;。当输入&lt;code&gt;make install&lt;/code&gt;，make会检查install的依赖&lt;code&gt;editor&lt;/code&gt;是否是最新，如果是，则执行其下的命令&lt;code&gt;mv editor /usr/local&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>对比几种文件共享协议</title>
    <link href="https://howiezhao.github.io/2019/04/17/file-sharing-protocol/"/>
    <id>https://howiezhao.github.io/2019/04/17/file-sharing-protocol/</id>
    <published>2019-04-17T10:07:32.000Z</published>
    <updated>2021-02-05T11:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><p><strong>SMB</strong>全称Server Message Block（即服务器消息块），又称Common Internet File System（即网络文件共享系统），所以也常被缩写为<strong>SMB/CIFS</strong>。</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SMB&quot;&gt;&lt;a href=&quot;#SMB&quot; class=&quot;headerlink&quot; title=&quot;SMB&quot;&gt;&lt;/a&gt;SMB&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;SMB&lt;/strong&gt;全称Server Message Block（即服务器消息块），又称Common Inter</summary>
      
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>Android刷机指南</title>
    <link href="https://howiezhao.github.io/2019/03/23/android-shuaji-guide/"/>
    <id>https://howiezhao.github.io/2019/03/23/android-shuaji-guide/</id>
    <published>2019-03-23T03:42:58.000Z</published>
    <updated>2021-02-05T09:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="软重启与硬重启"><a href="#软重启与硬重启" class="headerlink" title="软重启与硬重启"></a>软重启与硬重启</h3><p><strong>软重启</strong>（又称<strong>热重启</strong>）是指从操作系统层面上关机再开机，而<strong>硬重启</strong>（又称<strong>冷重启</strong>）是指直接关掉电源再开机。类似的，也有<strong>软（热）关机</strong>和<strong>硬（冷）关机</strong>，其区别类似于在 Windows “开始”菜单中点击关机和直接关掉主机电源的区别。一般而言，软（热）关机对设备更好。</p><a id="more"></a><h3 id="Bootloader-fastboot-Recovery"><a href="#Bootloader-fastboot-Recovery" class="headerlink" title="Bootloader/fastboot/Recovery"></a>Bootloader/fastboot/Recovery</h3><h3 id="Full-OTA-Image-与-Factory-Image"><a href="#Full-OTA-Image-与-Factory-Image" class="headerlink" title="Full OTA Image 与 Factory Image"></a>Full OTA Image 与 Factory Image</h3><h2 id="刷机流程"><a href="#刷机流程" class="headerlink" title="刷机流程"></a>刷机流程</h2><ol><li>提前备份必要的数据（下载的音乐、视频，QQ、微信的聊天记录，通话记录、短信、通讯录，相册等），尽量保持电量满。</li><li>恢复出厂设置（亦或，取消所有安全机制，如屏幕锁定等，并退出 Google 账号。）。</li><li>在开发者选项中开启 USB 调试。</li><li>解锁 Bootloader（需要的话）。</li><li>刷入第三方 Recovery，如 <a href="https://twrp.me/">TWRP</a>。</li><li>从 TWRP 中安装第三方 ROM，顺便 root。</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="开机无限进入-TWRP"><a href="#开机无限进入-TWRP" class="headerlink" title="开机无限进入 TWRP"></a>开机无限进入 TWRP</h3><p>碰到这种情况，你可能需要格式化 Data 分区。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h2&gt;&lt;h3 id=&quot;软重启与硬重启&quot;&gt;&lt;a href=&quot;#软重启与硬重启&quot; class=&quot;headerlink&quot; title=&quot;软重启与硬重启&quot;&gt;&lt;/a&gt;软重启与硬重启&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;软重启&lt;/strong&gt;（又称&lt;strong&gt;热重启&lt;/strong&gt;）是指从操作系统层面上关机再开机，而&lt;strong&gt;硬重启&lt;/strong&gt;（又称&lt;strong&gt;冷重启&lt;/strong&gt;）是指直接关掉电源再开机。类似的，也有&lt;strong&gt;软（热）关机&lt;/strong&gt;和&lt;strong&gt;硬（冷）关机&lt;/strong&gt;，其区别类似于在 Windows “开始”菜单中点击关机和直接关掉主机电源的区别。一般而言，软（热）关机对设备更好。&lt;/p&gt;</summary>
    
    
    
    <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
    <category term="Android" scheme="https://howiezhao.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
