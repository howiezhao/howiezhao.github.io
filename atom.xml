<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Howie&#39;s Notes</title>
  
  <subtitle>Machine Learning and Cyber Security</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://howiezhao.github.io/"/>
  <updated>2020-05-31T12:01:21.000Z</updated>
  <id>https://howiezhao.github.io/</id>
  
  <author>
    <name>Howie Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于区块链的二三事</title>
    <link href="https://howiezhao.github.io/2020/02/06/about-blockchain/"/>
    <id>https://howiezhao.github.io/2020/02/06/about-blockchain/</id>
    <published>2020-02-06T13:57:17.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>YubiKey 使用指南</title>
    <link href="https://howiezhao.github.io/2020/02/06/yubikey-usage-guide/"/>
    <id>https://howiezhao.github.io/2020/02/06/yubikey-usage-guide/</id>
    <published>2020-02-06T13:53:38.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>PGP 与 GPG</title>
    <link href="https://howiezhao.github.io/2020/02/06/pgp-gpg/"/>
    <id>https://howiezhao.github.io/2020/02/06/pgp-gpg/</id>
    <published>2020-02-06T13:50:20.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>macOS 下的包管理器：Homebrew</title>
    <link href="https://howiezhao.github.io/2020/02/06/homebrew-for-macos/"/>
    <id>https://howiezhao.github.io/2020/02/06/homebrew-for-macos/</id>
    <published>2020-02-06T13:40:23.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>无线电基础</title>
    <link href="https://howiezhao.github.io/2020/01/22/radio-basics/"/>
    <id>https://howiezhao.github.io/2020/01/22/radio-basics/</id>
    <published>2020-01-22T12:32:56.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="频率、频段和频谱"><a href="#频率、频段和频谱" class="headerlink" title="频率、频段和频谱"></a>频率、频段和频谱</h2><p><a href="https://www.zhihu.com/question/20883383" target="_blank" rel="noopener">https://www.zhihu.com/question/20883383</a></p><h2 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h2><h2 id="分贝"><a href="#分贝" class="headerlink" title="分贝"></a>分贝</h2><h2 id="LNA和VGA"><a href="#LNA和VGA" class="headerlink" title="LNA和VGA"></a>LNA和VGA</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;频率、频段和频谱&quot;&gt;&lt;a href=&quot;#频率、频段和频谱&quot; class=&quot;headerlink&quot; title=&quot;频率、频段和频谱&quot;&gt;&lt;/a&gt;频率、频段和频谱&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/208833
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>HackRF 初体验</title>
    <link href="https://howiezhao.github.io/2020/01/22/hackrf/"/>
    <id>https://howiezhao.github.io/2020/01/22/hackrf/</id>
    <published>2020-01-22T12:25:55.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://greatscottgadgets.com/hackrf/" target="_blank" rel="noopener">HackRF</a> 是由 Great Scott Gadgets 设计和制造的开源 SDR 硬件，其可以发送或接收 1 MHz 到 6 GHz 的无线电信号。目前 HackRF 的具体版本为 HackRF One。你可以通过其<a href="https://greatscottgadgets.com/wheretobuy/" target="_blank" rel="noopener">官网上列出的购买网址</a>购买它，也可以在万能的淘宝上购买。<img src="https://greatscottgadgets.com/images/h1-preliminary1-445.jpeg" alt="HackRF One"></p><a id="more"></a><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>你需要安装如下软件以使用 HackRF One：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:bladerf/bladerf</span><br><span class="line">sudo add-apt-repository -y ppa:myriadrf/drivers</span><br><span class="line">sudo add-apt-repository -y ppa:myriadrf/gnuradio</span><br><span class="line">sudo add-apt-repository -y ppa:gqrx/gqrx-sdr</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install gqrx-sdr hackrf</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hackrf_info    # 查看 Hack RF 连接信息</span><br><span class="line"></span><br><span class="line">hackrf_transfer    # 基于文件进行发送和接收 SDR</span><br><span class="line">hackrf_transfer -h    # 查看 hackrf_transfer 帮助信息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 录制信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r：将数据存储到文件中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f：中心频率，单位 Hz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：采样率，单位 Hz（4/8/10/12.5/16/20 MHz，默认 10 MHz）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n：采样数量（默认值是无限的）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：设置功放（1 表示开启，0 表示关闭）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g：设置 Rx VGA 增益（0 到 62 dB 之间，每次增加 2 dB）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l：设置 Rx LNA 增益（0 到 40 dB 之间，每次增加 8 dB）</span></span><br><span class="line">hackrf_transfer -r capture.raw -f 315000000 -l 8/16/24 -g 20/40 [-s 2000000 -n 10000000 -a 1]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重放信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t：从文件中读取数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x：设置 Tx VGA 增益（0 到 47 dB 之间，每次增加 1 dB）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -R：重复发送模式（默认为关闭）</span></span><br><span class="line">hackrf_transfer -t capture.raw -f 315000000 -x 40 [-s 2000000 -a 1]</span><br></pre></td></tr></table></figure><p>一般无线钥匙工作频段都在 315 Mhz、433.92 Mhz。<br>Tx Mode：发射模式<br>Rx Mode：接收模式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://greatscottgadgets.com/hackrf/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HackRF&lt;/a&gt; 是由 Great Scott Gadgets 设计和制造的开源 SDR 硬件，其可以发送或接收 1 MHz 到 6 GHz 的无线电信号。目前 HackRF 的具体版本为 HackRF One。你可以通过其&lt;a href=&quot;https://greatscottgadgets.com/wheretobuy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网上列出的购买网址&lt;/a&gt;购买它，也可以在万能的淘宝上购买。&lt;img src=&quot;https://greatscottgadgets.com/images/h1-preliminary1-445.jpeg&quot; alt=&quot;HackRF One&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 Sphinx 生成项目文档</title>
    <link href="https://howiezhao.github.io/2020/01/22/sphinx-document/"/>
    <id>https://howiezhao.github.io/2020/01/22/sphinx-document/</id>
    <published>2020-01-22T12:21:54.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.sphinx-doc.org/en/master/" target="_blank" rel="noopener">Sphinx</a> 是一个用 Python 编写的文档生成工具，其使用 <a href="https://howiezhao.github.io/2018/09/17/restructuredtext/">reStructuredText</a> 作为标记语言，目前广泛应用于 Python 相关项目的文档生成。比如 <a href="https://docs.python.org/zh-cn/3/" target="_blank" rel="noopener">Python 官方文档</a>就是基于 Sphinx 生成的，此外 <a href="https://www.kernel.org/doc/html/latest/index.html" target="_blank" rel="noopener">Linux 内核文档</a>的生成也于 2016 年从 <a href="http://www.doxygen.nl/" target="_blank" rel="noopener">Doxygen</a> 转向 Sphinx，要了解更多使用 Sphinx 的项目可参考其<a href="https://www.sphinx-doc.org/en/master/examples.html" target="_blank" rel="noopener">官方列表</a>。</p><a id="more"></a><p>使用 <code>pip install sphinx</code> 即可安装 Sphinx。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>按照最佳实践，项目文档一般是在项目的 <code>docs</code> 目录中，所以不妨先创建一个 <code>docs</code> 目录并进入，之后的一切有关 sphinx 的命令都在此目录中运行。</p><p>安装完 Sphinx 并进入 <code>docs</code> 目录后，输入 <code>sphinx-quickstart</code> 即可创建一个文档项目。该引导程序会询问你一些问题，并根据你给出的回答对生成的文档项目进行相关配置，当然，这些配置都可以在生成后的 <code>conf.py</code> 文件中进行重新设置。以下是它可能会问到的一些问题：</p><ul><li>分隔“source”和“build”目录（y/n）[n]：默认不分隔即可</li><li>项目名称：项目名称将显示在左侧导航栏顶部</li><li>作者姓名：作者姓名将显示在页面底部</li><li>项目版本：可不填</li><li>项目语言[en]：默认为英文，要切换为中文请输入 <code>zh_CN</code></li></ul><p>执行完成后，会在当前目录下生成如下文件/文件夹：</p><ul><li><code>_duild/</code>：存放构建之后的文件</li><li><code>_static/</code>：存放静态文件</li><li><code>_templates/</code>：存放模板文件</li><li><code>conf.py</code>：sphinx 的配置文件</li><li><code>index.rst</code>：文档主页</li><li><code>Makefile</code>：Linux 下 <code>make</code> 构建工具的配置文件</li><li><code>make.bat</code>：Windows 下的构建命令脚本</li></ul><p>编写完文档后，使用 <code>make html</code> 命令即可将其构建为 HTML 文件，其中，<code>html</code> 被称为构建器（builder），当然，你也可以使用别的构建器，比如 <code>latex</code>、<code>epub</code> 等。</p><p>输入 <code>make help</code> 可查看 make 支持的相关命令。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Sphinx 生成的 HTML 文件默认使用的主题为 <a href="https://github.com/bitprophet/alabaster" target="_blank" rel="noopener">Alabaster</a>（个人觉得挺好看的，<a href="https://cn.python-requests.org/zh_CN/latest/" target="_blank" rel="noopener">Request</a> 和 <a href="https://flask.palletsprojects.com/en/1.1.x/" target="_blank" rel="noopener">Flask</a> 项目文档的主题都是基于此主题修改的），除此之外，Sphinx 还内置了一些别的主题，具体可见其<a href="https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes" target="_blank" rel="noopener">官方文档中列出的</a>（个人觉得其余的主题不如 Alabaster 好看），当然，你也可以使用第三方主题。</p><p>第三方主题中最常见的非 <a href="https://github.com/readthedocs/sphinx_rtd_theme" target="_blank" rel="noopener">sphinx_rtd_theme</a> 莫属，<a href="https://docs.scrapy.org/en/latest/" target="_blank" rel="noopener">Scrapy</a> 项目的文档就使用的它，要使用 sphinx_rtd_theme，需要先执行 <code>pip install sphinx_rtd_theme</code> 命令下载它，然后修改 <code>conf.py</code> 配置文件中的 <code>html_theme</code> 变量为 <code>‘sphinx_rtd_theme’</code> 并在 <code>extensions</code> 列表中添加 <code>&#39;sphinx_rtd_theme&#39;</code>。</p><p>要探索更多的第三方主题，可参考 <a href="https://sphinx-themes.org/" target="_blank" rel="noopener">Sphinx Themes</a> 网站上收录的。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Sphinx 支持扩展，安装完 Sphinx 后就已经内置了一些扩展，除此之外，你也可以下载第三方扩展。</p><h3 id="内置扩展"><a href="#内置扩展" class="headerlink" title="内置扩展"></a>内置扩展</h3><h4 id="sphinx-ext-autodoc"><a href="#sphinx-ext-autodoc" class="headerlink" title="sphinx.ext.autodoc"></a>sphinx.ext.autodoc</h4><h4 id="sphinx-ext-coverage"><a href="#sphinx-ext-coverage" class="headerlink" title="sphinx.ext.coverage"></a>sphinx.ext.coverage</h4><h4 id="sphinx-ext-viewcode"><a href="#sphinx-ext-viewcode" class="headerlink" title="sphinx.ext.viewcode"></a>sphinx.ext.viewcode</h4><h4 id="sphinx-ext-napoleon"><a href="#sphinx-ext-napoleon" class="headerlink" title="sphinx.ext.napoleon"></a>sphinx.ext.napoleon</h4><h4 id="sphinx-ext-graphviz"><a href="#sphinx-ext-graphviz" class="headerlink" title="sphinx.ext.graphviz"></a>sphinx.ext.graphviz</h4><h4 id="sphinx-ext-todo"><a href="#sphinx-ext-todo" class="headerlink" title="sphinx.ext.todo"></a>sphinx.ext.todo</h4><h3 id="第三方扩展"><a href="#第三方扩展" class="headerlink" title="第三方扩展"></a>第三方扩展</h3><h4 id="recommonmark"><a href="#recommonmark" class="headerlink" title="recommonmark"></a>recommonmark</h4><h4 id="nbsphinx"><a href="#nbsphinx" class="headerlink" title="nbsphinx"></a>nbsphinx</h4><h4 id="sphinx-autodoc-typehints"><a href="#sphinx-autodoc-typehints" class="headerlink" title="sphinx-autodoc-typehints"></a>sphinx-autodoc-typehints</h4><h4 id="sphinx-gallery"><a href="#sphinx-gallery" class="headerlink" title="sphinx-gallery"></a>sphinx-gallery</h4><h2 id="Read-the-Docs"><a href="#Read-the-Docs" class="headerlink" title="Read the Docs"></a>Read the Docs</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.sphinx-doc.org/en/master/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sphinx&lt;/a&gt; 是一个用 Python 编写的文档生成工具，其使用 &lt;a href=&quot;https://howiezhao.github.io/2018/09/17/restructuredtext/&quot;&gt;reStructuredText&lt;/a&gt; 作为标记语言，目前广泛应用于 Python 相关项目的文档生成。比如 &lt;a href=&quot;https://docs.python.org/zh-cn/3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python 官方文档&lt;/a&gt;就是基于 Sphinx 生成的，此外 &lt;a href=&quot;https://www.kernel.org/doc/html/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux 内核文档&lt;/a&gt;的生成也于 2016 年从 &lt;a href=&quot;http://www.doxygen.nl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Doxygen&lt;/a&gt; 转向 Sphinx，要了解更多使用 Sphinx 的项目可参考其&lt;a href=&quot;https://www.sphinx-doc.org/en/master/examples.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方列表&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>Proxmark 入坑指南</title>
    <link href="https://howiezhao.github.io/2019/12/01/proxmark/"/>
    <id>https://howiezhao.github.io/2019/12/01/proxmark/</id>
    <published>2019-12-01T05:37:30.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Proxmark 是 RFID 界的瑞士军刀，请注意，其官网为 <a href="http://www.proxmark.org/" target="_blank" rel="noopener">proxmark.org</a>，其他的如 <a href="https://proxmark.com/" target="_blank" rel="noopener">proxmark.com</a>、<a href="https://www.proxmark3.com/" target="_blank" rel="noopener">proxmark3.com</a> 等，均为第三方商业网站，目前的最新硬件版本是 Proxmark 3。</p><a id="more"></a><h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><ul><li>Proxmark 3：这是 Proxmark 3 的原始版本，现已过时，不建议购买，产品图如下：</li></ul><p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/05.proxmark-3/PM3-Trans.png" alt="Proxmark 3"></p><ul><li>Proxmark 3 RDV 2：这是 Proxmark 3 的一次升级，又称为 Revision Two（修订第二版），产品图如下：</li></ul><p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/03.proxmark-3-rdv-2/PM3-RDV2-Trans.png" alt="Proxmark 3 RDV 2"></p><ul><li>Proxmark 3 Easy：这是 Proxmark 3 RDV 2 的廉价版本，专门通过淘宝在中国销售，也是目前淘宝上主要的 Proxmark 3 版本，产品图如下：</li></ul><p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/04.proxmark-3-easy/PM3-Easy-Trans.png" alt="Proxmark 3 Easy"></p><ul><li>Proxmark 3 EVO：这是 Proxmark 3 RDV 2 的一次进化，又称为 Evolution（进化），产品图如下：</li></ul><p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/02.proxmark-3-evo/PM3-Evo-Trans.png" alt="Proxmark 3 EVO"></p><ul><li>Proxmark 3 RDV 4：这是 Proxmark 3 的最新升级版本，产品图如下：</li></ul><p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/01.proxmark-3-rdv4/PM3-RDV4-Trans.png" alt="Proxmark 3 RDV 4"></p><h2 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h2><p>Proxmark 只有 2 个官方分销商：<a href="https://lab401.com/" target="_blank" rel="noopener">Lab401</a> 和 <a href="https://hackerwarehouse.com/" target="_blank" rel="noopener">Hacker Warehouse</a>，当然，你也可以从万能的淘宝上购买。</p><p>请注意，淘宝上的版本号并不规范，据我所知，淘宝上的大部分产品都是基于 Proxmark 3 Easy 的国内再次改造版，比如，它们所谓的<strong>“一体机”</strong>实际上是 Proxmark 3 Easy 和 <a href="https://github.com/iceman1001/ChameleonMini-rebooted" target="_blank" rel="noopener">ChameleonMini（变色龙）</a>的合体版。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Proxmark 是 RFID 界的瑞士军刀，请注意，其官网为 &lt;a href=&quot;http://www.proxmark.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proxmark.org&lt;/a&gt;，其他的如 &lt;a href=&quot;https://proxmark.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proxmark.com&lt;/a&gt;、&lt;a href=&quot;https://www.proxmark3.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;proxmark3.com&lt;/a&gt; 等，均为第三方商业网站，目前的最新硬件版本是 Proxmark 3。&lt;/p&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="硬件" scheme="https://howiezhao.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Scheme的五法十诫</title>
    <link href="https://howiezhao.github.io/2019/08/07/scheme-commandments-and-laws/"/>
    <id>https://howiezhao.github.io/2019/08/07/scheme-commandments-and-laws/</id>
    <published>2019-08-07T13:42:23.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>节选自《The Little Schemer》</p><h2 id="Scheme-五法"><a href="#Scheme-五法" class="headerlink" title="Scheme 五法"></a>Scheme 五法</h2><h3 id="Scheme-五法之第一法-——-car-之法则"><a href="#Scheme-五法之第一法-——-car-之法则" class="headerlink" title="Scheme 五法之第一法 —— car 之法则"></a>Scheme 五法之第一法 —— car 之法则</h3><p>基本元件 <em>car</em> 仅定义为针对非空列表。</p><h3 id="Scheme-五法之第二法-——-cdr-之法则"><a href="#Scheme-五法之第二法-——-cdr-之法则" class="headerlink" title="Scheme 五法之第二法 —— cdr 之法则"></a>Scheme 五法之第二法 —— cdr 之法则</h3><p>基本元件 <em>cdr</em> 仅定义为针对非空列表。任意非空列表的 <em>cdr</em> 总是另一个列表。</p><h3 id="Scheme-五法之第三法-——-cons-之法则"><a href="#Scheme-五法之第三法-——-cons-之法则" class="headerlink" title="Scheme 五法之第三法 —— cons 之法则"></a>Scheme 五法之第三法 —— cons 之法则</h3><p>基本元件 <em>cons</em> 需要两个参数。第二个参数必须是一个列表。结果是一个列表。</p><h3 id="Scheme-五法之第四法-——-Null-之法则"><a href="#Scheme-五法之第四法-——-Null-之法则" class="headerlink" title="Scheme 五法之第四法 —— Null? 之法则"></a>Scheme 五法之第四法 —— Null? 之法则</h3><p>基本元件 <em>null?</em> 仅定义为针对列表。</p><h3 id="Scheme-五法之第五法-——-eq-之法则"><a href="#Scheme-五法之第五法-——-eq-之法则" class="headerlink" title="Scheme 五法之第五法 —— eq? 之法则"></a>Scheme 五法之第五法 —— eq? 之法则</h3><p>基本元件 <em>eq?</em> 需要两个参数。每个参数都必须是一个非数字的原子。<br><a id="more"></a></p><h2 id="Scheme十诫"><a href="#Scheme十诫" class="headerlink" title="Scheme十诫"></a>Scheme十诫</h2><h3 id="第一诫"><a href="#第一诫" class="headerlink" title="第一诫"></a>第一诫</h3><p>当对一个原子列表 <em>lat</em> 进行递归调用时，询问两个有关 <em>lat</em> 的问题：<em>(null? lat)</em> 和 <strong>else</strong>。</p><p>当对一个数字 <em>n</em> 进行递归调用时，询问两个有关 <em>n</em> 的问题：<em>(zero? n)</em> 和 <strong>else</strong>。</p><p>当对一个S-表达式列表 <em>l</em> 进行递归调用时，询问三个有关 <em>l</em> 的问题：<em>(null? lat)</em>、<em>(atom? (car l))</em> 和 <strong>else</strong>。</p><h3 id="第二诫"><a href="#第二诫" class="headerlink" title="第二诫"></a>第二诫</h3><p>使用 <em>cons</em> 来构建列表。</p><h3 id="第三诫"><a href="#第三诫" class="headerlink" title="第三诫"></a>第三诫</h3><p>构建一个列表的时候，描述第一个典型元素，之后 <em>cons</em> 该元素到一般性递归（natural recursion）上。</p><h3 id="第四诫"><a href="#第四诫" class="headerlink" title="第四诫"></a>第四诫</h3><p>在递归时总是改变至少一个参数。当对一个原子列表 <em>lat</em> 进行递归调用时，使用 <em>(cdr lat)</em>。当对数字 <em>n</em> 进行递归调用时，使用 <em>(sub1 n)</em>。当对一个S-表达式 <em>l</em> 进行递归调用时，只要是 <em>(null? l)</em> 和 <em>(atom? (car l))</em> 都不为 true，那么就同时使用 <em>(car l)</em> 和 <em>(cdr l)</em>。</p><p>在递归时改变的参数，必须向着不断接近结束条件而改变。改变的参数必须在结束条件中得以测试：<br>    当使用 <em>cdr</em> 时，用 <em>null?</em> 测试是否结束；<br>    当使用 <em>sub1</em> 时,用 <em>zero?</em> 测试是否结束。</p><h3 id="第五诫"><a href="#第五诫" class="headerlink" title="第五诫"></a>第五诫</h3><p>当用 ➕ 构建一个值时，总是使用 0 作为结束代码行的值，因为加上 0 不会改变加法的值。</p><p>当用 ✖ 构建一个值时，总是使用 1 作为结柬代码行的值，因为乘以 1 不会改变乘法的值。</p><p>当用 <em>cons</em> 构建一个值时，总是考虑把 0 作为结束代码行的值。</p><h3 id="第六诫"><a href="#第六诫" class="headerlink" title="第六诫"></a>第六诫</h3><p>简化工作只在功能正确之后开展。</p><h3 id="第七诫"><a href="#第七诫" class="headerlink" title="第七诫"></a>第七诫</h3><p>对具有相同性质的 <em>subparts</em>（子部件）进行递归调用：</p><ul><li>列表的子列表。</li><li>算术表达式的子表达式。</li></ul><h3 id="第八诫"><a href="#第八诫" class="headerlink" title="第八诫"></a>第八诫</h3><p>使用辅助函数来抽象表示方式。</p><h3 id="第九诫"><a href="#第九诫" class="headerlink" title="第九诫"></a>第九诫</h3><p>用函数来抽象通用模式。</p><h3 id="第十诫"><a href="#第十诫" class="headerlink" title="第十诫"></a>第十诫</h3><p>构建函数,一次收集多个值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;节选自《The Little Schemer》&lt;/p&gt;
&lt;h2 id=&quot;Scheme-五法&quot;&gt;&lt;a href=&quot;#Scheme-五法&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法&quot;&gt;&lt;/a&gt;Scheme 五法&lt;/h2&gt;&lt;h3 id=&quot;Scheme-五法之第一法-——-car-之法则&quot;&gt;&lt;a href=&quot;#Scheme-五法之第一法-——-car-之法则&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法之第一法 —— car 之法则&quot;&gt;&lt;/a&gt;Scheme 五法之第一法 —— car 之法则&lt;/h3&gt;&lt;p&gt;基本元件 &lt;em&gt;car&lt;/em&gt; 仅定义为针对非空列表。&lt;/p&gt;
&lt;h3 id=&quot;Scheme-五法之第二法-——-cdr-之法则&quot;&gt;&lt;a href=&quot;#Scheme-五法之第二法-——-cdr-之法则&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法之第二法 —— cdr 之法则&quot;&gt;&lt;/a&gt;Scheme 五法之第二法 —— cdr 之法则&lt;/h3&gt;&lt;p&gt;基本元件 &lt;em&gt;cdr&lt;/em&gt; 仅定义为针对非空列表。任意非空列表的 &lt;em&gt;cdr&lt;/em&gt; 总是另一个列表。&lt;/p&gt;
&lt;h3 id=&quot;Scheme-五法之第三法-——-cons-之法则&quot;&gt;&lt;a href=&quot;#Scheme-五法之第三法-——-cons-之法则&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法之第三法 —— cons 之法则&quot;&gt;&lt;/a&gt;Scheme 五法之第三法 —— cons 之法则&lt;/h3&gt;&lt;p&gt;基本元件 &lt;em&gt;cons&lt;/em&gt; 需要两个参数。第二个参数必须是一个列表。结果是一个列表。&lt;/p&gt;
&lt;h3 id=&quot;Scheme-五法之第四法-——-Null-之法则&quot;&gt;&lt;a href=&quot;#Scheme-五法之第四法-——-Null-之法则&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法之第四法 —— Null? 之法则&quot;&gt;&lt;/a&gt;Scheme 五法之第四法 —— Null? 之法则&lt;/h3&gt;&lt;p&gt;基本元件 &lt;em&gt;null?&lt;/em&gt; 仅定义为针对列表。&lt;/p&gt;
&lt;h3 id=&quot;Scheme-五法之第五法-——-eq-之法则&quot;&gt;&lt;a href=&quot;#Scheme-五法之第五法-——-eq-之法则&quot; class=&quot;headerlink&quot; title=&quot;Scheme 五法之第五法 —— eq? 之法则&quot;&gt;&lt;/a&gt;Scheme 五法之第五法 —— eq? 之法则&lt;/h3&gt;&lt;p&gt;基本元件 &lt;em&gt;eq?&lt;/em&gt; 需要两个参数。每个参数都必须是一个非数字的原子。&lt;br&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://howiezhao.github.io/categories/Notes/"/>
    
    
      <category term="函数式编程" scheme="https://howiezhao.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ADB小记</title>
    <link href="https://howiezhao.github.io/2019/07/29/adb/"/>
    <id>https://howiezhao.github.io/2019/07/29/adb/</id>
    <published>2019-07-29T04:56:04.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="error-device-still-connecting"><a href="#error-device-still-connecting" class="headerlink" title="error: device still connecting"></a>error: device still connecting</h3><p>输入<code>adb shell</code>时显示<code>error: device still connecting</code>，一般可通过：关闭<strong>开发者模式</strong>然后重新打开<strong>开发者模式</strong>，接着开启<strong>USB调试</strong>并重新和电脑配对，即可解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;相关问题&quot;&gt;&lt;a href=&quot;#相关问题&quot; class=&quot;headerlink&quot; title=&quot;相关问题&quot;&gt;&lt;/a&gt;相关问题&lt;/h2&gt;&lt;h3 id=&quot;error-device-still-connecting&quot;&gt;&lt;a href=&quot;#error-device-sti
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Android" scheme="https://howiezhao.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>关于 Windows 的代理设置</title>
    <link href="https://howiezhao.github.io/2019/07/29/about-the-proxy-settings-for-windows/"/>
    <id>https://howiezhao.github.io/2019/07/29/about-the-proxy-settings-for-windows/</id>
    <published>2019-07-29T04:21:18.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Windows 的<strong>系统代理</strong>使用的其实是 <strong>IE 的代理设置</strong>，此外，对于<strong>绝大多数</strong>的应用程序而言，它们默认使用的也是 IE 的代理设置，比如，Chrome、Firefox、Microsoft Store 等。因此，如果想让绝大多数的应用程序使用代理，一个简单的方法是直接设置 IE 的代理（即系统代理）。不过，对于一小部分没有使用 IE 代理设置的应用程序，比如 Android Studio 等，你可能需要单独设置它们的代理（一般在软件的设置项中）。</p><p>值得注意的是，同为应用程序的 <strong>Shell</strong>（包括<strong>命令提示符</strong>和 <strong>PowerShell</strong>）就没有使用 IE 的代理设置，它们各自有自己的代理设置。具体而言，要为命令提示符设置代理，可使用如下两条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set HTTP_PROXY=http://user:password@proxy.domain.com:port</span><br><span class="line">set HTTPS_PROXY=https://user:password@proxy.domain.com:port</span><br></pre></td></tr></table></figure></p><p>而要为 PowerShell 设置代理则要使用<a href>这个脚本</a>。</p><p>最后，对于 Shell 中运行的程序，有一部分使用的是 IE 的代理设置，比如 <code>pip</code>、<code>git</code>、<code>npm</code> 等，另一部分则使用的是 Shell 的代理设置，比如 <code>curl</code>、<code>gem</code> 等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Windows 的&lt;strong&gt;系统代理&lt;/strong&gt;使用的其实是 &lt;strong&gt;IE 的代理设置&lt;/strong&gt;，此外，对于&lt;strong&gt;绝大多数&lt;/strong&gt;的应用程序而言，它们默认使用的也是 IE 的代理设置，比如，Chrome、Firefox、Mic
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Windows" scheme="https://howiezhao.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Nexus/Pixel相关问题解决</title>
    <link href="https://howiezhao.github.io/2019/07/21/nexus-pixel-problem/"/>
    <id>https://howiezhao.github.io/2019/07/21/nexus-pixel-problem/</id>
    <published>2019-07-21T02:15:55.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动网络-Wifi出现叹号或叉号"><a href="#移动网络-Wifi出现叹号或叉号" class="headerlink" title="移动网络/Wifi出现叹号或叉号"></a>移动网络/Wifi出现叹号或叉号</h2><p>Captive Portal是从Android 5开始引入的一项新功能，其主要用于检测网络连接是否正常，当用户连接网络后，系统会通过HTTP访问一个Google的服务器，若返回200状态码，则表示用户可能处在一个需要登录认证的网络环境中；若返回204状态码，则表示网络连接正常；若连接超时，则表示网络连接不正常，此时网络图标会显示一个叹号或叉号。</p><p>显然，Google的服务器是连接不上的，我们可以通过修改服务器地址来解决此问题。具体而言，连接ADB，针对不同的系统版本，下方分别给出了相关命令：</p><p>Android 9.0/8.1/8.0/7.1.2/7.1.1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204</span><br></pre></td></tr></table></figure></p><p>Android 7.1/7.0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings delete global captive_portal_server  </span><br><span class="line">adb shell settings put global captive_portal_detection_enabled 0</span><br></pre></td></tr></table></figure></p><p>Android 5.0-6.x：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global captive_portal_server www.google.cn</span><br></pre></td></tr></table></figure></p><p>执行之后，开启飞行模式，接着关闭飞行模式即可。<br><a id="more"></a></p><h2 id="搜索不到WiFi"><a href="#搜索不到WiFi" class="headerlink" title="搜索不到WiFi"></a>搜索不到WiFi</h2><p>因为美国2.4GHz频段的WiFi信道为1-11，而中国2.4GHz频段的WiFi信道为1-13，所以当2.4GHz频段的WiFi信道位于12或13时，美版的Nexus/Pixel会搜索不到WiFi，此时可通过重启路由器，使其自动更换信道，或进入路由器设置页面，将信道改为11以内任意信道即可。</p><h2 id="4G信号问题"><a href="#4G信号问题" class="headerlink" title="4G信号问题"></a>4G信号问题</h2><p>由于联通的网络制式一直采用的是国际通用的网络制式，所以Nexus/Pixel可以完美支持联通2G/3G/4G。</p><p>移动的3G网络制式采用的是自主研发的技术，所以Nexus/Pixel并不支持移动3G，然而移动4G网络制式采用的是自主研发和国际通用并行的方式，所以Nexus/Pixel只支持部分移动4G频段。</p><p>简单来说，Nexus/Pixel完美支持联通2G/3G/4G，支持移动2G，不支持移动3G，部分支持移动4G（具体表现为在城市有4G网络，在农村没有4G网络），电信2G/3G/4G可通过破解（本文不讨论这点）实现支持。</p><h2 id="Google（即负一屏）无法使用"><a href="#Google（即负一屏）无法使用" class="headerlink" title="Google（即负一屏）无法使用"></a>Google（即负一屏）无法使用</h2><h2 id="接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）"><a href="#接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）" class="headerlink" title="接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）"></a>接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）</h2><p>严格来说，这不算是Nexus/Pixel特有的问题，究其原因是距离感应器坏了，可通过设置使用电源键挂断电话，具体方法为在<strong>设置</strong> —&gt; <strong>辅助功能/无障碍</strong>中开启<strong>按电源按钮结束通话</strong>。</p><h2 id="蓝牙传输失败，显示不支持此内容"><a href="#蓝牙传输失败，显示不支持此内容" class="headerlink" title="蓝牙传输失败，显示不支持此内容"></a>蓝牙传输失败，显示不支持此内容</h2><p>由于版权问题，原生Android不支持传输以<code>.apk</code>结尾的文件，可通过将其改为<code>.jpg</code>结尾传输。</p><h2 id="Google-Play商店更新应用卡住"><a href="#Google-Play商店更新应用卡住" class="headerlink" title="Google Play商店更新应用卡住"></a>Google Play商店更新应用卡住</h2><p>在Android 9.0之前，Play商店是通过<strong>下载管理器</strong>下载应用的，出现这种情况可以直接将<strong>下载管理器</strong>强行停止，然后重新启动Play商店即可更新应用。在Android 9.0之后，可直接将Play商店强行停止再重新启动即可。</p><h2 id="系统无法更新"><a href="#系统无法更新" class="headerlink" title="系统无法更新"></a>系统无法更新</h2><p>具体表现为<strong>系统更新</strong>处永远显示<strong>正在安装系统更新</strong>，一般来说，这是由于网络原因引起的，目前并没有一个稳定的解决办法，建议直接下载新系统镜像并线刷。你可以在<a href="https://developers.google.cn/android/images" target="_blank" rel="noopener">这个官方地址</a>找到有关Nexus/Pixel的所有出厂镜像，其中也附带有详细的安装方法。</p><p>具体而言，你需要先解锁Bootloader，然后连接ADB，紧接着执行<code>adb reboot bootloader</code>进入fastboot模式，最后执行相应系统的<code>flash-all</code>脚本即可。</p><h2 id="Pixel-Pixel-XL-Verizon版解锁Bootloader教程"><a href="#Pixel-Pixel-XL-Verizon版解锁Bootloader教程" class="headerlink" title="Pixel/Pixel XL Verizon版解锁Bootloader教程"></a>Pixel/Pixel XL Verizon版解锁Bootloader教程</h2><p>教程来源自xda上的一篇<a href="https://www.xda-developers.com/unlock-bootloader-verizon-google-pixel-xl/" target="_blank" rel="noopener">文章</a>，具体步骤如下：</p><ol><li>从您的设备中删除Google帐户和任何类型的屏幕锁定（指纹，PIN，图案等）。</li><li>从您的设备中取出SIM卡。</li><li>重置您的设备。在设置向导中，跳过所有内容，不要连接到WiFi，不要添加指纹或任何类型的屏幕锁定。</li><li>转到开发人员选项并启用USB调试。</li><li>将手机连接到PC。</li><li>在adb目录中打开CMD并输入：<code>adb shell pm uninstall --user 0 com.android.phone</code></li><li>重启您的设备。</li><li>连接到WiFi，打开Chrome并转到google.com（或任何网站）。</li><li>转到开发人员选项并启用OEM解锁。</li><li>重启到bootloader并通过CMD运行：<code>fastboot oem unlock</code>或<code>fastboot flashing unlock</code>。</li><li>完成。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;移动网络-Wifi出现叹号或叉号&quot;&gt;&lt;a href=&quot;#移动网络-Wifi出现叹号或叉号&quot; class=&quot;headerlink&quot; title=&quot;移动网络/Wifi出现叹号或叉号&quot;&gt;&lt;/a&gt;移动网络/Wifi出现叹号或叉号&lt;/h2&gt;&lt;p&gt;Captive Portal是从Android 5开始引入的一项新功能，其主要用于检测网络连接是否正常，当用户连接网络后，系统会通过HTTP访问一个Google的服务器，若返回200状态码，则表示用户可能处在一个需要登录认证的网络环境中；若返回204状态码，则表示网络连接正常；若连接超时，则表示网络连接不正常，此时网络图标会显示一个叹号或叉号。&lt;/p&gt;
&lt;p&gt;显然，Google的服务器是连接不上的，我们可以通过修改服务器地址来解决此问题。具体而言，连接ADB，针对不同的系统版本，下方分别给出了相关命令：&lt;/p&gt;
&lt;p&gt;Android 9.0/8.1/8.0/7.1.2/7.1.1：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Android 7.1/7.0：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adb shell settings delete global captive_portal_server  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;adb shell settings put global captive_portal_detection_enabled 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Android 5.0-6.x：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adb shell settings put global captive_portal_server www.google.cn&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行之后，开启飞行模式，接着关闭飞行模式即可。&lt;br&gt;
    
    </summary>
    
      <category term="Bug" scheme="https://howiezhao.github.io/categories/Bug/"/>
    
    
      <category term="Android" scheme="https://howiezhao.github.io/tags/Android/"/>
    
      <category term="硬件" scheme="https://howiezhao.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>GCC小记</title>
    <link href="https://howiezhao.github.io/2019/04/18/gcc/"/>
    <id>https://howiezhao.github.io/2019/04/18/gcc/</id>
    <published>2019-04-18T09:42:24.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>GCC一般有两层意思，大的意思是指GNU Compiler Collection（即GNU编译器套装），小的意思是指GNU C Compiler（即GNU C语言编译器），在本文中，我默认大写的GCC指大的意思，小写的gcc指小的意思。</p><p>使用gcc编译C语言源代码的一般格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>Linux下<code>gcc</code>命令常见的参数及其含义如下所示：</p><ul><li><code>--help</code>：显示帮助信息</li><li><code>-o</code>：指定生成的文件名，若不指定，则默认生成a.out</li><li><code>-E</code>：生成<code>.i</code>格式的预处理文件</li><li><code>-S</code>：生成<code>.s</code>格式的汇编文件</li><li><code>-c</code>：生成<code>.o</code>格式的二进制文件</li><li><code>-save-temps</code>：保留所有生成的中间文件</li><li><code>-g</code>：生成必要的符号信息，为调试而用</li><li><code>-ggdb</code>：生成可特供于gdb使用的调试信息</li><li><code>-gstabs</code>：生成stabs格式的调试信息</li><li><code>-Wall</code>：显示所有常用的警告信息，即Warning all</li><li><code>-m32</code>：指定生成32位程序</li><li><code>-Os</code>：为减小代码大小而进行优化，即Optimizers small</li><li><code>-nostdinc</code>：不使用标准库</li><li><code>-fno-stack-protector</code>：不生成用于检测缓冲区溢出的代码</li><li><code>-I&lt;dir&gt;</code>：添加搜索头文件的路径</li><li><code>-fno-builtin</code>：除非用<code>__builtin_</code>前缀，否则不进行<code>builtin</code>函数的优化</li></ul><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>为了在Windows中使用GCC，诞生了<a href="http://www.mingw.org/" target="_blank" rel="noopener"><strong>MinGW</strong></a> 项目，即Minimalist GNU for Windows(适用于Windows的极简GNU)，它是将GCC编译器和GNU Binutils移植到Win32平台下的产物，又被称为mingw32。另有可用于产生32位及64位Windows可执行文件的<a href="https://mingw-w64.org/doku.php/start" target="_blank" rel="noopener"><strong>MinGW-w64</strong></a>项目，是从原MinGW项目产生的分支。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GCC一般有两层意思，大的意思是指GNU Compiler Collection（即GNU编译器套装），小的意思是指GNU C Compiler（即GNU C语言编译器），在本文中，我默认大写的GCC指大的意思，小写的gcc指小的意思。&lt;/p&gt;
&lt;p&gt;使用gcc编译C语言源代码的一般格式如下：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ gcc test.c -o &lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>QEMU小记</title>
    <link href="https://howiezhao.github.io/2019/04/18/qemu/"/>
    <id>https://howiezhao.github.io/2019/04/18/qemu/</id>
    <published>2019-04-18T09:17:11.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.qemu.org/" target="_blank" rel="noopener">QEMU</a>是Linux中使用最广的虚拟机，其便于调试的特性也适合于系统开发者。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用<code>sudo apt install qemu</code>即可在Ubuntu中安装QEMU，安装完成后直接输入<code>qemu</code>来验证是否成功安装，如果出错，可再输入<code>qemu-system-i386</code>来验证其是否成功安装，若成功，可建立如下所示的软链接，以方便日后使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu</span><br></pre></td></tr></table></figure></p><p>值得注意的是，QEMU的启动需要有图形界面，若未安装图形界面，则会报错：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not initialize SDL(No available video device) - exiting</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>使用QEMU运行一个虚拟机的命令格式为<code>qemu [options] [disk_image]</code>，其中disk_image即硬盘镜像文件。其常用的参数如下：</p><ul><li><code>-hda file</code>：使用file作为硬盘0的镜像文件。</li><li><code>-m megs</code>：设定虚拟内存为megs M字节，默认为128M字节。</li><li><code>-smp n</code>：设置为有n个CPU的SMP系统。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.qemu.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QEMU&lt;/a&gt;是Linux中使用最广的虚拟机，其便于调试的特性也适合于系统开发者。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;sudo apt install qemu&lt;/code&gt;即可在Ubuntu中安装QEMU，安装完成后直接输入&lt;code&gt;qemu&lt;/code&gt;来验证是否成功安装，如果出错，可再输入&lt;code&gt;qemu-system-i386&lt;/code&gt;来验证其是否成功安装，若成功，可建立如下所示的软链接，以方便日后使用。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是，QEMU的启动需要有图形界面，若未安装图形界面，则会报错：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Could not initialize SDL(No available video device) - exiting&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Makefile小记</title>
    <link href="https://howiezhao.github.io/2019/04/18/makefile/"/>
    <id>https://howiezhao.github.io/2019/04/18/makefile/</id>
    <published>2019-04-18T04:40:39.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中使用最广的构建工具是<strong>make</strong>，而make会读取<strong>Makefile</strong>文件中的配置信息来完成构建，一个简单的Makefile文件如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">editor : main.o text.o</span><br><span class="line">    gcc -o editor main.o text.o</span><br><span class="line">main.o : main.c def.h</span><br><span class="line">    gcc -c main.c  <span class="comment">#-c参数指定生成.o文件</span></span><br><span class="line">text.o : text.c com.h</span><br><span class="line">    gcc -c text.c</span><br><span class="line">install : editor</span><br><span class="line">    mv editor /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure></p><p>具体而言，冒号前面为<strong>target</strong>，即要生成的文件；冒号后面为<strong>dependencies</strong>，即被依赖的文件；每一个<strong>target:dependencies对</strong>的下一行为要执行的<strong>命令</strong>（注意要以Tab键起首）。当make不带参数时，默认执行第一个target。target也可以是要求make要完成的动作，执行这种target后并不能得到和target同名的文件，因此，也称做<strong>phony target</strong>（即伪target），如第7行所示。dependencies也可以为空，如常用的target为<code>clean</code>时，就没有依赖，只有命令，一般用于清理工作。</p><p>当输入<code>make</code>或<code>make editor</code>，即可开始构建。若<code>editor</code>这个target文件不存在，或者<code>main.o</code>、<code>text.o</code>这两个依赖文件被修改，都会导致make调用其下的命令<code>gcc -o editor main.o text.o</code>；接下来，由于引用到<code>main.o</code>和<code>text.o</code>，make会检查<code>main.o</code>的依赖<code>main.c</code>、<code>def.h</code>有无更新，如果有，则执行其下的命令<code>gcc -c main.c</code>；同理，也适用于<code>text.o</code>。当输入<code>make install</code>，make会检查install的依赖<code>editor</code>是否是最新，如果是，则执行其下的命令<code>mv editor /usr/local</code>。<br><a id="more"></a></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Makefile中以<code>#</code>开头的均为注释。</p><h2 id="回声"><a href="#回声" class="headerlink" title="回声"></a>回声</h2><p>正常情况下，make会打印每条命令，然后再执行，这就叫做<strong>回声</strong>。在命令的前面加上<code>@</code>，就可以关闭回声。由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上<code>@</code>。</p><h2 id="内置目标名"><a href="#内置目标名" class="headerlink" title="内置目标名"></a>内置目标名</h2><p><strong>内置目标名</strong>指示了如果某些名称作为target（目标名）出现，则具有特殊含义，常用的如下所示：</p><ul><li><code>.PHONY</code>：明确声明伪目标</li><li><code>.SUFFIXES</code>：消除默认后缀规则</li><li><code>.DELETE_ON_ERROR</code>：如果遇到错误（或make中断）则删除目标文件</li></ul><p>更多的内置目标名可以参考<a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets" target="_blank" rel="noopener">make官方手册</a>。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Makefile中也可以使用变量，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TXT = Hello World</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    <span class="built_in">echo</span> $(TXT)</span><br></pre></td></tr></table></figure></p><p>这类似于C语言中的宏，按照传统，变量名一般大写，使用变量时要放在<code>$()</code>之中。</p><p>有时，变量的值可能指向另一个变量，比如：<code>V1 = $(V2)</code>，这时会出现一个问题，V1的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果V2的值是动态变化的，这两种扩展方式的结果可能会差异很大。为了解决类似问题，Makefile一共提供了四个赋值运算符，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在运行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure></p><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><p>Makefile提供了一系列的内置变量，常见的如下所示：</p><ul><li><code>$(CC)</code>：指向当前使用的编译器</li></ul><p>更多的内置变量可以参考<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html" target="_blank" rel="noopener">make官方手册</a>。</p><h2 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h2><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(CC),gcc)</span><br><span class="line">  libs=$(libs_for_gcc)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=$(normal_libs)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure></p><p>上面代码判断当前编译器是否为gcc，然后指定不同的库文件。其中<code>ifeq</code>比较参数<code>arg1</code>和<code>arg2</code>是否相同，类似的，<code>ifneq</code>比较参数<code>arg1</code>和<code>arg2</code>是否不相同。</p><p>除此之外，还有<code>ifdef</code>判断变量是否被定义，<code>ifndef</code>判断变量是否没有被定义。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Makefile中还内置了许多函数，可供调用，格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> arguments)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$&#123;function arguments&#125;</span></span><br></pre></td></tr></table></figure></p><p>常用的函数有：</p><ul><li><code>$(shell)</code>：用来执行shell命令</li><li><code>$(wildcard)</code>：用来在Makefile中，替换Bash的通配符。</li><li><code>$(patsubst)</code>：用于模式匹配的替换，语法为<code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></li><li><code>$(filter)</code>：</li><li><code>$(addsuffix)</code>：</li><li><code>$(addprefix)</code>：</li><li><code>$(if)</code>：</li><li><code>$(foreach)</code>：</li><li><code>$(call)</code>：唯一一个可以用来创建新的参数化的函数，语法为<code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</code>，值得注意的是，call函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而在向call函数提供参数时，最安全的做法是去除所有多余的空格，避免造成一些奇怪的效果。</li></ul><p>相关示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell函数用法</span></span><br><span class="line">contents := $(shell cat foo) <span class="comment"># 将foo文件中的内容赋值给contents</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call函数用法</span></span><br><span class="line">reverse =  $(2) $(1)</span><br><span class="line">foo = $(call reverse,a,b) <span class="comment"># 最终foo的值为b a</span></span><br></pre></td></tr></table></figure></p><p>更多的内置函数可以参考<a href="https://www.gnu.org/software/make/manual/html_node/Functions.html" target="_blank" rel="noopener">make官方手册</a></p><h2 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h2><p>在Makefile中可以使用<code>include</code>关键字把别的Makefile包含进来，这很像C语言的<code>#include</code>，被包含的文件会原模原样的放在当前文件的包含位置。<code>include</code>的语法是：<code>include &lt;filename&gt;</code>，其中被包含的Makefile文件通常以<code>.mk</code>结尾。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux中使用最广的构建工具是&lt;strong&gt;make&lt;/strong&gt;，而make会读取&lt;strong&gt;Makefile&lt;/strong&gt;文件中的配置信息来完成构建，一个简单的Makefile文件如下所示：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;editor : main.o text.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gcc -o editor main.o text.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;main.o : main.c def.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gcc -c main.c  &lt;span class=&quot;comment&quot;&gt;#-c参数指定生成.o文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;text.o : text.c com.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gcc -c text.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;install : editor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mv editor /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;具体而言，冒号前面为&lt;strong&gt;target&lt;/strong&gt;，即要生成的文件；冒号后面为&lt;strong&gt;dependencies&lt;/strong&gt;，即被依赖的文件；每一个&lt;strong&gt;target:dependencies对&lt;/strong&gt;的下一行为要执行的&lt;strong&gt;命令&lt;/strong&gt;（注意要以Tab键起首）。当make不带参数时，默认执行第一个target。target也可以是要求make要完成的动作，执行这种target后并不能得到和target同名的文件，因此，也称做&lt;strong&gt;phony target&lt;/strong&gt;（即伪target），如第7行所示。dependencies也可以为空，如常用的target为&lt;code&gt;clean&lt;/code&gt;时，就没有依赖，只有命令，一般用于清理工作。&lt;/p&gt;
&lt;p&gt;当输入&lt;code&gt;make&lt;/code&gt;或&lt;code&gt;make editor&lt;/code&gt;，即可开始构建。若&lt;code&gt;editor&lt;/code&gt;这个target文件不存在，或者&lt;code&gt;main.o&lt;/code&gt;、&lt;code&gt;text.o&lt;/code&gt;这两个依赖文件被修改，都会导致make调用其下的命令&lt;code&gt;gcc -o editor main.o text.o&lt;/code&gt;；接下来，由于引用到&lt;code&gt;main.o&lt;/code&gt;和&lt;code&gt;text.o&lt;/code&gt;，make会检查&lt;code&gt;main.o&lt;/code&gt;的依赖&lt;code&gt;main.c&lt;/code&gt;、&lt;code&gt;def.h&lt;/code&gt;有无更新，如果有，则执行其下的命令&lt;code&gt;gcc -c main.c&lt;/code&gt;；同理，也适用于&lt;code&gt;text.o&lt;/code&gt;。当输入&lt;code&gt;make install&lt;/code&gt;，make会检查install的依赖&lt;code&gt;editor&lt;/code&gt;是否是最新，如果是，则执行其下的命令&lt;code&gt;mv editor /usr/local&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>对比几种文件共享协议</title>
    <link href="https://howiezhao.github.io/2019/04/17/file-sharing-protocol/"/>
    <id>https://howiezhao.github.io/2019/04/17/file-sharing-protocol/</id>
    <published>2019-04-17T10:07:32.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><p><strong>SMB</strong>全称Server Message Block（即服务器消息块），又称Common Internet File System（即网络文件共享系统），所以也常被缩写为<strong>SMB/CIFS</strong>。</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SMB&quot;&gt;&lt;a href=&quot;#SMB&quot; class=&quot;headerlink&quot; title=&quot;SMB&quot;&gt;&lt;/a&gt;SMB&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;SMB&lt;/strong&gt;全称Server Message Block（即服务器消息块），又称Common Inter
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>Android刷机指南</title>
    <link href="https://howiezhao.github.io/2019/03/23/android-shuaji-guide/"/>
    <id>https://howiezhao.github.io/2019/03/23/android-shuaji-guide/</id>
    <published>2019-03-23T03:42:58.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="软重启与硬重启"><a href="#软重启与硬重启" class="headerlink" title="软重启与硬重启"></a>软重启与硬重启</h3><p><strong>软重启</strong>（又称<strong>热重启</strong>）是指从操作系统层面上关机再开机，而<strong>硬重启</strong>（又称<strong>冷重启</strong>）是指直接关掉电源再开机。类似的，也有<strong>软（热）关机</strong>和<strong>硬（冷）关机</strong>，其区别类似于在Windows“开始”菜单中点击关机和直接关掉主机电源的区别。一般而言，软（热）关机对设备更好。<br><a id="more"></a></p><h3 id="Bootloader-fastboot-Recovery"><a href="#Bootloader-fastboot-Recovery" class="headerlink" title="Bootloader/fastboot/Recovery"></a>Bootloader/fastboot/Recovery</h3><h3 id="Full-OTA-Image与Factory-Image"><a href="#Full-OTA-Image与Factory-Image" class="headerlink" title="Full OTA Image与Factory Image"></a>Full OTA Image与Factory Image</h3><h2 id="刷机流程"><a href="#刷机流程" class="headerlink" title="刷机流程"></a>刷机流程</h2><ol><li>提前备份必要的数据（下载的音乐、视频，QQ、微信的聊天记录，通话记录、短信、通讯录，相册等），尽量保持电量满。</li><li>恢复出厂设置（亦或，取消所有安全机制，如屏幕锁定等，并退出Google账号。）。</li><li>在开发者选项中开启USB调试。</li><li>解锁Bootloader（需要的话）。</li><li>刷入第三方Recovery，如TWRP。<a href="https://twrp.me/" target="_blank" rel="noopener">https://twrp.me/</a></li><li>从TWRP中安装第三方ROM，顺便root。</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="开机无限进入TWRP"><a href="#开机无限进入TWRP" class="headerlink" title="开机无限进入TWRP"></a>开机无限进入TWRP</h3><p>碰到这种情况，你可能需要格式化Data分区。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h2&gt;&lt;h3 id=&quot;软重启与硬重启&quot;&gt;&lt;a href=&quot;#软重启与硬重启&quot; class=&quot;headerlink&quot; title=&quot;软重启与硬重启&quot;&gt;&lt;/a&gt;软重启与硬重启&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;软重启&lt;/strong&gt;（又称&lt;strong&gt;热重启&lt;/strong&gt;）是指从操作系统层面上关机再开机，而&lt;strong&gt;硬重启&lt;/strong&gt;（又称&lt;strong&gt;冷重启&lt;/strong&gt;）是指直接关掉电源再开机。类似的，也有&lt;strong&gt;软（热）关机&lt;/strong&gt;和&lt;strong&gt;硬（冷）关机&lt;/strong&gt;，其区别类似于在Windows“开始”菜单中点击关机和直接关掉主机电源的区别。一般而言，软（热）关机对设备更好。&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Android" scheme="https://howiezhao.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言小记</title>
    <link href="https://howiezhao.github.io/2019/03/09/assembly/"/>
    <id>https://howiezhao.github.io/2019/03/09/assembly/</id>
    <published>2019-03-09T09:41:13.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>汇编语言</strong>（Assembly Language，简称<strong>ASM</strong>）由<strong>汇编指令</strong>、<strong>伪指令</strong>和<strong>其他符号</strong>组成，其中汇编指令有对应的机器码，而伪指令和其他符号没有对应的机器码，仅由汇编器识别执行。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>汇编语言是依赖底层CPU架构的，不同的CPU架构拥有不同的汇编语言，比如，常用于PC的<strong>x86汇编</strong>和常用于嵌入式设备的<strong>ARM汇编</strong>。由于x86架构又分为16位、32位、64位等，其相应的汇编也有稍许不同。本文主要以32位x86汇编为例做简要介绍。<br><a id="more"></a></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>汇编语言的大部分指令都是直接操作CPU中的寄存器的，所以有必要了解以下x86架构的CPU中常见的寄存器。</p><p>16位x86CPU中常见的寄存器有：</p><ul><li>通用寄存器（<strong>8个</strong>）：<ul><li>数据寄存器：<ul><li>AX：累加寄存器，Accumulator</li><li>BX：基址寄存器，Base</li><li>CX：计数寄存器，Count</li><li>DX：数据寄存器，Data</li></ul></li><li>指针寄存器：<ul><li>SP：堆栈指针寄存器，Stack Pointer</li><li>BP：基址指针寄存器，Base Pointer</li></ul></li><li>变址寄存器：<ul><li>SI：源变址寄存器，Source Index</li><li>DI：目的变址寄存器，Destinatin Index</li></ul></li></ul></li><li>段寄存器：<ul><li>CS：代码段寄存器，Code Segment</li><li>DS：数据段寄存器，Data Segment</li><li>SS：堆栈段寄存器，Stack Segment</li><li>ES：附加段寄存器，Extra Segment</li></ul></li><li>控制寄存器：<ul><li>IP：指令指针寄存器，Instruction Pointer</li><li>FLAGS：标志寄存器</li></ul></li></ul><p>为了保证兼容性，AX、BX、CX、DX这四个寄存器都可分为两个可独立使用的8位寄存器来用，如AX可分为<strong>AH</strong>和<strong>AL</strong>，其中AH代表高（High）8位，AL代表低（Low）8位，其他3个也是如此。</p><p>32位x86CPU在16位的基础上增加了一些寄存器，那些和原来作用相同的寄存器一般会在前面加上<code>E</code>，其中常见的寄存器有：</p><ul><li>通用寄存器（<strong>8个</strong>）：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI</li><li>段寄存器：CS、DS、SS、ES、FS、GS，增加的FS、GS和ES一样，属于附加段寄存器</li><li>指令指针寄存器：EIP</li><li>标志寄存器：EFLAGS</li><li>系统表寄存器：GDTR、LDTR、IDTR、TR</li><li>控制寄存器：CR0、CR1、CR2、CR3、CR4</li><li>调试寄存器：DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7</li><li>测试寄存器：TR0、TR1、TR2、TR3、TR4、TR5、TR6、TR7</li></ul><p>类似的，64位又在32位的基础上增加了一些寄存器，那些和原来作用相同的寄存器一般会将前面的<code>E</code>改为<code>R</code>，其中常见的寄存器有：</p><ul><li>通用寄存器（<strong>16个</strong>）：RAX、RBX、RCX、RDX、RSP、RBP、RSI、RDI、R8、R9、R10、R11、R12、R13、R14、R15</li><li>指令指针寄存器：RIP</li><li>标志寄存器：RFLAGS</li></ul><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>常见的汇编指令如下：</p><ul><li><code>mov</code>：传送指令，两个操作对象的位数应该一致，如<code>mov eax,ebx</code>，表示将EBX的值送入EAX中。8086CPU不支持将数据直接送入段寄存器的操作，要想实现此功能，只能用一个寄存器来进行中转。</li><li><code>add</code>：加法指令，两个操作对象的位数应该一致，如<code>add eax,ebx</code>，表示将EAX和EBX相加，其值赋给EAX。</li><li><code>sub</code>：减法指令，如<code>sub eax,ebx</code>，表示用EAX减EBX，其值赋给EAX。</li><li><code>push</code>：</li><li><code>pop</code>：</li><li><code>jmp</code>：跳转指令，属于转移指令，如<code>jmp 2AE3:3</code>，表示将CS设为2AE3H，将IP设为0003H，CPU将从CS:IP（即2AE33H）处读取指令；<code>jmp eax</code>表示将EAX的值赋给IP，CS保持不变。</li><li><code>jnz</code>：条件跳转指令，检查EFLAGS标志寄存器中的ZF位（零标志位）是否为0，若不为0，则跳转。</li><li><code>jz</code>：条件跳转指令，检查EFLAGS标志寄存器中的ZF位（零标志位）是否为0，若为0，则跳转。</li><li><code>in</code>：从I/O端口读取内容，如<code>in al,21H</code>，表示从21H端口读取内容到AL中。</li><li><code>out</code>：向I/O端口写入内容，如<code>out 21H,al</code>，表示将AL的值写入到21H端口中。</li><li><code>xor</code>：按位异或运算，即相同为0，不同为1，如<code>xor eax,ebx</code>，表示将EAX和EBX按位异或，其值赋给EAX。对同一个值进行异或，会使其得0，汇编中常用这种方法得到0，如<code>xor eax,eax</code>。</li><li><code>or</code>：按位或运算，如<code>or eax,ebx</code>，表示将EAX和EBX按位或，其值赋给EAX。</li></ul><p>注意：汇编指令和寄存器名称不区分大小写。</p><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>伪指令依赖于具体的汇编器，这里我们以GNU中的as汇编器（gas）为例，讲述常见的伪指令及其含义：</p><ul><li><code>.set</code>：为变量设置一个值，如<code>.set CR0_PE_ON, 0x1</code>。</li><li><code>.globl</code>或<code>.global</code>：设置外部链接，使其在其他文件中可被调用，如<code>.globl start</code>。</li><li><code>.code16</code>：生成16位汇编代码。</li><li><code>.code32</code>：生成32位汇编代码。</li><li><code>.p2align</code>：</li><li><code>.word</code>：</li><li><code>.long</code>：</li></ul><p>想要了解更多的伪指令可以参考<a href="https://sourceware.org/binutils/docs/as/Pseudo-Ops.html#Pseudo-Ops" target="_blank" rel="noopener">gas的官方文档</a>。</p><h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><p>标号代表一个地址，类似于高级语言中的函数，在需要时可以使用跳转指令跳转到标号处执行，利用标号还可以实现死循环，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spin:</span><br><span class="line">    jmp spin</span><br></pre></td></tr></table></figure></p><h2 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h2><p>x86汇编语言的两大风格分别是<strong>Intel风格</strong>和<strong>AT&amp;T风格</strong>，分别被Microsoft和GNU所采用，两种风格的详细区别如下表所示：</p><table><thead><tr><th>项目</th><th>Intel风格</th><th>AT&amp;T风格</th></tr></thead><tbody><tr><td>操作数顺序</td><td>目标操作数在前，如<code>mov eax,8</code></td><td>源操作数在前，如<code>movl $8,%eax</code></td></tr><tr><td>寄存器名字</td><td>原样，如<code>mov eax,8</code></td><td>加<code>%</code>前缀，如<code>movl $8,%eax</code></td></tr><tr><td>立即数</td><td>原样，如<code>mov eax,8</code></td><td>加<code>$</code>前缀，如<code>movl $8,%eax</code></td></tr><tr><td>16进制立即数</td><td>用后缀<code>b</code>与<code>h</code>分别表示二进制与十六进制，对于16进制字母开头的要加前缀<code>0</code></td><td>加前缀<code>0x</code></td></tr><tr><td>访问内存长度的表示</td><td>前缀<code>byte ptr</code>，<code>word ptr</code>，<code>dword ptr</code></td><td>后缀<code>b</code>、<code>w</code>、<code>l</code>表示字节、字、长型</td></tr><tr><td>引用全局或静态变量var的值</td><td>[_var]</td><td>_var</td></tr><tr><td>引用全局或静态变量var的地址</td><td>_var</td><td>$_var</td></tr><tr><td>寄存器间址</td><td>[reg]</td><td>(%reg)</td></tr><tr><td>寄存器变址寻址</td><td>[reg + _x]</td><td>_x(%reg)</td></tr><tr><td>立即数变址寻址</td><td>[reg + 1]</td><td>1(%reg)</td></tr><tr><td>整数数组寻址</td><td>[eax*4 + array]</td><td>_array (,%eax, 4)</td></tr><tr><td>注释</td><td>:注释以英文分号开头</td><td>#注释以井号开头</td></tr></tbody></table><p>本文的书写风格以Intel风格为主。</p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>内联汇编（Inline Assembly）是指在C代码中嵌入汇编代码，显然，其语法是由具体的C编译器所决定的，这里主要以GNU中的gcc编译器为例简述其语法。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>要了解汇编语言更多的知识，可以阅读王爽的<a href="https://book.douban.com/subject/25726019/" target="_blank" rel="noopener">《汇编语言》</a>一书，这本书基于16位的8086CPU来讲解汇编，虽然处理器已过时，但思想永不褪色。</p><p>其次，<a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html" target="_blank" rel="noopener">Linux汇编语言开发指南</a>，也是一篇不错的介绍文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;汇编语言&lt;/strong&gt;（Assembly Language，简称&lt;strong&gt;ASM&lt;/strong&gt;）由&lt;strong&gt;汇编指令&lt;/strong&gt;、&lt;strong&gt;伪指令&lt;/strong&gt;和&lt;strong&gt;其他符号&lt;/strong&gt;组成，其中汇编指令有对应的机器码，而伪指令和其他符号没有对应的机器码，仅由汇编器识别执行。&lt;/p&gt;
&lt;h2 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h2&gt;&lt;p&gt;汇编语言是依赖底层CPU架构的，不同的CPU架构拥有不同的汇编语言，比如，常用于PC的&lt;strong&gt;x86汇编&lt;/strong&gt;和常用于嵌入式设备的&lt;strong&gt;ARM汇编&lt;/strong&gt;。由于x86架构又分为16位、32位、64位等，其相应的汇编也有稍许不同。本文主要以32位x86汇编为例做简要介绍。&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>成为黑客高手的必备技能</title>
    <link href="https://howiezhao.github.io/2019/02/25/hacker-essential-skills/"/>
    <id>https://howiezhao.github.io/2019/02/25/hacker-essential-skills/</id>
    <published>2019-02-25T12:39:30.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自<a href="https://null-byte.wonderhowto.com/how-to/essential-skills-becoming-master-hacker-0154509/" target="_blank" rel="noopener">https://null-byte.wonderhowto.com/how-to/essential-skills-becoming-master-hacker-0154509/</a> ，正文如下：</p><p>我的许多有抱负的黑客写信给我，都问同样的问题。“我需要什么技能才能成为一个好的黑客？”</p><p>由于黑客是最熟练的信息技术学科之一，因此需要广泛的IT技术和技术知识。要真正成为一名优秀的黑客，必须掌握许多技能。如果你没有我在此列出的所有技能，请不要气馁，可以将此列表作为你在不久的将来学习和掌握所需内容的起点。<br><a id="more"></a><br><img src="https://img.wonderhowto.com/img/original/78/70/63533756748235/0/635337567482357870.jpg" alt><br>这是我进入这个精英IT行业的万神殿所需技能的概述列表。我将这些技能分为三类，以帮助你从一个级别转到另一个级别，更容易掌握基本技能、中级技能和无形技能，并提供了指向Null Byte相关文章的链接，供你了解。</p><h2 id="基本技能"><a href="#基本技能" class="headerlink" title="基本技能"></a>基本技能</h2><p>这些是每个黑客在尝试破解之前应该知道的基础知识。一旦掌握了本节中的所有内容，就可以进入中间层。</p><h3 id="基本的计算机技能"><a href="#基本的计算机技能" class="headerlink" title="基本的计算机技能"></a>基本的计算机技能</h3><p>不用说，要成为一名黑客，你需要一些基本的计算机技能。这些技能超出了创建Word文档或浏览Internet的能力。你需要能够在Windows中使用命令行，编辑注册表以及设置网络参数。</p><p>许多这些基本技能可以在像A+这样的基础计算机技能课程中获得。</p><h3 id="网络技能"><a href="#网络技能" class="headerlink" title="网络技能"></a>网络技能</h3><p>你需要了解网络的基础知识，例如以下内容。</p><ul><li>DHCP</li><li>NAT</li><li>子网划分</li><li>IPv4</li><li>IPv6</li><li>公有和私有IP</li><li>DNS</li><li>路由器和交换机</li><li>VLANs</li><li>OSI模型</li><li>MAC寻址</li><li>ARP</li></ul><p>由于我们经常利用这些技术，你越了解它们的工作方式，你就会越成功。请注意，我没有编写下面的两个指南，但它们非常有用，并涵盖了上面提到的一些网络基础知识。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/hacker-fundamentals-tale-two-standards-0133727/" target="_blank" rel="noopener">黑客基础：两个标准的故事</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hacker-fundamentals-everymans-guide-network-packets-are-routed-across-web-0134491/" target="_blank" rel="noopener">一般人的网络数据包路由指南</a></li></ul><h3 id="Linux技能"><a href="#Linux技能" class="headerlink" title="Linux技能"></a>Linux技能</h3><p>发展Linux技能对于成为黑客是非常关键的。我们用作黑客的几乎所有工具都是为Linux开发的，Linux为我们提供了使用Windows时没有的功能。</p><p>如果你需要提高你的Linux技能，或者你刚开始使用Linux，请查看下面我的Linux初学者系列。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/linux-basics/" target="_blank" rel="noopener">针对有抱负的黑客的Linux基础知识</a></li></ul><h3 id="Wireshark或Tcpdump"><a href="#Wireshark或Tcpdump" class="headerlink" title="Wireshark或Tcpdump"></a>Wireshark或Tcpdump</h3><p>Wireshark是使用最广泛的嗅探器/协议分析器，而tcpdump是命令行嗅探器/协议分析器。两者在分析TCP/IP流量和攻击方面都非常有用。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/spy-your-buddys-network-traffic-intro-wireshark-and-osi-model-0133807/" target="_blank" rel="noopener">Wireshark和OSI模型介绍</a></li><li><a href="https://null-byte.wonderhowto.com/news/8-wireshark-filters-every-wiretapper-uses-spy-web-conversations-and-surfing-habits-0134508/" target="_blank" rel="noopener">Wireshark过滤器</a></li></ul><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>你需要熟练使用其中一个虚拟化软件包，如<a href="https://www.virtualbox.org/" target="_blank" rel="noopener">VirtualBox</a>或<a href="https://www.vmware.com/products/workstation-pro.html" target="_blank" rel="noopener">VMWare Workstation</a>。理想情况下，你需要一个安全的环境来练习你的黑客攻击行为，之后才能将它们带出现实世界。虚拟环境为你提供了一个安全的环境，可以在使用它们之前测试和优化你的黑客攻击。</p><h3 id="安全概念与技术"><a href="#安全概念与技术" class="headerlink" title="安全概念与技术"></a>安全概念与技术</h3><p>优秀的黑客了解安全概念和技术。克服安全管理员建立的障碍的唯一方法是熟悉它们。黑客必须了解诸如PKI（公钥基础架构），SSL（安全套接层），IDS（入侵检测系统），防火墙等等。</p><p>黑客初学者可以在Security+等基本安全课程中获得许多这些技能。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/snort/" target="_blank" rel="noopener">如何读写Snort规则来躲避IDS</a></li></ul><h3 id="无线技术"><a href="#无线技术" class="headerlink" title="无线技术"></a>无线技术</h3><p>为了能够破解无线，你必须首先了解它的工作原理。诸如加密算法（WEP，WPA，WPA2），四次握手和WPS之类的东西。此外，理解诸如连接和认证协议以及无线技术的法律约束等。</p><p>要开始学习，请查看以下有关无线术语和技术入门的指南，然后阅读我们的Wi-Fi黑客指南集，了解有关各种加密算法的详细信息以及每种黑客如何工作的示例。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/hack-wi-fi-getting-started-with-terms-technologies-0147659/" target="_blank" rel="noopener">Wi-Fi术语和技术入门</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/wi-fi-hacking/" target="_blank" rel="noopener">有抱负的黑客入侵Wi-Fi指南</a></li></ul><h2 id="中级技能"><a href="#中级技能" class="headerlink" title="中级技能"></a>中级技能</h2><p>这是事情变得有趣的地方，你真正开始感受到你作为黑客的能力。知道所有这些将允许你进入更直观的黑客攻击所有镜头 - 而不是其他一些黑客。</p><h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>如果没有<a href="https://null-byte.wonderhowto.com/how-to/scripting/" target="_blank" rel="noopener">编写脚本的技能</a>，黑客将被降级为使用其他黑客工具。这限制了你的效率。每天都会有一个新工具失效，因为安全管理员提出了防御措施。</p><p>要开发自己独特的工具，你需要至少熟练掌握一种脚本语言，包括BASH shell。这些应该包括Perl，Python或Ruby之一。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-perl-scripting-for-aspiring-hacker-part-1-0151750/" target="_blank" rel="noopener">针对有抱负的黑客的Perl脚本</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-scripting-for-aspiring-hacker-part-1-bash-basics-0149422/" target="_blank" rel="noopener">为有抱负的黑客编写脚本，第1部分：BASH基础知识</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-scripting-for-aspiring-hacker-part-2-conditional-statements-0149695/" target="_blank" rel="noopener">为有抱负的黑客编写脚本，第2部分：条件语句</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-scripting-for-aspiring-hacker-part-3-windows-powershell-0151075/" target="_blank" rel="noopener">为有抱负的黑客编写脚本，第3部分：Windows PowerShell</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-ultimate-list-hacking-scripts-for-metasploits-meterpreter-0149339/" target="_blank" rel="noopener">Metasploit中Meterpreter的黑客脚本终极列表</a></li></ul><h3 id="数据库技能"><a href="#数据库技能" class="headerlink" title="数据库技能"></a>数据库技能</h3><p>如果你希望能够熟练地<a href="https://null-byte.wonderhowto.com/how-to/db-hacking/" target="_blank" rel="noopener">破解数据库</a>，则需要了解数据库及其工作原理。这包括SQL语言。我还建议掌握一个主要的DBMS，如SQL Server，Oracle或MySQL。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-terms-technologies-you-need-know-before-getting-started-0148773/" target="_blank" rel="noopener">入门前需要了解的术语和技术</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-hunting-for-microsofts-sql-server-0148993/" target="_blank" rel="noopener">寻找微软的SQL Server</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-cracking-sql-server-passwords-owning-server-0149636/" target="_blank" rel="noopener">破解SQL Server密码并拥有服务器</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-hacking-mysql-online-databases-with-sqlmap-0150368/" target="_blank" rel="noopener">使用Sqlmap攻击MySQL在线数据库</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-extracting-data-from-online-databases-using-sqlmap-0150688/" target="_blank" rel="noopener">使用Sqlmap从在线数据库中提取数据</a></li></ul><h3 id="Web应用程序"><a href="#Web应用程序" class="headerlink" title="Web应用程序"></a>Web应用程序</h3><p>Web应用程序可能是近年来黑客最肥沃的土壤。你对Web应用程序如何工作以及它们背后的数据库了解得越多，你就会越成功。此外，你可能需要建立自己的网站以进行网络钓鱼和其他恶意目的。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-clone-any-website-using-httrack-0152420/" target="_blank" rel="noopener">如何使用HTTrack克隆任何网站</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-spoof-dns-lan-redirect-traffic-your-fake-website-0151620/" target="_blank" rel="noopener">如何将流量重定向到假网站</a></li></ul><h3 id="取证"><a href="#取证" class="headerlink" title="取证"></a>取证</h3><p>要成为好黑客，一定不要被抓住！你不能成为一名坐在牢房里5年的职业黑客。你对数字取证的了解越多，就越能避免和规避检测。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-1-tools-techniques-0149732/" target="_blank" rel="noopener">数字取证，第1部分：工具和技术</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-2-network-forensics-0149958/" target="_blank" rel="noopener">数字取证，第2部分：网络取证</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-3-recovering-deleted-files-0149868/" target="_blank" rel="noopener">数字取证，第3部分：恢复已删除的文件</a></li><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-4-evading-detection-while-dosing-0150445/" target="_blank" rel="noopener">数字取证，第4部分：DoSing时的逃避检测</a></li></ul><h3 id="高级TCP-IP"><a href="#高级TCP-IP" class="headerlink" title="高级TCP/IP"></a>高级TCP/IP</h3><p>黑客初学者必须了解TCP/IP基础知识，但要升级到中级，你必须了解TCP/IP协议栈和字段的详细信息。这些包括TCP和IP数据包中的每个字段（flags，window，df，tos，seq，ack等）如何被操纵并用于对抗受害者系统以启用中间人攻击等。</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>虽然要成为一个好的黑客不需要成为一个密码学家，但是你越了解每种密码算法的优缺点，就越有可能打败它。此外，黑客还可以利用密码学来隐藏他们的活动并逃避检测。</p><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>通过逆向工程，你可以打开一个恶意软件并使用其他功能重新构建它。就像在软件工程中一样，没有人从头开始构建新的应用程序。几乎每个新漏洞或恶意软件都使用其他现有恶意软件中的组件。</p><p>此外，逆向工程使黑客能够利用现有漏洞并更改其签名，以便它可以绕过IDS和<a href="https://null-byte.wonderhowto.com/how-to/evading-av-software/" target="_blank" rel="noopener">防病毒检测</a>。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-change-signature-metasploit-payloads-evade-antivirus-detection-0149867/" target="_blank" rel="noopener">如何更改Metasploit有效载荷签名以避免防病毒检测</a></li></ul><h2 id="无形技能"><a href="#无形技能" class="headerlink" title="无形技能"></a>无形技能</h2><p>除了所有这些计算机技能外，成功的黑客还必须具备一些无形技能。这些包括以下内容。</p><h3 id="创造性地思考"><a href="#创造性地思考" class="headerlink" title="创造性地思考"></a>创造性地思考</h3><p>黑客攻击系统总是有办法的，而且有很多方法可以实现。一个好的黑客可以创造性地思考同一个黑客的多种方法。</p><ul><li><a href="https://null-byte.wonderhowto.com/how-to/social-engineering/" target="_blank" rel="noopener">Null Byte的社会工程学指南</a></li><li><a href="https://null-byte.wonderhowto.com/forum/cryptolocker-innovative-creative-hack-0151753/" target="_blank" rel="noopener">CryptoLocker：一个创新和创造性的黑客</a></li></ul><h3 id="解决问题的能力"><a href="#解决问题的能力" class="headerlink" title="解决问题的能力"></a>解决问题的能力</h3><p>黑客总是遇到看似无法解决的问题。这就要求黑客习惯于分析性思维和解决问题。这通常要求黑客准确地诊断出问题所在，然后将问题分解为不同的组件。这是伴随着许多小时的练习而来的能力之一。</p><ul><li><a href="https://null-byte.wonderhowto.com/forum/problem-solving-is-essential-hacker-skill-0150882/" target="_blank" rel="noopener">解决问题是一项必不可少的黑客技能</a></li></ul><h3 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h3><p>黑客必须坚持不懈。如果你一开始失败了，请再试一次。如果再失败，请提出一种新的方法并重试。只有坚持不懈，你才能破解最安全的系统。</p><ul><li><a href="https://null-byte.wonderhowto.com/forum/so-you-want-be-hacker-0148983/" target="_blank" rel="noopener">那么......你想成为黑客吗？</a></li></ul><p>我希望这能给你一些指导，让你了解你需要学习和掌握什么，才能提升到黑客的中级水平。在未来的一篇文章中，我将讨论你需要掌握什么才能提升到高级或大师级的黑客，所以请记着回来，我的新手黑客们！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自&lt;a href=&quot;https://null-byte.wonderhowto.com/how-to/essential-skills-becoming-master-hacker-0154509/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://null-byte.wonderhowto.com/how-to/essential-skills-becoming-master-hacker-0154509/&lt;/a&gt; ，正文如下：&lt;/p&gt;
&lt;p&gt;我的许多有抱负的黑客写信给我，都问同样的问题。“我需要什么技能才能成为一个好的黑客？”&lt;/p&gt;
&lt;p&gt;由于黑客是最熟练的信息技术学科之一，因此需要广泛的IT技术和技术知识。要真正成为一名优秀的黑客，必须掌握许多技能。如果你没有我在此列出的所有技能，请不要气馁，可以将此列表作为你在不久的将来学习和掌握所需内容的起点。&lt;br&gt;
    
    </summary>
    
      <category term="Translation" scheme="https://howiezhao.github.io/categories/Translation/"/>
    
    
  </entry>
  
  <entry>
    <title>白帽子VPS选购指南</title>
    <link href="https://howiezhao.github.io/2019/02/25/whitehat-vps/"/>
    <id>https://howiezhao.github.io/2019/02/25/whitehat-vps/</id>
    <published>2019-02-25T10:17:38.000Z</published>
    <updated>2020-05-31T12:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自<a href="https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/" target="_blank" rel="noopener">https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/</a> ，正文如下：</p><p>从受信任的VPS进行网络钓鱼活动和托管Metasploit会话对于任何专业安全研究人员，渗透测试人员或白帽黑客都很重要。但是，可供选择的VPS非常有限，因为大多数提供商对任何类型的黑客都有零容忍政策，无论好坏。在研究了数十种产品之后，我们选出了5个理想的产品，非常适合Null Byte读者。<br><a id="more"></a><br>首先要理解的事情是......什么是VPS？嗯，它代表虚拟专用服务器，是许多用户认为的专用或私有服务器的虚拟化形式，即使它安装在同时运行多个操作系统的物理计算机上。VPS最常用于在线托管网站。</p><p>当我们从提供商处购买VPS时，我们实际上是在一个有着许多虚拟服务器的功能强大的高性能物理机器上“租用”一个分区。每个VPS都连接到互联网，使个人客户能够使用不同的操作系统，并提供对操作系统的完全root访问权限。每个客户（或服务器管理员）独立于共享VPS公司提供的物理计算机上的其他客户运营。</p><ul><li>不要错过：<a href="https://null-byte.wonderhowto.com/news/what-is-white-hat-hacker-0166878/" target="_blank" rel="noopener">什么是白帽黑客？</a></li></ul><p>从本质上讲，虚拟专用服务器是我们可以从世界上任何连接互联网的设备远程控制的计算机。这给了我们很大的能力。对于远程服务器而言，下面是它可以完成的一些事情：</p><ul><li>创建VPN连接</li><li>托管网络钓鱼站点</li><li>进行暴力攻击</li><li>创建IRC机器人</li><li>服务器代理</li><li>托管有效载荷</li><li>使用端口扫描器</li><li>创建蜜罐</li><li>托管Metasploit会话</li></ul><p>为了做到这一点，从我们的研究来看，<a href="https://bulletshield.su/" target="_blank" rel="noopener">BulletShield</a>是迄今为止最好的白帽和渗透测试人员的VPS提供商，紧随其后的是<a href="https://buyvm.net/" target="_blank" rel="noopener">BuyVM</a>和<a href="https://www.clientvps.com/" target="_blank" rel="noopener">ClientVPS</a>。亚军是<a href="https://vpsdime.com/" target="_blank" rel="noopener">VPSDime</a>和<a href="https://onehostcloud.hosting/" target="_blank" rel="noopener">OneHost Cloud</a>。你可以在下面的图表中看到原因，但跳到下面可以深入研究每个比较点的含义。<br><img src="https://img.wonderhowto.com/img/36/31/63655508941243/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="图表"></p><h2 id="关键比较点"><a href="#关键比较点" class="headerlink" title="关键比较点"></a>关键比较点</h2><p>网上有几个VPS对比图表，但没有一个对我来说是与渗透测试人员和白帽子有所联系的。在大多数专业的渗透测试场景中，我们需要在几天内启动VPS来托管有效载荷，接收泄漏数据或执行网络钓鱼攻击。</p><p>无论VPS提供商是否提供实时技术支持，难以理解的硬件规格或过多的操作系统选择都很重要。理想情况下，我们希望使用比特币（BTC）从位于尊重隐私的国家的VPS提供商处快速购买最新的Debian版本。</p><p>在比较本文中介绍的VPS提供商时，我试图尽可能客观公正。本文中没有VPS提供商付费参与比较图表。我使用下面的标准来得出上面的图表。</p><ul><li>不要错过：<a href="https://smartphones.gadgethacks.com/how-to/binance-101-sell-your-stellar-ripple-other-alt-coins-for-bitcoin-ethereum-0182373/" target="_blank" rel="noopener">如何在比特币和以太坊中出售你的Stellar，Ripple和其他替代币？</a></li></ul><h3 id="最好的价钱（Best-Price）"><a href="#最好的价钱（Best-Price）" class="headerlink" title="最好的价钱（Best Price）"></a>最好的价钱（Best Price）</h3><p>我相信定价透明度。这意味着提供商完全诚实地说他们的月费是多少。我的图表中列出的价格可能并不总是反映出给定提供商在主页上公布的价格。我的图表中的价格是计算所有强制性和隐藏费用后的结账价格。这些也是我在网站上找到的最便宜的VPS计划的价格。在大多数情况下，这通常有着512 MB的RAM和1个CPU内核。</p><h3 id="渗透测试人员友好型（Pentester-Friendly）"><a href="#渗透测试人员友好型（Pentester-Friendly）" class="headerlink" title="渗透测试人员友好型（Pentester-Friendly）"></a>渗透测试人员友好型（Pentester-Friendly）</h3><p>服务条款（ToS）和可接受的使用政策（AUP）可能是进入此比较图表的最高优先项。虽然最初考虑了数十个VPS提供商，但大多数明确禁止或阻止端口扫描器，有效载荷分发，网络钓鱼和（或）任何类型的黑客攻击。除了少数例外，这会立即取消VPS提供商在比较图表中的资格。</p><p>IT专业人员，安全研究人员和自学成才的白帽黑客在远程服务器上做了大量工作。对我来说很重要的是，这里的VPS提供商保留了最符合Null Byte受众需求的ToS政策。我的图表中的VPS提供商是少数几个没有完全敌视“黑客攻击”的ToS政策的提供商。</p><p>那些被认为是对渗透测试人员友好的提供商并没有在他们的ToS中明确声明允许“黑客攻击”（或任何相关术语）。没有一个VPS提供商会这样做。大多数这些提供商要么没有提及他们的ToS中的黑客攻击，要么他们的网站上根本没有提供ToS。这被认为表明黑客攻击活动非常不受欢迎，但可能不会导致帐户终止。</p><h3 id="请求个人信息（Requests-Personal-Info）"><a href="#请求个人信息（Requests-Personal-Info）" class="headerlink" title="请求个人信息（Requests Personal Info）"></a>请求个人信息（Requests Personal Info）</h3><p>向任何网站提交我们的真实姓名，地址，电话号码和其他个人身份信息都是不可取的。即使匿名不是你的首要任务，VPS提供商仍有一天可能会受到攻击，并且所有客户数据都会在网上泄露。</p><p>购买VPS订阅是理想的匿名完成，因为没有人知道我们在研究或渗透测试期间会遇到什么麻烦。对于你购买的服务器上发生的事情，有朝一日可能会对VPS提供商采取法律行动，因此最好将有关你自己的少量信息存储在提供商的客户数据库中。</p><p>在大多数情况下，我发现在注册期间可以提交一个完全虚假的姓名，地址和电话号码，但我并不认为这是提供商的“好功能”。向任何合法公司提交虚假信息几乎肯定会违反提供商的服务条款并导致帐户立即终止。</p><p>VPS提供商要求的电子邮件地址不属于“个人信息”，因为匿名获取一次性电子邮件地址很容易。毕竟VPS提供商需要建立与客户沟通的有效方法。</p><h3 id="接受比特币付款（Accepts-BTC-Payments）"><a href="#接受比特币付款（Accepts-BTC-Payments）" class="headerlink" title="接受比特币付款（Accepts BTC Payments）"></a>接受比特币付款（Accepts BTC Payments）</h3><p>如果获得比特币（BTC）不是障碍，这可能是你的首选付款方式。目前大多数提供商都接受比特币，但使用匿名加密货币的好处大部分都被VPS提供商对个人身份信息的请求所抵消。我发现使用比特币进行在线购物比使用信用卡更快更方便。</p><h3 id="接受预付信用卡（Accepts-Prepaid-Credit-Cards）"><a href="#接受预付信用卡（Accepts-Prepaid-Credit-Cards）" class="headerlink" title="接受预付信用卡（Accepts Prepaid Credit Cards）"></a>接受预付信用卡（Accepts Prepaid Credit Cards）</h3><p>获取比特币进行匿名交易可能很困难。用现金购买<a href="https://null-byte.wonderhowto.com/how-to/securely-anonymously-spend-money-online-0131351/" target="_blank" rel="noopener">预付卡或一次性借记卡</a>可能更方便。如果没有使用预付借记卡实际提交付款，很难验证这一点。在大多数情况下，我能够联系客户服务代表，并从他们那里获得有关使用预付卡进行交易的直接答复。</p><h3 id="Tor友好型网站（Tor-Friendly-Website）"><a href="#Tor友好型网站（Tor-Friendly-Website）" class="headerlink" title="Tor友好型网站（Tor-Friendly Website）"></a>Tor友好型网站（Tor-Friendly Website）</h3><p>如果你通过安全的VPN连接使用信用卡进行在线购买或通过Tor匿名进行在线购买，VPS提供商有时会暂停你的帐户。联系客户支持并解决暂停可能需要数天时间。</p><p>我使用同一个常用的Firefox浏览器通过Tor浏览了每个站点。要求访问者填写验证码以查看其网站或处理结帐的提供商被标记为对希望保持匿名的用户不友好。这并不意味着可以通过Tor进行事务处理。在查看这些网站时，我只尽可能地进入结账过程，而不实际提交付款。</p><ul><li>不要错过：<a href="https://null-byte.wonderhowto.com/how-to/access-dark-web-while-staying-anonymous-with-tor-0179341/" target="_blank" rel="noopener">如何使用Tor匿名的访问暗网？</a></li></ul><h3 id="公司总部所在国（Company-HQ-39-s-Country）"><a href="#公司总部所在国（Company-HQ-39-s-Country）" class="headerlink" title="公司总部所在国（Company HQ&#39;s Country）"></a>公司总部所在国（Company HQ&#39;s Country）</h3><p>认为提供安全加密交易的公司将与当局充分<a href="https://www.theregister.co.uk/2011/09/26/hidemyass_lulzsec_controversy/" target="_blank" rel="noopener">合作以捕获黑客</a>并不是不切实际的。VPS的IP地址是否来自尊重隐私的国家并不总是重要的。如果向你提供VPS的公司位于美国或英国，他们很可能会毫不犹豫地将你的个人信息交给任何权威人士。</p><p>进一步涉及隐私问题，<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E7%BE%8E%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">UKUSA协议</a>是英国，美国，澳大利亚，加拿大和新西兰之间的协议，旨在合作收集，分析和共享情报。这个群体的成员被称为<a href="https://zh.wikipedia.org/wiki/%E4%BA%94%E7%9C%BC%E8%81%AF%E7%9B%9F" target="_blank" rel="noopener">五眼联盟</a>。这些国家因拥有侵犯隐私的法律和政策而臭名昭著。</p><p>在最尊重隐私的国家选择VPS提供商可能不是最优先考虑的问题，但至少考虑具有<a href="https://nomadcapitalist.com/2013/12/15/top-5-best-countries-host-website-data-privacy/" target="_blank" rel="noopener">良好隐私法律的国家</a>的提供商是有意义的。</p><h3 id="离岸解决方案（Offshore-Solutions）"><a href="#离岸解决方案（Offshore-Solutions）" class="headerlink" title="离岸解决方案（Offshore Solutions）"></a>离岸解决方案（Offshore Solutions）</h3><p>“离岸VPS”意味着服务器位于公司的国家边界位置之外，并且可能允许一定程度的自由裁量权。这对你作为渗透测试人员以及你受委托保护的公司非常重要，因为你可能会收到不应共享或泄露的妥协和敏感信息。我们鼓励读者独立询问VPS提供商，以确定他们的离岸解决方案是否适合你。</p><p>提供商指出，提供离岸解决方案通常要付出一定的代价。不应该假设他们最便宜的VPS解决方案也是其离岸选项的价格。</p><h2 id="1、BulletShield"><a href="#1、BulletShield" class="headerlink" title="1、BulletShield"></a>1、BulletShield</h2><p><a href="https://bulletshield.su/" target="_blank" rel="noopener">BulletShield</a>是我的首选，是Null Byte读者的最佳VPS提供商。BulletShield在注册账户或准备提交比特币交易时不要求任何类型的个人信息。他们还强制要求比特币交易，并且没有明确禁止任何渗透测试活动的ToS。<br><img src="https://img.wonderhowto.com/img/36/93/63655505111133/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="BulletShield"><br>缺点是他们不接受预付信用卡，最便宜的价格有点贵，但如果你重视隐私，价格不一定是主要考虑因素。</p><p>在涉及公司总部时，BulletShield不会透露这些信息。快速域名搜索显示，它是由加拿大公司Tucows Domains Inc.购买的，是从位于西印度群岛偏远岛屿的Charlestown购买的。但是，这并不意味着这就是BulletShield的总部所在地，这只是域名注册商BulletShield使用注册域名的地方。</p><p>他们提供离岸解决方案和Tor友好型网站，使BulletShield整体处于领先地位。但是，一位客户服务代表向我提到“渗透测试”是“仅允许......防弹服务”，这可能是成本方面的问题。</p><ul><li>ToS：无可用</li><li>AUP：无可用</li><li>隐私：无可用</li></ul><h2 id="2、BuyVM"><a href="#2、BuyVM" class="headerlink" title="2、BuyVM"></a>2、BuyVM</h2><p><a href="https://buyvm.net/" target="_blank" rel="noopener">BuyVM</a>是允许合法渗透测试的亚军，如果公司或相关人员给出明确和合法的书面同意。一位代表证实了这一点，他们说“他们需要一份来自法律团队的完整文件，代表有关目标的授权书”。<br><img src="https://img.wonderhowto.com/img/33/95/63655505142883/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="BuyVM"><br>他们的起价确实提升了他们的排名，VPS解决方案每月只需2.42美元。但是，他们确实要求你提供个人信息，并且为了注册帐户，“帐户详细信息必须与付款方式提供的信息相符”，这可能意味着匿名预付卡将无法使用。不过，比特币是可以被接受的。</p><p>虽然他们确实有一个Tor友好的网站，但他们总部设在加拿大，并不提供离岸解决方案，这可能是负面的，取决于你使用VPS的目的。</p><ul><li>ToS：<a href="https://buyvm.net/terms-of-service/" target="_blank" rel="noopener">链接</a></li><li>AUP：<a href="https://buyvm.net/acceptable-use-policy/" target="_blank" rel="noopener">链接</a></li><li>隐私：<a href="https://buyvm.net/privacy-policy/" target="_blank" rel="noopener">链接</a></li></ul><h2 id="3、ClientVPS"><a href="#3、ClientVPS" class="headerlink" title="3、ClientVPS"></a>3、ClientVPS</h2><p><a href="https://www.clientvps.com/" target="_blank" rel="noopener">ClientVPS</a>有一个ToS，即你所执行的任何导致对人身或财产“受到伤害”，侵犯版权等的行为都要你自己承担全部责任。<br><img src="https://img.wonderhowto.com/img/69/58/63655505152117/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="ClientVPS"><br>总的来说，他们的价格是最昂贵的，但亮点包括接受比特币（预付Visa尚卡不清楚），拥有Tor友好的网站，总部设在俄罗斯（信息请求经常被忽略），并提供离岸解决方案，所有这些都巩固了其目前在排名中的地位。</p><p>除了高昂的价格外，其他缺点包括他们缺乏有关合法渗透测试的信息（他们没有回复我的询问），他们确实要求你提供个人数据。</p><ul><li>ToS：<a href="https://www.clientvps.com/terms-of-service" target="_blank" rel="noopener">链接</a></li><li>AUP：无公开链接</li><li>隐私：<a href="https://www.clientvps.com/privacy-policy" target="_blank" rel="noopener">链接</a></li></ul><h2 id="4、VPSDime"><a href="#4、VPSDime" class="headerlink" title="4、VPSDime"></a>4、VPSDime</h2><p><a href="https://vpsdime.com/" target="_blank" rel="noopener">VPSDime</a>不是一个非常理想的选择，因为它们没有比特币支付选项，不允许客户匿名查看他们的网站，也没有任何离岸VPS解决方案。但是，他们的ToS只是明确禁止“端口扫描”。他们没有提及渗透测试，漏洞扫描，网络钓鱼或其他常见的渗透活动。<br><img src="https://img.wonderhowto.com/img/00/36/63655505163524/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="VPSDime"><br>当询问澄清他们的合法渗透测试政策时，他们没有回复我的电子邮件。他们的ToS太模糊了，我无法确定是否允许这样的（合法）活动。出于这个原因，我建议读者在使用他们的服务之前联系VPSDime澄清。</p><p>虽然VPSDime没有明显的好处，但它们是最便宜的选择之一。</p><ul><li>ToS：<a href="https://vpsdime.com/tos.html" target="_blank" rel="noopener">链接</a></li><li>AUP：<a href="https://vpsdime.com/aup.html" target="_blank" rel="noopener">链接</a></li><li>隐私：<a href="https://vpsdime.com/privacy.html" target="_blank" rel="noopener">链接</a></li></ul><h2 id="5、OneHost-Cloud"><a href="#5、OneHost-Cloud" class="headerlink" title="5、OneHost Cloud"></a>5、OneHost Cloud</h2><p><a href="https://onehostcloud.hosting/" target="_blank" rel="noopener">OneHost Cloud</a>是我能找到的唯一提供Kali Linux VPS和渗透测试解决方案的VPS提供商。他们的价格仅为每月6.59美元，这是该提供商的另一个主要好处，并且他们接受比特币付款。<br><img src="https://img.wonderhowto.com/img/55/35/63655505173336/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="OneHost Cloud"><br>对于那些不打算在未经同意的情况下非法扫描网站或入侵实体的白帽子来说，OneHost Cloud<br>似乎是最佳选择。毕竟如果它们提供Kali解决方案但不允许合法的渗透测试，那么对于客户来说也会非常混乱。但是，当我询问合法渗透测试时，他们只是回答：</p><blockquote><p>来自此地址的所有未来电子邮件都将被阻止。</p></blockquote><p>这是在没有任何理由或解释的情况下发给我的。出于这个原因，OneHost Cloud排在最后，我建议读者在执行任何类型的渗透测试之前，独立地向OneHost Cloud询问他们的ToS策略。</p><p>该提供商的其他缺点是要求提供个人信息；位于英国伦敦；没有匿名网站；并且缺乏有关离岸解决方案和预付卡的信息。</p><ul><li>ToS：<a href="https://onehostcloud.hosting/legal/" target="_blank" rel="noopener">链接</a></li><li>AUP：无公开链接</li><li>隐私：<a href="https://onehostcloud.hosting/privacy-policy/" target="_blank" rel="noopener">链接</a></li></ul><h2 id="意见"><a href="#意见" class="headerlink" title="意见"></a>意见</h2><p>专业和独立渗透测试人员的选择是非常有限的。大多数VPS提供商都有检测系统，如果检测到任何类型的扫描，网络钓鱼或垃圾邮件，它们会自动暂停客户帐户。在我们的测试计划中，可能需要数天才能解决暂停并造成重大挫折。</p><p>选择愿意与我们合作以更好地保护公司网站的提供商是至关重要的。如果你是一个专业的渗透测试者，或者只是一个希望以安全和匿名的方式加强技能的新手黑客，那么选择最能满足你需求并获得乐趣的提供商。</p><ul><li>不要错过：<a href="https://null-byte.wonderhowto.com/how-to/hack-anyones-wi-fi-password-using-birthday-card-part-1-creating-payload-0183043/" target="_blank" rel="noopener">如何使用生日卡片破解任何人的Wi-Fi密码？</a></li></ul><h2 id="一些评论"><a href="#一些评论" class="headerlink" title="一些评论"></a>一些评论</h2><p>Pulkit Singhania：</p><blockquote><p>Cloudsigma实际上也是一个不错的选择。<br>  他们提供免费的vps，没有任何登录或任何注册的免费，但只有一个小时。<br>  我亲自尝试过，它提供2GB内存和50GB硬盘，最高可达25兆字节/秒的互联网流量。<br>  如果你使用公司电子邮件注册，则可免费试用7天</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自&lt;a href=&quot;https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/&lt;/a&gt; ，正文如下：&lt;/p&gt;
&lt;p&gt;从受信任的VPS进行网络钓鱼活动和托管Metasploit会话对于任何专业安全研究人员，渗透测试人员或白帽黑客都很重要。但是，可供选择的VPS非常有限，因为大多数提供商对任何类型的黑客都有零容忍政策，无论好坏。在研究了数十种产品之后，我们选出了5个理想的产品，非常适合Null Byte读者。&lt;br&gt;
    
    </summary>
    
      <category term="Translation" scheme="https://howiezhao.github.io/categories/Translation/"/>
    
    
  </entry>
  
</feed>
