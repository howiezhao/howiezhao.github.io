<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Howie&#39;s Notes</title>
  
  <subtitle>Machine Learning and Cyber Security</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://howiezhao.github.io/"/>
  <updated>2018-08-10T13:31:12.145Z</updated>
  <id>https://howiezhao.github.io/</id>
  
  <author>
    <name>Howie Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Base编码家族</title>
    <link href="https://howiezhao.github.io/2018/08/10/base/"/>
    <id>https://howiezhao.github.io/2018/08/10/base/</id>
    <published>2018-08-10T09:07:56.000Z</published>
    <updated>2018-08-10T13:31:12.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><h2 id="Base32"><a href="#Base32" class="headerlink" title="Base32"></a>Base32</h2><h2 id="Base16"><a href="#Base16" class="headerlink" title="Base16"></a>Base16</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Base64&quot;&gt;&lt;a href=&quot;#Base64&quot; class=&quot;headerlink&quot; title=&quot;Base64&quot;&gt;&lt;/a&gt;Base64&lt;/h2&gt;&lt;h2 id=&quot;Base32&quot;&gt;&lt;a href=&quot;#Base32&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="密码学" scheme="https://howiezhao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>古典密码学</title>
    <link href="https://howiezhao.github.io/2018/08/10/classical-crypto/"/>
    <id>https://howiezhao.github.io/2018/08/10/classical-crypto/</id>
    <published>2018-08-10T03:17:41.000Z</published>
    <updated>2018-08-10T13:31:05.977Z</updated>
    
    <content type="html"><![CDATA[<p>古典密码学主要包括两类，即<strong>代换</strong>和<strong>置换</strong>。</p><h2 id="代换"><a href="#代换" class="headerlink" title="代换"></a>代换</h2><p>代换密码是将明文中的字符替代成其他字符，典型的有凯撒密码、维吉尼亚密码、培根密码等。</p><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p>凯撒密码(Caesar cipher)就是将明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文。例如，当偏移量为3时，所有的字母A将被替换成D，B变成E，以此类推。<br>明文<code>Hello World</code>的加密过程如下：</p><ol><li>取偏移量为3</li><li>计算<code>H</code>的后3位为<code>K</code></li><li>以此类推</li><li>密文为：<code>Khoor Zruog</code></li></ol><p>类似的，解密过程如下：</p><ol><li>计算<code>K</code>的前3位为<code>H</code></li><li>以此类推</li><li>明文为：<code>Hello World</code></li></ol><p>注意：当偏移量为13时，这种凯撒密码的特例又被称为<strong>ROT13</strong>(回转13位)加密。当偏移量未知时，可采用穷举法一个个试，偏移量必定小于26。<br><a id="more"></a></p><h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码(Bacon’s cipher)加密时，明文中的每个字母都会转换成一组5个英文字母。其转换依靠下表：</p><table><thead><tr><th>明文</th><th>密文</th><th>明文</th><th>密文</th><th>明文</th><th>密文</th><th>明文</th><th>密文</th></tr></thead><tbody><tr><td>a</td><td>AAAAA</td><td>g</td><td>AABBA</td><td>n</td><td>ABBAA</td><td>t</td><td>BAABA</td></tr><tr><td>b</td><td>AAAAB</td><td>h</td><td>AABBB</td><td>o</td><td>ABBAB</td><td>u-v</td><td>BAABB</td></tr><tr><td>c</td><td>AAABA</td><td>i-j</td><td>ABAAA</td><td>p</td><td>ABBBA</td><td>w</td><td>BABAA</td></tr><tr><td>d</td><td>AAABB</td><td>k</td><td>ABAAB</td><td>q</td><td>ABBBB</td><td>x</td><td>BABAB</td></tr><tr><td>e</td><td>AABAA</td><td>l</td><td>ABABA</td><td>r</td><td>BAAAA</td><td>y</td><td>BABBA</td></tr><tr><td>f</td><td>AABAB</td><td>m</td><td>ABABB</td><td>s</td><td>BAAAB</td><td>z</td><td>BABBB</td></tr></tbody></table><p>按照上表，明文<code>hello</code>的密文为<code>AABBBAABAAABABBABABBABBBA</code>，显然，密文的长度是明文长度的<strong>5</strong>倍。<br>除了上表用来加密小写明文外，还有一张用来加密大写明文的表，如下：</p><table><thead><tr><th>明文</th><th>密文</th><th>明文</th><th>密文</th><th>明文</th><th>密文</th><th>明文</th><th>密文</th><th>明文</th><th>密文</th></tr></thead><tbody><tr><td>A</td><td>aaaaa</td><td>G</td><td>aabba</td><td>M</td><td>abbaa</td><td>S</td><td>baaba</td><td>Y</td><td>bbaaa</td></tr><tr><td>B</td><td>aaaab</td><td>H</td><td>aabbb</td><td>N</td><td>abbab</td><td>T</td><td>baabb</td><td>Z</td><td>bbaab</td></tr><tr><td>C</td><td>aaaba</td><td>I</td><td>abaaa</td><td>O</td><td>abbba</td><td>U</td><td>babaa</td></tr><tr><td>D</td><td>aaabb</td><td>J</td><td>abaab</td><td>P</td><td>abbbb</td><td>V</td><td>babab</td></tr><tr><td>E</td><td>aabaa</td><td>K</td><td>ababa</td><td>Q</td><td>baaaa</td><td>W</td><td>babba</td></tr><tr><td>F</td><td>aabab</td><td>L</td><td>ababb</td><td>R</td><td>baaab</td><td>X</td><td>babbb</td></tr></tbody></table><p>同理，明文<code>HELLO</code>的密文为<code>aabbbaabaaababbababbabbba</code>。<br>注意：虽然表中出现了<code>A</code> <code>B</code>两种字符，但培根密码的本质是二进制，即用两种不同的特征来加密明文，可以是字母的大小写或字体的样式等等。例如采用字母的大小写加密<code>hello</code>为<code>GOod gOOd STUdY, dAY dAy UP, haHa</code>，其中大写代表<code>A</code>，小写代表<code>B</code>；类似的，也可以用粗体代表<code>A</code>，正常代表<code>B</code>，以字体的样式加密<code>hello</code>。显然，培根密码所包含的信息可以和用于承载其的文章完全无关。</p><h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><p>置换密码是将明文中的字母重新排列，字母本身不变，但其位置改变，典型的有栅栏密码等。</p><h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p>栅栏密码(Rail fence cipher)，又称篱笆密码，就是把要加密的明文分成n个一组，然后把每组的第一个字连起来，紧接着把每组的第二个字连起来，以此类推，形成一段无规律的话。<br>明文<code>Hello World</code>的加密过程如下：</p><ol><li>去掉空格：<code>HelloWorld</code></li><li>5个一组：<code>Hello</code>，<code>World</code></li><li>取出每组第1个字母：<code>HW</code></li><li>取出每组第2个字母：<code>eo</code></li><li>以此类推</li><li>连在一起：<code>HWeolrllod</code></li><li>加上适当空格：<code>HWeol rllod</code></li></ol><p>类似的，解密过程如下：</p><ol><li>去掉空格：<code>HWeolrllod</code></li><li>分成5栏：<code>HW</code>、<code>eo</code>、<code>lr</code>、<code>ll</code>、<code>od</code></li><li>取出每栏第1个字母：<code>Hello</code></li><li>依次类推</li><li>连在一起：<code>HelloWorld</code></li><li>加上适当空格：<code>Hello World</code></li></ol><p>注意：这里栅栏的栏数取决于n的取值，一般而言，n要整除字母数，n不可能大于或等于字母数，当不知道n为多少时，可采用穷举法一个个试。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="当铺密码"><a href="#当铺密码" class="headerlink" title="当铺密码"></a>当铺密码</h3><p>准确来说，当铺密码不是一种加密方式而是一种编码方式，它是将中文和数字进行转化的算法，具体为：当前汉字有多少笔画出头，就转化成数字几。如<code>王夫 井工 夫口 由中人</code>即为<code>67 84 70 123</code>。</p><h3 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h3><p>猪圈密码(Pigpen cipher)，又称共济会密码(Masonic cipher)，是一种以格子为基础的简单代换式密码。下图为猪圈密码中所用符号与26个英语字母之间的对应关系：<br><img src="/images/pigpen.png" alt="猪圈密码"><br>明文<code>X MARKS THE SPOT</code>的加密结果如下：<br><img src="/images/pigpen-eg.png" alt="猪圈密码例子"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;古典密码学主要包括两类，即&lt;strong&gt;代换&lt;/strong&gt;和&lt;strong&gt;置换&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;代换&quot;&gt;&lt;a href=&quot;#代换&quot; class=&quot;headerlink&quot; title=&quot;代换&quot;&gt;&lt;/a&gt;代换&lt;/h2&gt;&lt;p&gt;代换密码是将明文中的字符替代成其他字符，典型的有凯撒密码、维吉尼亚密码、培根密码等。&lt;/p&gt;
&lt;h3 id=&quot;凯撒密码&quot;&gt;&lt;a href=&quot;#凯撒密码&quot; class=&quot;headerlink&quot; title=&quot;凯撒密码&quot;&gt;&lt;/a&gt;凯撒密码&lt;/h3&gt;&lt;p&gt;凯撒密码(Caesar cipher)就是将明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文。例如，当偏移量为3时，所有的字母A将被替换成D，B变成E，以此类推。&lt;br&gt;明文&lt;code&gt;Hello World&lt;/code&gt;的加密过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;取偏移量为3&lt;/li&gt;
&lt;li&gt;计算&lt;code&gt;H&lt;/code&gt;的后3位为&lt;code&gt;K&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以此类推&lt;/li&gt;
&lt;li&gt;密文为：&lt;code&gt;Khoor Zruog&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似的，解密过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算&lt;code&gt;K&lt;/code&gt;的前3位为&lt;code&gt;H&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以此类推&lt;/li&gt;
&lt;li&gt;明文为：&lt;code&gt;Hello World&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：当偏移量为13时，这种凯撒密码的特例又被称为&lt;strong&gt;ROT13&lt;/strong&gt;(回转13位)加密。当偏移量未知时，可采用穷举法一个个试，偏移量必定小于26。&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="密码学" scheme="https://howiezhao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JSFuck</title>
    <link href="https://howiezhao.github.io/2018/08/10/jsfuck/"/>
    <id>https://howiezhao.github.io/2018/08/10/jsfuck/</id>
    <published>2018-08-10T00:59:58.000Z</published>
    <updated>2018-08-10T02:21:18.152Z</updated>
    
    <content type="html"><![CDATA[<p>JSFuck是一种JavaScript的编码方式，它的命名起源于Brainfuck，同样，为了避讳脏话，它又被写作JSF*ck，以JSFuck风格写出的代码不需要另外的编译器或解释器执行，原生的JavaScript解释器即可直接运行。<br>JSFuck种共使用<code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>!</code>、<code>+</code>这<strong>6</strong>种字符。<code>alert(1)</code>这段JavaScript代码用JSFuck风格表示如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()</span><br></pre></td></tr></table></figure></p><p>要将任意的JavaScript代码编码为JSFuck风格，可前往<a href="http://www.jsfuck.com/" target="_blank" rel="noopener">JSFuck</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSFuck是一种JavaScript的编码方式，它的命名起源于Brainfuck，同样，为了避讳脏话，它又被写作JSF*ck，以JSFuck风格写出的代码不需要另外的编译器或解释器执行，原生的JavaScript解释器即可直接运行。&lt;br&gt;JSFuck种共使用&lt;code&gt;
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>Brainfuck</title>
    <link href="https://howiezhao.github.io/2018/08/09/Brainfuck/"/>
    <id>https://howiezhao.github.io/2018/08/09/Brainfuck/</id>
    <published>2018-08-09T09:15:44.000Z</published>
    <updated>2018-08-10T00:58:53.514Z</updated>
    
    <content type="html"><![CDATA[<p>Brainfuck是在1993年创建的一种极小化的计算机语言，由于fuck在英语中是脏话，这种语言有时也被称为Brainf*ck或Brainf***，或被简称为BF。<br>Brainfuck中共有8种字符，它们及其含义如下所示：</p><ul><li><code>&gt;</code>：指针加一</li><li><code>&lt;</code>：指针减一</li><li><code>+</code>：指针指向的字节的值加一</li><li><code>-</code>：指针指向的字节的值减一</li><li><code>.</code>：输出指针指向的单元内容(ASCII码)</li><li><code>,</code>：输入内容到指针指向的单元(ASCII码)</li><li><code>[</code>：如果指针指向的单元值为零，向后跳转到对应的<code>]</code>指令的次一指令处</li><li><code>]</code>：如果指针指向的单元值不为零，向前跳转到对应的<code>[</code>指令的次一指令处</li></ul><p>下面是一个用Brainfuck在屏幕上打印<code>Hello World</code>的程序例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.</span><br><span class="line">&gt;.+++.------.--------.&gt;+.&gt;.</span><br></pre></td></tr></table></figure></p><p>程序的运行结果如<a href="https://fatiherikli.github.io/brainfuck-visualizer/" target="_blank" rel="noopener">Brainfuck Visualizer</a>所示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Brainfuck是在1993年创建的一种极小化的计算机语言，由于fuck在英语中是脏话，这种语言有时也被称为Brainf*ck或Brainf***，或被简称为BF。&lt;br&gt;Brainfuck中共有8种字符，它们及其含义如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;g
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>《TAOUP》读书笔记</title>
    <link href="https://howiezhao.github.io/2018/08/02/taoup/"/>
    <id>https://howiezhao.github.io/2018/08/02/taoup/</id>
    <published>2018-08-02T14:31:46.000Z</published>
    <updated>2018-08-10T00:59:19.408Z</updated>
    
    <content type="html"><![CDATA[<p>我没有写错，本文所记述的不是Knuth的那本举世瞩目的TAOCP(计算机程序设计艺术)，而是ESR所写的<strong>TAOUP</strong>，即The Art of UNIX Programming(UNIX编程艺术)。</p><h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p>Unix的设计哲学总体上可以概括为以下几点：</p><ol><li>模块原则：使用简洁的接口拼合简单的部件</li><li>清晰原则：清晰胜于机巧</li><li>组合原则：设计时考虑拼接组合</li><li>分离原则：策略同机制分离，接口同引擎分离</li><li>简洁原则：设计要简洁，复杂度能低则低</li><li>吝啬原则：除非却无它法，不要编写庞大的程序</li><li>透明性原则：设计要可见，以便审查和调试</li><li>健壮原则：健壮源于透明与简洁</li><li>表示原则：把知识叠入数据以求逻辑质朴而健壮</li><li>通俗原则：接口设计避免标新立异</li><li>缄默原则：如果一个程序没什么好说的，就沉默</li><li>补救原则：出现异常时，马上退出并给出足够错误信息</li><li>经济原则：宁花机器一分，不花程序员一秒</li><li>生成原则：避免手工hack，尽量编写程序去生成程序</li><li>优化原则：雕琢前先要有原型，跑之前先学会走</li><li>多样原则：决不相信所谓“不二法门”的断言</li><li>扩展原则：设计着眼未来，未来总比预想来得快<a id="more"></a>所有的Unix哲学浓缩为一条铁律就是<strong>KISS</strong>原则，即Keep It Simple, Stupid！</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我没有写错，本文所记述的不是Knuth的那本举世瞩目的TAOCP(计算机程序设计艺术)，而是ESR所写的&lt;strong&gt;TAOUP&lt;/strong&gt;，即The Art of UNIX Programming(UNIX编程艺术)。&lt;/p&gt;
&lt;h2 id=&quot;哲学&quot;&gt;&lt;a href=&quot;#哲学&quot; class=&quot;headerlink&quot; title=&quot;哲学&quot;&gt;&lt;/a&gt;哲学&lt;/h2&gt;&lt;p&gt;Unix的设计哲学总体上可以概括为以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块原则：使用简洁的接口拼合简单的部件&lt;/li&gt;
&lt;li&gt;清晰原则：清晰胜于机巧&lt;/li&gt;
&lt;li&gt;组合原则：设计时考虑拼接组合&lt;/li&gt;
&lt;li&gt;分离原则：策略同机制分离，接口同引擎分离&lt;/li&gt;
&lt;li&gt;简洁原则：设计要简洁，复杂度能低则低&lt;/li&gt;
&lt;li&gt;吝啬原则：除非却无它法，不要编写庞大的程序&lt;/li&gt;
&lt;li&gt;透明性原则：设计要可见，以便审查和调试&lt;/li&gt;
&lt;li&gt;健壮原则：健壮源于透明与简洁&lt;/li&gt;
&lt;li&gt;表示原则：把知识叠入数据以求逻辑质朴而健壮&lt;/li&gt;
&lt;li&gt;通俗原则：接口设计避免标新立异&lt;/li&gt;
&lt;li&gt;缄默原则：如果一个程序没什么好说的，就沉默&lt;/li&gt;
&lt;li&gt;补救原则：出现异常时，马上退出并给出足够错误信息&lt;/li&gt;
&lt;li&gt;经济原则：宁花机器一分，不花程序员一秒&lt;/li&gt;
&lt;li&gt;生成原则：避免手工hack，尽量编写程序去生成程序&lt;/li&gt;
&lt;li&gt;优化原则：雕琢前先要有原型，跑之前先学会走&lt;/li&gt;
&lt;li&gt;多样原则：决不相信所谓“不二法门”的断言&lt;/li&gt;
&lt;li&gt;扩展原则：设计着眼未来，未来总比预想来得快
    
    </summary>
    
      <category term="Notes" scheme="https://howiezhao.github.io/categories/Notes/"/>
    
    
      <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于代理那些事</title>
    <link href="https://howiezhao.github.io/2018/07/26/about-proxy/"/>
    <id>https://howiezhao.github.io/2018/07/26/about-proxy/</id>
    <published>2018-07-26T04:08:41.000Z</published>
    <updated>2018-07-27T13:44:49.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正向连接与反向连接"><a href="#正向连接与反向连接" class="headerlink" title="正向连接与反向连接"></a>正向连接与反向连接</h2><p><strong>正向连接</strong>即黑客主动连接受害者，这种情况下要求受害者有公网IP，常用于对服务器的渗透；<strong>反向连接</strong>即受害者主动连接黑客，这种情况下要求黑客有公网IP，常用于对个人的渗透。</p><h2 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h2><p>在英语中，<strong>Proxy</strong>表示<strong>服务器代理</strong>这种动作，而<strong>Agent</strong>表示<strong>代理服务器</strong>这种物质，显然，我们这里讨论的是Proxy这种动作，而非代理服务器本身。<br>不论正向还是反向，代理都是基于这样一个事实：即A与B的通信要经过C的转发，这里的C就是Agent，为了方便讨论，我们将A视为客户端，将B视为服务器端。<br><strong>正向代理</strong>(Forward Proxy)：也就是常说的代理，代理服务器偏向于客户端，服务器端只能得到代理服务器的IP地址，隐藏了客户端的IP地址。常用于科学上网工具。<br><strong>反向代理</strong>(Reverse Proxy)：代理服务器偏向于服务器端，客户端只能得到代理服务器的IP地址，隐藏了服务器端的IP地址。常用于网站镜像等。<br><a id="more"></a></p><h2 id="端口转发与端口映射"><a href="#端口转发与端口映射" class="headerlink" title="端口转发与端口映射"></a>端口转发与端口映射</h2><p>传统意义上，我们认为<strong>端口转发</strong>(Port Forwarding)与<strong>端口映射</strong>(Port Mapping)表达同样的内容。顾名思义，端口转发指的是将某个IP的某个端口转发到另一个IP的另一个端口，这样，可以通过访问后者以达到访问前者的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正向连接与反向连接&quot;&gt;&lt;a href=&quot;#正向连接与反向连接&quot; class=&quot;headerlink&quot; title=&quot;正向连接与反向连接&quot;&gt;&lt;/a&gt;正向连接与反向连接&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;正向连接&lt;/strong&gt;即黑客主动连接受害者，这种情况下要求受害者有公网IP，常用于对服务器的渗透；&lt;strong&gt;反向连接&lt;/strong&gt;即受害者主动连接黑客，这种情况下要求黑客有公网IP，常用于对个人的渗透。&lt;/p&gt;
&lt;h2 id=&quot;正向代理与反向代理&quot;&gt;&lt;a href=&quot;#正向代理与反向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理与反向代理&quot;&gt;&lt;/a&gt;正向代理与反向代理&lt;/h2&gt;&lt;p&gt;在英语中，&lt;strong&gt;Proxy&lt;/strong&gt;表示&lt;strong&gt;服务器代理&lt;/strong&gt;这种动作，而&lt;strong&gt;Agent&lt;/strong&gt;表示&lt;strong&gt;代理服务器&lt;/strong&gt;这种物质，显然，我们这里讨论的是Proxy这种动作，而非代理服务器本身。&lt;br&gt;不论正向还是反向，代理都是基于这样一个事实：即A与B的通信要经过C的转发，这里的C就是Agent，为了方便讨论，我们将A视为客户端，将B视为服务器端。&lt;br&gt;&lt;strong&gt;正向代理&lt;/strong&gt;(Forward Proxy)：也就是常说的代理，代理服务器偏向于客户端，服务器端只能得到代理服务器的IP地址，隐藏了客户端的IP地址。常用于科学上网工具。&lt;br&gt;&lt;strong&gt;反向代理&lt;/strong&gt;(Reverse Proxy)：代理服务器偏向于服务器端，客户端只能得到代理服务器的IP地址，隐藏了服务器端的IP地址。常用于网站镜像等。&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="渗透" scheme="https://howiezhao.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>XML、JSON与YAML</title>
    <link href="https://howiezhao.github.io/2018/07/21/xml-json-yaml/"/>
    <id>https://howiezhao.github.io/2018/07/21/xml-json-yaml/</id>
    <published>2018-07-21T11:50:23.000Z</published>
    <updated>2018-08-02T15:01:23.824Z</updated>
    
    <content type="html"><![CDATA[<p>XML、JSON与YAML是三种常见的信息标记形式，这三者由于其特有的属性而在不同的领域广为使用。</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p><strong>XML</strong>，Extensible Markup Language(可扩展标记语言)，倘若我要表示某个人的简要信息，用XML可写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;person&gt;</span><br><span class="line">    &lt;firstName&gt;Tian&lt;/firstName&gt;</span><br><span class="line">    &lt;lastName&gt;Song&lt;/lastName&gt;</span><br><span class="line">    &lt;address&gt;</span><br><span class="line">        &lt;streetAddr&gt;中关村南大街5号&lt;/streetAddr&gt;</span><br><span class="line">        &lt;city&gt;北京市&lt;/city&gt;</span><br><span class="line">        &lt;zipcode&gt;100081&lt;/zipcode&gt;</span><br><span class="line">    &lt;/address&gt;</span><br><span class="line">    &lt;prof&gt;Computer System&lt;/prof&gt;&lt;prof&gt;Security&lt;/prof&gt;</span><br><span class="line">&lt;/person&gt;</span><br></pre></td></tr></table></figure></p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><strong>JSON</strong>，JavaScript Object Notation(JavaScript对象表示法)，倘若我要表示某个人的简要信息，用JSON可写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;firstName&quot; : &quot;Tian&quot;,</span><br><span class="line">    &quot;lastName&quot; : &quot;Song&quot;,</span><br><span class="line">    &quot;address&quot; : &#123;</span><br><span class="line">                    &quot;streetAddr&quot; : &quot;中关村南大街5号&quot;,</span><br><span class="line">                    &quot;city&quot; : &quot;北京市&quot;,</span><br><span class="line">                    &quot;zipcode&quot; : &quot;100081&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">    &quot;prof&quot; : [&quot;Computer System&quot;, &quot;Security&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><p><strong>YAML</strong>，在开发这种语言之初，其意为Yet Another Markup Language(仍是一种标记语言)，之后为了强调这种语言以数据作为中心，而不是以标记语言为重点，故解释为YAML Ain’t a Markup Language(YAML不是一种标记语言)，倘若我要表示某个人的简要信息，用YAML可写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">firstName : Tian</span><br><span class="line">lastName : Song</span><br><span class="line">address : </span><br><span class="line">    streetAddr : 中关村南大街5号</span><br><span class="line">    city : 北京市</span><br><span class="line">    zipcode : 100081</span><br><span class="line">prof : </span><br><span class="line">-Computer System</span><br><span class="line">-Security</span><br></pre></td></tr></table></figure></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>XML是最早的通用信息标记语言，可扩展性好，但繁琐，主要用于Internet上的信息交互与传递，以及用户界面的编写，比如Android；JSON中的信息有类型，适合程序处理(js)，较XML简洁，主要用于移动应用云端和节点的信息通信，无注释；YAML信息无类型，文本信息比例最高，可读性好，主要用于各类系统的配置文件，有注释易读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;XML、JSON与YAML是三种常见的信息标记形式，这三者由于其特有的属性而在不同的领域广为使用。&lt;/p&gt;
&lt;h2 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;X
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown小记</title>
    <link href="https://howiezhao.github.io/2018/07/21/markdown-cheatsheet/"/>
    <id>https://howiezhao.github.io/2018/07/21/markdown-cheatsheet/</id>
    <published>2018-07-21T00:50:42.000Z</published>
    <updated>2018-07-21T13:05:55.882Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种轻量标记语言，它允许人们采用其规定的语法编写文档，而后Markdown解析器会将其转化为有效的HTML文档，以便在网页中显示，时至今日，有许多Markdown解析器增强了Markdown的基本语法。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p># 一级标题<br>#### 四级标题<br>对应HTML，最高6级标题。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>- 无序列表项<br>- 无序列表项<br>- 无序列表项</p><p>1. 有序列表项<br>2. 有序列表项<br>3. 有序列表项<br><a id="more"></a></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>[Howie’s Blog](<a href="http://howiezhao.com" target="_blank" rel="noopener">http://howiezhao.com</a>)<br>超文本链接必须带http。</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>![一张图片](/images/abc.jpg)<br>当图片无法显示时，则显示中括号中的语句。图片的路径为相对路径，即当前markdown文件所在路径下的images中的abc.jpg。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>*斜体*<br>**粗体**</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>```<br>这里是多行代码<br>```</p><p>`这里是单行代码`</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表头1 | 表头2<br>-– | -–<br>单元格1 | 单元格2<br>单元格3 | 单元格4</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>> 这是引用</p><h3 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h3><p>-–，这是一条水平区分线，用3个或以上的短横线表示</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>和传统编程语言一样，markdown使用 \ 转义以上特殊字符。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>在特殊字符与要书写的文字之间加上空格</li><li>不同段之间加一空行</li></ol><h2 id="GitHub-Flavored-Markdown"><a href="#GitHub-Flavored-Markdown" class="headerlink" title="GitHub Flavored Markdown"></a>GitHub Flavored Markdown</h2><p>GitHub Flavored Markdown，简记为GFM，即GitHub风格的Markdown语法，是GitHub中编辑器使用的Markdown语法格式，略微区别于标准的Markdown语法，主要如下：</p><ol><li>链接自动识别：GFM会自动为标准的URL加上链接</li><li>语法着色：在```后输入语言，即可着色</li><li>删除线：使用~~表示删除线</li><li>任务列表：使用- []或- [1]表示未勾选或已勾选的列表</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown是一种轻量标记语言，它允许人们采用其规定的语法编写文档，而后Markdown解析器会将其转化为有效的HTML文档，以便在网页中显示，时至今日，有许多Markdown解析器增强了Markdown的基本语法。&lt;/p&gt;
&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h3&gt;&lt;p&gt;# 一级标题&lt;br&gt;#### 四级标题&lt;br&gt;对应HTML，最高6级标题。&lt;/p&gt;
&lt;h3 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h3&gt;&lt;p&gt;- 无序列表项&lt;br&gt;- 无序列表项&lt;br&gt;- 无序列表项&lt;/p&gt;
&lt;p&gt;1. 有序列表项&lt;br&gt;2. 有序列表项&lt;br&gt;3. 有序列表项&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>Udacity：Apollo起步学习笔记</title>
    <link href="https://howiezhao.github.io/2018/07/21/udacity-apollo/"/>
    <id>https://howiezhao.github.io/2018/07/21/udacity-apollo/</id>
    <published>2018-07-21T00:36:36.000Z</published>
    <updated>2018-07-21T13:35:04.933Z</updated>
    
    <content type="html"><![CDATA[<p>本笔记记录自<a href="https://cn.udacity.com/course/self-driving-car-fundamentals-featuring-apollo--ud0419" target="_blank" rel="noopener">ud0419-无人驾驶第一课：从Apollo起步</a>。</p><h2 id="一、无人驾驶概览"><a href="#一、无人驾驶概览" class="headerlink" title="一、无人驾驶概览"></a>一、无人驾驶概览</h2><p>无人驾驶车的6个等级：</p><ul><li>0级——基本等级：驾驶员是系统的唯一决策者。</li><li>1级——驾驶员辅助(Driver Assistance)：车辆为驾驶员提供转向或加速支持，驾驶员必须保持充分参与。</li><li>2级——部分自动化(Partial Automation)：车辆自动控制几项功能，如自动巡航控制和车道保持，但是驾驶员仍然必须执行自治系统处理的任何功能。</li><li>3级——有条件的自动化(Conditional Automation)：车辆自主驾驶，但驾驶员必须准备在必要的时候随时接管。</li><li>4级——高度自动化(No Human Interference)：车辆控制驾驶体验的所有面面，并且不期望驾驶员的介入，车辆可能根本没有方向盘或任何驾驶员控制装置，但是车辆可能被限制在某些区域，通常这被称为“地理围栏”，车辆可以在特定的地理围栏内完全自主的运行，但是在地理围栏之外，车辆不能自主操作，或者根本无法操作。</li><li>5级——完全自动化(Full Automation)：车辆可以在人类可以驾驶的任何地方完全自主地运行，在所有情况下应与人类驾驶员的水平一样高或比其更高。</li></ul><a id="more"></a><p>无人驾驶车的5个核心部件：</p><ul><li>计算机视觉(Computer Vision)：通过摄像头图像弄清楚我们周围的世界是怎样的。</li><li>传感器融合(Sensor Fusion)：合并来自其他传感器的数据，如激光和雷达，从而更加深入的了解我们周围的环境。</li><li>定位(Localization)：精确的确定我们在那个世界所处的位置。</li><li>路径规划(Path Planning)：绘制这个世界的路线，帮助我们到达我们想去的地方。</li><li>控制(Control)：为了让汽车沿着我们在路径规划期间建立的轨道。</li></ul><p>Apollo技术框架包含的4个层面：</p><ul><li>参考车辆平台</li><li>参考硬件平台</li><li>开源软件平台</li><li>云服务平台</li></ul><h2 id="二、高精度地图"><a href="#二、高精度地图" class="headerlink" title="二、高精度地图"></a>二、高精度地图</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本笔记记录自&lt;a href=&quot;https://cn.udacity.com/course/self-driving-car-fundamentals-featuring-apollo--ud0419&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ud0419-无人驾驶第一课：从Apollo起步&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一、无人驾驶概览&quot;&gt;&lt;a href=&quot;#一、无人驾驶概览&quot; class=&quot;headerlink&quot; title=&quot;一、无人驾驶概览&quot;&gt;&lt;/a&gt;一、无人驾驶概览&lt;/h2&gt;&lt;p&gt;无人驾驶车的6个等级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0级——基本等级：驾驶员是系统的唯一决策者。&lt;/li&gt;
&lt;li&gt;1级——驾驶员辅助(Driver Assistance)：车辆为驾驶员提供转向或加速支持，驾驶员必须保持充分参与。&lt;/li&gt;
&lt;li&gt;2级——部分自动化(Partial Automation)：车辆自动控制几项功能，如自动巡航控制和车道保持，但是驾驶员仍然必须执行自治系统处理的任何功能。&lt;/li&gt;
&lt;li&gt;3级——有条件的自动化(Conditional Automation)：车辆自主驾驶，但驾驶员必须准备在必要的时候随时接管。&lt;/li&gt;
&lt;li&gt;4级——高度自动化(No Human Interference)：车辆控制驾驶体验的所有面面，并且不期望驾驶员的介入，车辆可能根本没有方向盘或任何驾驶员控制装置，但是车辆可能被限制在某些区域，通常这被称为“地理围栏”，车辆可以在特定的地理围栏内完全自主的运行，但是在地理围栏之外，车辆不能自主操作，或者根本无法操作。&lt;/li&gt;
&lt;li&gt;5级——完全自动化(Full Automation)：车辆可以在人类可以驾驶的任何地方完全自主地运行，在所有情况下应与人类驾驶员的水平一样高或比其更高。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Notes" scheme="https://howiezhao.github.io/categories/Notes/"/>
    
    
      <category term="无人驾驶" scheme="https://howiezhao.github.io/tags/%E6%97%A0%E4%BA%BA%E9%A9%BE%E9%A9%B6/"/>
    
      <category term="Apollo" scheme="https://howiezhao.github.io/tags/Apollo/"/>
    
  </entry>
  
  <entry>
    <title>关于PowerShell</title>
    <link href="https://howiezhao.github.io/2018/07/16/about-powershell/"/>
    <id>https://howiezhao.github.io/2018/07/16/about-powershell/</id>
    <published>2018-07-16T06:56:07.000Z</published>
    <updated>2018-07-24T04:57:31.724Z</updated>
    
    <content type="html"><![CDATA[<p>PowerShell是微软用来取代CMD的一个强大的Shell。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>在不同版本的Windows中已经内置了不同版本的PowerShell，常见情况如下：</p><ul><li>Windows XP SP2 / Server 2003 SP1：PowerShell 1.0</li><li>Windows 7 / Server 2008：PowerShell 2.0，此版本包含了PowerShell ISE，即Integrated Scripting Environment(集成的脚本环境)，用来方便的编写PowerShell脚本。</li><li>Windows 8 / Server 2012：PowerShell 3.0，从此版本开始，PowerShell被集成进了WMF中，即Windows Management Framework(Windows管理框架)。</li><li>Windows 8.1 / Server 2012 R2：PowerShell 4.0</li><li>Windows 10：PowerShell 5.0，此版本的WMF包含了PowerShellGet，可用于在线下载、安装模块。</li></ul><a id="more"></a><h2 id="优势及劣势"><a href="#优势及劣势" class="headerlink" title="优势及劣势"></a>优势及劣势</h2><p>PowerShell相较于CMD的优势是不言而喻的，相较于Unix中的Shell，它的优势主要体现在2方面：面向对象特性以及与.NET的深度结合。<br>劣势当然也有，相较于CMD，至今为止它的启动速度仍然较慢，相较于Unix中的Shell，它的生态环境还欠火候，可以期待未来有更多的人关注到PowerShell。</p><h2 id="Cmdlets与pipeline"><a href="#Cmdlets与pipeline" class="headerlink" title="Cmdlets与pipeline"></a>Cmdlets与pipeline</h2><p>Cmdlets与pipeline是PowerShell中的两个核心概念，</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>PowerShell中的大多数常用命令都有对应于Linux中相关命令的别名，比如ls、mv、ps、cat、kill、wget等，下面介绍的命令为PowerShell所不同于Linux中的命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Get-Host <span class="comment">#查看PowerShell版本信息</span></span><br><span class="line"><span class="built_in">help</span> <span class="comment">#查看帮助信息</span></span><br><span class="line">Install-Module <span class="comment">#从powershellgallery.com下载安装第三方模块</span></span><br><span class="line">Import-Module <span class="comment">#导入模块，安装的模块需要先导入才能使用</span></span><br></pre></td></tr></table></figure></p><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><ul><li><a href="https://github.com/dahlbyk/posh-git" target="_blank" rel="noopener">posh-git</a>：PowerShell中的Git增强模块</li><li><a href="https://github.com/JanDeDobbeleer/oh-my-posh" target="_blank" rel="noopener">oh-my-posh</a>：类似于oh-my-zsh</li><li><a href="https://github.com/lzybkr/PSReadLine" target="_blank" rel="noopener">PSReadline</a>：一个增强的命令行编辑模块</li><li><a href="https://github.com/JulianChow94/Windows-screenFetch" target="_blank" rel="noopener">windows-screenfetch</a>：Windows下的screenfetch模块</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PowerShell是微软用来取代CMD的一个强大的Shell。&lt;/p&gt;
&lt;h2 id=&quot;版本&quot;&gt;&lt;a href=&quot;#版本&quot; class=&quot;headerlink&quot; title=&quot;版本&quot;&gt;&lt;/a&gt;版本&lt;/h2&gt;&lt;p&gt;在不同版本的Windows中已经内置了不同版本的PowerShell，常见情况如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows XP SP2 / Server 2003 SP1：PowerShell 1.0&lt;/li&gt;
&lt;li&gt;Windows 7 / Server 2008：PowerShell 2.0，此版本包含了PowerShell ISE，即Integrated Scripting Environment(集成的脚本环境)，用来方便的编写PowerShell脚本。&lt;/li&gt;
&lt;li&gt;Windows 8 / Server 2012：PowerShell 3.0，从此版本开始，PowerShell被集成进了WMF中，即Windows Management Framework(Windows管理框架)。&lt;/li&gt;
&lt;li&gt;Windows 8.1 / Server 2012 R2：PowerShell 4.0&lt;/li&gt;
&lt;li&gt;Windows 10：PowerShell 5.0，此版本的WMF包含了PowerShellGet，可用于在线下载、安装模块。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Windows" scheme="https://howiezhao.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Windows10的传递优化</title>
    <link href="https://howiezhao.github.io/2018/07/16/delivery-optimization/"/>
    <id>https://howiezhao.github.io/2018/07/16/delivery-optimization/</id>
    <published>2018-07-16T03:27:28.000Z</published>
    <updated>2018-07-16T03:56:55.923Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便快速的下载Windows更新，微软在Windows10中启用了一种新的更新机制，即<a href="https://privacy.microsoft.com/zh-CN/windows-10-windows-update-delivery-optimization" target="_blank" rel="noopener"><strong>传递优化</strong></a>(Delivery Optimization)，这本质上是一种P2P架构，换句话来说，倘若开启了传递优化功能，更新时将会额外的从别的已更新的且开启传递优化功能的电脑上下载，同时也会上传已更新的文件到需要更新的电脑上。值得注意的是，传递优化对局域网进行了特殊处理，即当局域网内一台电脑完成更新后，传递优化会使得此局域网内的其他电脑依次完成更新。<br>开启或关闭传递优化的设置路径为：设置 ——&gt; 更新和安全 ——&gt; Windows更新 ——&gt; 高级选项 ——&gt; 传递优化。传递优化用于上传的文件路径位于：C:\Windows\Logs\dosvc。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了方便快速的下载Windows更新，微软在Windows10中启用了一种新的更新机制，即&lt;a href=&quot;https://privacy.microsoft.com/zh-CN/windows-10-windows-update-delivery-optimization
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Windows" scheme="https://howiezhao.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>useradd与adduser</title>
    <link href="https://howiezhao.github.io/2018/07/16/useradd-adduser/"/>
    <id>https://howiezhao.github.io/2018/07/16/useradd-adduser/</id>
    <published>2018-07-16T02:44:41.000Z</published>
    <updated>2018-07-24T05:37:13.904Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux中创建用户可以用<code>useradd</code>或者<code>adduser</code>，值得注意的是创建的用户并不一定可以登录，登录的用户肯定要有它的用户主目录、登录Shell等相关配置，而这两个命令之间的差异就在于此。</p><h2 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h2><p>当使用<code>adduser howie</code>命令时，系统除了创建howie用户，还会自动创建用户主目录、同名用户组、登录Shell等，并提示输入用户密码，这一切操作都将以一个对话的形式完成。</p><h2 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h2><p>当使用<code>useradd howie</code>命令时，系统只会创建howie用户，而不会创建用户密码、用户主目录、同名用户组、登录shell等，若要指定密码，可以接着采用<code>passwd howie</code>命令。其次，<code>useradd</code>有众多参数，我们可以通过使用这些参数来达到和<code>adduser</code>一样的效果，如<code>useradd -d /home/howie -m -s /bin/bash howie</code>，不过注意之后还得使用<code>passwd</code>命令创建密码，当然也可以使用<code>-p</code>参数直接设置密码，但这样会将密码直接显示在终端屏幕上，不安全。</p><h2 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h2><p>当使用<code>userdel howie</code>命令时，系统只会删除howie用户，并不会删除用户主目录以及用户邮箱目录，因此可以使用<code>-r</code>参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux中创建用户可以用&lt;code&gt;useradd&lt;/code&gt;或者&lt;code&gt;adduser&lt;/code&gt;，值得注意的是创建的用户并不一定可以登录，登录的用户肯定要有它的用户主目录、登录Shell等相关配置，而这两个命令之间的差异就在于此。&lt;/p&gt;
&lt;h2 id=&quot;a
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>云服务的三种模式</title>
    <link href="https://howiezhao.github.io/2018/07/15/xaas/"/>
    <id>https://howiezhao.github.io/2018/07/15/xaas/</id>
    <published>2018-07-15T08:58:01.000Z</published>
    <updated>2018-07-16T09:39:36.674Z</updated>
    
    <content type="html"><![CDATA[<p>云服务的模式一般有IaaS、PaaS、SaaS三种，既然是云服务，也即我们不用购买真实的计算设备，所有的模式都是基于此之上的。</p><h2 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h2><p><strong>IaaS</strong>，Infrastructure as a Service(基础设施即服务)，云服务的最底层，服务商提供操作系统、存储设施、硬件配置等资源，典型的例子是<strong>VPS</strong>，即Virtual Private Server(虚拟专用服务器)，这类服务一般提供必要的Shell接口，可使用户连接到操作系统进行相关配置，常见的VPS厂商有<a href="https://aws.amazon.com/cn/ec2/" target="_blank" rel="noopener">Amazon EC2</a>、<a href="https://www.aliyun.com/product/ecs" target="_blank" rel="noopener">阿里云 ECS</a>等。</p><h2 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h2><p><strong>PaaS</strong>，Platform as a Service(平台即服务)，云服务的中间层，服务商提供必要的应用，用户无权访问操作系统及硬件等资源，典型的例子是<strong>虚拟空间</strong>，这类服务一般会提供必要的Web服务器、数据库等，用户可以直接在其上部署Web应用，我用过的虚拟空间有<a href="http://www.laoxuehost.com/" target="_blank" rel="noopener">老薛主机</a>，常见的PaaS厂商有<a href="https://cloud.google.com/appengine/" target="_blank" rel="noopener">Google App Engine</a>。</p><h2 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h2><p><strong>SaaS</strong>，Software as a Service(软件即服务)，云服务的最高层，直接提供现成的应用供用户使用，用户所付出的精力最少，例如本站采用的Hexo、WordPress等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;云服务的模式一般有IaaS、PaaS、SaaS三种，既然是云服务，也即我们不用购买真实的计算设备，所有的模式都是基于此之上的。&lt;/p&gt;
&lt;h2 id=&quot;IaaS&quot;&gt;&lt;a href=&quot;#IaaS&quot; class=&quot;headerlink&quot; title=&quot;IaaS&quot;&gt;&lt;/a&gt;Iaa
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>编译与构建</title>
    <link href="https://howiezhao.github.io/2018/07/15/compile-build/"/>
    <id>https://howiezhao.github.io/2018/07/15/compile-build/</id>
    <published>2018-07-15T06:29:13.000Z</published>
    <updated>2018-07-15T08:50:54.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><strong>编译(compile)</strong>，一般而言是将源代码转换成汇编代码，用以实现这种过程的工具称为<strong>编译器(compiler)</strong>。但要注意，编译器在同一时刻只能转换一个编译单元，所谓<strong>编译单元</strong>是指单个的源文件。目前在Linux中使用最广的编译器是<strong>GCC</strong>，即GNU Compiler Collection(GNU编译器套装)，GCC的原名为GNU C Compiler(GNU C语言编译器)，因为在后续逐渐支持了C++、Java等更多的语言，所以更改了其缩写的含义。使用GCC编译C语言源代码的一般格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>若不指定生成文件，则默认生成a.out。<br><a id="more"></a></p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>程序通常由多个编译单元组成，倘若逐个的去编译，这多少显得有点琐碎，因此我们需要一个自动化工具用来从源代码生成用户可以使用的目标，而这个工具就是<strong>构建系统(build system)</strong>，构建系统所作的就是<strong>构建(build)</strong>，构建的过程中肯定会调用到编译。从这个意义上来说，构建的范围比编译更广。在Linux中使用最广的构建系统是<strong>GNU make</strong>，它会读取<strong>makefile</strong>文件中的配置信息来完成构建，makefile的简要格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">editor : main.o text.o</span><br><span class="line">    gcc -o editor main.o text.o</span><br><span class="line">main.o : main.c def.h</span><br><span class="line">    gcc -c main.c  <span class="comment">#-c参数指定生成.o文件</span></span><br><span class="line">text.o : text.c com.h</span><br><span class="line">    gcc -c text.c</span><br><span class="line">install : editor</span><br><span class="line">    mv editor /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure></p><p>冒号前面为<strong>target</strong>，即要生成的文件；冒号后面为<strong>dependencies</strong>，即被依赖的文件；每一个target:dependencies对的下一行为要执行的命令。当make不带参数时，默认执行第一个target。target也可以是要求make要完成的动作，执行这种target后并不能得到和target同名的文件，因此，也称做<strong>伪target</strong>，如第7行所示。dependencies可以为空，如常用的target为clean时，就没有依赖，只有命令。<br>当输入<code>make</code>或<code>make editor</code>，即可开始构建。若editor这个target文件不存在，或者main.o、text.o这两个依赖文件被修改，都会导致make调用其下的命令<code>gcc -o editor main.o text.o</code>；接下来，由于引用到main.o和text.o，make会检查main.o的依赖main.c、def.h有无更新，如果有，则执行其下的命令<code>gcc -c main.c</code>；同理，也适用于text.o。当输入<code>make install</code>，make会检查install的依赖editor是否是最新，如果是，则执行其下的命令<code>mv editor /usr/local</code>。<br>makefile中也可以包含<strong>宏</strong>，上面的文件使用宏后如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OBJECTS = main.o text.o</span><br><span class="line">INSTALL_PATH = /usr/<span class="built_in">local</span></span><br><span class="line">editor : $(OBJECTS)</span><br><span class="line">    gcc -o editor $(OBJECTS)</span><br><span class="line">main.o : main.c</span><br><span class="line">    gcc -c main.c</span><br><span class="line">text.o : text.c</span><br><span class="line">    gcc -c text.c</span><br><span class="line">install : editor</span><br><span class="line">    mv editor $(INSTALL_PATH)</span><br></pre></td></tr></table></figure></p><h2 id="另外的"><a href="#另外的" class="headerlink" title="另外的"></a>另外的</h2><p>为了在Windows中使用GCC，诞生了<a href="http://www.mingw.org/" target="_blank" rel="noopener"><strong>MinGW</strong></a> 项目，即Minimalist GNU for Windows(适用于Windows的极简GNU)，它是将GCC编译器和GNU Binutils移植到Win32平台下的产物，又被称为mingw32。另有可用于产生32位及64位Windows可执行文件的<a href="https://mingw-w64.org/doku.php/start" target="_blank" rel="noopener"><strong>MinGW-w64</strong></a>项目，是从原MinGW项目产生的分支。<br>Java世界中使用最广的构建系统是<strong>Maven</strong>，而在Android Studio中则使用到了后起之秀<strong>Gradle</strong>。<br>C语言从源代码到可执行文件的过程依次经过了<strong>预处理</strong>、<strong>编译</strong>、<strong>链接</strong>这几个步骤，即我们常说的GCC是编译器，但它实际可以完成的工作不止是编译，具体生成结果取决于我们的参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;编译(compile)&lt;/strong&gt;，一般而言是将源代码转换成汇编代码，用以实现这种过程的工具称为&lt;strong&gt;编译器(compiler)&lt;/strong&gt;。但要注意，编译器在同一时刻只能转换一个编译单元，所谓&lt;strong&gt;编译单元&lt;/strong&gt;是指单个的源文件。目前在Linux中使用最广的编译器是&lt;strong&gt;GCC&lt;/strong&gt;，即GNU Compiler Collection(GNU编译器套装)，GCC的原名为GNU C Compiler(GNU C语言编译器)，因为在后续逐渐支持了C++、Java等更多的语言，所以更改了其缩写的含义。使用GCC编译C语言源代码的一般格式如下：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ gcc test.c -o &lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;若不指定生成文件，则默认生成a.out。&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统加固</title>
    <link href="https://howiezhao.github.io/2018/05/19/linux-reinforcement/"/>
    <id>https://howiezhao.github.io/2018/05/19/linux-reinforcement/</id>
    <published>2018-05-19T05:59:05.000Z</published>
    <updated>2018-07-24T11:51:19.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="帐户与口令"><a href="#帐户与口令" class="headerlink" title="帐户与口令"></a>帐户与口令</h2><p>此方面的加固主要为了防止针对帐户的暴力破解。</p><p>禁用或删除无用帐户：<br>使用命令<code>userdel &lt;用户名&gt;</code>删除不必要的帐户，使用参数<code>-r</code>即可删除相应用户的家目录和邮箱目录。<br>使用命令<code>passwd -l &lt;用户名&gt;</code>锁定不必要的帐户，解锁可使用<code>passwd -u &lt;用户名&gt;</code>。</p><p>检查特殊帐户：<br>使用命令<code>awk -F: &#39;($2==&quot;&quot;)&#39; /etc/shadow</code>查看空口令帐户，若存在，则使用命令<code>passwd &lt;用户名&gt;</code>为空口令帐户设定密码。<br>使用命令<code>awk -F: &#39;($3==0)&#39; /etc/passwd</code>查看uid为0的帐户，确认uid为0的帐户只有root帐户。</p><p>添加口令策略：<br>使用命令<code>change -m 0 -M 30 -E 2020-01-01 -W 7 &lt;用户名&gt;</code>修改帐户口令策略，<code>-m</code>表示密码最小使用天数，<code>-M</code>表示密码最大使用天数，<code>-E</code>表示密码到期时间，<code>-W</code>表示密码到期前多少天提醒。或者可以直接编辑/etc/login.defs文件进行修改。<a id="more"></a></p><p>设置用户锁定：<br>在CentOS7中，编辑/etc/pam.d/system-auth文件，添加<code>auth required pam_tally2.so onerr=fail deny=6 unlock_time=300</code>此行，表示当密码连续输错6次后锁定，锁定时间300秒。<br>限制能su到root的用户：<br>编辑/etc/pam.d/su文件，添加<code>auth required pam_wheel.so group=test</code>此行，表示只允许test组用户su到root。</p><h2 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h2><p>服务越少，系统越安全。</p><p>关闭不必要的服务：<br>在CentOS中，使用命令<code>chkconfig --level &lt;init级别&gt; &lt;服务名&gt; on|off|reset</code>设置服务在指定init级别下开机是否启动。</p><p>SSH服务安全：<br>编辑/etc/ssh/sshd_config文件，修改默认端口，即<code>Port</code>项；禁止root用户远程登录，即<code>PermitRootLogin</code>项；禁止空密码登录，即<code>PermitEmptyPasswords</code>项；限制登录密码输错次数。</p><h2 id="文件系统安全"><a href="#文件系统安全" class="headerlink" title="文件系统安全"></a>文件系统安全</h2><p>权限越小，系统越安全</p><p>设置umask值：<br>编辑/etc/profile文件，修改umask值为027。</p><p>设置登录超时：<br>编辑/etc/profile文件，添加<code>TIMEOUT=180</code>，即登录后无操作3分钟将超时断开连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;帐户与口令&quot;&gt;&lt;a href=&quot;#帐户与口令&quot; class=&quot;headerlink&quot; title=&quot;帐户与口令&quot;&gt;&lt;/a&gt;帐户与口令&lt;/h2&gt;&lt;p&gt;此方面的加固主要为了防止针对帐户的暴力破解。&lt;/p&gt;
&lt;p&gt;禁用或删除无用帐户：&lt;br&gt;使用命令&lt;code&gt;userdel &amp;lt;用户名&amp;gt;&lt;/code&gt;删除不必要的帐户，使用参数&lt;code&gt;-r&lt;/code&gt;即可删除相应用户的家目录和邮箱目录。&lt;br&gt;使用命令&lt;code&gt;passwd -l &amp;lt;用户名&amp;gt;&lt;/code&gt;锁定不必要的帐户，解锁可使用&lt;code&gt;passwd -u &amp;lt;用户名&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;检查特殊帐户：&lt;br&gt;使用命令&lt;code&gt;awk -F: &amp;#39;($2==&amp;quot;&amp;quot;)&amp;#39; /etc/shadow&lt;/code&gt;查看空口令帐户，若存在，则使用命令&lt;code&gt;passwd &amp;lt;用户名&amp;gt;&lt;/code&gt;为空口令帐户设定密码。&lt;br&gt;使用命令&lt;code&gt;awk -F: &amp;#39;($3==0)&amp;#39; /etc/passwd&lt;/code&gt;查看uid为0的帐户，确认uid为0的帐户只有root帐户。&lt;/p&gt;
&lt;p&gt;添加口令策略：&lt;br&gt;使用命令&lt;code&gt;change -m 0 -M 30 -E 2020-01-01 -W 7 &amp;lt;用户名&amp;gt;&lt;/code&gt;修改帐户口令策略，&lt;code&gt;-m&lt;/code&gt;表示密码最小使用天数，&lt;code&gt;-M&lt;/code&gt;表示密码最大使用天数，&lt;code&gt;-E&lt;/code&gt;表示密码到期时间，&lt;code&gt;-W&lt;/code&gt;表示密码到期前多少天提醒。或者可以直接编辑/etc/login.defs文件进行修改。
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统加固</title>
    <link href="https://howiezhao.github.io/2018/05/19/windows-reinforcement/"/>
    <id>https://howiezhao.github.io/2018/05/19/windows-reinforcement/</id>
    <published>2018-05-19T05:58:51.000Z</published>
    <updated>2018-07-24T13:29:23.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>下面这几项应为每一个使用Windows的用户的最最基本安全配置：</p><ol><li>开启Windows防火墙</li><li>设置用户帐户控制(UAC)为合适级别</li><li>保持Windows更新</li></ol><a id="more"></a><h2 id="帐户安全"><a href="#帐户安全" class="headerlink" title="帐户安全"></a>帐户安全</h2><p>此方面的加固主要是为了防止针对帐户的暴力破解，帐户是黑客入侵系统的突破口，帐户越多，危险系数越高。</p><p>停用Guest帐户：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中禁用Guest帐户，并为Guest帐户设置复杂密码，并拒绝远程访问。</p><p>重命名或禁用Administrator帐户：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中为Administrator帐户重命名，或直接禁用。</p><p>创建陷阱帐户：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中创建一个名为Administrator的本地帐户，并将它的权限设置成最低，加上一个超过10位的强密码。可通过将其隶属于Guest组已达到权限最低。</p><p>限制用户数量：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中删除所有的测试帐户、共享帐户和普通部门帐户，一般情况下，如果系统用户超过10个，一般总会存在一两个弱口令帐户。</p><p>开启帐户锁定策略：<br>在<strong>本地安全策略</strong>的<strong>帐户锁定策略</strong>中设置帐户锁定阈值为3次，帐户锁定时间为30分钟，重置帐户锁定计数器为30分钟之后。</p><h2 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h2><p>一个安全操作系统的基本原则是：最小的权限+最少的服务=最大的安全。</p><p>开启密码策略：<br>在<strong>本地安全策略</strong>的<strong>密码策略</strong>中启用密码复杂性要求，设置密码长度最小值为7，密码最短使用期限为1，密码最长使用期限为42，强制密码历史为24，禁用以可还原的加密储存密码。</p><p>设置双重加密帐户保护：<br>在运行对话框中输入syskey，启用SAM数据库加密工具，为Windows登录设置双重加密，注意此功能在Windows10中已被剔除。</p><p>取消默认共享：<br>编辑注册表键HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\LanmanServer\Parameters，新建项AutoShareServer，值为0，即可关闭盘符默认共享，新建项AutoShareWks，值为0，即可关闭ADMIN默认共享。</p><p>开启审核策略：<br>在<strong>本地安全策略</strong>的<strong>审核策略</strong>中审核所有的成功失败操作，记录的信息可以在<strong>事件查看器</strong>的<strong>Windows日志</strong>中查看。</p><p>修改TTL值：<br>编辑注册表键HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Tcpip\Parameters，新建项defaultTTL，随便赋值，以防黑客通过ping获取TTL以鉴别操作系统类型。</p><p>关闭不必要的服务：<br>Windows默认会启动多个服务，可以在<strong>计算机管理</strong>的<strong>服务</strong>中禁用相关服务，下面列出了一些可以禁用的服务：</p><ul><li>COM+ Event System</li><li>Computer Browser</li><li>Distributed Link Tracking Client</li><li>Routing and Remote Access</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本配置&quot;&gt;&lt;a href=&quot;#基本配置&quot; class=&quot;headerlink&quot; title=&quot;基本配置&quot;&gt;&lt;/a&gt;基本配置&lt;/h2&gt;&lt;p&gt;下面这几项应为每一个使用Windows的用户的最最基本安全配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开启Windows防火墙&lt;/li&gt;
&lt;li&gt;设置用户帐户控制(UAC)为合适级别&lt;/li&gt;
&lt;li&gt;保持Windows更新&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Windows" scheme="https://howiezhao.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>802.11协议分析</title>
    <link href="https://howiezhao.github.io/2018/05/11/80211/"/>
    <id>https://howiezhao.github.io/2018/05/11/80211/</id>
    <published>2018-05-11T10:53:11.000Z</published>
    <updated>2018-05-11T10:53:45.387Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>IPSec运行机制</title>
    <link href="https://howiezhao.github.io/2018/05/11/ipsec/"/>
    <id>https://howiezhao.github.io/2018/05/11/ipsec/</id>
    <published>2018-05-11T10:48:46.000Z</published>
    <updated>2018-05-11T10:51:42.647Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>IP协议分析</title>
    <link href="https://howiezhao.github.io/2018/05/11/ip/"/>
    <id>https://howiezhao.github.io/2018/05/11/ip/</id>
    <published>2018-05-11T10:48:39.000Z</published>
    <updated>2018-05-12T15:21:22.048Z</updated>
    
    <content type="html"><![CDATA[<p>IP(Internet Protocol，网际协议)</p><h2 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h2><p><img src="/images/ip.PNG" alt=""><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IP(Internet Protocol，网际协议)&lt;/p&gt;
&lt;h2 id=&quot;数据报格式&quot;&gt;&lt;a href=&quot;#数据报格式&quot; class=&quot;headerlink&quot; title=&quot;数据报格式&quot;&gt;&lt;/a&gt;数据报格式&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/ip.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议分析</title>
    <link href="https://howiezhao.github.io/2018/05/11/tcp/"/>
    <id>https://howiezhao.github.io/2018/05/11/tcp/</id>
    <published>2018-05-11T10:48:30.000Z</published>
    <updated>2018-05-12T15:18:47.029Z</updated>
    
    <content type="html"><![CDATA[<p>TCP(Transmission Control Protocol，传输控制协议)</p><h2 id="报文段结构"><a href="#报文段结构" class="headerlink" title="报文段结构"></a>报文段结构</h2><p><img src="/images/tcp.PNG" alt=""><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP(Transmission Control Protocol，传输控制协议)&lt;/p&gt;
&lt;h2 id=&quot;报文段结构&quot;&gt;&lt;a href=&quot;#报文段结构&quot; class=&quot;headerlink&quot; title=&quot;报文段结构&quot;&gt;&lt;/a&gt;报文段结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/tcp.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
