<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Howie&#39;s Notes</title>
  
  <subtitle>Machine Learning and Cyber Security</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://howiezhao.github.io/"/>
  <updated>2018-09-14T14:05:58.087Z</updated>
  <id>https://howiezhao.github.io/</id>
  
  <author>
    <name>Howie Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端相关术语</title>
    <link href="https://howiezhao.github.io/2018/09/14/front-end-terminology/"/>
    <id>https://howiezhao.github.io/2018/09/14/front-end-terminology/</id>
    <published>2018-09-14T13:46:24.000Z</published>
    <updated>2018-09-14T14:05:58.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h2><p>轮播图，在Bootstrap中又被称为Carousel，是当今网站主页非常常用的一种动态效果。</p><h2 id="视差滚动"><a href="#视差滚动" class="headerlink" title="视差滚动"></a>视差滚动</h2><p>视差滚动，又称Parallax Scrolling，指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</p><h2 id="ToolTip"><a href="#ToolTip" class="headerlink" title="ToolTip"></a>ToolTip</h2><p>ToolTip，在Bootstrap 4 中又被称为提示冒泡</p><h2 id="手风琴效果"><a href="#手风琴效果" class="headerlink" title="手风琴效果"></a>手风琴效果</h2><p>手风琴效果，又被称为Accordion</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;轮播图&quot;&gt;&lt;a href=&quot;#轮播图&quot; class=&quot;headerlink&quot; title=&quot;轮播图&quot;&gt;&lt;/a&gt;轮播图&lt;/h2&gt;&lt;p&gt;轮播图，在Bootstrap中又被称为Carousel，是当今网站主页非常常用的一种动态效果。&lt;/p&gt;
&lt;h2 id=&quot;视差滚动&quot;&gt;
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Web" scheme="https://howiezhao.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>网站的WWW问题</title>
    <link href="https://howiezhao.github.io/2018/09/12/web-www/"/>
    <id>https://howiezhao.github.io/2018/09/12/web-www/</id>
    <published>2018-09-12T14:07:51.000Z</published>
    <updated>2018-09-12T14:09:12.586Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Web" scheme="https://howiezhao.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX小记</title>
    <link href="https://howiezhao.github.io/2018/09/12/latex/"/>
    <id>https://howiezhao.github.io/2018/09/12/latex/</id>
    <published>2018-09-12T14:05:52.000Z</published>
    <updated>2018-09-12T14:06:35.727Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>辗转相除法</title>
    <link href="https://howiezhao.github.io/2018/09/12/euclidean/"/>
    <id>https://howiezhao.github.io/2018/09/12/euclidean/</id>
    <published>2018-09-12T14:00:58.000Z</published>
    <updated>2018-09-12T14:01:32.369Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>IRC是什么</title>
    <link href="https://howiezhao.github.io/2018/09/12/what-is-irc/"/>
    <id>https://howiezhao.github.io/2018/09/12/what-is-irc/</id>
    <published>2018-09-12T13:59:18.000Z</published>
    <updated>2018-09-12T14:00:01.455Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ifconfig与ip</title>
    <link href="https://howiezhao.github.io/2018/09/12/ifconfig-ip/"/>
    <id>https://howiezhao.github.io/2018/09/12/ifconfig-ip/</id>
    <published>2018-09-12T13:53:46.000Z</published>
    <updated>2018-09-12T13:54:21.943Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>巴科斯范式</title>
    <link href="https://howiezhao.github.io/2018/09/12/bnf/"/>
    <id>https://howiezhao.github.io/2018/09/12/bnf/</id>
    <published>2018-09-12T13:51:01.000Z</published>
    <updated>2018-09-12T13:52:03.353Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>基于人的信息收集</title>
    <link href="https://howiezhao.github.io/2018/09/09/human-based-information-gathering/"/>
    <id>https://howiezhao.github.io/2018/09/09/human-based-information-gathering/</id>
    <published>2018-09-09T05:43:26.000Z</published>
    <updated>2018-09-11T04:30:06.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h2><p>根据目标朋友圈、微博等社交网络所发的照片，查看Exif信息，可得到目标当时的位置、相机规格等信息。</p><h2 id="WiFi"><a href="#WiFi" class="headerlink" title="WiFi"></a>WiFi</h2><p>根据目标所连接的WiFi名称可大致判断目标所在的位置，多数情况下，WiFi的名称一般为所在旅馆、餐馆、机构等名称的缩写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;照片&quot;&gt;&lt;a href=&quot;#照片&quot; class=&quot;headerlink&quot; title=&quot;照片&quot;&gt;&lt;/a&gt;照片&lt;/h2&gt;&lt;p&gt;根据目标朋友圈、微博等社交网络所发的照片，查看Exif信息，可得到目标当时的位置、相机规格等信息。&lt;/p&gt;
&lt;h2 id=&quot;WiFi&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="社会工程学" scheme="https://howiezhao.github.io/tags/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Docker入坑指南</title>
    <link href="https://howiezhao.github.io/2018/08/31/docker/"/>
    <id>https://howiezhao.github.io/2018/08/31/docker/</id>
    <published>2018-08-31T08:59:28.000Z</published>
    <updated>2018-09-10T14:14:39.932Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一种基于Linux的容器化技术，类似于轻量的虚拟机。它采用C/S架构，使用Go语言开发。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Docker分为2个版本：<strong>社区版</strong>(Community Edition, CE)和<strong>企业版</strong>(Enterprise Edition, EE)，顾名思义，企业版是收费的。针对macOS10.10.3和Windows 10，Docker还推出了<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker Desktop</a>，Docker Desktop又分为2个渠道(channel)，<strong>稳定渠道</strong>(Stable)和<strong>抢先渠道</strong>(Edge)，需要注意的是，Docker Desktop对系统是有要求的，例如，针对Win10的<a href="https://store.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener">Docker for Windows</a>因为要用到Hyper-V虚拟机，所以要求系统是64位专业版或企业版并开启Hyper-V功能。针对老版本的Windows或macOS，可以使用<a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">Docker Toolbox</a>，它会附带安装一个VirtualBox虚拟机。<br>使用<code>docker version</code>可以查看docker版本，直接输入<code>docker</code>可以查看docker相关命令。<br><a id="more"></a></p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p><strong>镜像</strong>(image)文件可以用来生成容器实例，其类似于在虚拟机中安装操作系统时所使用的ISO镜像。<br>image文件可以包含一个tag(标签)，即版本号。<br>你可以使用远程仓库中别人制作好的image文件，也可以自己制作image文件。要制作image文件就要编写<strong>Dockerfile</strong>文件，其类似于Makefile文件<br>image的常用命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有image文件</span></span><br><span class="line">docker image ls</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的image文件</span></span><br><span class="line">docker image rm [image-name]</span><br><span class="line">docker rmi [image-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的image文件从远程仓库拉取到本地</span></span><br><span class="line">docker image pull [image-name]</span><br><span class="line">docker pull [image-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用当前文件夹中的Dockerfile制作一个名为demo、tag为0.0.1的image文件</span></span><br><span class="line"><span class="comment"># 若不指定tag，则默认的标签为latest</span></span><br><span class="line">docker image build -t demo:0.0.1 .</span><br><span class="line">docker build -t demo:0.0.1 .</span><br></pre></td></tr></table></figure></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>image文件生成的容器(container)实例，本身也是一个文件，称为<strong>容器文件</strong>。当关闭容器时，并不会删除容器文件，只是容器停止运行而已。<br>类似于在虚拟机中安装的操作系统，其本身会在硬盘中创建一系列文件，当关闭操作系统时，相应的文件并不会删除。<br>container的常用命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从指定的image文件生成一个正在运行的容器实例，</span></span><br><span class="line"><span class="comment"># 若本地没有指定的image文件，会从远程仓库中自动抓取下来</span></span><br><span class="line">docker container run [image-name]</span><br><span class="line">docker run [image-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机正在运行的容器，使用参数`-all`列出所有容器文件</span></span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">docker container rm [container-id]</span><br><span class="line">docker rm [container-id]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭指定的容器实例</span></span><br><span class="line">docker container <span class="built_in">kill</span> [container-id]</span><br><span class="line">docker <span class="built_in">kill</span> [container-id]</span><br></pre></td></tr></table></figure></p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p><strong>仓库</strong>(repository)是不同标签的image的集合，注册处(registry)又是不同仓库的集合，Docker的官方Registry是<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，类似于GitHub。使用<code>docker login</code>可以登录到自己在Docker Hub上注册的帐号。值得注意的是，国内访问Docker Hub速度较慢，建议设置代理或使用<a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">国内镜像站</a>。一般来说，国内镜像站只包含流行的公有镜像，私有镜像仍需要从Docker Hub中拉取。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker是一种基于Linux的容器化技术，类似于轻量的虚拟机。它采用C/S架构，使用Go语言开发。&lt;/p&gt;
&lt;h2 id=&quot;版本&quot;&gt;&lt;a href=&quot;#版本&quot; class=&quot;headerlink&quot; title=&quot;版本&quot;&gt;&lt;/a&gt;版本&lt;/h2&gt;&lt;p&gt;Docker分为2个版本：&lt;strong&gt;社区版&lt;/strong&gt;(Community Edition, CE)和&lt;strong&gt;企业版&lt;/strong&gt;(Enterprise Edition, EE)，顾名思义，企业版是收费的。针对macOS10.10.3和Windows 10，Docker还推出了&lt;a href=&quot;https://www.docker.com/products/docker-desktop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker Desktop&lt;/a&gt;，Docker Desktop又分为2个渠道(channel)，&lt;strong&gt;稳定渠道&lt;/strong&gt;(Stable)和&lt;strong&gt;抢先渠道&lt;/strong&gt;(Edge)，需要注意的是，Docker Desktop对系统是有要求的，例如，针对Win10的&lt;a href=&quot;https://store.docker.com/editions/community/docker-ce-desktop-windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker for Windows&lt;/a&gt;因为要用到Hyper-V虚拟机，所以要求系统是64位专业版或企业版并开启Hyper-V功能。针对老版本的Windows或macOS，可以使用&lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker Toolbox&lt;/a&gt;，它会附带安装一个VirtualBox虚拟机。&lt;br&gt;使用&lt;code&gt;docker version&lt;/code&gt;可以查看docker版本，直接输入&lt;code&gt;docker&lt;/code&gt;可以查看docker相关命令。&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>Git小记</title>
    <link href="https://howiezhao.github.io/2018/08/31/git/"/>
    <id>https://howiezhao.github.io/2018/08/31/git/</id>
    <published>2018-08-31T08:59:18.000Z</published>
    <updated>2018-09-11T05:03:36.197Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前最流行的<strong>分布式版本控制系统</strong>(Distributed Version Control System, DVCS)，所谓版本控制，即可以随时记录并切换文件的不同版本。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git共有3个配置文件，分别是：</p><ul><li><code>/etc/gitconfig</code>文件用于配置所有用户的配置信息，使用<code>git config --system</code>命令配置</li><li>某个用户主目录下的<code>.gitconfig</code>文件只适用于该用户，使用<code>git config --global</code>命令配置</li><li>当前Git仓库的<code>.git/config</code>仅针对当前项目，直接使用<code>git config</code>命令进行配置</li></ul><p>注意：每一个级别会覆盖上一级别的配置，所以<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。<br>一般来说，针对新安装的Git环境，要配置如下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置提交时使用的用户名和邮箱，必须配置</span></span><br><span class="line">git config --global user.name <span class="string">"Howie Zhao"</span></span><br><span class="line">git config --global user.email howiezhaohr@hotmail.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启颜色显示</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>另外，Git默认使用的编辑器是Vim，若要配置成自己喜欢的编辑器(如Emacs)，可使用命令：<code>git config --global core.editor emacs</code>。<br>最后，你可以使用<code>git config --list</code>来查看所有配置信息。<br><a id="more"></a></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>要开始对某个项目进行版本控制，需要先在其所在路径下执行<code>git init</code>进行初始化，此命令会在当前路径下创建一个<code>.git</code>的隐藏文件夹，这就是Git仓库目录。<br>Git分为3个区域，Git仓库、工作目录、暂存区域：</p><ul><li><strong>Git仓库目录</strong>是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</li><li><strong>工作目录</strong>是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li><li><strong>暂存区域</strong>是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。</li></ul><p>基本的 Git 工作流程如下：</p><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><p>如果Git目录中保存着的特定版本文件，就属于<strong>已提交状态</strong>(committed)。如果作了修改并已放入暂存区域，就属于<strong>已暂存状态</strong>(staged)。如果自上次取出后，作了修改但还没有放到暂存区域，就是<strong>已修改状态</strong>(modified)。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>使用<code>git add test.txt</code>可以将需要被追踪的文件(test.txt)添加到缓存区，使用<code>git commit -m &#39;first commit&#39;</code>可以将缓存区的内容提交到本地仓库，参数<code>-m</code>指定提交时的附带信息，使用<code>git push</code>可以将本地仓库推送到远程仓库，使用<code>git clone</code>可以将远程仓库克隆到本地，使用<code>git pull</code>可以将远程仓库的更新拉取到本地仓库。<br>使用<code>git status</code>可以查看Git仓库状态，使用<code>git log</code>可以查看commit记录。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p><strong>直接记录快照，而非差异比较</strong>：Git与其他版本控制系统的主要区别在于对待数据的方法，其他的VCS主要记录不同版本之间的差异，而Git则相当于直接记录不同版本的快照。<br><strong>近乎所有操作都是本地执行</strong>：在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。<br><strong>Git保证完整性</strong>：Git中所有数据在存储前都计算校验和(SHA-1)，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。若你在传送过程中丢失信息或损坏文件，Git就能发现。<br><strong>Git一般只添加数据</strong>：你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>应明确一点，Git是由Linux创始人Linus Torvalds开发的分布式版本控制系统，而GitHub是使用Git实现的代码托管网站，两者并非一类。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>在命令行中直接输入<code>git</code>，可查看相关命令，要了解更多关于Git的内容，可以参考<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">《Pro Git》</a>一书。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是目前最流行的&lt;strong&gt;分布式版本控制系统&lt;/strong&gt;(Distributed Version Control System, DVCS)，所谓版本控制，即可以随时记录并切换文件的不同版本。&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;p&gt;Git共有3个配置文件，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/gitconfig&lt;/code&gt;文件用于配置所有用户的配置信息，使用&lt;code&gt;git config --system&lt;/code&gt;命令配置&lt;/li&gt;
&lt;li&gt;某个用户主目录下的&lt;code&gt;.gitconfig&lt;/code&gt;文件只适用于该用户，使用&lt;code&gt;git config --global&lt;/code&gt;命令配置&lt;/li&gt;
&lt;li&gt;当前Git仓库的&lt;code&gt;.git/config&lt;/code&gt;仅针对当前项目，直接使用&lt;code&gt;git config&lt;/code&gt;命令进行配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：每一个级别会覆盖上一级别的配置，所以&lt;code&gt;.git/config&lt;/code&gt;的配置变量会覆盖&lt;code&gt;/etc/gitconfig&lt;/code&gt;中的配置变量。&lt;br&gt;一般来说，针对新安装的Git环境，要配置如下信息：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 配置提交时使用的用户名和邮箱，必须配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name &lt;span class=&quot;string&quot;&gt;&quot;Howie Zhao&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email howiezhaohr@hotmail.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 开启颜色显示&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global color.ui &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另外，Git默认使用的编辑器是Vim，若要配置成自己喜欢的编辑器(如Emacs)，可使用命令：&lt;code&gt;git config --global core.editor emacs&lt;/code&gt;。&lt;br&gt;最后，你可以使用&lt;code&gt;git config --list&lt;/code&gt;来查看所有配置信息。&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>telnet协议分析</title>
    <link href="https://howiezhao.github.io/2018/08/24/telnet/"/>
    <id>https://howiezhao.github.io/2018/08/24/telnet/</id>
    <published>2018-08-24T11:44:44.000Z</published>
    <updated>2018-09-12T13:56:54.920Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SSH协议分析</title>
    <link href="https://howiezhao.github.io/2018/08/24/ssh/"/>
    <id>https://howiezhao.github.io/2018/08/24/ssh/</id>
    <published>2018-08-24T11:44:35.000Z</published>
    <updated>2018-08-24T14:44:03.332Z</updated>
    
    <content type="html"><![CDATA[<p>SSH(Secure Shell)即<strong>安全外壳协议</strong>，是一种位于应用层的加密的网络传输协议，虽然任何网络服务都可以通过SSH实现安全传输，但其最常见的用途还是远程登录，是Telnet等非安全Shell的替代品。</p><h2 id="OpenSSH的运行机制"><a href="#OpenSSH的运行机制" class="headerlink" title="OpenSSH的运行机制"></a>OpenSSH的运行机制</h2><p>SSH是一种协议，其实现多种多样，目前使用最广泛的实现是OpenSSH项目。当使用<code>ssh user@host</code>命令进行登录时，所完成的整个过程如下：</p><ol><li>远程主机收到用户的登录请求，把自己的公钥发给用户</li><li>用户使用这个公钥，将登录密码加密后，发送给远程主机</li><li>远程主机用自己的私钥，解密登录密码，若密码正确，则同意用户登录</li><li>后续过程中，用户发送的信息都采用此方式进行加密发送</li></ol><p>因为不像HTTPS协议，SSH协议的公钥是没有证书中心(CA)公证的，所以为了防止中间人攻击，当用户第一次登录远程主机时，系统会提示如下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">'host (12.18.429.21)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure></p><p>即系统无法确认远程主机的真实性(远程主机有可能是中间人)，只知道远程主机的公钥指纹，询问用户是否继续连接。公钥指纹就是对公钥进行哈希计算得到的，为了方便用户的比较。用户并没有什么好的办法得知自己想要连接的真实远程主机的公钥指纹，一个可行的办法是远程主机在其官方网站上贴出自己的公钥指纹，方便用户和系统提示的指纹进行比较。<br>假定当用户进行风险衡量后决定继续连接，接下来的过程就如上述提到的一样。远程主机的公钥会被保存在<code>$HOME/.ssh/known_hosts</code>文件中，当用户下次再连接时，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>除了采用口令登录外，还可使用公钥登录，原理为：用户将自己的公钥储存在远程主机上，登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>OpenSSH提供了一个工具 —— <code>ssh-keygen</code>，使用它可以方便的生成一对公私钥，生成的公钥为id_rsa.pub，私钥为id_rsa，保存在<code>$HOME/.ssh</code>目录下，当然你可以使用<code>-t</code>参数指定密钥的类型，使用<code>-f</code>参数指定生成的目录，更多的参数可以使用<code>--help</code>参数查看。<br>有了密钥对后，可以使用<code>ssh-copy-id user@host</code>命令将自己的公钥上传至远程主机，远程主机会将用户的公钥，保存在登录后的用户主目录的<code>$HOME/.ssh/authorized_keys</code>文件中。实际上，<code>ssh-copy-id</code>命令的整个过程就如下命令一样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@host <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>最后还要对远程主机的SSH服务端配置文件，即<code>/etc/ssh/sshd_config</code>文件进行相关配置，并重启SSH服务即可生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SSH(Secure Shell)即&lt;strong&gt;安全外壳协议&lt;/strong&gt;，是一种位于应用层的加密的网络传输协议，虽然任何网络服务都可以通过SSH实现安全传输，但其最常见的用途还是远程登录，是Telnet等非安全Shell的替代品。&lt;/p&gt;
&lt;h2 id=&quot;Open
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="计算机网络" scheme="https://howiezhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>WSL相关问题解决</title>
    <link href="https://howiezhao.github.io/2018/08/21/wsl-problem/"/>
    <id>https://howiezhao.github.io/2018/08/21/wsl-problem/</id>
    <published>2018-08-21T11:23:05.000Z</published>
    <updated>2018-08-22T05:35:38.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名称问题"><a href="#名称问题" class="headerlink" title="名称问题"></a>名称问题</h2><p>最早这个项目命名为<strong>Bash on Ubuntu on Windows</strong>，随后改名为<strong>Windows Subsystem for Linux</strong>，即<strong>WSL</strong>，值得肯定的是，随着Windows 10逐渐更新，慢慢统一了命名。<br><a id="more"></a></p><h2 id="SSH问题"><a href="#SSH问题" class="headerlink" title="SSH问题"></a>SSH问题</h2><p>要想在WSL中开启SSH服务，需要在配置文件(/etc/ssh/sshd_config)中作如下修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Port 2222  <span class="comment">#将22改为2222，因Win10中自带的SSH服务也在监听22端口</span></span><br><span class="line">ListenAddress 0.0.0.0  <span class="comment">#取消注释，监听所有端口</span></span><br><span class="line">UsePrivilegeSeparation no  <span class="comment">#将yes修改为no</span></span><br><span class="line">PermitRootLogin yes  <span class="comment">#将prohibit-password修改为yes，允许root用户登录，视个人情况而定</span></span><br><span class="line">PasswordAuthentication yes  <span class="comment">#将no修改为yes，允许密码登录</span></span><br></pre></td></tr></table></figure></p><p>修改完成后用<code>sudo service ssh start</code>启动SSH服务，可能会报如下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Could not load host key: /etc/ssh/ssh_host_rsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_dsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ed25519_key</span><br></pre></td></tr></table></figure></p><p>并且此时无法使用SSH客户端连接到服务器端，客户端会报如下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection closed by 127.0.0.1 port 2222</span><br></pre></td></tr></table></figure></p><p>造成这种情况的原因是服务端在启动SSH服务时发现加密过程中需要用到的密钥文件未找到，可依次用如下命令生成所需文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span><br><span class="line">ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key</span><br></pre></td></tr></table></figure></p><p>其中<code>-t</code>参数表示加密类型，<code>-f</code>参数表示生成的密钥文件名，错误信息中缺少什么密钥按需生成即可。之后再重新启动SSH服务即可正常工作。</p><h2 id="图形界面问题"><a href="#图形界面问题" class="headerlink" title="图形界面问题"></a>图形界面问题</h2><h2 id="EXE程序问题"><a href="#EXE程序问题" class="headerlink" title="EXE程序问题"></a>EXE程序问题</h2><h2 id="netstat和ps"><a href="#netstat和ps" class="headerlink" title="netstat和ps"></a>netstat和ps</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;名称问题&quot;&gt;&lt;a href=&quot;#名称问题&quot; class=&quot;headerlink&quot; title=&quot;名称问题&quot;&gt;&lt;/a&gt;名称问题&lt;/h2&gt;&lt;p&gt;最早这个项目命名为&lt;strong&gt;Bash on Ubuntu on Windows&lt;/strong&gt;，随后改名为&lt;strong&gt;Windows Subsystem for Linux&lt;/strong&gt;，即&lt;strong&gt;WSL&lt;/strong&gt;，值得肯定的是，随着Windows 10逐渐更新，慢慢统一了命名。&lt;br&gt;
    
    </summary>
    
      <category term="Bug" scheme="https://howiezhao.github.io/categories/Bug/"/>
    
    
      <category term="Windows" scheme="https://howiezhao.github.io/tags/Windows/"/>
    
      <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio模拟器相关问题解决</title>
    <link href="https://howiezhao.github.io/2018/08/21/android-emulator-problem/"/>
    <id>https://howiezhao.github.io/2018/08/21/android-emulator-problem/</id>
    <published>2018-08-21T11:22:50.000Z</published>
    <updated>2018-08-24T05:49:57.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><a id="more"></a><h2 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h2><p>Android SDK工具包中包含着一个模拟器的命令行程序 —— <code>emulator</code>，它可以在不启动Android Studio的情况下开启Android模拟器，在Windows系统中，<code>emulator</code>位于<code>%LOCALAPPDATA%\Android\Sdk\tools</code>文件夹下，<code>emulator -list-avds</code>命令可以列出所有已创建的AVD，<code>emulator -avd &lt;avd-name&gt;</code>命令即可启动相应的AVD，要查看<code>emulator</code>更多的参数，可以使用<code>emulator -help</code>。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>建议创建的AVD为Pixel，版本为Android 7.1.1。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络问题&quot;&gt;&lt;a href=&quot;#网络问题&quot; class=&quot;headerlink&quot; title=&quot;网络问题&quot;&gt;&lt;/a&gt;网络问题&lt;/h2&gt;
    
    </summary>
    
      <category term="Bug" scheme="https://howiezhao.github.io/categories/Bug/"/>
    
    
  </entry>
  
  <entry>
    <title>Hyper-V相关问题解决</title>
    <link href="https://howiezhao.github.io/2018/08/20/hyper-v-problem/"/>
    <id>https://howiezhao.github.io/2018/08/20/hyper-v-problem/</id>
    <published>2018-08-20T12:12:02.000Z</published>
    <updated>2018-08-24T05:33:15.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全屏问题"><a href="#全屏问题" class="headerlink" title="全屏问题"></a>全屏问题</h2><p>由于Hyper-V最初是为服务器设计的，所以到目前为止，Hyper-V对于全屏的支持没有VMware做得好，同样，Hyper-V也不能像VMware那样随意更改窗口大小，这多少显得很不方便。对于Windows虚拟机的全屏操作，目前较为理想的解决方案是使用<strong>远程桌面连接</strong>，记得要在虚拟机中开启远程桌面连接功能；而对于Linux虚拟机的全屏操作，可以通过修改<code>/etc/default/grub</code>文件，更改其中<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash video=hyperv_fb:1920x1080&quot;</code>，接着<code>update-grub</code>并重启即可。<br><a id="more"></a></p><h2 id="显卡问题"><a href="#显卡问题" class="headerlink" title="显卡问题"></a>显卡问题</h2><p>开启Hyper-V功能后，原主机的显卡可能会出现问题，对于我的1803版Win10来说，电脑中原来的Intel(R) HD Graphics 4600核芯显卡不能正常工作，具体表现在工具栏中英特尔核芯显卡控制面板图标消失，以及系统设置中莫名出现多个显示器，最直观的感受是每当点亮屏幕，图像显示会变慢，并且有一个逐渐适配屏幕大小的过程。究其原因是系统中原本的4624版驱动程序与Hyper-V不兼容，解决办法是去官网下载最新版驱动程序并升级即可。</p><h2 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h2><p>由于Hyper-V采用的是硬件虚拟化技术，所以开启Hyper-V功能后相当于原本的物理机也运行在虚拟化上了，因此不能再使用VMware或者VirtualBox，它们不允许在虚拟机上运行虚拟机，而此时原主机在它们眼中就是一个虚拟机。早期的Android Studio中自带的模拟器也会由于这种原因导致模拟器无法启动，只需将模拟器升级到最新版即可解决，Android Studio 3.1.4版之后自带模拟器(v27.3.9)已经可以支持Hyper-V，在开启Hyper-V的系统中，它使用<strong>Windows虚拟机监控程序平台</strong>替代了Intel的<strong>HAXM</strong>，使用前需要在Windows功能中启用<strong>Windows虚拟机监控程序平台</strong>功能。</p><h2 id="网卡问题"><a href="#网卡问题" class="headerlink" title="网卡问题"></a>网卡问题</h2><p>要想使Hyper-V中的虚拟机上网，可以通过创建<strong>虚拟交换机</strong>实现，虚拟交换机有3种类型，<strong>外部</strong>相当于VMware的<strong>桥接模式</strong>，<strong>内部</strong>相当于VMware的<strong>NAT模式</strong>，<strong>专用</strong>相当于VMware的<strong>仅主机模式</strong>，所有虚拟机会默认使用<strong>内部</strong>类型的<strong>默认交换机</strong>，这是<strong>虚拟交换机管理器</strong>自动创建的。如果我们选择创建<strong>外部</strong>类型的虚拟交换机，则会把Hyper-V的网络桥接在物理网卡上，那物理网卡将变成一个虚拟交换机。因此我们会发现原来使用的网卡变成了<strong>vEthernet</strong>，这是正常现象，不用担心。Hyper-V会自动创建一个虚拟网卡来继承原物理网卡的配置，物理计算机可以正常使用网络。</p><h2 id="代数问题"><a href="#代数问题" class="headerlink" title="代数问题"></a>代数问题</h2><p>在创建虚拟机时可以选择虚拟机代数，简单来说，第一代虚拟机支持创建32位与64位操作系统，创建的虚拟硬盘为<code>.vhd</code>格式，第二代虚拟机只能创建64位操作系统，创建的虚拟硬盘为<code>.vhdx</code>格式，并且必须是Windows 8或者Windows Server 2012以上版本，对于Linux，微软官方有一份详细的清单表明哪些版本可以创建第二代虚拟机。为方便起见，可以在首次创建时选择第二代虚拟机，若不能成功启动，且屏幕显示<code>No operating system was loaded. Press a key to retry the boot sequence...</code>信息，则可以在设置中关闭<strong>安全启动</strong>并重启虚拟机，或者删掉虚拟机并重新创建第一代虚拟机。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全屏问题&quot;&gt;&lt;a href=&quot;#全屏问题&quot; class=&quot;headerlink&quot; title=&quot;全屏问题&quot;&gt;&lt;/a&gt;全屏问题&lt;/h2&gt;&lt;p&gt;由于Hyper-V最初是为服务器设计的，所以到目前为止，Hyper-V对于全屏的支持没有VMware做得好，同样，Hyper-V也不能像VMware那样随意更改窗口大小，这多少显得很不方便。对于Windows虚拟机的全屏操作，目前较为理想的解决方案是使用&lt;strong&gt;远程桌面连接&lt;/strong&gt;，记得要在虚拟机中开启远程桌面连接功能；而对于Linux虚拟机的全屏操作，可以通过修改&lt;code&gt;/etc/default/grub&lt;/code&gt;文件，更改其中&lt;code&gt;GRUB_CMDLINE_LINUX_DEFAULT=&amp;quot;quiet splash video=hyperv_fb:1920x1080&amp;quot;&lt;/code&gt;，接着&lt;code&gt;update-grub&lt;/code&gt;并重启即可。&lt;br&gt;
    
    </summary>
    
      <category term="Bug" scheme="https://howiezhao.github.io/categories/Bug/"/>
    
    
      <category term="Windows" scheme="https://howiezhao.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Base编码家族</title>
    <link href="https://howiezhao.github.io/2018/08/10/base/"/>
    <id>https://howiezhao.github.io/2018/08/10/base/</id>
    <published>2018-08-10T09:07:56.000Z</published>
    <updated>2018-08-11T15:11:25.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>Base64，顾名思义是一种基于<strong>64</strong>个可打印字符来表示二进制数据的表示方法，这64个字符分别为<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>以及<code>+</code>与<code>/</code>。64个字符可用6个比特位表示，3个字节有24个比特位，对应于4个Base64单元，所以编码后的数据要比原始数据略长，为原来的4/3。Base64索引表如下所示：</p><table><thead><tr><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>16</td><td>Q</td><td>32</td><td>g</td><td>48</td><td>w</td></tr><tr><td>1</td><td>B</td><td>17</td><td>R</td><td>33</td><td>h</td><td>49</td><td>x</td></tr><tr><td>2</td><td>C</td><td>18</td><td>S</td><td>34</td><td>i</td><td>50</td><td>y</td></tr><tr><td>3</td><td>D</td><td>19</td><td>T</td><td>35</td><td>j</td><td>51</td><td>z</td></tr><tr><td>4</td><td>E</td><td>20</td><td>U</td><td>36</td><td>k</td><td>52</td><td>0</td></tr><tr><td>5</td><td>F</td><td>21</td><td>V</td><td>37</td><td>l</td><td>53</td><td>1</td></tr><tr><td>6</td><td>G</td><td>22</td><td>W</td><td>38</td><td>m</td><td>54</td><td>2</td></tr><tr><td>7</td><td>H</td><td>23</td><td>X</td><td>39</td><td>n</td><td>55</td><td>3</td></tr><tr><td>8</td><td>I</td><td>24</td><td>Y</td><td>40</td><td>o</td><td>56</td><td>4</td></tr><tr><td>9</td><td>J</td><td>25</td><td>Z</td><td>41</td><td>p</td><td>57</td><td>5</td></tr><tr><td>10</td><td>K</td><td>26</td><td>a</td><td>42</td><td>q</td><td>58</td><td>6</td></tr><tr><td>11</td><td>L</td><td>27</td><td>b</td><td>43</td><td>r</td><td>59</td><td>7</td></tr><tr><td>12</td><td>M</td><td>28</td><td>c</td><td>44</td><td>s</td><td>60</td><td>8</td></tr><tr><td>13</td><td>N</td><td>29</td><td>d</td><td>45</td><td>t</td><td>61</td><td>9</td></tr><tr><td>14</td><td>O</td><td>30</td><td>e</td><td>46</td><td>u</td><td>62</td><td>+</td></tr><tr><td>15</td><td>P</td><td>31</td><td>f</td><td>47</td><td>v</td><td>63</td><td>/</td></tr></tbody></table><a id="more"></a><p>编码<code>Hello</code>的过程如下：</p><table><thead><tr><th>文本</th><th>H</th><th>e</th><th>l</th><th>l</th><th>o</th><th></th></tr></thead><tbody><tr><td>ASCII编码</td><td>72</td><td>101</td><td>108</td><td>108</td><td>111</td><td></td></tr><tr><td>二进制位</td><td>‭01001000‬</td><td>‭01100101‬</td><td>‭01101100‬</td><td>‭01101100‬</td><td>‭01101111‬</td><td>00000000</td></tr></tbody></table><p>以6个二进制位进行编码：</p><table><thead><tr><th>二进制位</th><th>010010</th><th>000110</th><th>010101</th><th>101100</th><th>011011</th><th>000110</th><th>111100</th><th>000000</th></tr></thead><tbody><tr><td>索引</td><td>18</td><td>6</td><td>21</td><td>44</td><td>27</td><td>6</td><td>60</td><td></td></tr><tr><td>Base64编码</td><td>S</td><td>G</td><td>V</td><td>s</td><td>b</td><td>G</td><td>8</td><td>=</td></tr></tbody></table><p>若原数据不是3的倍数，且多出1个字节，则在编码末尾加2个<code>=</code>，多出2个字节，则在编码末尾加1个<code>=</code>。换言之，若多出1个字节，则最后一个6位的Base64字节块有4位是0值，若多出2个字节，则最后一个6位的Base64字节块有2位是0值。</p><h2 id="Base32"><a href="#Base32" class="headerlink" title="Base32"></a>Base32</h2><p>与上类似，Base32基于32个可打印字符，分别为<code>A-Z</code>以及<code>2-7</code>。32个字符可用5个比特位表示，5个字节有40个比特位，对应于8个Base32单元，编码后的数据比原始数据略长8/5。若原数据不是5的倍数，且多出1个字节，则在编码末尾加4个<code>=</code>，多出2个字节，则在编码末尾加3个<code>=</code>，多出3个字节，则在编码末尾加2个<code>=</code>，多出4个字节，则在编码末尾加1个<code>=</code>。Base32索引表如下所示：</p><table><thead><tr><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>8</td><td>I</td><td>16</td><td>Q</td><td>24</td><td>Y</td></tr><tr><td>1</td><td>B</td><td>9</td><td>J</td><td>17</td><td>R</td><td>25</td><td>Z</td></tr><tr><td>2</td><td>C</td><td>10</td><td>K</td><td>18</td><td>S</td><td>26</td><td>2</td></tr><tr><td>3</td><td>D</td><td>11</td><td>L</td><td>19</td><td>T</td><td>27</td><td>3</td></tr><tr><td>4</td><td>E</td><td>12</td><td>M</td><td>20</td><td>U</td><td>28</td><td>4</td></tr><tr><td>5</td><td>F</td><td>13</td><td>N</td><td>21</td><td>V</td><td>29</td><td>5</td></tr><tr><td>6</td><td>G</td><td>14</td><td>O</td><td>22</td><td>W</td><td>30</td><td>6</td></tr><tr><td>7</td><td>H</td><td>15</td><td>P</td><td>23</td><td>X</td><td>31</td><td>7</td></tr></tbody></table><h2 id="Base16"><a href="#Base16" class="headerlink" title="Base16"></a>Base16</h2><p>与上类似，Base16基于16个可打印字符，分别为<code>0-9</code>以及<code>A-F</code>。16个字符可用4个比特位表示，1个字节有8个比特位，对应于2个Base16单元，编码后的数据比原始数据略长2。显然，在Base16中不需要在末尾填充<code>=</code>。Base16索引表如下所示：</p><table><thead><tr><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>4</td><td>4</td><td>8</td><td>8</td><td>12</td><td>C</td></tr><tr><td>1</td><td>1</td><td>5</td><td>5</td><td>9</td><td>9</td><td>13</td><td>D</td></tr><tr><td>2</td><td>2</td><td>6</td><td>6</td><td>10</td><td>A</td><td>14</td><td>E</td></tr><tr><td>3</td><td>3</td><td>7</td><td>7</td><td>11</td><td>B</td><td>15</td><td>F</td></tr></tbody></table><h2 id="XXencode"><a href="#XXencode" class="headerlink" title="XXencode"></a>XXencode</h2><p>XXencode不属于Base编码家族，但与Base64编码极为类似，区别仅在于64个可打印字符及其顺序，XXencode使用的为<code>+</code>、<code>-</code>、<code>0-9</code>、<code>A-Z</code>、<code>a-z</code>。</p><h2 id="UUencode"><a href="#UUencode" class="headerlink" title="UUencode"></a>UUencode</h2><p>UUencode也与Base64极为类似，它使用的字符及其顺序为<code>(space)</code>、<code>!</code>、<code>&quot;</code>、<code>#</code>、<code>$</code>、<code>%</code>、<code>&amp;</code>、<code>&#39;</code>、<code>(</code>、<code>)</code>、<code>*</code>、<code>+</code>、<code>,</code>、<code>-</code>、<code>.</code>、<code>/</code>、<code>0-9</code>、<code>:</code>、<code>;</code>、<code>&lt;</code>、<code>=</code>、<code>&gt;</code>、<code>?</code>、<code>@</code>、<code>A-Z</code>、<code>[</code>、<code>\</code>、<code>]</code>、<code>^</code>、<code>_</code>、`。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Base64&quot;&gt;&lt;a href=&quot;#Base64&quot; class=&quot;headerlink&quot; title=&quot;Base64&quot;&gt;&lt;/a&gt;Base64&lt;/h2&gt;&lt;p&gt;Base64，顾名思义是一种基于&lt;strong&gt;64&lt;/strong&gt;个可打印字符来表示二进制数据的表示方法，这64个字符分别为&lt;code&gt;A-Z&lt;/code&gt;、&lt;code&gt;a-z&lt;/code&gt;、&lt;code&gt;0-9&lt;/code&gt;以及&lt;code&gt;+&lt;/code&gt;与&lt;code&gt;/&lt;/code&gt;。64个字符可用6个比特位表示，3个字节有24个比特位，对应于4个Base64单元，所以编码后的数据要比原始数据略长，为原来的4/3。Base64索引表如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;Q&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;j&lt;/td&gt;
&lt;td&gt;51&lt;/td&gt;
&lt;td&gt;z&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;36&lt;/td&gt;
&lt;td&gt;k&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;53&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;38&lt;/td&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;54&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;39&lt;/td&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;J&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;Z&lt;/td&gt;
&lt;td&gt;41&lt;/td&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;57&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;K&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;42&lt;/td&gt;
&lt;td&gt;q&lt;/td&gt;
&lt;td&gt;58&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;43&lt;/td&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;59&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;61&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;31&lt;/td&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;47&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;63&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="密码学" scheme="https://howiezhao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>古典密码学</title>
    <link href="https://howiezhao.github.io/2018/08/10/classical-crypto/"/>
    <id>https://howiezhao.github.io/2018/08/10/classical-crypto/</id>
    <published>2018-08-10T03:17:41.000Z</published>
    <updated>2018-09-09T05:38:55.730Z</updated>
    
    <content type="html"><![CDATA[<p>古典密码学主要包括两类，即<strong>代换</strong>和<strong>置换</strong>。</p><h2 id="代换"><a href="#代换" class="headerlink" title="代换"></a>代换</h2><p>代换密码是将明文中的字符替代成其他字符，即<strong>替代转换</strong>，若整个加密过程中每个字符采用同一张表替代，则为<strong>单表代换密码</strong>，类似的，若整个加密过程中每个字符采用不同的表替代，则为<strong>多表代换密码</strong>，典型的单表代换密码有凯撒密码、培根密码等，多表代换密码有维吉尼亚密码等。</p><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p>凯撒密码(Caesar cipher)就是将明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文。例如，当偏移量为3时，所有的字母A将被替换成D，B变成E，以此类推。<br>明文<code>Hello World</code>的加密过程如下：</p><ol><li>取偏移量为3</li><li>计算<code>H</code>的后3位为<code>K</code></li><li>以此类推</li><li>密文为：<code>Khoor Zruog</code></li></ol><p>类似的，解密过程如下：</p><ol><li>计算<code>K</code>的前3位为<code>H</code></li><li>以此类推</li><li>明文为：<code>Hello World</code></li></ol><p>注意：当偏移量为13时，这种凯撒密码的特例又被称为<strong>ROT13</strong>(回转13位)加密，ROT13加密是一种<strong>对等加密</strong>(Reciprocal cipher)，对等加密是对称加密的一个特例，即该类密码的加密算法是它自己本身的逆反函数，换言之，要对其解密，只需对其密文再次套用加密算法即可。当偏移量未知时，可采用穷举法一个个试，偏移量必定小于26。<br><a id="more"></a></p><h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码(Bacon’s cipher)加密时，明文中的每个字母都会转换成一组5个英文字母。其转换依靠下表：</p><table><thead><tr><th>明文</th><th>密文</th><th>明文</th><th>密文</th><th>明文</th><th>密文</th><th>明文</th><th>密文</th></tr></thead><tbody><tr><td>a</td><td>AAAAA</td><td>g</td><td>AABBA</td><td>n</td><td>ABBAA</td><td>t</td><td>BAABA</td></tr><tr><td>b</td><td>AAAAB</td><td>h</td><td>AABBB</td><td>o</td><td>ABBAB</td><td>u-v</td><td>BAABB</td></tr><tr><td>c</td><td>AAABA</td><td>i-j</td><td>ABAAA</td><td>p</td><td>ABBBA</td><td>w</td><td>BABAA</td></tr><tr><td>d</td><td>AAABB</td><td>k</td><td>ABAAB</td><td>q</td><td>ABBBB</td><td>x</td><td>BABAB</td></tr><tr><td>e</td><td>AABAA</td><td>l</td><td>ABABA</td><td>r</td><td>BAAAA</td><td>y</td><td>BABBA</td></tr><tr><td>f</td><td>AABAB</td><td>m</td><td>ABABB</td><td>s</td><td>BAAAB</td><td>z</td><td>BABBB</td></tr></tbody></table><p>按照上表，明文<code>hello</code>的密文为<code>AABBBAABAAABABBABABBABBBA</code>，显然，密文的长度是明文长度的<strong>5</strong>倍。<br>除了上表用来加密小写明文外，还有一张用来加密大写明文的表，如下：</p><table><thead><tr><th>明文</th><th>密文</th><th>明文</th><th>密文</th><th>明文</th><th>密文</th><th>明文</th><th>密文</th><th>明文</th><th>密文</th></tr></thead><tbody><tr><td>A</td><td>aaaaa</td><td>G</td><td>aabba</td><td>M</td><td>abbaa</td><td>S</td><td>baaba</td><td>Y</td><td>bbaaa</td></tr><tr><td>B</td><td>aaaab</td><td>H</td><td>aabbb</td><td>N</td><td>abbab</td><td>T</td><td>baabb</td><td>Z</td><td>bbaab</td></tr><tr><td>C</td><td>aaaba</td><td>I</td><td>abaaa</td><td>O</td><td>abbba</td><td>U</td><td>babaa</td></tr><tr><td>D</td><td>aaabb</td><td>J</td><td>abaab</td><td>P</td><td>abbbb</td><td>V</td><td>babab</td></tr><tr><td>E</td><td>aabaa</td><td>K</td><td>ababa</td><td>Q</td><td>baaaa</td><td>W</td><td>babba</td></tr><tr><td>F</td><td>aabab</td><td>L</td><td>ababb</td><td>R</td><td>baaab</td><td>X</td><td>babbb</td></tr></tbody></table><p>同理，明文<code>HELLO</code>的密文为<code>aabbbaabaaababbababbabbba</code>。<br>注意：虽然表中出现了<code>A</code> <code>B</code>两种字符，但培根密码的本质是二进制，即用两种不同的特征来加密明文，可以是字母的大小写或字体的样式等等。例如采用字母的大小写加密<code>hello</code>为<code>GOod gOOd STUdY, dAY dAy UP, haHa</code>，其中大写代表<code>A</code>，小写代表<code>B</code>；类似的，也可以用粗体代表<code>A</code>，正常代表<code>B</code>，以字体的样式加密<code>hello</code>。显然，培根密码所包含的信息可以和用于承载其的文章完全无关。</p><h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><p>维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，用来加解密的维吉尼亚表格如下所示：<br><img src="/images/vigenere.png" alt="维吉尼亚表格"><br>这一表格包括了26行字母表，每一行都由前一行向左偏移1位得到。<strong>行为明文行，列为密钥列，密文位于表格内。</strong><br>明文<code>HELLOWORLD</code>的加密结果如下：</p><ol><li>选择某一关键词作为密钥，如<code>SECRET</code></li><li>对于明文第1个字母<code>H</code>，对应密钥的第1个字母<code>S</code>，于是使用表格中<code>S</code>行字母表进行加密，得到密文第一个字母<code>Z</code></li><li>以此类推，若密钥长度小于明文长度，则转到密钥第1个字母继续循环，最终得到密文<code>ZINCSPGVNU</code></li></ol><p>类似的，解密过程如下：</p><ol><li>根据密钥第1个字母<code>S</code>所对应的<code>S</code>行字母表，发现密文第1个字母<code>Z</code>位于<code>H</code>列，因而明文第1个字母为<code>H</code></li><li>依次类推</li></ol><p>显而易见，维吉尼亚密码相对于本文介绍的其他古典密码，很难利用穷举法破解。</p><h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><p>置换密码是将明文中的字母重新排列，字母本身不变，但其位置改变，即<strong>位置转换</strong>，典型的有栅栏密码等。</p><h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p>栅栏密码(Rail fence cipher)，又称篱笆密码，就是把要加密的明文分成n个一组，然后把每组的第一个字连起来，紧接着把每组的第二个字连起来，以此类推，形成一段无规律的话。<br>明文<code>Hello World</code>的加密过程如下：</p><ol><li>去掉空格：<code>HelloWorld</code></li><li>5个一组：<code>Hello</code>，<code>World</code></li><li>取出每组第1个字母：<code>HW</code></li><li>取出每组第2个字母：<code>eo</code></li><li>以此类推</li><li>连在一起：<code>HWeolrllod</code></li><li>加上适当空格：<code>HWeol rllod</code></li></ol><p>类似的，解密过程如下：</p><ol><li>去掉空格：<code>HWeolrllod</code></li><li>分成5栏：<code>HW</code>、<code>eo</code>、<code>lr</code>、<code>ll</code>、<code>od</code></li><li>取出每栏第1个字母：<code>Hello</code></li><li>依次类推</li><li>连在一起：<code>HelloWorld</code></li><li>加上适当空格：<code>Hello World</code></li></ol><p>注意：这里栅栏的栏数取决于n的取值，一般而言，n要整除字母数，n不可能大于或等于字母数，当不知道n为多少时，可采用穷举法一个个试。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="当铺密码"><a href="#当铺密码" class="headerlink" title="当铺密码"></a>当铺密码</h3><p>准确来说，当铺密码不是一种加密方式而是一种编码方式，它是将中文和数字进行转化的算法，具体为：当前汉字有多少笔画出头，就转化成数字几。如<code>王夫 井工 夫口 由中人</code>即为<code>67 84 70 123</code>。</p><h3 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h3><p>猪圈密码(Pigpen cipher)，又称共济会密码(Masonic cipher)，是一种以格子为基础的简单代换式密码。下图为猪圈密码中所用符号与26个英语字母之间的对应关系：<br><img src="/images/pigpen.png" alt="猪圈密码"><br>明文<code>X MARKS THE SPOT</code>的加密结果如下：<br><img src="/images/pigpen-eg.png" alt="猪圈密码例子"></p><h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><p>猪圈密码还有一种变形，即采用图片中字符位置一一对应的形式加解密，如<code>FLAG</code>可加密为<code>OCJP</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;古典密码学主要包括两类，即&lt;strong&gt;代换&lt;/strong&gt;和&lt;strong&gt;置换&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;代换&quot;&gt;&lt;a href=&quot;#代换&quot; class=&quot;headerlink&quot; title=&quot;代换&quot;&gt;&lt;/a&gt;代换&lt;/h2&gt;&lt;p&gt;代换密码是将明文中的字符替代成其他字符，即&lt;strong&gt;替代转换&lt;/strong&gt;，若整个加密过程中每个字符采用同一张表替代，则为&lt;strong&gt;单表代换密码&lt;/strong&gt;，类似的，若整个加密过程中每个字符采用不同的表替代，则为&lt;strong&gt;多表代换密码&lt;/strong&gt;，典型的单表代换密码有凯撒密码、培根密码等，多表代换密码有维吉尼亚密码等。&lt;/p&gt;
&lt;h3 id=&quot;凯撒密码&quot;&gt;&lt;a href=&quot;#凯撒密码&quot; class=&quot;headerlink&quot; title=&quot;凯撒密码&quot;&gt;&lt;/a&gt;凯撒密码&lt;/h3&gt;&lt;p&gt;凯撒密码(Caesar cipher)就是将明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文。例如，当偏移量为3时，所有的字母A将被替换成D，B变成E，以此类推。&lt;br&gt;明文&lt;code&gt;Hello World&lt;/code&gt;的加密过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;取偏移量为3&lt;/li&gt;
&lt;li&gt;计算&lt;code&gt;H&lt;/code&gt;的后3位为&lt;code&gt;K&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以此类推&lt;/li&gt;
&lt;li&gt;密文为：&lt;code&gt;Khoor Zruog&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似的，解密过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算&lt;code&gt;K&lt;/code&gt;的前3位为&lt;code&gt;H&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以此类推&lt;/li&gt;
&lt;li&gt;明文为：&lt;code&gt;Hello World&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：当偏移量为13时，这种凯撒密码的特例又被称为&lt;strong&gt;ROT13&lt;/strong&gt;(回转13位)加密，ROT13加密是一种&lt;strong&gt;对等加密&lt;/strong&gt;(Reciprocal cipher)，对等加密是对称加密的一个特例，即该类密码的加密算法是它自己本身的逆反函数，换言之，要对其解密，只需对其密文再次套用加密算法即可。当偏移量未知时，可采用穷举法一个个试，偏移量必定小于26。&lt;br&gt;
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
      <category term="密码学" scheme="https://howiezhao.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JSFuck</title>
    <link href="https://howiezhao.github.io/2018/08/10/jsfuck/"/>
    <id>https://howiezhao.github.io/2018/08/10/jsfuck/</id>
    <published>2018-08-10T00:59:58.000Z</published>
    <updated>2018-08-10T02:21:18.152Z</updated>
    
    <content type="html"><![CDATA[<p>JSFuck是一种JavaScript的编码方式，它的命名起源于Brainfuck，同样，为了避讳脏话，它又被写作JSF*ck，以JSFuck风格写出的代码不需要另外的编译器或解释器执行，原生的JavaScript解释器即可直接运行。<br>JSFuck种共使用<code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>!</code>、<code>+</code>这<strong>6</strong>种字符。<code>alert(1)</code>这段JavaScript代码用JSFuck风格表示如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()</span><br></pre></td></tr></table></figure></p><p>要将任意的JavaScript代码编码为JSFuck风格，可前往<a href="http://www.jsfuck.com/" target="_blank" rel="noopener">JSFuck</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSFuck是一种JavaScript的编码方式，它的命名起源于Brainfuck，同样，为了避讳脏话，它又被写作JSF*ck，以JSFuck风格写出的代码不需要另外的编译器或解释器执行，原生的JavaScript解释器即可直接运行。&lt;br&gt;JSFuck种共使用&lt;code&gt;
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>Brainfuck</title>
    <link href="https://howiezhao.github.io/2018/08/09/Brainfuck/"/>
    <id>https://howiezhao.github.io/2018/08/09/Brainfuck/</id>
    <published>2018-08-09T09:15:44.000Z</published>
    <updated>2018-08-10T00:58:53.514Z</updated>
    
    <content type="html"><![CDATA[<p>Brainfuck是在1993年创建的一种极小化的计算机语言，由于fuck在英语中是脏话，这种语言有时也被称为Brainf*ck或Brainf***，或被简称为BF。<br>Brainfuck中共有8种字符，它们及其含义如下所示：</p><ul><li><code>&gt;</code>：指针加一</li><li><code>&lt;</code>：指针减一</li><li><code>+</code>：指针指向的字节的值加一</li><li><code>-</code>：指针指向的字节的值减一</li><li><code>.</code>：输出指针指向的单元内容(ASCII码)</li><li><code>,</code>：输入内容到指针指向的单元(ASCII码)</li><li><code>[</code>：如果指针指向的单元值为零，向后跳转到对应的<code>]</code>指令的次一指令处</li><li><code>]</code>：如果指针指向的单元值不为零，向前跳转到对应的<code>[</code>指令的次一指令处</li></ul><p>下面是一个用Brainfuck在屏幕上打印<code>Hello World</code>的程序例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.</span><br><span class="line">&gt;.+++.------.--------.&gt;+.&gt;.</span><br></pre></td></tr></table></figure></p><p>程序的运行结果如<a href="https://fatiherikli.github.io/brainfuck-visualizer/" target="_blank" rel="noopener">Brainfuck Visualizer</a>所示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Brainfuck是在1993年创建的一种极小化的计算机语言，由于fuck在英语中是脏话，这种语言有时也被称为Brainf*ck或Brainf***，或被简称为BF。&lt;br&gt;Brainfuck中共有8种字符，它们及其含义如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;g
      
    
    </summary>
    
      <category term="CheatSheet" scheme="https://howiezhao.github.io/categories/CheatSheet/"/>
    
    
  </entry>
  
  <entry>
    <title>《TAOUP》读书笔记</title>
    <link href="https://howiezhao.github.io/2018/08/02/taoup/"/>
    <id>https://howiezhao.github.io/2018/08/02/taoup/</id>
    <published>2018-08-02T14:31:46.000Z</published>
    <updated>2018-08-10T00:59:19.408Z</updated>
    
    <content type="html"><![CDATA[<p>我没有写错，本文所记述的不是Knuth的那本举世瞩目的TAOCP(计算机程序设计艺术)，而是ESR所写的<strong>TAOUP</strong>，即The Art of UNIX Programming(UNIX编程艺术)。</p><h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p>Unix的设计哲学总体上可以概括为以下几点：</p><ol><li>模块原则：使用简洁的接口拼合简单的部件</li><li>清晰原则：清晰胜于机巧</li><li>组合原则：设计时考虑拼接组合</li><li>分离原则：策略同机制分离，接口同引擎分离</li><li>简洁原则：设计要简洁，复杂度能低则低</li><li>吝啬原则：除非却无它法，不要编写庞大的程序</li><li>透明性原则：设计要可见，以便审查和调试</li><li>健壮原则：健壮源于透明与简洁</li><li>表示原则：把知识叠入数据以求逻辑质朴而健壮</li><li>通俗原则：接口设计避免标新立异</li><li>缄默原则：如果一个程序没什么好说的，就沉默</li><li>补救原则：出现异常时，马上退出并给出足够错误信息</li><li>经济原则：宁花机器一分，不花程序员一秒</li><li>生成原则：避免手工hack，尽量编写程序去生成程序</li><li>优化原则：雕琢前先要有原型，跑之前先学会走</li><li>多样原则：决不相信所谓“不二法门”的断言</li><li>扩展原则：设计着眼未来，未来总比预想来得快<a id="more"></a>所有的Unix哲学浓缩为一条铁律就是<strong>KISS</strong>原则，即Keep It Simple, Stupid！</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我没有写错，本文所记述的不是Knuth的那本举世瞩目的TAOCP(计算机程序设计艺术)，而是ESR所写的&lt;strong&gt;TAOUP&lt;/strong&gt;，即The Art of UNIX Programming(UNIX编程艺术)。&lt;/p&gt;
&lt;h2 id=&quot;哲学&quot;&gt;&lt;a href=&quot;#哲学&quot; class=&quot;headerlink&quot; title=&quot;哲学&quot;&gt;&lt;/a&gt;哲学&lt;/h2&gt;&lt;p&gt;Unix的设计哲学总体上可以概括为以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块原则：使用简洁的接口拼合简单的部件&lt;/li&gt;
&lt;li&gt;清晰原则：清晰胜于机巧&lt;/li&gt;
&lt;li&gt;组合原则：设计时考虑拼接组合&lt;/li&gt;
&lt;li&gt;分离原则：策略同机制分离，接口同引擎分离&lt;/li&gt;
&lt;li&gt;简洁原则：设计要简洁，复杂度能低则低&lt;/li&gt;
&lt;li&gt;吝啬原则：除非却无它法，不要编写庞大的程序&lt;/li&gt;
&lt;li&gt;透明性原则：设计要可见，以便审查和调试&lt;/li&gt;
&lt;li&gt;健壮原则：健壮源于透明与简洁&lt;/li&gt;
&lt;li&gt;表示原则：把知识叠入数据以求逻辑质朴而健壮&lt;/li&gt;
&lt;li&gt;通俗原则：接口设计避免标新立异&lt;/li&gt;
&lt;li&gt;缄默原则：如果一个程序没什么好说的，就沉默&lt;/li&gt;
&lt;li&gt;补救原则：出现异常时，马上退出并给出足够错误信息&lt;/li&gt;
&lt;li&gt;经济原则：宁花机器一分，不花程序员一秒&lt;/li&gt;
&lt;li&gt;生成原则：避免手工hack，尽量编写程序去生成程序&lt;/li&gt;
&lt;li&gt;优化原则：雕琢前先要有原型，跑之前先学会走&lt;/li&gt;
&lt;li&gt;多样原则：决不相信所谓“不二法门”的断言&lt;/li&gt;
&lt;li&gt;扩展原则：设计着眼未来，未来总比预想来得快
    
    </summary>
    
      <category term="Notes" scheme="https://howiezhao.github.io/categories/Notes/"/>
    
    
      <category term="Linux" scheme="https://howiezhao.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
