---
title: TCP 协议分析
date: 2018-05-11 18:48:30
categories: CheatSheet
tags:
  - 计算机网络
---

TCP 全称 Transmission Control Protocol，即**传输控制协议**，它为调用它的应用程序提供了一种可靠的、**面向连接**（connection-oriented）的服务。

TCP 连接提供的是**全双工服务**（full-duplex service），TCP 连接也总是**点对点**（point-to-point）的。

相比 {% post_link udp UDP %}，TCP 主要多了 2 种服务：**可靠数据传输**（reliable data transfer）和**拥塞控制**（congestion control）。

## 可靠数据传输

TCP 提供的可靠数据传输具体包含以下 3 点：

- 分组中的比特不会受损（由 0 变为 1，或者相反），即不存在比特差错
- 分组中的比特不会丢失
- 所有数据都是按照其发送顺序进行交付

### 受损

我们先假设分组中的比特不会丢失且顺序不会改变，在此来讨论如何保证比特不会受损：

在计算机网络环境中，基于**肯定确认**（positive acknowledgment，**ACK**）（“OK”）与**否定确认**（negative acknowledgment，**NAK**）（“请重复一遍”）这样的重传机制的可靠数据传输协议称为**自动重传请求（Automatic Repeat reQuest，ARQ）协议**。

ARQ 协议中还需要另外三种协议功能来处理存在比特差错的情况：

- **差错检测**：需要一种机制以使接收方检测到何时出现了比特差错。类似于 UDP 的做法，通过检验和字段可以实现此功能。
- **接收方反馈**：发送方要了解接收方情况（此时为分组是否被正确接收）的唯一途径就是让接收方提供明确的反馈信息给发送方。
- **重传**：接收方收到有差错的分组时，发送方将重传该分组。

当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得更多的数据，因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。这样的协议被称为**停等**（stop-and-wait）协议。

除此之外，还需要考虑到 ACK 或 NAK 分组受损的可能性：当发送方收到含糊不清的 ACK 或 NAK 分组时，一个简单的解决方法是重传当前数据分组。然而，这种方法在发送方到接收方的信道中引入了**冗余分组**（duplicate packet）。冗余分组的根本困难在于接收方不知道它上次所发送的 ACK 或 NAK 是否被发送方正确地收到。因此它无法 *事先* 知道接收到的分组是新的还是一次重传！

解决这个新问题的一个简单方法是在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的**序号**（sequence number）放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否是一次重传。

至此，我们介绍了保证比特不会受损用到的所有技术，由于引入了序号，还有一个可以优化的地方：如果不发送 NAK，而是对上次正确接收的分组发送一个 ACK，我们也能实现与 NAK 一样的效果。发送方接收到对同一个分组的两个 ACK（即接收**冗余 ACK**（duplicate ACK））后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。

### 丢失

仍然假设顺序不会改变，在保证比特不会受损之后，我们来讨论如何保证比特不会丢失：

要做到这一点，我们具体要解决两个问题：怎样检测丢包以及发生丢包后该做些什么，对于第二个问题，使用上文所介绍的所有技术即可解决，为解决第一个问题，还需增加一种新的协议机制。

发送方每次发送一个分组（包括第一次分组和重传分组）时，便启动一个**倒计数定时器**（countdown timer）；如果在定时器结束后仍未收到 ACK，则重传该分组。注意到如果一个分组经历了一个特别大的时延，发送方可能会重传该分组，即使该数据分组及其 ACK 都没有丢失。这就在发送方到接收方的信道中引入了**冗余数据分组**（duplicate data packet）的可能性。幸运的是，已经有足够的功能（即序号）来处理冗余分组情况。

### 性能

如果我们定义发送方（或信道）的**利用率**（utilization）为：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比，那么上文所述的停等协议有着非常低的发送方利用率，要解决此问题，就要允许发送方发送多个分组而无须等待确认。因为许多从 *发送方* 向 *接收方* 输送的分组可以被看成是填充到一条流水线中，故这种技术被称为**流水线**（pipelining）。

流水线技术对可靠数据传输协议可带来如下影响：

- 必须增加序号范围，
- 协议的发送方和接收方两端也许不得不缓存多个分组。

具体而言，所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：

- 回退 N 步（Go-Back-N，GBN）
- 选择重传（Selective Repeat，SR）

#### 回退 N 步

在**回退 N 步（GBN）协议**中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数 N。

下图显示了发送方看到的 GBN 协议的序号范围。如果我们将**基序号（base）**定义为最早未确认分组的序号，将**下一个序号（nextseqnum）**定义为最小的未使用序号（即下一个待发的序号），则可将序号范围分割成 4 段：

- `[0, base-1]` 段内的序号对应于已经发送并被确认的分组；
- `[base, nextseqnum-1]` 段内对应已经发送但未被确认的分组；
- `[nextseqnum, base+N-1]` 段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话；
- 大于或等于 `base+N` 的序号是不能使用的，直到当前流水线中未被确认的分组（特别是序号为 `base` 的分组）已得到确认为止。

![gbn sender seqnum](/images/gbn-sender-seqnum.jpg)

如上图所示，那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为 N 的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N 常被称为**窗口长度**（window size），GBN 协议也常被称为**滑动窗口协议**（sliding-window protocol）。

之所以要限制这些被发送的、未被确认的分组的数目为 N，是因为要实现后续介绍的流量控制。

GBN 发送方必须响应三种类型的事件：

- *上层的调用。*
- *收到一个 ACK。*
- *超时事件。*

对 GBN 接收方而言，如果一个序号为 `n` 的分组被正确接收到，并且按序（即上次交付给上层的数据是序号为 `n-1` 的分组），则接收方为分组 `n` 发送一个 ACK，并将该分组中的数据部分交付到上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送 ACK。

这种方法的优点是接收缓存简单，即接收方不需要缓存任何失序分组。因此，虽然发送方必须维护窗口的上下边界及 `nextseqnum` 在该窗口中的位置，但是接收方需要维护的唯一信息就是下一个按序接收的分组的序号。该值保存在 `expectedseqnum` 变量中。

#### 选择重传

当窗口长度和带宽时延积都很大时，GBN 会存在着一些性能问题，在流水线中会有很多分组更是如此。单个分组的差错就能够引起 GBN 重传大量分组，许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥。

顾名思义，选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方 *逐个* 地确认正确接收的分组。再次用窗口长度 N 来限制流水线中未完成、未被确认的分组数。然而，与 GBN 不同的是，发送方已经收到了对窗口中某些分组的 ACK。下图显示了 SR 发送方和接收方看到的序号范围：

![sr sender receiver seqnum](/images/sr-sender-receiver-seqnum.jpg)

SR 接收方将确认一个正确的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组（即序号更小的分组）皆被收到为止，这时才可以将一批分组按序交付给上层。

对 SR 发送方而言：

1. *从上层收到数据。*
2. *超时。*
3. *收到 ACK。*

对 SR 接收方而言：

1. *序号在 `[rcv_base, rcv_base+N-1]` 内的分组被正确接收。*
2. *序号在 `[rcv_base-N, rcv_base-1]` 内的分组被正确收到。*
3. *其他情况。* 忽略该分组。

**注意**：当窗口长度比序号空间小 1 时协议无法工作。对于 SR 协议而言，窗口长度必须小于或等于序号空间大小的一半。

总结上文，为了实现可靠数据传输，我们需要使用以下技术：

- 检验和
- 肯定确认，即 ACK 分组
- 重传
- 序号
- 定时器

## 拥塞控制

## TCP 报文段结构

![TCP 报文段结构](/images/tcp.PNG)

## TCP 连接与状态

### 创建

客户端 TCP 会用以下方式与服务器端 TCP 建立一条 TCP 连接：

1. 客户端 TCP 首先向服务器端 TCP 发送一个 **SYN 报文段**。
该报文段不包含应用层数据，但是报文段的首部中的 SYN 标志位被置为 1，序号字段为一个随机的初始序号（不妨设为 `client_isn`）。
客户端 TCP 初始为 **CLOSED**（关闭）状态，发送此 SYN 报文段后，将进入 **SYN_SENT** 状态。
2. 服务器端 TCP 收到 SYN 报文段后，会为该 TCP 连接分配 TCP 缓存和变量，并向客户端 TCP 发送一个 **SYNACK 报文段**。
该报文段也不包含应用层数据，但是报文段的首部中的 SYN 标志位被置为 1，确认号字段为 `client_isn + 1`，序号字段为一个随机的初始序号（不妨设为 `server_isn`）。
服务器端 TCP 初始为 CLOSED 状态，当服务器应用程序创建一个监听套接字时，将进入 **LISTEN** 状态，发送此 SYNACK 报文段后，将进入 **SYN_RCVD** 状态。
3. 客户端 TCP 收到 SYNACK 报文段后，也会为该 TCP 连接分配 TCP 缓存和变量，并向服务器端 TCP 发送一个 **ACK 报文段**。
该报文段的首部中的 SYN 标志位被置为 0，确认号字段为 `server_isn + 1`，可以携带应用层数据。
发送此 ACK 报文段后，客户端 TCP 将进入 **ESTABLISHED**（已建立）状态，服务器端 TCP 收到 ACK 报文段后也将进入 ESTABLISHED 状态。

一旦完成以上 3 个步骤，客户和服务器主机就可以相互发送包括数据的报文段了。在以后每一个报文段中，SYN 比特都将被置为 0。为了创建该连接，在两台主机之间发送了 3 个分组，由于这个原因，这种连接创建过程通常被称为 **3 次握手**（three-way handshake）。

### 关闭

参与一条 TCP 连接的两个进程中的任何一个都能终止该连接。当连接结束后，主机中的“资源”（即缓存和变量）将被释放。假设客户端打算关闭连接，它将遵循以下步骤：

1. 客户端 TCP 向服务器端 TCP 发送一个 **FIN 报文段**。
该报文段的首部中的 FIN 标志位被置为 1。
发送此 FIN 报文段后，客户端 TCP 将从 ESTABLISHED 状态进入到 **FIN_WAIT_1** 状态。
2. 服务器端 TCP 收到 FIN 报文段后，会向客户端 TCP 发送一个 **ACK 报文段**。
发送此 ACK 报文段后，服务器端 TCP 将从 ESTABLISHED 状态进入到 **CLOSE_WAIT** 状态，客户端 TCP 收到 ACK 报文段后将进入 **FIN_WAIT_2** 状态。
3. 服务器端 TCP 向客户端 TCP 发送一个 **FIN 报文段**。
发送此 FIN 报文段后，服务器端 TCP 将进入 **LAST_ACK** 状态。
4. 客户端 TCP 收到 FIN 报文段后，会向服务器端 TCP 发送一个 **ACK 报文段**。
发送此 ACK 报文段后，客户端 TCP 将进入 **TIME_WAIT** 状态，服务器端 TCP 收到 ACK 报文段后将进入 CLOSED 状态。
假定此 ACK 丢失，TIME_WAIT 状态使 TCP 客户重传最后的确认报文。
在 TIME_WAIT 状态中所消耗的时间是与具体实现有关的，而典型的值是 30 秒、1 分钟或 2 分钟。
经过等待后，连接就正式关闭，客户端所有资源（包括端口号）将被释放。

为了关闭该连接，在两台主机之间发送了 4 个分组，由于这个原因，这种连接关闭过程通常被称为 **4 次挥手**。
